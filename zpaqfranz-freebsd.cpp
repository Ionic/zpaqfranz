/*
                         __                     
  _____ __   __ _  __ _ / _|_ __ __ _ _ __  ____
 |_  / '_ \ / _` |/ _` | |_| '__/ _` | '_ \|_  /
  / /| |_) | (_| | (_| |  _| | | (_| | | | |/ / 
 /___| .__/ \__,_|\__, |_| |_|  \__,_|_| |_/___|
     |_|             |_|                        

 EXPERIMENTAL BUILD
 The source is a mess
 Strongly in development
 https://github.com/fcorbelli/zpaqfranz

 This is the FreeBSD-port stripped version
 compile only on amd64
 if you need the "full" version, with non amd64 CPU support, get the "full" source
 code and compile with -DNOJIT 
 ... or... use OpenBSD :-)
                                                                    

HIDDEN GEMS
If the executable is named "dir" act (just about) like Windows' dir

WARNINGS
Some strange warning with some compilers  (too old, or too new).

FreeBSD Targets (look at full source on github for others)

FreeBSD (11.x) gcc 7
gcc7 -O3 -march=native -Dunix zpaqfranz.cpp -lstdc++ -pthread -o zpaqfranz -static -lm

FreeBSD (12.1) gcc 9.3.0
g++ -O3 -march=native -Dunix zpaqfranz.cpp  -pthread -o zpaqfranz -static-libstdc++ -static-libgcc

FreeBSD (11.4) gcc 10.2.0
g++ -O3 -march=native -Dunix zpaqfranz.cpp  -pthread -o zpaqfranz -static-libstdc++ -static-libgcc -Wno-stringop-overflow

FreeBSD (11.3) clang 6.0.0
clang++ -march=native -Dunix zpaqfranz.cpp  -pthread -o zpaqfranz -static
	
*/

#define ZPAQ_VERSION "55.9-experimental"
#define ZSFX_VERSION ""
#define FRANZOFFSET 		50
#define FRANZOFFSETSHA256 	76 
#define FRANZMAXPATH 		240
#define FRANZO_NONE			0
#define FRANZO_CRC_32 		1
#define	FRANZO_XXHASH64		2
#define FRANZO_SHA_1		3
#define FRANZO_SHA_256		4
#define	FRANZO_XXH3			5
#define	FRANZO_BLAKE3		6
#define FRANZO_SHA3			7
#define FRANZO_MD5			8
#define _FILE_OFFSET_BITS 64  
#ifndef UNICODE
	#define UNICODE  
#endif
#ifndef DEBUG
	#define NDEBUG 1
#endif
#include <algorithm>
#include <array>
#include <assert.h>
#include <cstddef>
#include <cstdio>
#include <dirent.h>
#include <fcntl.h>
#include <iostream>
#include <map>
#include <math.h>
#include <memory>
#include <pthread.h>
#include <stdarg.h>
#include <stdexcept>
#include <stdio.h>
#include <string.h>
#include <string>
#include <sys/ioctl.h>
#include <sys/mman.h>
#include <sys/mount.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/sysctl.h>
#include <sys/time.h>
#include <sys/times.h>
#include <sys/types.h>
#include <termios.h>
#include <time.h>
#include <unistd.h>
#include <utime.h>
#include <vector>
namespace libzpaq {
typedef uint8_t U8;
typedef uint16_t U16;
typedef uint32_t U32;
typedef uint64_t U64;
extern const char* compname[256];    
extern const int compsize[256];      
extern const char* opcodelist[272];  
extern void error(const char* msg);
class Reader {
public:
  virtual int get() = 0;  
  virtual int read(char* buf, int n); 
  virtual ~Reader() {}
};
class Writer {
public:
  virtual void put(int c) = 0;  
  virtual void write(const char* buf, int n);  
  virtual ~Writer() {}
};
int toU16(const char* p);
template <typename T>
class Array {
  T *data;     
  size_t n;    
  int offset;  
  void operator=(const Array&);  
  Array(const Array&);  
public:
  Array(size_t sz=0, int ex=0): data(0), n(0), offset(0) {
    resize(sz, ex);} 
  void resize(size_t sz, int ex=0); 
  ~Array() {resize(0);}  
  size_t size() const {return n;}  
  int isize() const {return int(n);}  
  T& operator[](size_t i) {assert(n>0 && i<n); return data[i];}
  T& operator()(size_t i) {assert(n>0 && (n&(n-1))==0); return data[i&(n-1)];}
};
template<typename T>
void Array<T>::resize(size_t sz, int ex) {
  assert(size_t(-1)>0);  
  while (ex>0) {
    if (sz>sz*2) error("Array too big");
    sz*=2, --ex;
  }
  if (n>0) {
    assert(offset>0 && offset<=64);
    assert((char*)data-offset);
    ::free((char*)data-offset);
  }
  n=0;
  offset=0;
  if (sz==0) return;
  n=sz;
  const size_t nb=128+n*sizeof(T);  
  if (nb<=128 || (nb-128)/sizeof(T)!=n) n=0, error("Array too big");
  data=(T*)::calloc(nb, 1);
  if (!data) n=0, error("Out of memory");
  offset=64-(((char*)data-(char*)0)&63);
  assert(offset>0 && offset<=64);
  data=(T*)((char*)data+offset);
}
class SHA1 
{
public:
	void put(int c);
	void write(const char* buf, int64_t n); 
	double size() const {return len/8;}     
	uint64_t usize() const {return len/8;}  
	const char* result();  
	SHA1() {init();}
private:
	U32 w[16];        
	U64 len;          
	U32 h[5];         
	char hbuf[20];    
	void process();   
	void init();      
};
void SHA1::init() 
{
	len=0;
	memset(w, 0, sizeof(w));
	h[0]=0x67452301;
	h[1]=0xEFCDAB89;
	h[2]=0x98BADCFE;
	h[3]=0x10325476;
	h[4]=0xC3D2E1F0;
}
void SHA1::put(int c) 
{ 	
	U32& r=w[U32(len)>>5&15];
	r=(r<<8)|(c&255);
    len+=8;
	if ((U32(len)&511)==0)
		process();
}
const char* SHA1::result() 
{
	const U64 s=len;
	put(0x80);
	while ((len&511)!=448)
	put(0);
	put(s>>56);
	put(s>>48);
	put(s>>40);
	put(s>>32);
	put(s>>24);
	put(s>>16);
	put(s>>8);
	put(s);
	for (unsigned int i=0; i<5; ++i) 
	{
		hbuf[4*i]=h[i]>>24;
		hbuf[4*i+1]=h[i]>>16;
		hbuf[4*i+2]=h[i]>>8;
		hbuf[4*i+3]=h[i];
	}
	init();
	return hbuf;
}
void SHA1::write(const char* buf, int64_t n) 
{
  const unsigned char* p=(const unsigned char*) buf;
  for (; n>0 && (U32(len)&511)!=0; --n) put(*p++);
  for (; n>=64; n-=64) {
    for (unsigned int i=0; i<16; ++i)
      w[i]=p[0]<<24|p[1]<<16|p[2]<<8|p[3], p+=4;
    len+=512;
	process();
  }
  for (; n>0; --n) put(*p++);
}
void SHA1::process() 
{
  U32 a=h[0], b=h[1], c=h[2], d=h[3], e=h[4];
  static const U32 k[4]={0x5A827999, 0x6ED9EBA1, 0x8F1BBCDC, 0xCA62C1D6};
  #define f(a,b,c,d,e,i) \
    if (i>=16) \
      w[(i)&15]^=w[(i-3)&15]^w[(i-8)&15]^w[(i-14)&15], \
      w[(i)&15]=w[(i)&15]<<1|w[(i)&15]>>31; \
    e+=(a<<5|a>>27)+k[(i)/20]+w[(i)&15] \
      +((i)%40>=20 ? b^c^d : i>=40 ? (b&c)|(d&(b|c)) : d^(b&(c^d))); \
    b=b<<30|b>>2;
  #define r(i) f(a,b,c,d,e,i) f(e,a,b,c,d,i+1) f(d,e,a,b,c,i+2) \
               f(c,d,e,a,b,i+3) f(b,c,d,e,a,i+4)
  r(0)  r(5)  r(10) r(15) r(20) r(25) r(30) r(35)
  r(40) r(45) r(50) r(55) r(60) r(65) r(70) r(75)
  #undef f
  #undef r
  h[0]+=a; h[1]+=b; h[2]+=c; h[3]+=d; h[4]+=e;
}
class SHA256 {
public:
  void put(int c) {  
    unsigned& r=w[len0>>5&15];
    r=(r<<8)|(c&255);
    if (!(len0+=8)) ++len1;
    if ((len0&511)==0) process();
  }
  void write(const char* buf, int64_t n); 
  double size() const {return len0/8+len1*536870912.0;} 
  uint64_t usize() const {return len0/8+(U64(len1)<<29);} 
  const char* result();  
  SHA256() {init();}
private:
  void init();           
  unsigned len0, len1;   
  unsigned s[8];         
  unsigned w[16];        
  char hbuf[32];         
  void process();        
};
class AES_CTR {
  U32 Te0[256], Te1[256], Te2[256], Te3[256], Te4[256]; 
  U32 ek[60];  
  int Nr;  
  U32 iv0, iv1;  
public:
  AES_CTR(const char* key, int keylen, const char* iv=0);
  void encrypt(U32 s0, U32 s1, U32 s2, U32 s3, unsigned char* ct);
  void encrypt(char* buf, int n, U64 offset);  
};
void scrypt(const char* pw, int pwlen,
            const char* salt, int saltlen,
            int n, int r, int p, char* buf, int buflen);
void stretchKey(char* out, const char* key, const char* salt);
void random(char* buf, int n);
typedef enum {NONE,CONS,CM,ICM,MATCH,AVG,MIX2,MIX,ISSE,SSE} CompType;
extern const int compsize[256];
class Decoder;  
class ZPAQL {
public:
  ZPAQL();
  ~ZPAQL();
  void clear();           
  void inith();           
  void initp();           
  double memory();        
  void run(U32 input);    
  int read(Reader* in2);  
  bool write(Writer* out2, bool pp); 
  int step(U32 input, int mode);  
  Writer* output;         
  SHA1* sha1;             
  U32 H(int i) {return h(i);}  
  void flush();           
  void outc(int ch) {     
    if (ch<0 || (outbuf[bufptr]=ch, ++bufptr==outbuf.isize())) flush();
  }
  Array<U8> header;   
  int cend;           
  int hbegin, hend;   
private:
  Array<U8> m;        
  Array<U32> h;       
  Array<U32> r;       
  Array<char> outbuf; 
  int bufptr;         
  U32 a, b, c, d;     
  int f;              
  int pc;             
  int rcode_size;     
  U8* rcode;          
  int assemble();  
  void init(int hbits, int mbits);  
  int execute();  
  void run0(U32 input);  
  void div(U32 x) {if (x) a/=x; else a=0;}
  void mod(U32 x) {if (x) a%=x; else a=0;}
  void swap(U32& x) {a^=x; x^=a; a^=x;}
  void swap(U8& x)  {a^=x; x^=a; a^=x;}
  void err();  
};
struct Component {
  size_t limit;   
  size_t cxt;     
  size_t a, b, c; 
  Array<U32> cm;  
  Array<U8> ht;   
  Array<U16> a16; 
  void init();    
  Component() {init();}
};
class StateTable {
public:
  U8 ns[1024]; 
  int next(int state, int y) {  
    assert(state>=0 && state<256);
    assert(y>=0 && y<4);
    return ns[state*4+y];
  }
  int cminit(int state) {  
    assert(state>=0 && state<256);
    return ((ns[state*4+3]*2+1)<<22)/(ns[state*4+2]+ns[state*4+3]+1);
  }
  StateTable();
};
class Predictor {
public:
  Predictor(ZPAQL&);
  ~Predictor();
  void init();          
  int predict();        
  void update(int y);   
  int stat(int);        
  bool isModeled() {    
    assert(z.header.isize()>6);
    return z.header[6]!=0;
  }
private:
  int c8;               
  int hmap4;            
  int p[256];           
  U32 h[256];           
  ZPAQL& z;             
  Component comp[256];  
  bool initTables;      
  int predict0();       
  void update0(int y);  
  int dt2k[256];        
  int dt[1024];         
  U16 squasht[4096];    
  short stretcht[32768];
  StateTable st;        
  U8* pcode;            
  int pcode_size;       
  void train(Component& cr, int y) {
    assert(y==0 || y==1);
    U32& pn=cr.cm(cr.cxt);
    U32 count=pn&0x3ff;
    int error=y*32767-(cr.cm(cr.cxt)>>17);
    pn+=(error*dt[count]&-1024)+(count<cr.limit);
  }
  int squash(int x) {
    assert(initTables);
    assert(x>=-2048 && x<=2047);
    return squasht[x+2048];
  }
  int stretch(int x) {
    assert(initTables);
    assert(x>=0 && x<=32767);
    return stretcht[x];
  }
  int clamp2k(int x) {
    if (x<-2048) return -2048;
    else if (x>2047) return 2047;
    else return x;
  }
  int clamp512k(int x) {
    if (x<-(1<<19)) return -(1<<19);
    else if (x>=(1<<19)) return (1<<19)-1;
    else return x;
  }
  size_t find(Array<U8>& ht, int sizebits, U32 cxt);
  int assemble_p();
};
class Decoder: public Reader {
public:
  Reader* in;        
  Decoder(ZPAQL& z);
  int decompress();  
  int skip();        
  void init();       
  int stat(int x) {return pr.stat(x);}
  int get() {        
    if (rpos==wpos) {
      rpos=0;
      wpos=in ? in->read(&buf[0], BUFSIZE) : 0;
      assert(wpos<=BUFSIZE);
    }
    return rpos<wpos ? U8(buf[rpos++]) : -1;
  }
  int buffered() {return wpos-rpos;}  
private:
  U32 low, high;     
  U32 curr;          
  U32 rpos, wpos;    
  Predictor pr;      
  enum {BUFSIZE=1<<16};
  Array<char> buf;   
  int decode(int p); 
};
class PostProcessor {
  int state;   
  int hsize;   
  int ph, pm;  
public:
  ZPAQL z;     
  PostProcessor(): state(0), hsize(0), ph(0), pm(0) {}
  void init(int h, int m);  
  int write(int c);  
  int getState() const {return state;}
  void setOutput(Writer* out) {z.output=out;}
  void setSHA1(SHA1* sha1ptr) {z.sha1=sha1ptr;}
};
class Decompresser {
public:
  Decompresser(): z(), dec(z), pp(), state(BLOCK), decode_state(FIRSTSEG) {}
  void setInput(Reader* in) {dec.in=in;}
  bool findBlock(double* memptr = 0);
  void hcomp(Writer* out2) {z.write(out2, false);}
  bool findFilename(Writer* = 0);
  void readComment(Writer* = 0);
  void setOutput(Writer* out) {pp.setOutput(out);}
  void setSHA1(SHA1* sha1ptr) {pp.setSHA1(sha1ptr);}
  bool decompress(int n = -1);  
  bool pcomp(Writer* out2) {return pp.z.write(out2, true);}
  void readSegmentEnd(char* sha1string = 0);
  int stat(int x) {return dec.stat(x);}
  int buffered() {return dec.buffered();}
private:
  ZPAQL z;
  Decoder dec;
  PostProcessor pp;
  enum {BLOCK, FILENAME, COMMENT, DATA, SEGEND} state;  
  enum {FIRSTSEG, SEG, SKIP} decode_state;  
};
void decompress(Reader* in, Writer* out);
class Encoder {
public:
  Encoder(ZPAQL& z):
    out(0), low(1), high(0xFFFFFFFF), pr(z) {}
  void init();
  void compress(int c);  
  int stat(int x) {return pr.stat(x);}
  Writer* out;  
private:
  U32 low, high; 
  Predictor pr;  
  Array<char> buf; 
  void encode(int y, int p); 
};
class Compiler {
public:
  Compiler(const char* in, int* args, ZPAQL& hz, ZPAQL& pz, Writer* out2);
private:
  const char* in;  
  int* args;       
  ZPAQL& hz;       
  ZPAQL& pz;       
  Writer* out2;    
  int line;        
  int state;       
  typedef enum {NONE,CONS,CM,ICM,MATCH,AVG,MIX2,MIX,ISSE,SSE,
    JT=39,JF=47,JMP=63,LJ=255,
    POST=256,PCOMP,END,IF,IFNOT,ELSE,ENDIF,DO,
    WHILE,UNTIL,FOREVER,IFL,IFNOTL,ELSEL,SEMICOLON} CompType;
  void syntaxError(const char* msg, const char* expected=0); 
  void next();                     
  bool matchToken(const char* tok);
  int rtoken(int low, int high);   
  int rtoken(const char* list[]);  
  void rtoken(const char* s);      
  int compile_comp(ZPAQL& z);      
  class Stack {
    libzpaq::Array<U16> s;
    size_t top;
  public:
    Stack(int n): s(n), top(0) {}
    void push(const U16& x) {
      if (top>=s.size()) error("IF or DO nested too deep");
      s[top++]=x;
    }
    U16 pop() {
      if (top<=0) error("unmatched IF or DO");
      return s[--top];
    }
  };
  Stack if_stack, do_stack;
};
class Compressor {
public:
  Compressor(): enc(z), in(0), state(INIT), verify(false) {}
  void setOutput(Writer* out) {enc.out=out;}
  void writeTag();
  void startBlock(int level);  
  void startBlock(const char* hcomp);     
  void startBlock(const char* config,     
                  int* args,              
                  Writer* pcomp_cmd = 0); 
  void setVerify(bool v) {verify = v;}    
  void hcomp(Writer* out2) {z.write(out2, false);}
  bool pcomp(Writer* out2) {return pz.write(out2, true);}
  void startSegment(const char* filename = 0, const char* comment = 0);
  void setInput(Reader* i) {in=i;}
  void postProcess(const char* pcomp = 0, int len = 0);  
  bool compress(int n = -1);  
  void endSegment(const char* sha1string = 0);
  char* endSegmentChecksum(int64_t* size = 0, bool dosha1=true);
  int64_t getSize() {return sha1.usize();}
  const char* getChecksum() {return sha1.result();}
  void endBlock();
  int stat(int x) {return enc.stat(x);}
private:
  ZPAQL z, pz;  
  Encoder enc;  
  Reader* in;   
  SHA1 sha1;    
  char sha1result[20];  
  enum {INIT, BLOCK1, SEG1, BLOCK2, SEG2} state;
  bool verify;  
};
class StringBuffer: public libzpaq::Reader, public libzpaq::Writer {
  unsigned char* p;  
  size_t al;         
  size_t wpos;       
  size_t rpos;       
  size_t limit;      
  const size_t init; 
  void reserve(size_t a) {
    assert(!al==!p);
    if (a<=al) return;
    unsigned char* q=0;
    if (a>0) q=(unsigned char*)(p ? realloc(p, a) : malloc(a));
    if (a>0 && !q) error("Out of memory");
    p=q;
    al=a;
  }
  void lengthen(size_t n) {
    assert(wpos<=al);
    if (wpos+n>limit || wpos+n<wpos) error("StringBuffer overflow");
    if (wpos+n<=al) return;
    size_t a=al;
    while (wpos+n>=a) a=a*2+init;
    reserve(a);
  }
  void operator=(const StringBuffer&);
  StringBuffer(const StringBuffer&);
public:
  unsigned char* data() {assert(p || wpos==0); return p;}
  StringBuffer(size_t n=0):
      p(0), al(0), wpos(0), rpos(0), limit(size_t(-1)), init(n>128?n:128) {}
  void setLimit(size_t n) {limit=n;}
  ~StringBuffer() {if (p) free(p);}
  size_t size() const {return wpos;}
  size_t remaining() const {return wpos-rpos;}
  void reset() {
    if (p) free(p);
    p=0;
    al=rpos=wpos=0;
  }
  void put(int c) {  
    lengthen(1);
    assert(p);
    assert(wpos<al);
    p[wpos++]=c;
    assert(wpos<=al);
  }
  void write(const char* buf, int n) {
    if (n<1) return;
    lengthen(n);
    assert(p);
    assert(wpos+n<=al);
    if (buf) memcpy(p+wpos, buf, n);
    wpos+=n;
  }
  int get() {
    assert(rpos<=wpos);
    assert(rpos==wpos || p);
    return rpos<wpos ? p[rpos++] : -1;
  }
  int read(char* buf, int n) {
    assert(rpos<=wpos);
    assert(wpos<=al);
    assert(!al==!p);
    if (rpos+n>wpos) n=wpos-rpos;
    if (n>0 && buf) memcpy(buf, p+rpos, n);
    rpos+=n;
    return n;
  }
  const char* c_str() const {return (const char*)p;}
  void resize(size_t i) {
    wpos=i;
    if (rpos>wpos) rpos=wpos;
  }
  void swap(StringBuffer& s) {
    std::swap(p, s.p);
    std::swap(al, s.al);
    std::swap(wpos, s.wpos);
    std::swap(rpos, s.rpos);
    std::swap(limit, s.limit);
  }
};
void compress(Reader* in, Writer* out, const char* method,
     const char* filename=0, const char* comment=0, bool dosha1=true);
void compressBlock(StringBuffer* in, Writer* out, const char* method,
     const char* filename=0, const char* comment=0, bool dosha1=true);
int toU16(const char* p) {
  return (p[0]&255)+256*(p[1]&255);
}
int Reader::read(char* buf, int n) {
  int i=0, c;
  while (i<n && (c=get())>=0)
    buf[i++]=c;
  return i;
}
void Writer::write(const char* buf, int n) {
  for (int i=0; i<n; ++i)
    put(U8(buf[i]));
}
void allocx(U8* &p, int &n, int newsize) {
  if (p || n) {
    if (p)
      munmap(p, n);
    p=0;
    n=0;
  }
  if (newsize>0) {
    p=(U8*)mmap(0, newsize, PROT_READ|PROT_WRITE|PROT_EXEC,
                MAP_PRIVATE|MAP_ANON, -1, 0);
    if ((void*)p==MAP_FAILED) p=0;
    if (p)
      n=newsize;
    else {
      n=0;
      error("allocx failed");
    }
  }
}
void SHA256::init() {
  len0=len1=0;
  s[0]=0x6a09e667;
  s[1]=0xbb67ae85;
  s[2]=0x3c6ef372;
  s[3]=0xa54ff53a;
  s[4]=0x510e527f;
  s[5]=0x9b05688c;
  s[6]=0x1f83d9ab;
  s[7]=0x5be0cd19;
  memset(w, 0, sizeof(w));
}
void SHA256::process() {
  #define ror(a,b) ((a)>>(b)|(a<<(32-(b))))
  #define m(i) \
     w[(i)&15]+=w[(i-7)&15] \
       +(ror(w[(i-15)&15],7)^ror(w[(i-15)&15],18)^(w[(i-15)&15]>>3)) \
       +(ror(w[(i-2)&15],17)^ror(w[(i-2)&15],19)^(w[(i-2)&15]>>10))
  #define r(a,b,c,d,e,f,g,h,i) { \
    unsigned t1=ror(e,14)^e; \
    t1=ror(t1,5)^e; \
    h+=ror(t1,6)+((e&f)^(~e&g))+k[i]+w[(i)&15]; } \
    d+=h; \
    {unsigned t1=ror(a,9)^a; \
    t1=ror(t1,11)^a; \
    h+=ror(t1,2)+((a&b)^(c&(a^b))); }
  #define mr(a,b,c,d,e,f,g,h,i) m(i); r(a,b,c,d,e,f,g,h,i);
  #define r8(i) \
    r(a,b,c,d,e,f,g,h,i);   \
    r(h,a,b,c,d,e,f,g,i+1); \
    r(g,h,a,b,c,d,e,f,i+2); \
    r(f,g,h,a,b,c,d,e,i+3); \
    r(e,f,g,h,a,b,c,d,i+4); \
    r(d,e,f,g,h,a,b,c,i+5); \
    r(c,d,e,f,g,h,a,b,i+6); \
    r(b,c,d,e,f,g,h,a,i+7);
  #define mr8(i) \
    mr(a,b,c,d,e,f,g,h,i);   \
    mr(h,a,b,c,d,e,f,g,i+1); \
    mr(g,h,a,b,c,d,e,f,i+2); \
    mr(f,g,h,a,b,c,d,e,i+3); \
    mr(e,f,g,h,a,b,c,d,i+4); \
    mr(d,e,f,g,h,a,b,c,i+5); \
    mr(c,d,e,f,g,h,a,b,i+6); \
    mr(b,c,d,e,f,g,h,a,i+7);
  static const unsigned k[64]={
    0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5,
    0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
    0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3,
    0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
    0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc,
    0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
    0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7,
    0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
    0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13,
    0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
    0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3,
    0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
    0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5,
    0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
    0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208,
    0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2};
  unsigned a=s[0];
  unsigned b=s[1];
  unsigned c=s[2];
  unsigned d=s[3];
  unsigned e=s[4];
  unsigned f=s[5];
  unsigned g=s[6];
  unsigned h=s[7];
  r8(0);
  r8(8);
  mr8(16);
  mr8(24);
  mr8(32);
  mr8(40);
  mr8(48);
  mr8(56);
  s[0]+=a;
  s[1]+=b;
  s[2]+=c;
  s[3]+=d;
  s[4]+=e;
  s[5]+=f;
  s[6]+=g;
  s[7]+=h;
  #undef mr8
  #undef r8
  #undef mr
  #undef r
  #undef m
  #undef ror
}
const char* SHA256::result() {
  const unsigned s1=len1, s0=len0;
  put(0x80);
  while ((len0&511)!=448) put(0);
  put(s1>>24);
  put(s1>>16);
  put(s1>>8);
  put(s1);
  put(s0>>24);
  put(s0>>16);
  put(s0>>8);
  put(s0);
  for (unsigned int i=0; i<8; ++i) {
    hbuf[4*i]=s[i]>>24;
    hbuf[4*i+1]=s[i]>>16;
    hbuf[4*i+2]=s[i]>>8;
    hbuf[4*i+3]=s[i];
  }
  init();
  return hbuf;
}
void SHA256::write(const char* buf, int64_t n) 
{
	for (int64_t i=0;i<n;i++)
		put(*(buf+i));
}
#define Te4_0 0x000000FF & Te4
#define Te4_1 0x0000FF00 & Te4
#define Te4_2 0x00FF0000 & Te4
#define Te4_3 0xFF000000 & Te4
static inline unsigned byte(unsigned x, unsigned n) {return (x>>(8*n))&255;}
static inline void LOAD32H(U32& x, const char* y) {
  const unsigned char* u=(const unsigned char*)y;
  x=u[0]<<24|u[1]<<16|u[2]<<8|u[3];
}
static inline void STORE32H(U32& x, unsigned char* y) {
  y[0]=x>>24;
  y[1]=x>>16;
  y[2]=x>>8;
  y[3]=x;
}
#define setup_mix(temp) \
  ((Te4_3[byte(temp, 2)]) ^ (Te4_2[byte(temp, 1)]) ^ \
   (Te4_1[byte(temp, 0)]) ^ (Te4_0[byte(temp, 3)]))
AES_CTR::AES_CTR(const char* key, int keylen, const char* iv) {
  assert(key  != NULL);
  assert(keylen==16 || keylen==24 || keylen==32);
  iv0=iv1=0;
  if (iv) {
    LOAD32H(iv0, iv);
    LOAD32H(iv1, iv+4);
  }
  for (unsigned int i=0; i<256; ++i) {
    unsigned s1=
    "\x63\x7c\x77\x7b\xf2\x6b\x6f\xc5\x30\x01\x67\x2b\xfe\xd7\xab\x76"
    "\xca\x82\xc9\x7d\xfa\x59\x47\xf0\xad\xd4\xa2\xaf\x9c\xa4\x72\xc0"
    "\xb7\xfd\x93\x26\x36\x3f\xf7\xcc\x34\xa5\xe5\xf1\x71\xd8\x31\x15"
    "\x04\xc7\x23\xc3\x18\x96\x05\x9a\x07\x12\x80\xe2\xeb\x27\xb2\x75"
    "\x09\x83\x2c\x1a\x1b\x6e\x5a\xa0\x52\x3b\xd6\xb3\x29\xe3\x2f\x84"
    "\x53\xd1\x00\xed\x20\xfc\xb1\x5b\x6a\xcb\xbe\x39\x4a\x4c\x58\xcf"
    "\xd0\xef\xaa\xfb\x43\x4d\x33\x85\x45\xf9\x02\x7f\x50\x3c\x9f\xa8"
    "\x51\xa3\x40\x8f\x92\x9d\x38\xf5\xbc\xb6\xda\x21\x10\xff\xf3\xd2"
    "\xcd\x0c\x13\xec\x5f\x97\x44\x17\xc4\xa7\x7e\x3d\x64\x5d\x19\x73"
    "\x60\x81\x4f\xdc\x22\x2a\x90\x88\x46\xee\xb8\x14\xde\x5e\x0b\xdb"
    "\xe0\x32\x3a\x0a\x49\x06\x24\x5c\xc2\xd3\xac\x62\x91\x95\xe4\x79"
    "\xe7\xc8\x37\x6d\x8d\xd5\x4e\xa9\x6c\x56\xf4\xea\x65\x7a\xae\x08"
    "\xba\x78\x25\x2e\x1c\xa6\xb4\xc6\xe8\xdd\x74\x1f\x4b\xbd\x8b\x8a"
    "\x70\x3e\xb5\x66\x48\x03\xf6\x0e\x61\x35\x57\xb9\x86\xc1\x1d\x9e"
    "\xe1\xf8\x98\x11\x69\xd9\x8e\x94\x9b\x1e\x87\xe9\xce\x55\x28\xdf"
    "\x8c\xa1\x89\x0d\xbf\xe6\x42\x68\x41\x99\x2d\x0f\xb0\x54\xbb\x16"
    [i]&255;
    unsigned s2=s1<<1;
    if (s2>=0x100) s2^=0x11b;
    unsigned s3=s1^s2;
    Te0[i]=s2<<24|s1<<16|s1<<8|s3;
    Te1[i]=s3<<24|s2<<16|s1<<8|s1;
    Te2[i]=s1<<24|s3<<16|s2<<8|s1;
    Te3[i]=s1<<24|s1<<16|s3<<8|s2;
    Te4[i]=s1<<24|s1<<16|s1<<8|s1;
  }
  Nr = 10 + ((keylen/8)-2)*2;  
  int i = 0;
  U32* rk = &ek[0];
  U32 temp;
  static const U32 rcon[10] = {
    0x01000000UL, 0x02000000UL, 0x04000000UL, 0x08000000UL,
    0x10000000UL, 0x20000000UL, 0x40000000UL, 0x80000000UL,
    0x1B000000UL, 0x36000000UL};  
  LOAD32H(rk[0], key   );
  LOAD32H(rk[1], key +  4);
  LOAD32H(rk[2], key +  8);
  LOAD32H(rk[3], key + 12);
  if (keylen == 16) {
    for (;;) {
      temp  = rk[3];
      rk[4] = rk[0] ^ setup_mix(temp) ^ rcon[i];
      rk[5] = rk[1] ^ rk[4];
      rk[6] = rk[2] ^ rk[5];
      rk[7] = rk[3] ^ rk[6];
      if (++i == 10) {
         break;
      }
      rk += 4;
    }
  }
  else if (keylen == 24) {
    LOAD32H(rk[4], key + 16);
    LOAD32H(rk[5], key + 20);
    for (;;) {
      temp = rk[5];
      rk[ 6] = rk[ 0] ^ setup_mix(temp) ^ rcon[i];
      rk[ 7] = rk[ 1] ^ rk[ 6];
      rk[ 8] = rk[ 2] ^ rk[ 7];
      rk[ 9] = rk[ 3] ^ rk[ 8];
      if (++i == 8) {
        break;
      }
      rk[10] = rk[ 4] ^ rk[ 9];
      rk[11] = rk[ 5] ^ rk[10];
      rk += 6;
    }
  }
  else if (keylen == 32) {
    LOAD32H(rk[4], key + 16);
    LOAD32H(rk[5], key + 20);
    LOAD32H(rk[6], key + 24);
    LOAD32H(rk[7], key + 28);
    for (;;) {
      temp = rk[7];
      rk[ 8] = rk[ 0] ^ setup_mix(temp) ^ rcon[i];
      rk[ 9] = rk[ 1] ^ rk[ 8];
      rk[10] = rk[ 2] ^ rk[ 9];
      rk[11] = rk[ 3] ^ rk[10];
      if (++i == 7) {
        break;
      }
      temp = rk[11];
      rk[12] = rk[ 4] ^ setup_mix(temp<<24|temp>>8);
      rk[13] = rk[ 5] ^ rk[12];
      rk[14] = rk[ 6] ^ rk[13];
      rk[15] = rk[ 7] ^ rk[14];
      rk += 8;
    }
  }
}
void AES_CTR::encrypt(U32 s0, U32 s1, U32 s2, U32 s3, unsigned char* ct) {
  int r = Nr >> 1;
  U32 *rk = &ek[0];
  U32 t0=0, t1=0, t2=0, t3=0;
  s0 ^= rk[0];
  s1 ^= rk[1];
  s2 ^= rk[2];
  s3 ^= rk[3];
  for (;;) {
    t0 =
      Te0[byte(s0, 3)] ^
      Te1[byte(s1, 2)] ^
      Te2[byte(s2, 1)] ^
      Te3[byte(s3, 0)] ^
      rk[4];
    t1 =
      Te0[byte(s1, 3)] ^
      Te1[byte(s2, 2)] ^
      Te2[byte(s3, 1)] ^
      Te3[byte(s0, 0)] ^
      rk[5];
    t2 =
      Te0[byte(s2, 3)] ^
      Te1[byte(s3, 2)] ^
      Te2[byte(s0, 1)] ^
      Te3[byte(s1, 0)] ^
      rk[6];
    t3 =
      Te0[byte(s3, 3)] ^
      Te1[byte(s0, 2)] ^
      Te2[byte(s1, 1)] ^
      Te3[byte(s2, 0)] ^
      rk[7];
    rk += 8;
    if (--r == 0) {
      break;
    }
    s0 =
      Te0[byte(t0, 3)] ^
      Te1[byte(t1, 2)] ^
      Te2[byte(t2, 1)] ^
      Te3[byte(t3, 0)] ^
      rk[0];
    s1 =
      Te0[byte(t1, 3)] ^
      Te1[byte(t2, 2)] ^
      Te2[byte(t3, 1)] ^
      Te3[byte(t0, 0)] ^
      rk[1];
    s2 =
      Te0[byte(t2, 3)] ^
      Te1[byte(t3, 2)] ^
      Te2[byte(t0, 1)] ^
      Te3[byte(t1, 0)] ^
      rk[2];
    s3 =
      Te0[byte(t3, 3)] ^
      Te1[byte(t0, 2)] ^
      Te2[byte(t1, 1)] ^
      Te3[byte(t2, 0)] ^
      rk[3];
  }
  s0 =
    (Te4_3[byte(t0, 3)]) ^
    (Te4_2[byte(t1, 2)]) ^
    (Te4_1[byte(t2, 1)]) ^
    (Te4_0[byte(t3, 0)]) ^
    rk[0];
  STORE32H(s0, ct);
  s1 =
    (Te4_3[byte(t1, 3)]) ^
    (Te4_2[byte(t2, 2)]) ^
    (Te4_1[byte(t3, 1)]) ^
    (Te4_0[byte(t0, 0)]) ^
    rk[1];
  STORE32H(s1, ct+4);
  s2 =
    (Te4_3[byte(t2, 3)]) ^
    (Te4_2[byte(t3, 2)]) ^
    (Te4_1[byte(t0, 1)]) ^
    (Te4_0[byte(t1, 0)]) ^
    rk[2];
  STORE32H(s2, ct+8);
  s3 =
    (Te4_3[byte(t3, 3)]) ^
    (Te4_2[byte(t0, 2)]) ^
    (Te4_1[byte(t1, 1)]) ^
    (Te4_0[byte(t2, 0)]) ^ 
    rk[3];
  STORE32H(s3, ct+12);
}
void AES_CTR::encrypt(char* buf, int n, U64 offset) {
  for (U64 i=offset/16; i<=(offset+n)/16; ++i) {
    unsigned char ct[16];
    encrypt(iv0, iv1, i>>32, i, ct);
    for (int j=0; j<16; ++j) {
      const int k=i*16-offset+j;
      if (k>=0 && k<n)
        buf[k]^=ct[j];
    }
  }
}
#undef setup_mix
#undef Te4_3
#undef Te4_2
#undef Te4_1
#undef Te4_0
static void pbkdf2(const char* pw, int pwLen, const char* salt, int saltLen,
                    char* buf, int dkLen) {
  assert(dkLen%32==0);
  assert(pwLen<=64);
  libzpaq::SHA256 sha256;
  char b[32];
  for (int i=1; i*32<=dkLen; ++i) {
    for (int j=0; j<pwLen; ++j) sha256.put(pw[j]^0x36);
    for (int j=pwLen; j<64; ++j) sha256.put(0x36);
    for (int j=0; j<saltLen; ++j) sha256.put(salt[j]);
    for (int j=24; j>=0; j-=8) sha256.put(i>>j);
    memcpy(b, sha256.result(), 32);
    for (int j=0; j<pwLen; ++j) sha256.put(pw[j]^0x5c);
    for (int j=pwLen; j<64; ++j) sha256.put(0x5c);
    for (int j=0; j<32; ++j) sha256.put(b[j]);
    memcpy(buf+i*32-32, sha256.result(), 32);
  }
}
static void salsa8(U32* b) {
  unsigned x[16]={0};
  memcpy(x, b, 64);
  for (unsigned int i=0; i<4; ++i) {
    #define R(a,b) (((a)<<(b))+((a)>>(32-b)))
    x[ 4] ^= R(x[ 0]+x[12], 7);  x[ 8] ^= R(x[ 4]+x[ 0], 9);
    x[12] ^= R(x[ 8]+x[ 4],13);  x[ 0] ^= R(x[12]+x[ 8],18);
    x[ 9] ^= R(x[ 5]+x[ 1], 7);  x[13] ^= R(x[ 9]+x[ 5], 9);
    x[ 1] ^= R(x[13]+x[ 9],13);  x[ 5] ^= R(x[ 1]+x[13],18);
    x[14] ^= R(x[10]+x[ 6], 7);  x[ 2] ^= R(x[14]+x[10], 9);
    x[ 6] ^= R(x[ 2]+x[14],13);  x[10] ^= R(x[ 6]+x[ 2],18);
    x[ 3] ^= R(x[15]+x[11], 7);  x[ 7] ^= R(x[ 3]+x[15], 9);
    x[11] ^= R(x[ 7]+x[ 3],13);  x[15] ^= R(x[11]+x[ 7],18);
    x[ 1] ^= R(x[ 0]+x[ 3], 7);  x[ 2] ^= R(x[ 1]+x[ 0], 9);
    x[ 3] ^= R(x[ 2]+x[ 1],13);  x[ 0] ^= R(x[ 3]+x[ 2],18);
    x[ 6] ^= R(x[ 5]+x[ 4], 7);  x[ 7] ^= R(x[ 6]+x[ 5], 9);
    x[ 4] ^= R(x[ 7]+x[ 6],13);  x[ 5] ^= R(x[ 4]+x[ 7],18);
    x[11] ^= R(x[10]+x[ 9], 7);  x[ 8] ^= R(x[11]+x[10], 9);
    x[ 9] ^= R(x[ 8]+x[11],13);  x[10] ^= R(x[ 9]+x[ 8],18);
    x[12] ^= R(x[15]+x[14], 7);  x[13] ^= R(x[12]+x[15], 9);
    x[14] ^= R(x[13]+x[12],13);  x[15] ^= R(x[14]+x[13],18);
    #undef R
  }
  for (unsigned int i=0; i<16; ++i) b[i]+=x[i];
}
static void blockmix(U32* b, int r) {
  assert(r<=8);
  U32 x[16];
  U32 y[256];
  memcpy(x, b+32*r-16, 64);
  for (int i=0; i<2*r; ++i) {
    for (int j=0; j<16; ++j) x[j]^=b[i*16+j];
    salsa8(x);
    memcpy(&y[i*16], x, 64);
  }
  for (int i=0; i<r; ++i) memcpy(b+i*16, &y[i*32], 64);
  for (int i=0; i<r; ++i) memcpy(b+(i+r)*16, &y[i*32+16], 64);
}
static void smix(char* b, int r, int n) {
  libzpaq::Array<U32> x(32*r), v(32*r*n);
  for (int i=0; i<r*128; ++i) x[i/4]+=(b[i]&255)<<i%4*8;
  for (int i=0; i<n; ++i) {
    memcpy(&v[i*r*32], &x[0], r*128);
    blockmix(&x[0], r);
  }
  for (int i=0; i<n; ++i) {
    U32 j=x[(2*r-1)*16]&(n-1);
    for (int k=0; k<r*32; ++k) x[k]^=v[j*r*32+k];
    blockmix(&x[0], r);
  }
  for (int i=0; i<r*128; ++i) b[i]=x[i/4]>>(i%4*8);
}
void scrypt(const char* pw, int pwlen,
            const char* salt, int saltlen,
            int n, int r, int p, char* buf, int buflen) {
  assert(r<=8);
  assert(n>0 && (n&(n-1))==0);  
  libzpaq::Array<char> b(p*r*128);
  pbkdf2(pw, pwlen, salt, saltlen,  &b[0], p*r*128);
  for (int i=0; i<p; ++i) smix(&b[i*r*128], r, n);
  pbkdf2(pw, pwlen, &b[0], p*r*128,  buf, buflen);
}
void stretchKey(char* out, const char* in, const char* salt) {
  scrypt(in, 32, salt, 32, 1<<14, 8, 1, out, 32);
}
void random(char* buf, int n) {
  FILE* in=fopen("/dev/urandom", "rb");
  if (in && int(fread(buf, 1, n, in))==n)
    fclose(in);
  else {
    error("key generation failed");
  }
  if (n>=1 && (buf[0]=='z' || buf[0]=='7'))
    buf[0]^=0x80;
}
const int compsize[256]={0,2,3,2,3,4,6,6,3,5};
void Component::init() {
  limit=cxt=a=b=c=0;
  cm.resize(0);
  ht.resize(0);
  a16.resize(0);
}
static const U8 sns[1024]={
     1,     2,     0,     0,     3,     5,     1,     0,
     4,     6,     0,     1,     7,     9,     2,     0,
     8,    11,     1,     1,     8,    11,     1,     1,
    10,    12,     0,     2,    13,    15,     3,     0,
    14,    17,     2,     1,    14,    17,     2,     1,
    16,    19,     1,     2,    16,    19,     1,     2,
    18,    20,     0,     3,    21,    23,     4,     0,
    22,    25,     3,     1,    22,    25,     3,     1,
    24,    27,     2,     2,    24,    27,     2,     2,
    26,    29,     1,     3,    26,    29,     1,     3,
    28,    30,     0,     4,    31,    33,     5,     0,
    32,    35,     4,     1,    32,    35,     4,     1,
    34,    37,     3,     2,    34,    37,     3,     2,
    36,    39,     2,     3,    36,    39,     2,     3,
    38,    41,     1,     4,    38,    41,     1,     4,
    40,    42,     0,     5,    43,    33,     6,     0,
    44,    47,     5,     1,    44,    47,     5,     1,
    46,    49,     4,     2,    46,    49,     4,     2,
    48,    51,     3,     3,    48,    51,     3,     3,
    50,    53,     2,     4,    50,    53,     2,     4,
    52,    55,     1,     5,    52,    55,     1,     5,
    40,    56,     0,     6,    57,    45,     7,     0,
    58,    47,     6,     1,    58,    47,     6,     1,
    60,    63,     5,     2,    60,    63,     5,     2,
    62,    65,     4,     3,    62,    65,     4,     3,
    64,    67,     3,     4,    64,    67,     3,     4,
    66,    69,     2,     5,    66,    69,     2,     5,
    52,    71,     1,     6,    52,    71,     1,     6,
    54,    72,     0,     7,    73,    59,     8,     0,
    74,    61,     7,     1,    74,    61,     7,     1,
    76,    63,     6,     2,    76,    63,     6,     2,
    78,    81,     5,     3,    78,    81,     5,     3,
    80,    83,     4,     4,    80,    83,     4,     4,
    82,    85,     3,     5,    82,    85,     3,     5,
    66,    87,     2,     6,    66,    87,     2,     6,
    68,    89,     1,     7,    68,    89,     1,     7,
    70,    90,     0,     8,    91,    59,     9,     0,
    92,    77,     8,     1,    92,    77,     8,     1,
    94,    79,     7,     2,    94,    79,     7,     2,
    96,    81,     6,     3,    96,    81,     6,     3,
    98,   101,     5,     4,    98,   101,     5,     4,
   100,   103,     4,     5,   100,   103,     4,     5,
    82,   105,     3,     6,    82,   105,     3,     6,
    84,   107,     2,     7,    84,   107,     2,     7,
    86,   109,     1,     8,    86,   109,     1,     8,
    70,   110,     0,     9,   111,    59,    10,     0,
   112,    77,     9,     1,   112,    77,     9,     1,
   114,    97,     8,     2,   114,    97,     8,     2,
   116,    99,     7,     3,   116,    99,     7,     3,
    62,   101,     6,     4,    62,   101,     6,     4,
    80,    83,     5,     5,    80,    83,     5,     5,
   100,    67,     4,     6,   100,    67,     4,     6,
   102,   119,     3,     7,   102,   119,     3,     7,
   104,   121,     2,     8,   104,   121,     2,     8,
    86,   123,     1,     9,    86,   123,     1,     9,
    70,   124,     0,    10,   125,    59,    11,     0,
   126,    77,    10,     1,   126,    77,    10,     1,
   128,    97,     9,     2,   128,    97,     9,     2,
    60,    63,     8,     3,    60,    63,     8,     3,
    66,    69,     3,     8,    66,    69,     3,     8,
   104,   131,     2,     9,   104,   131,     2,     9,
    86,   133,     1,    10,    86,   133,     1,    10,
    70,   134,     0,    11,   135,    59,    12,     0,
   136,    77,    11,     1,   136,    77,    11,     1,
   138,    97,    10,     2,   138,    97,    10,     2,
   104,   141,     2,    10,   104,   141,     2,    10,
    86,   143,     1,    11,    86,   143,     1,    11,
    70,   144,     0,    12,   145,    59,    13,     0,
   146,    77,    12,     1,   146,    77,    12,     1,
   148,    97,    11,     2,   148,    97,    11,     2,
   104,   151,     2,    11,   104,   151,     2,    11,
    86,   153,     1,    12,    86,   153,     1,    12,
    70,   154,     0,    13,   155,    59,    14,     0,
   156,    77,    13,     1,   156,    77,    13,     1,
   158,    97,    12,     2,   158,    97,    12,     2,
   104,   161,     2,    12,   104,   161,     2,    12,
    86,   163,     1,    13,    86,   163,     1,    13,
    70,   164,     0,    14,   165,    59,    15,     0,
   166,    77,    14,     1,   166,    77,    14,     1,
   168,    97,    13,     2,   168,    97,    13,     2,
   104,   171,     2,    13,   104,   171,     2,    13,
    86,   173,     1,    14,    86,   173,     1,    14,
    70,   174,     0,    15,   175,    59,    16,     0,
   176,    77,    15,     1,   176,    77,    15,     1,
   178,    97,    14,     2,   178,    97,    14,     2,
   104,   181,     2,    14,   104,   181,     2,    14,
    86,   183,     1,    15,    86,   183,     1,    15,
    70,   184,     0,    16,   185,    59,    17,     0,
   186,    77,    16,     1,   186,    77,    16,     1,
    74,    97,    15,     2,    74,    97,    15,     2,
   104,    89,     2,    15,   104,    89,     2,    15,
    86,   187,     1,    16,    86,   187,     1,    16,
    70,   188,     0,    17,   189,    59,    18,     0,
   190,    77,    17,     1,    86,   191,     1,    17,
    70,   192,     0,    18,   193,    59,    19,     0,
   194,    77,    18,     1,    86,   195,     1,    18,
    70,   196,     0,    19,   193,    59,    20,     0,
   197,    77,    19,     1,    86,   198,     1,    19,
    70,   196,     0,    20,   199,    77,    20,     1,
    86,   200,     1,    20,   201,    77,    21,     1,
    86,   202,     1,    21,   203,    77,    22,     1,
    86,   204,     1,    22,   205,    77,    23,     1,
    86,   206,     1,    23,   207,    77,    24,     1,
    86,   208,     1,    24,   209,    77,    25,     1,
    86,   210,     1,    25,   211,    77,    26,     1,
    86,   212,     1,    26,   213,    77,    27,     1,
    86,   214,     1,    27,   215,    77,    28,     1,
    86,   216,     1,    28,   217,    77,    29,     1,
    86,   218,     1,    29,   219,    77,    30,     1,
    86,   220,     1,    30,   221,    77,    31,     1,
    86,   222,     1,    31,   223,    77,    32,     1,
    86,   224,     1,    32,   225,    77,    33,     1,
    86,   226,     1,    33,   227,    77,    34,     1,
    86,   228,     1,    34,   229,    77,    35,     1,
    86,   230,     1,    35,   231,    77,    36,     1,
    86,   232,     1,    36,   233,    77,    37,     1,
    86,   234,     1,    37,   235,    77,    38,     1,
    86,   236,     1,    38,   237,    77,    39,     1,
    86,   238,     1,    39,   239,    77,    40,     1,
    86,   240,     1,    40,   241,    77,    41,     1,
    86,   242,     1,    41,   243,    77,    42,     1,
    86,   244,     1,    42,   245,    77,    43,     1,
    86,   246,     1,    43,   247,    77,    44,     1,
    86,   248,     1,    44,   249,    77,    45,     1,
    86,   250,     1,    45,   251,    77,    46,     1,
    86,   252,     1,    46,   253,    77,    47,     1,
    86,   254,     1,    47,   253,    77,    48,     1,
    86,   254,     1,    48,     0,     0,     0,     0
};
StateTable::StateTable() {
  memcpy(ns, sns, sizeof(ns));
}
bool ZPAQL::write(Writer* out2, bool pp) {
  if (header.size()<=6) return false;
  assert(header[0]+256*header[1]==cend-2+hend-hbegin);
  assert(cend>=7);
  assert(hbegin>=cend);
  assert(hend>=hbegin);
  assert(out2);
  if (!pp) {  
    for (int i=0; i<cend; ++i)
      out2->put(header[i]);
  }
  else {  
    out2->put((hend-hbegin)&255);
    out2->put((hend-hbegin)>>8);
  }
  for (int i=hbegin; i<hend; ++i)
    out2->put(header[i]);
  return true;
}
int ZPAQL::read(Reader* in2) {
  int hsize=in2->get();
  hsize+=in2->get()*256;
  header.resize(hsize+300);
  cend=hbegin=hend=0;
  header[cend++]=hsize&255;
  header[cend++]=hsize>>8;
  while (cend<7) header[cend++]=in2->get(); 
  int n=header[cend-1];
  for (int i=0; i<n; ++i) {
    int type=in2->get();  
    if (type<0 || type>255) error("unexpected end of file");
    header[cend++]=type;  
    int size=compsize[type];
    if (size<1) error("Invalid component type");
    if (cend+size>hsize) error("COMP overflows header");
    for (int j=1; j<size; ++j)
      header[cend++]=in2->get();
  }
  if ((header[cend++]=in2->get())!=0) error("missing COMP END");
  hbegin=hend=cend+128;
  if (hend>hsize+129) error("missing HCOMP");
  while (hend<hsize+129) {
    assert(hend<header.isize()-8);
    int op=in2->get();
    if (op==-1) error("unexpected end of file");
    header[hend++]=op;
  }
  if ((header[hend++]=in2->get())!=0) error("missing HCOMP END");
  assert(cend>=7 && cend<header.isize());
  assert(hbegin==cend+128 && hbegin<header.isize());
  assert(hend>hbegin && hend<header.isize());
  assert(hsize==header[0]+256*header[1]);
  assert(hsize==cend-2+hend-hbegin);
  allocx(rcode, rcode_size, 0);  
  return cend+hend-hbegin;
}
void ZPAQL::clear() {
  cend=hbegin=hend=0;  
  a=b=c=d=f=pc=0;      
  header.resize(0);
  h.resize(0);
  m.resize(0);
  r.resize(0);
  allocx(rcode, rcode_size, 0);
}
ZPAQL::ZPAQL() {
  output=0;
  sha1=0;
  rcode=0;
  rcode_size=0;
  clear();
  outbuf.resize(1<<14);
  bufptr=0;
}
ZPAQL::~ZPAQL() {
  allocx(rcode, rcode_size, 0);
}
void ZPAQL::inith() {
  assert(header.isize()>6);
  assert(output==0);
  assert(sha1==0);
  init(header[2], header[3]); 
}
void ZPAQL::initp() {
  assert(header.isize()>6);
  init(header[4], header[5]); 
}
void ZPAQL::flush() {
  if (output) output->write(&outbuf[0], bufptr);
  if (sha1) sha1->write(&outbuf[0], bufptr);
  bufptr=0;
}
static double pow2(int x) {
  double r=1;
  for (; x>0; x--) r+=r;
  return r;
}
double ZPAQL::memory() {
  double mem=pow2(header[2]+2)+pow2(header[3])  
            +pow2(header[4]+2)+pow2(header[5])  
            +header.size();
  int cp=7;  
  for (unsigned int i=0; i<header[6]; ++i) {  
    assert(cp<cend);
    double size=pow2(header[cp+1]); 
    switch(header[cp]) {
      case CM: mem+=4*size; break;
      case ICM: mem+=64*size+1024; break;
      case MATCH: mem+=4*size+pow2(header[cp+2]); break; 
      case MIX2: mem+=2*size; break;
      case MIX: mem+=4*size*header[cp+3]; break; 
      case ISSE: mem+=64*size+2048; break;
      case SSE: mem+=128*size; break;
    }
    cp+=compsize[header[cp]];
  }
  return mem;
}
void ZPAQL::init(int hbits, int mbits) {
  assert(header.isize()>0);
  assert(cend>=7);
  assert(hbegin>=cend+128);
  assert(hend>=hbegin);
  assert(hend<header.isize()-130);
  assert(header[0]+256*header[1]==cend-2+hend-hbegin);
  assert(bufptr==0);
  assert(outbuf.isize()>0);
  if (hbits>32) error("H too big");
  if (mbits>32) error("M too big");
  h.resize(1, hbits);
  m.resize(1, mbits);
  r.resize(256);
  a=b=c=d=pc=f=0;
}
void ZPAQL::run0(U32 input) {
  assert(cend>6);
  assert(hbegin>=cend+128);
  assert(hend>=hbegin);
  assert(hend<header.isize()-130);
  assert(m.size()>0);
  assert(h.size()>0);
  assert(header[0]+256*header[1]==cend+hend-hbegin-2);
  pc=hbegin;
  a=input;
  while (execute()) ;
}
int ZPAQL::execute() {
  switch(header[pc++]) {
    case 0: err(); break; 
    case 1: ++a; break; 
    case 2: --a; break; 
    case 3: a = ~a; break; 
    case 4: a = 0; break; 
    case 7: a = r[header[pc++]]; break; 
    case 8: swap(b); break; 
    case 9: ++b; break; 
    case 10: --b; break; 
    case 11: b = ~b; break; 
    case 12: b = 0; break; 
    case 15: b = r[header[pc++]]; break; 
    case 16: swap(c); break; 
    case 17: ++c; break; 
    case 18: --c; break; 
    case 19: c = ~c; break; 
    case 20: c = 0; break; 
    case 23: c = r[header[pc++]]; break; 
    case 24: swap(d); break; 
    case 25: ++d; break; 
    case 26: --d; break; 
    case 27: d = ~d; break; 
    case 28: d = 0; break; 
    case 31: d = r[header[pc++]]; break; 
    case 32: swap(m(b)); break; 
    case 33: ++m(b); break; 
    case 34: --m(b); break; 
    case 35: m(b) = ~m(b); break; 
    case 36: m(b) = 0; break; 
    case 39: if (f) pc+=((header[pc]+128)&255)-127; else ++pc; break; 
    case 40: swap(m(c)); break; 
    case 41: ++m(c); break; 
    case 42: --m(c); break; 
    case 43: m(c) = ~m(c); break; 
    case 44: m(c) = 0; break; 
    case 47: if (!f) pc+=((header[pc]+128)&255)-127; else ++pc; break; 
    case 48: swap(h(d)); break; 
    case 49: ++h(d); break; 
    case 50: --h(d); break; 
    case 51: h(d) = ~h(d); break; 
    case 52: h(d) = 0; break; 
    case 55: r[header[pc++]] = a; break; 
    case 56: return 0  ; 
    case 57: outc(a&255); break; 
    case 59: a = (a+m(b)+512)*773; break; 
    case 60: h(d) = (h(d)+a+512)*773; break; 
    case 63: pc+=((header[pc]+128)&255)-127; break; 
    case 64: break; 
    case 65: a = b; break; 
    case 66: a = c; break; 
    case 67: a = d; break; 
    case 68: a = m(b); break; 
    case 69: a = m(c); break; 
    case 70: a = h(d); break; 
    case 71: a = header[pc++]; break; 
    case 72: b = a; break; 
    case 73: break; 
    case 74: b = c; break; 
    case 75: b = d; break; 
    case 76: b = m(b); break; 
    case 77: b = m(c); break; 
    case 78: b = h(d); break; 
    case 79: b = header[pc++]; break; 
    case 80: c = a; break; 
    case 81: c = b; break; 
    case 82: break; 
    case 83: c = d; break; 
    case 84: c = m(b); break; 
    case 85: c = m(c); break; 
    case 86: c = h(d); break; 
    case 87: c = header[pc++]; break; 
    case 88: d = a; break; 
    case 89: d = b; break; 
    case 90: d = c; break; 
    case 91: break; 
    case 92: d = m(b); break; 
    case 93: d = m(c); break; 
    case 94: d = h(d); break; 
    case 95: d = header[pc++]; break; 
    case 96: m(b) = a; break; 
    case 97: m(b) = b; break; 
    case 98: m(b) = c; break; 
    case 99: m(b) = d; break; 
    case 100: break; 
    case 101: m(b) = m(c); break; 
    case 102: m(b) = h(d); break; 
    case 103: m(b) = header[pc++]; break; 
    case 104: m(c) = a; break; 
    case 105: m(c) = b; break; 
    case 106: m(c) = c; break; 
    case 107: m(c) = d; break; 
    case 108: m(c) = m(b); break; 
    case 109: break; 
    case 110: m(c) = h(d); break; 
    case 111: m(c) = header[pc++]; break; 
    case 112: h(d) = a; break; 
    case 113: h(d) = b; break; 
    case 114: h(d) = c; break; 
    case 115: h(d) = d; break; 
    case 116: h(d) = m(b); break; 
    case 117: h(d) = m(c); break; 
    case 118: break; 
    case 119: h(d) = header[pc++]; break; 
    case 128: a += a; break; 
    case 129: a += b; break; 
    case 130: a += c; break; 
    case 131: a += d; break; 
    case 132: a += m(b); break; 
    case 133: a += m(c); break; 
    case 134: a += h(d); break; 
    case 135: a += header[pc++]; break; 
    case 136: a -= a; break; 
    case 137: a -= b; break; 
    case 138: a -= c; break; 
    case 139: a -= d; break; 
    case 140: a -= m(b); break; 
    case 141: a -= m(c); break; 
    case 142: a -= h(d); break; 
    case 143: a -= header[pc++]; break; 
    case 144: a *= a; break; 
    case 145: a *= b; break; 
    case 146: a *= c; break; 
    case 147: a *= d; break; 
    case 148: a *= m(b); break; 
    case 149: a *= m(c); break; 
    case 150: a *= h(d); break; 
    case 151: a *= header[pc++]; break; 
    case 152: div(a); break; 
    case 153: div(b); break; 
    case 154: div(c); break; 
    case 155: div(d); break; 
    case 156: div(m(b)); break; 
    case 157: div(m(c)); break; 
    case 158: div(h(d)); break; 
    case 159: div(header[pc++]); break; 
    case 160: mod(a); break; 
    case 161: mod(b); break; 
    case 162: mod(c); break; 
    case 163: mod(d); break; 
    case 164: mod(m(b)); break; 
    case 165: mod(m(c)); break; 
    case 166: mod(h(d)); break; 
    case 167: mod(header[pc++]); break; 
    case 168: a &= a; break; 
    case 169: a &= b; break; 
    case 170: a &= c; break; 
    case 171: a &= d; break; 
    case 172: a &= m(b); break; 
    case 173: a &= m(c); break; 
    case 174: a &= h(d); break; 
    case 175: a &= header[pc++]; break; 
    case 176: a &= ~ a; break; 
    case 177: a &= ~ b; break; 
    case 178: a &= ~ c; break; 
    case 179: a &= ~ d; break; 
    case 180: a &= ~ m(b); break; 
    case 181: a &= ~ m(c); break; 
    case 182: a &= ~ h(d); break; 
    case 183: a &= ~ header[pc++]; break; 
    case 184: a |= a; break; 
    case 185: a |= b; break; 
    case 186: a |= c; break; 
    case 187: a |= d; break; 
    case 188: a |= m(b); break; 
    case 189: a |= m(c); break; 
    case 190: a |= h(d); break; 
    case 191: a |= header[pc++]; break; 
    case 192: a ^= a; break; 
    case 193: a ^= b; break; 
    case 194: a ^= c; break; 
    case 195: a ^= d; break; 
    case 196: a ^= m(b); break; 
    case 197: a ^= m(c); break; 
    case 198: a ^= h(d); break; 
    case 199: a ^= header[pc++]; break; 
    case 200: a <<= (a&31); break; 
    case 201: a <<= (b&31); break; 
    case 202: a <<= (c&31); break; 
    case 203: a <<= (d&31); break; 
    case 204: a <<= (m(b)&31); break; 
    case 205: a <<= (m(c)&31); break; 
    case 206: a <<= (h(d)&31); break; 
    case 207: a <<= (header[pc++]&31); break; 
    case 208: a >>= (a&31); break; 
    case 209: a >>= (b&31); break; 
    case 210: a >>= (c&31); break; 
    case 211: a >>= (d&31); break; 
    case 212: a >>= (m(b)&31); break; 
    case 213: a >>= (m(c)&31); break; 
    case 214: a >>= (h(d)&31); break; 
    case 215: a >>= (header[pc++]&31); break; 
    case 216: f = 1; break; 
    case 217: f = (a == b); break; 
    case 218: f = (a == c); break; 
    case 219: f = (a == d); break; 
    case 220: f = (a == U32(m(b))); break; 
    case 221: f = (a == U32(m(c))); break; 
    case 222: f = (a == h(d)); break; 
    case 223: f = (a == U32(header[pc++])); break; 
    case 224: f = 0; break; 
    case 225: f = (a < b); break; 
    case 226: f = (a < c); break; 
    case 227: f = (a < d); break; 
    case 228: f = (a < U32(m(b))); break; 
    case 229: f = (a < U32(m(c))); break; 
    case 230: f = (a < h(d)); break; 
    case 231: f = (a < U32(header[pc++])); break; 
    case 232: f = 0; break; 
    case 233: f = (a > b); break; 
    case 234: f = (a > c); break; 
    case 235: f = (a > d); break; 
    case 236: f = (a > U32(m(b))); break; 
    case 237: f = (a > U32(m(c))); break; 
    case 238: f = (a > h(d)); break; 
    case 239: f = (a > U32(header[pc++])); break; 
    case 255: if((pc=hbegin+header[pc]+256*header[pc+1])>=hend)err();break;
    default: err();
  }
  return 1;
}
void ZPAQL::err() {
  error("ZPAQL execution error");
}
static const int sdt2k[256]={
     0,  2048,  1024,   682,   512,   409,   341,   292,
   256,   227,   204,   186,   170,   157,   146,   136,
   128,   120,   113,   107,   102,    97,    93,    89,
    85,    81,    78,    75,    73,    70,    68,    66,
    64,    62,    60,    58,    56,    55,    53,    52,
    51,    49,    48,    47,    46,    45,    44,    43,
    42,    41,    40,    40,    39,    38,    37,    37,
    36,    35,    35,    34,    34,    33,    33,    32,
    32,    31,    31,    30,    30,    29,    29,    28,
    28,    28,    27,    27,    26,    26,    26,    25,
    25,    25,    24,    24,    24,    24,    23,    23,
    23,    23,    22,    22,    22,    22,    21,    21,
    21,    21,    20,    20,    20,    20,    20,    19,
    19,    19,    19,    19,    18,    18,    18,    18,
    18,    18,    17,    17,    17,    17,    17,    17,
    17,    16,    16,    16,    16,    16,    16,    16,
    16,    15,    15,    15,    15,    15,    15,    15,
    15,    14,    14,    14,    14,    14,    14,    14,
    14,    14,    14,    13,    13,    13,    13,    13,
    13,    13,    13,    13,    13,    13,    12,    12,
    12,    12,    12,    12,    12,    12,    12,    12,
    12,    12,    12,    11,    11,    11,    11,    11,
    11,    11,    11,    11,    11,    11,    11,    11,
    11,    11,    11,    10,    10,    10,    10,    10,
    10,    10,    10,    10,    10,    10,    10,    10,
    10,    10,    10,    10,    10,     9,     9,     9,
     9,     9,     9,     9,     9,     9,     9,     9,
     9,     9,     9,     9,     9,     9,     9,     9,
     9,     9,     9,     9,     8,     8,     8,     8,
     8,     8,     8,     8,     8,     8,     8,     8,
     8,     8,     8,     8,     8,     8,     8,     8,
     8,     8,     8,     8,     8,     8,     8,     8
};
static const int sdt[1024]={
 87380, 52428, 37448, 29126, 23830, 20164, 17476, 15420,
 13796, 12482, 11396, 10484,  9708,  9038,  8456,  7942,
  7488,  7084,  6720,  6392,  6096,  5824,  5576,  5348,
  5140,  4946,  4766,  4598,  4442,  4296,  4160,  4032,
  3912,  3798,  3692,  3590,  3494,  3404,  3318,  3236,
  3158,  3084,  3012,  2944,  2880,  2818,  2758,  2702,
  2646,  2594,  2544,  2496,  2448,  2404,  2360,  2318,
  2278,  2240,  2202,  2166,  2130,  2096,  2064,  2032,
  2000,  1970,  1940,  1912,  1884,  1858,  1832,  1806,
  1782,  1758,  1736,  1712,  1690,  1668,  1648,  1628,
  1608,  1588,  1568,  1550,  1532,  1514,  1496,  1480,
  1464,  1448,  1432,  1416,  1400,  1386,  1372,  1358,
  1344,  1330,  1316,  1304,  1290,  1278,  1266,  1254,
  1242,  1230,  1218,  1208,  1196,  1186,  1174,  1164,
  1154,  1144,  1134,  1124,  1114,  1106,  1096,  1086,
  1078,  1068,  1060,  1052,  1044,  1036,  1028,  1020,
  1012,  1004,   996,   988,   980,   974,   966,   960,
   952,   946,   938,   932,   926,   918,   912,   906,
   900,   894,   888,   882,   876,   870,   864,   858,
   852,   848,   842,   836,   832,   826,   820,   816,
   810,   806,   800,   796,   790,   786,   782,   776,
   772,   768,   764,   758,   754,   750,   746,   742,
   738,   734,   730,   726,   722,   718,   714,   710,
   706,   702,   698,   694,   690,   688,   684,   680,
   676,   672,   670,   666,   662,   660,   656,   652,
   650,   646,   644,   640,   636,   634,   630,   628,
   624,   622,   618,   616,   612,   610,   608,   604,
   602,   598,   596,   594,   590,   588,   586,   582,
   580,   578,   576,   572,   570,   568,   566,   562,
   560,   558,   556,   554,   550,   548,   546,   544,
   542,   540,   538,   536,   532,   530,   528,   526,
   524,   522,   520,   518,   516,   514,   512,   510,
   508,   506,   504,   502,   500,   498,   496,   494,
   492,   490,   488,   488,   486,   484,   482,   480,
   478,   476,   474,   474,   472,   470,   468,   466,
   464,   462,   462,   460,   458,   456,   454,   454,
   452,   450,   448,   448,   446,   444,   442,   442,
   440,   438,   436,   436,   434,   432,   430,   430,
   428,   426,   426,   424,   422,   422,   420,   418,
   418,   416,   414,   414,   412,   410,   410,   408,
   406,   406,   404,   402,   402,   400,   400,   398,
   396,   396,   394,   394,   392,   390,   390,   388,
   388,   386,   386,   384,   382,   382,   380,   380,
   378,   378,   376,   376,   374,   372,   372,   370,
   370,   368,   368,   366,   366,   364,   364,   362,
   362,   360,   360,   358,   358,   356,   356,   354,
   354,   352,   352,   350,   350,   348,   348,   348,
   346,   346,   344,   344,   342,   342,   340,   340,
   340,   338,   338,   336,   336,   334,   334,   332,
   332,   332,   330,   330,   328,   328,   328,   326,
   326,   324,   324,   324,   322,   322,   320,   320,
   320,   318,   318,   316,   316,   316,   314,   314,
   312,   312,   312,   310,   310,   310,   308,   308,
   308,   306,   306,   304,   304,   304,   302,   302,
   302,   300,   300,   300,   298,   298,   298,   296,
   296,   296,   294,   294,   294,   292,   292,   292,
   290,   290,   290,   288,   288,   288,   286,   286,
   286,   284,   284,   284,   284,   282,   282,   282,
   280,   280,   280,   278,   278,   278,   276,   276,
   276,   276,   274,   274,   274,   272,   272,   272,
   272,   270,   270,   270,   268,   268,   268,   268,
   266,   266,   266,   266,   264,   264,   264,   262,
   262,   262,   262,   260,   260,   260,   260,   258,
   258,   258,   258,   256,   256,   256,   256,   254,
   254,   254,   254,   252,   252,   252,   252,   250,
   250,   250,   250,   248,   248,   248,   248,   248,
   246,   246,   246,   246,   244,   244,   244,   244,
   242,   242,   242,   242,   242,   240,   240,   240,
   240,   238,   238,   238,   238,   238,   236,   236,
   236,   236,   234,   234,   234,   234,   234,   232,
   232,   232,   232,   232,   230,   230,   230,   230,
   230,   228,   228,   228,   228,   228,   226,   226,
   226,   226,   226,   224,   224,   224,   224,   224,
   222,   222,   222,   222,   222,   220,   220,   220,
   220,   220,   220,   218,   218,   218,   218,   218,
   216,   216,   216,   216,   216,   216,   214,   214,
   214,   214,   214,   212,   212,   212,   212,   212,
   212,   210,   210,   210,   210,   210,   210,   208,
   208,   208,   208,   208,   208,   206,   206,   206,
   206,   206,   206,   204,   204,   204,   204,   204,
   204,   204,   202,   202,   202,   202,   202,   202,
   200,   200,   200,   200,   200,   200,   198,   198,
   198,   198,   198,   198,   198,   196,   196,   196,
   196,   196,   196,   196,   194,   194,   194,   194,
   194,   194,   194,   192,   192,   192,   192,   192,
   192,   192,   190,   190,   190,   190,   190,   190,
   190,   188,   188,   188,   188,   188,   188,   188,
   186,   186,   186,   186,   186,   186,   186,   186,
   184,   184,   184,   184,   184,   184,   184,   182,
   182,   182,   182,   182,   182,   182,   182,   180,
   180,   180,   180,   180,   180,   180,   180,   178,
   178,   178,   178,   178,   178,   178,   178,   176,
   176,   176,   176,   176,   176,   176,   176,   176,
   174,   174,   174,   174,   174,   174,   174,   174,
   172,   172,   172,   172,   172,   172,   172,   172,
   172,   170,   170,   170,   170,   170,   170,   170,
   170,   170,   168,   168,   168,   168,   168,   168,
   168,   168,   168,   166,   166,   166,   166,   166,
   166,   166,   166,   166,   166,   164,   164,   164,
   164,   164,   164,   164,   164,   164,   162,   162,
   162,   162,   162,   162,   162,   162,   162,   162,
   160,   160,   160,   160,   160,   160,   160,   160,
   160,   160,   158,   158,   158,   158,   158,   158,
   158,   158,   158,   158,   158,   156,   156,   156,
   156,   156,   156,   156,   156,   156,   156,   154,
   154,   154,   154,   154,   154,   154,   154,   154,
   154,   154,   152,   152,   152,   152,   152,   152,
   152,   152,   152,   152,   152,   150,   150,   150,
   150,   150,   150,   150,   150,   150,   150,   150,
   150,   148,   148,   148,   148,   148,   148,   148,
   148,   148,   148,   148,   148,   146,   146,   146,
   146,   146,   146,   146,   146,   146,   146,   146,
   146,   144,   144,   144,   144,   144,   144,   144,
   144,   144,   144,   144,   144,   142,   142,   142,
   142,   142,   142,   142,   142,   142,   142,   142,
   142,   142,   140,   140,   140,   140,   140,   140,
   140,   140,   140,   140,   140,   140,   140,   138,
   138,   138,   138,   138,   138,   138,   138,   138,
   138,   138,   138,   138,   138,   136,   136,   136,
   136,   136,   136,   136,   136,   136,   136,   136,
   136,   136,   136,   134,   134,   134,   134,   134,
   134,   134,   134,   134,   134,   134,   134,   134,
   134,   132,   132,   132,   132,   132,   132,   132,
   132,   132,   132,   132,   132,   132,   132,   132,
   130,   130,   130,   130,   130,   130,   130,   130,
   130,   130,   130,   130,   130,   130,   130,   128,
   128,   128,   128,   128,   128,   128,   128,   128,
   128,   128,   128,   128,   128,   128,   128,   126
};
static const U16 ssquasht[1344]={
     0,     0,     0,     0,     0,     0,     0,     1,
     1,     1,     1,     1,     1,     1,     1,     1,
     1,     1,     1,     1,     1,     1,     1,     1,
     1,     1,     1,     1,     1,     1,     1,     1,
     1,     1,     1,     1,     1,     1,     1,     1,
     1,     1,     1,     1,     1,     1,     1,     1,
     1,     1,     1,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     3,     3,     3,
     3,     3,     3,     3,     3,     3,     3,     3,
     3,     3,     3,     3,     3,     3,     3,     3,
     4,     4,     4,     4,     4,     4,     4,     4,
     4,     4,     4,     4,     4,     4,     5,     5,
     5,     5,     5,     5,     5,     5,     5,     5,
     5,     5,     6,     6,     6,     6,     6,     6,
     6,     6,     6,     6,     7,     7,     7,     7,
     7,     7,     7,     7,     8,     8,     8,     8,
     8,     8,     8,     8,     9,     9,     9,     9,
     9,     9,    10,    10,    10,    10,    10,    10,
    10,    11,    11,    11,    11,    11,    12,    12,
    12,    12,    12,    13,    13,    13,    13,    13,
    14,    14,    14,    14,    15,    15,    15,    15,
    15,    16,    16,    16,    17,    17,    17,    17,
    18,    18,    18,    18,    19,    19,    19,    20,
    20,    20,    21,    21,    21,    22,    22,    22,
    23,    23,    23,    24,    24,    25,    25,    25,
    26,    26,    27,    27,    28,    28,    28,    29,
    29,    30,    30,    31,    31,    32,    32,    33,
    33,    34,    34,    35,    36,    36,    37,    37,
    38,    38,    39,    40,    40,    41,    42,    42,
    43,    44,    44,    45,    46,    46,    47,    48,
    49,    49,    50,    51,    52,    53,    54,    54,
    55,    56,    57,    58,    59,    60,    61,    62,
    63,    64,    65,    66,    67,    68,    69,    70,
    71,    72,    73,    74,    76,    77,    78,    79,
    81,    82,    83,    84,    86,    87,    88,    90,
    91,    93,    94,    96,    97,    99,   100,   102,
   103,   105,   107,   108,   110,   112,   114,   115,
   117,   119,   121,   123,   125,   127,   129,   131,
   133,   135,   137,   139,   141,   144,   146,   148,
   151,   153,   155,   158,   160,   163,   165,   168,
   171,   173,   176,   179,   182,   184,   187,   190,
   193,   196,   199,   202,   206,   209,   212,   215,
   219,   222,   226,   229,   233,   237,   240,   244,
   248,   252,   256,   260,   264,   268,   272,   276,
   281,   285,   289,   294,   299,   303,   308,   313,
   318,   323,   328,   333,   338,   343,   349,   354,
   360,   365,   371,   377,   382,   388,   394,   401,
   407,   413,   420,   426,   433,   440,   446,   453,
   460,   467,   475,   482,   490,   497,   505,   513,
   521,   529,   537,   545,   554,   562,   571,   580,
   589,   598,   607,   617,   626,   636,   646,   656,
   666,   676,   686,   697,   708,   719,   730,   741,
   752,   764,   776,   788,   800,   812,   825,   837,
   850,   863,   876,   890,   903,   917,   931,   946,
   960,   975,   990,  1005,  1020,  1036,  1051,  1067,
  1084,  1100,  1117,  1134,  1151,  1169,  1186,  1204,
  1223,  1241,  1260,  1279,  1298,  1318,  1338,  1358,
  1379,  1399,  1421,  1442,  1464,  1486,  1508,  1531,
  1554,  1577,  1600,  1624,  1649,  1673,  1698,  1724,
  1749,  1775,  1802,  1829,  1856,  1883,  1911,  1940,
  1968,  1998,  2027,  2057,  2087,  2118,  2149,  2181,
  2213,  2245,  2278,  2312,  2345,  2380,  2414,  2450,
  2485,  2521,  2558,  2595,  2633,  2671,  2709,  2748,
  2788,  2828,  2869,  2910,  2952,  2994,  3037,  3080,
  3124,  3168,  3213,  3259,  3305,  3352,  3399,  3447,
  3496,  3545,  3594,  3645,  3696,  3747,  3799,  3852,
  3906,  3960,  4014,  4070,  4126,  4182,  4240,  4298,
  4356,  4416,  4476,  4537,  4598,  4660,  4723,  4786,
  4851,  4916,  4981,  5048,  5115,  5183,  5251,  5320,
  5390,  5461,  5533,  5605,  5678,  5752,  5826,  5901,
  5977,  6054,  6131,  6210,  6289,  6369,  6449,  6530,
  6613,  6695,  6779,  6863,  6949,  7035,  7121,  7209,
  7297,  7386,  7476,  7566,  7658,  7750,  7842,  7936,
  8030,  8126,  8221,  8318,  8415,  8513,  8612,  8712,
  8812,  8913,  9015,  9117,  9221,  9324,  9429,  9534,
  9640,  9747,  9854,  9962, 10071, 10180, 10290, 10401,
 10512, 10624, 10737, 10850, 10963, 11078, 11192, 11308,
 11424, 11540, 11658, 11775, 11893, 12012, 12131, 12251,
 12371, 12491, 12612, 12734, 12856, 12978, 13101, 13224,
 13347, 13471, 13595, 13719, 13844, 13969, 14095, 14220,
 14346, 14472, 14599, 14725, 14852, 14979, 15106, 15233,
 15361, 15488, 15616, 15744, 15872, 16000, 16128, 16256,
 16384, 16511, 16639, 16767, 16895, 17023, 17151, 17279,
 17406, 17534, 17661, 17788, 17915, 18042, 18168, 18295,
 18421, 18547, 18672, 18798, 18923, 19048, 19172, 19296,
 19420, 19543, 19666, 19789, 19911, 20033, 20155, 20276,
 20396, 20516, 20636, 20755, 20874, 20992, 21109, 21227,
 21343, 21459, 21575, 21689, 21804, 21917, 22030, 22143,
 22255, 22366, 22477, 22587, 22696, 22805, 22913, 23020,
 23127, 23233, 23338, 23443, 23546, 23650, 23752, 23854,
 23955, 24055, 24155, 24254, 24352, 24449, 24546, 24641,
 24737, 24831, 24925, 25017, 25109, 25201, 25291, 25381,
 25470, 25558, 25646, 25732, 25818, 25904, 25988, 26072,
 26154, 26237, 26318, 26398, 26478, 26557, 26636, 26713,
 26790, 26866, 26941, 27015, 27089, 27162, 27234, 27306,
 27377, 27447, 27516, 27584, 27652, 27719, 27786, 27851,
 27916, 27981, 28044, 28107, 28169, 28230, 28291, 28351,
 28411, 28469, 28527, 28585, 28641, 28697, 28753, 28807,
 28861, 28915, 28968, 29020, 29071, 29122, 29173, 29222,
 29271, 29320, 29368, 29415, 29462, 29508, 29554, 29599,
 29643, 29687, 29730, 29773, 29815, 29857, 29898, 29939,
 29979, 30019, 30058, 30096, 30134, 30172, 30209, 30246,
 30282, 30317, 30353, 30387, 30422, 30455, 30489, 30522,
 30554, 30586, 30618, 30649, 30680, 30710, 30740, 30769,
 30799, 30827, 30856, 30884, 30911, 30938, 30965, 30992,
 31018, 31043, 31069, 31094, 31118, 31143, 31167, 31190,
 31213, 31236, 31259, 31281, 31303, 31325, 31346, 31368,
 31388, 31409, 31429, 31449, 31469, 31488, 31507, 31526,
 31544, 31563, 31581, 31598, 31616, 31633, 31650, 31667,
 31683, 31700, 31716, 31731, 31747, 31762, 31777, 31792,
 31807, 31821, 31836, 31850, 31864, 31877, 31891, 31904,
 31917, 31930, 31942, 31955, 31967, 31979, 31991, 32003,
 32015, 32026, 32037, 32048, 32059, 32070, 32081, 32091,
 32101, 32111, 32121, 32131, 32141, 32150, 32160, 32169,
 32178, 32187, 32196, 32205, 32213, 32222, 32230, 32238,
 32246, 32254, 32262, 32270, 32277, 32285, 32292, 32300,
 32307, 32314, 32321, 32327, 32334, 32341, 32347, 32354,
 32360, 32366, 32373, 32379, 32385, 32390, 32396, 32402,
 32407, 32413, 32418, 32424, 32429, 32434, 32439, 32444,
 32449, 32454, 32459, 32464, 32468, 32473, 32478, 32482,
 32486, 32491, 32495, 32499, 32503, 32507, 32511, 32515,
 32519, 32523, 32527, 32530, 32534, 32538, 32541, 32545,
 32548, 32552, 32555, 32558, 32561, 32565, 32568, 32571,
 32574, 32577, 32580, 32583, 32585, 32588, 32591, 32594,
 32596, 32599, 32602, 32604, 32607, 32609, 32612, 32614,
 32616, 32619, 32621, 32623, 32626, 32628, 32630, 32632,
 32634, 32636, 32638, 32640, 32642, 32644, 32646, 32648,
 32650, 32652, 32653, 32655, 32657, 32659, 32660, 32662,
 32664, 32665, 32667, 32668, 32670, 32671, 32673, 32674,
 32676, 32677, 32679, 32680, 32681, 32683, 32684, 32685,
 32686, 32688, 32689, 32690, 32691, 32693, 32694, 32695,
 32696, 32697, 32698, 32699, 32700, 32701, 32702, 32703,
 32704, 32705, 32706, 32707, 32708, 32709, 32710, 32711,
 32712, 32713, 32713, 32714, 32715, 32716, 32717, 32718,
 32718, 32719, 32720, 32721, 32721, 32722, 32723, 32723,
 32724, 32725, 32725, 32726, 32727, 32727, 32728, 32729,
 32729, 32730, 32730, 32731, 32731, 32732, 32733, 32733,
 32734, 32734, 32735, 32735, 32736, 32736, 32737, 32737,
 32738, 32738, 32739, 32739, 32739, 32740, 32740, 32741,
 32741, 32742, 32742, 32742, 32743, 32743, 32744, 32744,
 32744, 32745, 32745, 32745, 32746, 32746, 32746, 32747,
 32747, 32747, 32748, 32748, 32748, 32749, 32749, 32749,
 32749, 32750, 32750, 32750, 32750, 32751, 32751, 32751,
 32752, 32752, 32752, 32752, 32752, 32753, 32753, 32753,
 32753, 32754, 32754, 32754, 32754, 32754, 32755, 32755,
 32755, 32755, 32755, 32756, 32756, 32756, 32756, 32756,
 32757, 32757, 32757, 32757, 32757, 32757, 32757, 32758,
 32758, 32758, 32758, 32758, 32758, 32759, 32759, 32759,
 32759, 32759, 32759, 32759, 32759, 32760, 32760, 32760,
 32760, 32760, 32760, 32760, 32760, 32761, 32761, 32761,
 32761, 32761, 32761, 32761, 32761, 32761, 32761, 32762,
 32762, 32762, 32762, 32762, 32762, 32762, 32762, 32762,
 32762, 32762, 32762, 32763, 32763, 32763, 32763, 32763,
 32763, 32763, 32763, 32763, 32763, 32763, 32763, 32763,
 32763, 32764, 32764, 32764, 32764, 32764, 32764, 32764,
 32764, 32764, 32764, 32764, 32764, 32764, 32764, 32764,
 32764, 32764, 32764, 32764, 32765, 32765, 32765, 32765,
 32765, 32765, 32765, 32765, 32765, 32765, 32765, 32765,
 32765, 32765, 32765, 32765, 32765, 32765, 32765, 32765,
 32765, 32765, 32765, 32765, 32765, 32765, 32766, 32766,
 32766, 32766, 32766, 32766, 32766, 32766, 32766, 32766,
 32766, 32766, 32766, 32766, 32766, 32766, 32766, 32766,
 32766, 32766, 32766, 32766, 32766, 32766, 32766, 32766,
 32766, 32766, 32766, 32766, 32766, 32766, 32766, 32766,
 32766, 32766, 32766, 32766, 32766, 32766, 32766, 32766,
 32766, 32766, 32767, 32767, 32767, 32767, 32767, 32767
};
static const U8 stdt[712]={
    64,   128,   128,   128,   128,   128,   127,   128,
   127,   128,   127,   127,   127,   127,   126,   126,
   126,   126,   126,   125,   125,   124,   125,   124,
   123,   123,   123,   123,   122,   122,   121,   121,
   120,   120,   119,   119,   118,   118,   118,   116,
   117,   115,   116,   114,   114,   113,   113,   112,
   112,   111,   110,   110,   109,   108,   108,   107,
   106,   106,   105,   104,   104,   102,   103,   101,
   101,   100,    99,    98,    98,    97,    96,    96,
    94,    94,    94,    92,    92,    91,    90,    89,
    89,    88,    87,    86,    86,    84,    84,    84,
    82,    82,    81,    80,    79,    79,    78,    77,
    76,    76,    75,    74,    73,    73,    72,    71,
    70,    70,    69,    68,    67,    67,    66,    65,
    65,    64,    63,    62,    62,    61,    61,    59,
    59,    59,    57,    58,    56,    56,    55,    54,
    54,    53,    52,    52,    51,    51,    50,    49,
    49,    48,    48,    47,    47,    45,    46,    44,
    45,    43,    43,    43,    42,    41,    41,    40,
    40,    40,    39,    38,    38,    37,    37,    36,
    36,    36,    35,    34,    34,    34,    33,    32,
    33,    32,    31,    31,    30,    31,    29,    30,
    28,    29,    28,    28,    27,    27,    27,    26,
    26,    25,    26,    24,    25,    24,    24,    23,
    23,    23,    23,    22,    22,    21,    22,    21,
    20,    21,    20,    19,    20,    19,    19,    19,
    18,    18,    18,    18,    17,    17,    17,    17,
    16,    16,    16,    16,    15,    15,    15,    15,
    15,    14,    14,    14,    14,    13,    14,    13,
    13,    13,    12,    13,    12,    12,    12,    11,
    12,    11,    11,    11,    11,    11,    10,    11,
    10,    10,    10,    10,     9,    10,     9,     9,
     9,     9,     9,     8,     9,     8,     9,     8,
     8,     8,     7,     8,     8,     7,     7,     8,
     7,     7,     7,     6,     7,     7,     6,     6,
     7,     6,     6,     6,     6,     6,     6,     5,
     6,     5,     6,     5,     5,     5,     5,     5,
     5,     5,     5,     5,     4,     5,     4,     5,
     4,     4,     5,     4,     4,     4,     4,     4,
     4,     3,     4,     4,     3,     4,     4,     3,
     3,     4,     3,     3,     3,     4,     3,     3,
     3,     3,     3,     3,     2,     3,     3,     3,
     2,     3,     2,     3,     3,     2,     2,     3,
     2,     2,     3,     2,     2,     2,     2,     3,
     2,     2,     2,     2,     2,     2,     1,     2,
     2,     2,     2,     1,     2,     2,     2,     1,
     2,     1,     2,     2,     1,     2,     1,     2,
     1,     1,     2,     1,     1,     2,     1,     1,
     2,     1,     1,     1,     1,     2,     1,     1,
     1,     1,     1,     1,     1,     1,     1,     1,
     1,     1,     1,     1,     1,     1,     1,     1,
     1,     1,     0,     1,     1,     1,     1,     0,
     1,     1,     1,     0,     1,     1,     1,     0,
     1,     1,     0,     1,     1,     0,     1,     0,
     1,     1,     0,     1,     0,     1,     0,     1,
     0,     1,     0,     1,     0,     1,     0,     1,
     0,     1,     0,     1,     0,     1,     0,     0,
     1,     0,     1,     0,     0,     1,     0,     1,
     0,     0,     1,     0,     0,     1,     0,     0,
     1,     0,     0,     1,     0,     0,     0,     1,
     0,     0,     1,     0,     0,     0,     1,     0,
     0,     0,     1,     0,     0,     0,     1,     0,
     0,     0,     0,     1,     0,     0,     0,     0,
     1,     0,     0,     0,     0,     1,     0,     0,
     0,     0,     0,     1,     0,     0,     0,     0,
     0,     1,     0,     0,     0,     0,     0,     0,
     1,     0,     0,     0,     0,     0,     0,     0,
     1,     0,     0,     0,     0,     0,     0,     0,
     0,     0,     1,     0,     0,     0,     0,     0,
     0,     0,     0,     0,     1,     0,     0,     0,
     0,     0,     0,     0,     0,     0,     0,     0,
     0,     1,     0,     0,     0,     0,     0,     0,
     0,     0,     0,     0,     0,     0,     0,     0,
     0,     1,     0,     0,     0,     0,     0,     0,
     0,     0,     0,     0,     0,     0,     0,     0,
     0,     0,     0,     0,     0,     0,     0,     1,
     0,     0,     0,     0,     0,     0,     0,     0,
     0,     0,     0,     0,     0,     0,     0,     0,
     0,     0,     0,     0,     0,     0,     0,     0,
     0,     0,     0,     0,     0,     0,     0,     1,
     0,     0,     0,     0,     0,     0,     0,     0,
     0,     0,     0,     0,     0,     0,     0,     0,
     0,     0,     0,     0,     0,     0,     0,     0,
     0,     0,     0,     0,     0,     0,     0,     0,
     0,     0,     0,     0,     0,     0,     0,     0,
     0,     0,     0,     0,     0,     0,     0,     0,
     0,     0,     0,     0,     0,     0,     0,     0,
     0,     0,     0,     0,     0,     0,     0,     0,
     0,     0,     0,     0,     0,     0,     1,     0
};
Predictor::Predictor(ZPAQL& zr):
    c8(1), hmap4(1), z(zr) {
  assert(sizeof(U8)==1);
  assert(sizeof(U16)==2);
  assert(sizeof(U32)==4);
  assert(sizeof(U64)==8);
  assert(sizeof(short)==2);
  assert(sizeof(int)==4);
  pcode=0;
  pcode_size=0;
  initTables=false;
}
Predictor::~Predictor() {
  allocx(pcode, pcode_size, 0);  
}
void Predictor::init() {
  allocx(pcode, pcode_size, 0);
  z.inith();
  if (!initTables && isModeled()) {
    initTables=true;
    memcpy(dt2k, sdt2k, sizeof(dt2k));
    memcpy(dt, sdt, sizeof(dt));
    memset(squasht, 0, 1376*2);
    memcpy(squasht+1376, ssquasht, 1344*2);
    for (int i=2720; i<4096; ++i) squasht[i]=32767;
    int k=16384;
    for (unsigned int i=0; i<712; ++i)
      for (int j=stdt[i]; j>0; --j)
        stretcht[k++]=i;
    assert(k==32768);
    for (unsigned int i=0; i<16384; ++i)
      stretcht[i]=-stretcht[32767-i];
#ifndef NDEBUG
    U32 sqsum=0, stsum=0;
    for (int i=32767; i>=0; --i)
      stsum=stsum*3+stretch(i);
    for (int i=4095; i>=0; --i)
      sqsum=sqsum*3+squash(i-2048);
    assert(stsum==3887533746u);
    assert(sqsum==2278286169u);
#endif
  }
  for (unsigned int i=0; i<256; ++i) h[i]=p[i]=0;
  for (unsigned int i=0; i<256; ++i)  
    comp[i].init();
  int n=z.header[6]; 
  const U8* cp=&z.header[7];  
  for (int i=0; i<n; ++i) {
    assert(cp<&z.header[z.cend]);
    assert(cp>&z.header[0] && cp<&z.header[z.header.isize()-8]);
    Component& cr=comp[i];
    switch(cp[0]) {
      case CONS:  
        p[i]=(cp[1]-128)*4;
        break;
      case CM: 
        if (cp[1]>32) error("max size for CM is 32");
        cr.cm.resize(1, cp[1]);  
        cr.limit=cp[2]*4;
        for (size_t j=0; j<cr.cm.size(); ++j)
          cr.cm[j]=0x80000000;
        break;
      case ICM: 
        if (cp[1]>26) error("max size for ICM is 26");
        cr.limit=1023;
        cr.cm.resize(256);
        cr.ht.resize(64, cp[1]);
        for (size_t j=0; j<cr.cm.size(); ++j)
          cr.cm[j]=st.cminit(j);
        break;
      case MATCH:  
        if (cp[1]>32 || cp[2]>32) error("max size for MATCH is 32 32");
        cr.cm.resize(1, cp[1]);  
        cr.ht.resize(1, cp[2]);  
        cr.ht(0)=1;
        break;
      case AVG: 
        if (cp[1]>=i) error("AVG j >= i");
        if (cp[2]>=i) error("AVG k >= i");
        break;
      case MIX2:  
        if (cp[1]>32) error("max size for MIX2 is 32");
        if (cp[3]>=i) error("MIX2 k >= i");
        if (cp[2]>=i) error("MIX2 j >= i");
        cr.c=(size_t(1)<<cp[1]); 
        cr.a16.resize(1, cp[1]);  
        for (size_t j=0; j<cr.a16.size(); ++j)
          cr.a16[j]=32768;
        break;
      case MIX: {  
        if (cp[1]>32) error("max size for MIX is 32");
        if (cp[2]>=i) error("MIX j >= i");
        if (cp[3]<1 || cp[3]>i-cp[2]) error("MIX m not in 1..i-j");
        int m=cp[3];  
        assert(m>=1);
        cr.c=(size_t(1)<<cp[1]); 
        cr.cm.resize(m, cp[1]);  
        for (size_t j=0; j<cr.cm.size(); ++j)
          cr.cm[j]=65536/m;
        break;
      }
      case ISSE:  
        if (cp[1]>32) error("max size for ISSE is 32");
        if (cp[2]>=i) error("ISSE j >= i");
        cr.ht.resize(64, cp[1]);
        cr.cm.resize(512);
        for (int j=0; j<256; ++j) {
          cr.cm[j*2]=1<<15;
          cr.cm[j*2+1]=clamp512k(stretch(st.cminit(j)>>8)*1024);
        }
        break;
      case SSE: 
        if (cp[1]>32) error("max size for SSE is 32");
        if (cp[2]>=i) error("SSE j >= i");
        if (cp[3]>cp[4]*4) error("SSE start > limit*4");
        cr.cm.resize(32, cp[1]);
        cr.limit=cp[4]*4;
        for (size_t j=0; j<cr.cm.size(); ++j)
          cr.cm[j]=squash((j&31)*64-992)<<17|cp[3];
        break;
      default: error("unknown component type");
    }
    assert(compsize[*cp]>0);
    cp+=compsize[*cp];
    assert(cp>=&z.header[7] && cp<&z.header[z.cend]);
  }
}
int Predictor::predict0() {
  assert(initTables);
  assert(c8>=1 && c8<=255);
  int n=z.header[6];
  assert(n>0 && n<=255);
  const U8* cp=&z.header[7];
  assert(cp[-1]==n);
  for (int i=0; i<n; ++i) {
    assert(cp>&z.header[0] && cp<&z.header[z.header.isize()-8]);
    Component& cr=comp[i];
    switch(cp[0]) {
      case CONS:  
        break;
      case CM:  
        cr.cxt=h[i]^hmap4;
        p[i]=stretch(cr.cm(cr.cxt)>>17);
        break;
      case ICM: 
        assert((hmap4&15)>0);
        if (c8==1 || (c8&0xf0)==16) cr.c=find(cr.ht, cp[1]+2, h[i]+16*c8);
        cr.cxt=cr.ht[cr.c+(hmap4&15)];
        p[i]=stretch(cr.cm(cr.cxt)>>8);
        break;
      case MATCH: 
        assert(cr.cm.size()==(size_t(1)<<cp[1]));
        assert(cr.ht.size()==(size_t(1)<<cp[2]));
        assert(cr.a<=255);
        assert(cr.c==0 || cr.c==1);
        assert(cr.cxt<8);
        assert(cr.limit<cr.ht.size());
        if (cr.a==0) p[i]=0;
        else {
          cr.c=(cr.ht(cr.limit-cr.b)>>(7-cr.cxt))&1; 
          p[i]=stretch(dt2k[cr.a]*(cr.c*-2+1)&32767);
        }
        break;
      case AVG: 
        p[i]=(p[cp[1]]*cp[3]+p[cp[2]]*(256-cp[3]))>>8;
        break;
      case MIX2: { 
        cr.cxt=((h[i]+(c8&cp[5]))&(cr.c-1));
        assert(cr.cxt<cr.a16.size());
        int w=cr.a16[cr.cxt];
        assert(w>=0 && w<65536);
        p[i]=(w*p[cp[2]]+(65536-w)*p[cp[3]])>>16;
        assert(p[i]>=-2048 && p[i]<2048);
      }
        break;
      case MIX: {  
        int m=cp[3];
        assert(m>=1 && m<=i);
        cr.cxt=h[i]+(c8&cp[5]);
        cr.cxt=(cr.cxt&(cr.c-1))*m; 
        assert(cr.cxt<=cr.cm.size()-m);
        int* wt=(int*)&cr.cm[cr.cxt];
        p[i]=0;
        for (int j=0; j<m; ++j)
          p[i]+=(wt[j]>>8)*p[cp[2]+j];
        p[i]=clamp2k(p[i]>>8);
      }
        break;
      case ISSE: { 
        assert((hmap4&15)>0);
        if (c8==1 || (c8&0xf0)==16)
          cr.c=find(cr.ht, cp[1]+2, h[i]+16*c8);
        cr.cxt=cr.ht[cr.c+(hmap4&15)];  
        int *wt=(int*)&cr.cm[cr.cxt*2];
        p[i]=clamp2k((wt[0]*p[cp[2]]+wt[1]*64)>>16);
      }
        break;
      case SSE: { 
        cr.cxt=(h[i]+c8)*32;
        int pq=p[cp[2]]+992;
        if (pq<0) pq=0;
        if (pq>1983) pq=1983;
        int wt=pq&63;
        pq>>=6;
        assert(pq>=0 && pq<=30);
        cr.cxt+=pq;
        p[i]=stretch(((cr.cm(cr.cxt)>>10)*(64-wt)+(cr.cm(cr.cxt+1)>>10)*wt)>>13);
        cr.cxt+=wt>>5;
      }
        break;
      default:
        error("component predict not implemented");
    }
    cp+=compsize[cp[0]];
    assert(cp<&z.header[z.cend]);
    assert(p[i]>=-2048 && p[i]<2048);
  }
  assert(cp[0]==NONE);
  return squash(p[n-1]);
}
void Predictor::update0(int y) {
  assert(initTables);
  assert(y==0 || y==1);
  assert(c8>=1 && c8<=255);
  assert(hmap4>=1 && hmap4<=511);
  const U8* cp=&z.header[7];
  int n=z.header[6];
  assert(n>=1 && n<=255);
  assert(cp[-1]==n);
  for (int i=0; i<n; ++i) {
    Component& cr=comp[i];
    switch(cp[0]) {
      case CONS:  
        break;
      case CM:  
        train(cr, y);
        break;
      case ICM: { 
        cr.ht[cr.c+(hmap4&15)]=st.next(cr.ht[cr.c+(hmap4&15)], y);
        U32& pn=cr.cm(cr.cxt);
        pn+=int(y*32767-(pn>>8))>>2;
      }
        break;
      case MATCH: 
      {
        assert(cr.a<=255);
        assert(cr.c==0 || cr.c==1);
        assert(cr.cxt<8);
        assert(cr.cm.size()==(size_t(1)<<cp[1]));
        assert(cr.ht.size()==(size_t(1)<<cp[2]));
        assert(cr.limit<cr.ht.size());
        if (int(cr.c)!=y) cr.a=0;  
        cr.ht(cr.limit)+=cr.ht(cr.limit)+y;
        if (++cr.cxt==8) {
          cr.cxt=0;
          ++cr.limit;
          cr.limit&=(1<<cp[2])-1;
          if (cr.a==0) {  
            cr.b=cr.limit-cr.cm(h[i]);
            if (cr.b&(cr.ht.size()-1))
              while (cr.a<255
                     && cr.ht(cr.limit-cr.a-1)==cr.ht(cr.limit-cr.a-cr.b-1))
                ++cr.a;
          }
          else cr.a+=cr.a<255;
          cr.cm(h[i])=cr.limit;
        }
      }
        break;
      case AVG:  
        break;
      case MIX2: { 
        assert(cr.a16.size()==cr.c);
        assert(cr.cxt<cr.a16.size());
        int err=(y*32767-squash(p[i]))*cp[4]>>5;
        int w=cr.a16[cr.cxt];
        w+=(err*(p[cp[2]]-p[cp[3]])+(1<<12))>>13;
        if (w<0) w=0;
        if (w>65535) w=65535;
        cr.a16[cr.cxt]=w;
      }
        break;
      case MIX: {   
        int m=cp[3];
        assert(m>0 && m<=i);
        assert(cr.cm.size()==m*cr.c);
        assert(cr.cxt+m<=cr.cm.size());
        int err=(y*32767-squash(p[i]))*cp[4]>>4;
        int* wt=(int*)&cr.cm[cr.cxt];
        for (int j=0; j<m; ++j)
          wt[j]=clamp512k(wt[j]+((err*p[cp[2]+j]+(1<<12))>>13));
      }
        break;
      case ISSE: { 
        assert(cr.cxt==cr.ht[cr.c+(hmap4&15)]);
        int err=y*32767-squash(p[i]);
        int *wt=(int*)&cr.cm[cr.cxt*2];
        wt[0]=clamp512k(wt[0]+((err*p[cp[2]]+(1<<12))>>13));
        wt[1]=clamp512k(wt[1]+((err+16)>>5));
        cr.ht[cr.c+(hmap4&15)]=st.next(cr.cxt, y);
      }
        break;
      case SSE:  
        train(cr, y);
        break;
      default:
        assert(0);
    }
    cp+=compsize[cp[0]];
    assert(cp>=&z.header[7] && cp<&z.header[z.cend] 
           && cp<&z.header[z.header.isize()-8]);
  }
  assert(cp[0]==NONE);
  c8+=c8+y;
  if (c8>=256) {
    z.run(c8-256);
    hmap4=1;
    c8=1;
    for (int i=0; i<n; ++i) h[i]=z.H(i);
  }
  else if (c8>=16 && c8<32)
    hmap4=(hmap4&0xf)<<5|y<<4|1;
  else
    hmap4=(hmap4&0x1f0)|(((hmap4&0xf)*2+y)&0xf);
}
size_t Predictor::find(Array<U8>& ht, int sizebits, U32 cxt) {
  assert(initTables);
  assert(ht.size()==size_t(16)<<sizebits);
  int chk=cxt>>sizebits&255;
  size_t h0=(cxt*16)&(ht.size()-16);
  if (ht[h0]==chk) return h0;
  size_t h1=h0^16;
  if (ht[h1]==chk) return h1;
  size_t h2=h0^32;
  if (ht[h2]==chk) return h2;
  if (ht[h0+1]<=ht[h1+1] && ht[h0+1]<=ht[h2+1])
    return memset(&ht[h0], 0, 16), ht[h0]=chk, h0;
  else if (ht[h1+1]<ht[h2+1])
    return memset(&ht[h1], 0, 16), ht[h1]=chk, h1;
  else
    return memset(&ht[h2], 0, 16), ht[h2]=chk, h2;
}
Decoder::Decoder(ZPAQL& z):
    in(0), low(1), high(0xFFFFFFFF), curr(0), rpos(0), wpos(0),
    pr(z), buf(BUFSIZE) {
}
void Decoder::init() {
  pr.init();
  if (pr.isModeled()) low=1, high=0xFFFFFFFF, curr=0;
  else low=high=curr=0;
}
int Decoder::decode(int p) {
  assert(pr.isModeled());
  assert(p>=0 && p<65536);
  assert(high>low && low>0);
  if (curr<low || curr>high) error("archive corrupted");
  assert(curr>=low && curr<=high);
  U32 mid=low+U32(((high-low)*U64(U32(p)))>>16);  
  assert(high>mid && mid>=low);
  int y;
  if (curr<=mid) y=1, high=mid;  
  else y=0, low=mid+1;
  while ((high^low)<0x1000000) { 
    high=high<<8|255;
    low=low<<8;
    low+=(low==0);
    int c=get();
    if (c<0) error("unexpected end of file");
    curr=curr<<8|c;
  }
  return y;
}
int Decoder::decompress() {
  if (pr.isModeled()) {  
    if (curr==0) {  
      for (int i=0; i<4; ++i)
        curr=curr<<8|get();
    }
    if (decode(0)) {
      if (curr!=0) error("decoding end of stream");
      return -1;
    }
    else {
      int c=1;
      while (c<256) {  
        int p=pr.predict()*2+1;
        c+=c+decode(p);
        pr.update(c&1);
      }
      return c-256;
    }
  }
  else {
    if (curr==0) {
      for (int i=0; i<4; ++i) curr=curr<<8|get();
      if (curr==0) return -1;
    }
    --curr;
    return get();
  }
}
int Decoder::skip() {
  int c=-1;
  if (pr.isModeled()) {
    while (curr==0)  
      curr=get();
    while (curr && (c=get())>=0)  
      curr=curr<<8|c;
    while ((c=get())==0) ;  
    return c;
  }
  else {
    if (curr==0)  
      for (int i=0; i<4 && (c=get())>=0; ++i) curr=curr<<8|c;
    while (curr>0) {
      while (curr>0) {
        --curr;
        if (get()<0) return error("skipped to EOF"), -1;
      }
      for (int i=0; i<4 && (c=get())>=0; ++i) curr=curr<<8|c;
    }
    if (c>=0) c=get();
    return c;
  }
}
void PostProcessor::init(int h, int m) {
  state=hsize=0;
  ph=h;
  pm=m;
  z.clear();
}
int PostProcessor::write(int c) {
  assert(c>=-1 && c<=255);
  switch (state) {
    case 0:  
      if (c<0) error("Unexpected EOS");
      state=c+1;  
      if (state>2) error("unknown post processing type");
      if (state==1) z.clear();
      break;
    case 1:  
      z.outc(c);
      break;
    case 2: 
      if (c<0) error("Unexpected EOS");
      hsize=c;  
      state=3;
      break;
    case 3:  
      if (c<0) error("Unexpected EOS");
      hsize+=c*256;  
      if (hsize<1) error("Empty PCOMP");
      z.header.resize(hsize+300);
      z.cend=8;
      z.hbegin=z.hend=z.cend+128;
      z.header[4]=ph;
      z.header[5]=pm;
      state=4;
      break;
    case 4:  
      if (c<0) error("Unexpected EOS");
      assert(z.hend<z.header.isize());
      z.header[z.hend++]=c;  
      if (z.hend-z.hbegin==hsize) {  
        hsize=z.cend-2+z.hend-z.hbegin;
        z.header[0]=hsize&255;  
        z.header[1]=hsize>>8;
        z.initp();
        state=5;
      }
      break;
    case 5:  
      z.run(c);
      if (c<0) z.flush();
      break;
  }
  return state;
}
bool Decompresser::findBlock(double* memptr) {
  assert(state==BLOCK);
  U32 h1=0x3D49B113, h2=0x29EB7F93, h3=0x2614BE13, h4=0x3828EB13;
  int c;
  while ((c=dec.get())!=-1) {
    h1=h1*12+c;
    h2=h2*20+c;
    h3=h3*28+c;
    h4=h4*44+c;
    if (h1==0xB16B88F1 && h2==0xFF5376F1 && h3==0x72AC5BF1 && h4==0x2F909AF1)
      break;  
  }
  if (c==-1) return false;
  if ((c=dec.get())!=1 && c!=2) error("unsupported ZPAQ level");
  if (dec.get()!=1) error("unsupported ZPAQL type");
  z.read(&dec);
  if (c==1 && z.header.isize()>6 && z.header[6]==0)
    error("ZPAQ level 1 requires at least 1 component");
  if (memptr) *memptr=z.memory();
  state=FILENAME;
  decode_state=FIRSTSEG;
  return true;
}
bool Decompresser::findFilename(Writer* filename) {
  assert(state==FILENAME);
  int c=dec.get();
  if (c==1) {  
    while (true) {
      c=dec.get();
      if (c==-1) error("unexpected EOF");
      if (c==0) {
        state=COMMENT;
        return true;
      }
      if (filename) filename->put(c);
    }
  }
  else if (c==255) {  
    state=BLOCK;
    return false;
  }
  else
    error("missing segment or end of block");
  return false;
}
void Decompresser::readComment(Writer* comment) {
  assert(state==COMMENT);
  state=DATA;
  while (true) {
    int c=dec.get();
    if (c==-1) error("unexpected EOF");
    if (c==0) break;
    if (comment) comment->put(c);
  }
  if (dec.get()!=0) error("missing reserved byte");
}
bool Decompresser::decompress(int n) {
  assert(state==DATA);
  if (decode_state==SKIP) error("decompression after skipped segment");
  assert(decode_state!=SKIP);
  if (decode_state==FIRSTSEG) {
    dec.init();
    assert(z.header.size()>5);
    pp.init(z.header[4], z.header[5]);
    decode_state=SEG;
  }
  while ((pp.getState()&3)!=1)
    pp.write(dec.decompress());
  while (n) {
    int c=dec.decompress();
    pp.write(c);
    if (c==-1) {
      state=SEGEND;
      return false;
    }
    if (n>0) --n;
  }
  return true;
}
void Decompresser::readSegmentEnd(char* sha1string) {
  assert(state==DATA || state==SEGEND);
  int c=0;
  if (state==DATA) {
    c=dec.skip();
    decode_state=SKIP;
  }
  else if (state==SEGEND)
    c=dec.get();
  state=FILENAME;
  if (c==254) {
    if (sha1string) sha1string[0]=0;  
  }
  else if (c==253) {
    if (sha1string) sha1string[0]=1;
    for (int i=1; i<=20; ++i) {
      c=dec.get();
      if (sha1string) sha1string[i]=c;
    }
  }
  else
    error("missing end of segment marker");
}
void decompress(Reader* in, Writer* out) {
  Decompresser d;
  d.setInput(in);
  d.setOutput(out);
  while (d.findBlock()) {       
    while (d.findFilename()) {  
      d.readComment();          
      d.decompress();           
      d.readSegmentEnd();       
    }
  }
}
void Encoder::init() {
  low=1;
  high=0xFFFFFFFF;
  pr.init();
  if (!pr.isModeled()) low=0, buf.resize(1<<16);
}
void Encoder::encode(int y, int p) {
  assert(out);
  assert(p>=0 && p<65536);
  assert(y==0 || y==1);
  assert(high>low && low>0);
  U32 mid=low+U32(((high-low)*U64(U32(p)))>>16);  
  assert(high>mid && mid>=low);
  if (y) high=mid; else low=mid+1; 
  while ((high^low)<0x1000000) { 
    out->put(high>>24);  
    high=high<<8|255;
    low=low<<8;
    low+=(low==0); 
  }
}
void Encoder::compress(int c) {
  assert(out);
  if (pr.isModeled()) {
    if (c==-1)
      encode(1, 0);
    else {
      assert(c>=0 && c<=255);
      encode(0, 0);
      for (int i=7; i>=0; --i) {
        int p=pr.predict()*2+1;
        assert(p>0 && p<65536);
        int y=c>>i&1;
        encode(y, p);
        pr.update(y);
      }
    }
  }
  else {
    if (low && (c<0 || low==buf.size())) {
      out->put((low>>24)&255);
      out->put((low>>16)&255);
      out->put((low>>8)&255);
      out->put(low&255);
      out->write(&buf[0], low);
      low=0;
    }
    if (c>=0) buf[low++]=c;
  }
}
const char* compname[256]=
  {"","const","cm","icm","match","avg","mix2","mix","isse","sse",0};
const char* opcodelist[272]={
"error","a++",  "a--",  "a!",   "a=0",  "",     "",     "a=r",
"b<>a", "b++",  "b--",  "b!",   "b=0",  "",     "",     "b=r",
"c<>a", "c++",  "c--",  "c!",   "c=0",  "",     "",     "c=r",
"d<>a", "d++",  "d--",  "d!",   "d=0",  "",     "",     "d=r",
"*b<>a","*b++", "*b--", "*b!",  "*b=0", "",     "",     "jt",
"*c<>a","*c++", "*c--", "*c!",  "*c=0", "",     "",     "jf",
"*d<>a","*d++", "*d--", "*d!",  "*d=0", "",     "",     "r=a",
"halt", "out",  "",     "hash", "hashd","",     "",     "jmp",
"a=a",  "a=b",  "a=c",  "a=d",  "a=*b", "a=*c", "a=*d", "a=",
"b=a",  "b=b",  "b=c",  "b=d",  "b=*b", "b=*c", "b=*d", "b=",
"c=a",  "c=b",  "c=c",  "c=d",  "c=*b", "c=*c", "c=*d", "c=",
"d=a",  "d=b",  "d=c",  "d=d",  "d=*b", "d=*c", "d=*d", "d=",
"*b=a", "*b=b", "*b=c", "*b=d", "*b=*b","*b=*c","*b=*d","*b=",
"*c=a", "*c=b", "*c=c", "*c=d", "*c=*b","*c=*c","*c=*d","*c=",
"*d=a", "*d=b", "*d=c", "*d=d", "*d=*b","*d=*c","*d=*d","*d=",
"",     "",     "",     "",     "",     "",     "",     "",
"a+=a", "a+=b", "a+=c", "a+=d", "a+=*b","a+=*c","a+=*d","a+=",
"a-=a", "a-=b", "a-=c", "a-=d", "a-=*b","a-=*c","a-=*d","a-=",
"a*=a", "a*=b", "a*=c", "a*=d", "a*=*b","a*=*c","a*=*d","a*=",
"a/=a", "a/=b", "a/=c", "a/=d", "a/=*b","a/=*c","a/=*d","a/=",
"a%=a", "a%=b", "a%=c", "a%=d", "a%=*b","a%=*c","a%=*d","a%=",
"a&=a", "a&=b", "a&=c", "a&=d", "a&=*b","a&=*c","a&=*d","a&=",
"a&~a", "a&~b", "a&~c", "a&~d", "a&~*b","a&~*c","a&~*d","a&~",
"a|=a", "a|=b", "a|=c", "a|=d", "a|=*b","a|=*c","a|=*d","a|=",
"a^=a", "a^=b", "a^=c", "a^=d", "a^=*b","a^=*c","a^=*d","a^=",
"a<<=a","a<<=b","a<<=c","a<<=d","a<<=*b","a<<=*c","a<<=*d","a<<=",
"a>>=a","a>>=b","a>>=c","a>>=d","a>>=*b","a>>=*c","a>>=*d","a>>=",
"a==a", "a==b", "a==c", "a==d", "a==*b","a==*c","a==*d","a==",
"a<a",  "a<b",  "a<c",  "a<d",  "a<*b", "a<*c", "a<*d", "a<",
"a>a",  "a>b",  "a>c",  "a>d",  "a>*b", "a>*c", "a>*d", "a>",
"",     "",     "",     "",     "",     "",     "",     "",
"",     "",     "",     "",     "",     "",     "",     "lj",
"post", "pcomp","end",  "if",   "ifnot","else", "endif","do",
"while","until","forever","ifl","ifnotl","elsel",";",    0};
void Compiler::next() {
  assert(in);
  for (; *in; ++in) {
    if (*in=='\n') ++line;
    if (*in=='(') state+=1+(state<0);
    else if (state>0 && *in==')') --state;
    else if (state<0 && *in<=' ') state=0;
    else if (state==0 && *in>' ') {state=-1; break;}
  }
  if (!*in) error("unexpected end of config");
}
int tolower(int c) {return (c>='A' && c<='Z') ? c+'a'-'A' : c;}
bool Compiler::matchToken(const char* word) {
  const char* a=in;
  for (; (*a>' ' && *a!='(' && *word); ++a, ++word)
    if (tolower(*a)!=tolower(*word)) return false;
  return !*word && (*a<=' ' || *a=='(');
}
void Compiler::syntaxError(const char* msg, const char* expected) {
  Array<char> sbuf(128);  
  char* s=&sbuf[0];
  strcat(s, "Config line ");
  for (int i=strlen(s), r=1000000; r; r/=10)  
    if (line/r) s[i++]='0'+line/r%10;
  strcat(s, " at ");
  for (int i=strlen(s); i<40 && *in>' '; ++i)  
    s[i]=*in++;
  strcat(s, ": ");
  strncat(s, msg, 40);  
  if (expected) {
    strcat(s, ", expected: ");
    strncat(s, expected, 20);  
  }
  error(s);
}
int Compiler::rtoken(const char* list[]) {
  assert(in);
  assert(list);
  next();
  for (int i=0; list[i]; ++i)
    if (matchToken(list[i]))
      return i;
  syntaxError("unexpected");
  assert(0);
  return -1; 
}
void Compiler::rtoken(const char* s) {
  assert(s);
  next();
  if (!matchToken(s)) syntaxError("expected", s);
}
int Compiler::rtoken(int low, int high) {
  next();
  int r=0;
  if (in[0]=='$' && in[1]>='1' && in[1]<='9') {
    if (in[2]=='+') r=atoi(in+3);
    if (args) r+=args[in[1]-'1'];
  }
  else if (in[0]=='-' || (in[0]>='0' && in[0]<='9')) r=atoi(in);
  else syntaxError("expected a number");
  if (r<low) syntaxError("number too low");
  if (r>high) syntaxError("number too high");
  return r;
}
int Compiler::compile_comp(ZPAQL& z) {
  int op=0;
  const int comp_begin=z.hend;
  while (true) {
    op=rtoken(opcodelist);
    if (op==POST || op==PCOMP || op==END) break;
    int operand=-1; 
    int operand2=-1;  
    if (op==IF) {
      op=JF;
      operand=0; 
      if_stack.push(z.hend+1); 
    }
    else if (op==IFNOT) {
      op=JT;
      operand=0;
      if_stack.push(z.hend+1); 
    }
    else if (op==IFL || op==IFNOTL) {  
      if (op==IFL) z.header[z.hend++]=(JT);
      if (op==IFNOTL) z.header[z.hend++]=(JF);
      z.header[z.hend++]=(3);
      op=LJ;
      operand=operand2=0;
      if_stack.push(z.hend+1);
    }
    else if (op==ELSE || op==ELSEL) {
      if (op==ELSE) op=JMP, operand=0;
      if (op==ELSEL) op=LJ, operand=operand2=0;
      int a=if_stack.pop();  
      assert(a>comp_begin && a<int(z.hend));
      if (z.header[a-1]!=LJ) {  
        assert(z.header[a-1]==JT || z.header[a-1]==JF || z.header[a-1]==JMP);
        int j=z.hend-a+1+(op==LJ); 
        assert(j>=0);
        if (j>127) syntaxError("IF too big, try IFL, IFNOTL");
        z.header[a]=j;
      }
      else {  
        int j=z.hend-comp_begin+2+(op==LJ);
        assert(j>=0);
        z.header[a]=j&255;
        z.header[a+1]=(j>>8)&255;
      }
      if_stack.push(z.hend+1);  
    }
    else if (op==ENDIF) {
      int a=if_stack.pop();  
      assert(a>comp_begin && a<int(z.hend));
      int j=z.hend-a-1;  
      assert(j>=0);
      if (z.header[a-1]!=LJ) {
        assert(z.header[a-1]==JT || z.header[a-1]==JF || z.header[a-1]==JMP);
        if (j>127) syntaxError("IF too big, try IFL, IFNOTL, ELSEL\n");
        z.header[a]=j;
      }
      else {
        assert(a+1<int(z.hend));
        j=z.hend-comp_begin;
        z.header[a]=j&255;
        z.header[a+1]=(j>>8)&255;
      }
    }
    else if (op==DO) {
      do_stack.push(z.hend);
    }
    else if (op==WHILE || op==UNTIL || op==FOREVER) {
      int a=do_stack.pop();
      assert(a>=comp_begin && a<int(z.hend));
      int j=a-z.hend-2;
      assert(j<=-2);
      if (j>=-127) {  
        if (op==WHILE) op=JT;
        if (op==UNTIL) op=JF;
        if (op==FOREVER) op=JMP;
        operand=j&255;
      }
      else {  
        j=a-comp_begin;
        assert(j>=0 && j<int(z.hend)-comp_begin);
        if (op==WHILE) {
          z.header[z.hend++]=(JF);
          z.header[z.hend++]=(3);
        }
        if (op==UNTIL) {
          z.header[z.hend++]=(JT);
          z.header[z.hend++]=(3);
        }
        op=LJ;
        operand=j&255;
        operand2=j>>8;
      }
    }
    else if ((op&7)==7) { 
      if (op==LJ) {
        operand=rtoken(0, 65535);
        operand2=operand>>8;
        operand&=255;
      }
      else if (op==JT || op==JF || op==JMP) {
        operand=rtoken(-128, 127);
        operand&=255;
      }
      else
        operand=rtoken(0, 255);
    }
    if (op>=0 && op<=255)
      z.header[z.hend++]=(op);
    if (operand>=0)
      z.header[z.hend++]=(operand);
    if (operand2>=0)
      z.header[z.hend++]=(operand2);
    if (z.hend>=z.header.isize()-130 || z.hend-z.hbegin+z.cend-2>65535)
      syntaxError("program too big");
  }
  z.header[z.hend++]=(0); 
  return op;
}
Compiler::Compiler(const char* in_, int* args_, ZPAQL& hz_, ZPAQL& pz_,
                   Writer* out2_): in(in_), args(args_), hz(hz_), pz(pz_),
                   out2(out2_), if_stack(1000), do_stack(1000) {
  line=1;
  state=0;
  hz.clear();
  pz.clear();
  hz.header.resize(68000); 
  rtoken("comp");
  hz.header[2]=rtoken(0, 255);  
  hz.header[3]=rtoken(0, 255);  
  hz.header[4]=rtoken(0, 255);  
  hz.header[5]=rtoken(0, 255);  
  const int n=hz.header[6]=rtoken(0, 255);  
  hz.cend=7;
  for (int i=0; i<n; ++i) {
    rtoken(i, i);
    CompType type=CompType(rtoken(compname));
    hz.header[hz.cend++]=type;
    int clen=libzpaq::compsize[type&255];
    if (clen<1 || clen>10) syntaxError("invalid component");
    for (int j=1; j<clen; ++j)
      hz.header[hz.cend++]=rtoken(0, 255);  
  }
  hz.header[hz.cend++];  
  hz.hbegin=hz.hend=hz.cend+128;
  rtoken("hcomp");
  int op=compile_comp(hz);
  int hsize=hz.cend-2+hz.hend-hz.hbegin;
  hz.header[0]=hsize&255;
  hz.header[1]=hsize>>8;
  if (op==POST) {
    rtoken(0, 0);
    rtoken("end");
  }
  else if (op==PCOMP) {
    pz.header.resize(68000);
    pz.header[4]=hz.header[4];  
    pz.header[5]=hz.header[5];  
    pz.cend=8;
    pz.hbegin=pz.hend=pz.cend+128;
    next();
    while (*in && *in!=';') {
      if (out2)
        out2->put(*in);
      ++in;
    }
    if (*in) ++in;
    op=compile_comp(pz);
    int len=pz.cend-2+pz.hend-pz.hbegin;  
    assert(len>=0);
    pz.header[0]=len&255;
    pz.header[1]=len>>8;
    if (op!=END)
      syntaxError("expected END");
  }
  else if (op!=END)
    syntaxError("expected END or POST 0 END or PCOMP cmd ; ... END");
}
void Compressor::writeTag() {
  assert(state==INIT);
  enc.out->put(0x37);
  enc.out->put(0x6b);
  enc.out->put(0x53);
  enc.out->put(0x74);
  enc.out->put(0xa0);
  enc.out->put(0x31);
  enc.out->put(0x83);
  enc.out->put(0xd3);
  enc.out->put(0x8c);
  enc.out->put(0xb2);
  enc.out->put(0x28);
  enc.out->put(0xb0);
  enc.out->put(0xd3);
}
void Compressor::startBlock(int level) {
  static const char models[]={
  26,0,1,2,0,0,2,3,16,8,19,0,0,96,4,28,
  59,10,59,112,25,10,59,10,59,112,56,0,
  69,0,3,3,0,0,8,3,5,8,13,0,8,17,1,8,
  18,2,8,18,3,8,19,4,4,22,24,7,16,0,7,24,
  (char)-1,0,17,104,74,4,95,1,59,112,10,25,59,112,10,25,
  59,112,10,25,59,112,10,25,59,112,10,25,59,10,59,112,
  25,69,(char)-49,8,112,56,0,
  (char)-60,0,5,9,0,0,22,1,(char)-96,3,5,8,13,1,8,16,
  2,8,18,3,8,19,4,8,19,5,8,20,6,4,22,24,
  3,17,8,19,9,3,13,3,13,3,13,3,14,7,16,0,
  15,24,(char)-1,7,8,0,16,10,(char)-1,6,0,15,16,24,0,9,
  8,17,32,(char)-1,6,8,17,18,16,(char)-1,9,16,19,32,(char)-1,6,
  0,19,20,16,0,0,17,104,74,4,95,2,59,112,10,25,
  59,112,10,25,59,112,10,25,59,112,10,25,59,112,10,25,
  59,10,59,112,10,25,59,112,10,25,69,(char)-73,32,(char)-17,64,47,
  14,(char)-25,91,47,10,25,60,26,48,(char)-122,(char)-105,20,112,63,9,70,
  (char)-33,0,39,3,25,112,26,52,25,25,74,10,4,59,112,25,
  10,4,59,112,25,10,4,59,112,25,65,(char)-113,(char)-44,72,4,59,
  112,8,(char)-113,(char)-40,8,68,(char)-81,60,60,25,69,(char)-49,9,112,25,25,
  25,25,25,112,56,0,
  0,0}; 
  if (level<1) error("compression level must be at least 1");
  const char* p=models;
  int i;
  for (i=1; i<level && toU16(p); ++i)
    p+=toU16(p)+2;
  if (toU16(p)<1) error("compression level too high");
  startBlock(p);
}
class MemoryReader: public Reader {
  const char* p;
public:
  MemoryReader(const char* p_): p(p_) {}
  int get() {return *p++&255;}
};
void Compressor::startBlock(const char* hcomp) {
  assert(state==INIT);
  MemoryReader m(hcomp);
  z.read(&m);
  pz.sha1=&sha1;
  assert(z.header.isize()>6);
  enc.out->put('z');
  enc.out->put('P');
  enc.out->put('Q');
  enc.out->put(1+(z.header[6]==0));  
  enc.out->put(1);
  z.write(enc.out, false);
  state=BLOCK1;
}
void Compressor::startBlock(const char* config, int* args, Writer* pcomp_cmd) {
  assert(state==INIT);
  Compiler(config, args, z, pz, pcomp_cmd);
  pz.sha1=&sha1;
  assert(z.header.isize()>6);
  enc.out->put('z');
  enc.out->put('P');
  enc.out->put('Q');
  enc.out->put(1+(z.header[6]==0));  
  enc.out->put(1);
  z.write(enc.out, false);
  state=BLOCK1;
}
void Compressor::startSegment(const char* filename, const char* comment) {
  assert(state==BLOCK1 || state==BLOCK2);
  enc.out->put(1);
  while (filename && *filename)
    enc.out->put(*filename++);
  enc.out->put(0);
  while (comment && *comment)
    enc.out->put(*comment++);
  enc.out->put(0);
  enc.out->put(0);
  if (state==BLOCK1) state=SEG1;
  if (state==BLOCK2) state=SEG2;
}
void Compressor::postProcess(const char* pcomp, int len) {
  if (state==SEG2) return;
  assert(state==SEG1);
  enc.init();
  if (!pcomp) {
    len=pz.hend-pz.hbegin;
    if (len>0) {
      assert(pz.header.isize()>pz.hend);
      assert(pz.hbegin>=0);
      pcomp=(const char*)&pz.header[pz.hbegin];
    }
    assert(len>=0);
  }
  else if (len==0) {
    len=toU16(pcomp);
    pcomp+=2;
  }
  if (len>0) {
    enc.compress(1);
    enc.compress(len&255);
    enc.compress((len>>8)&255);
    for (int i=0; i<len; ++i)
      enc.compress(pcomp[i]&255);
    if (verify)
      pz.initp();
  }
  else
    enc.compress(0);
  state=SEG2;
}
bool Compressor::compress(int n) {
  if (state==SEG1)
    postProcess();
  assert(state==SEG2);
  const int BUFSIZE=1<<14;
  char buf[BUFSIZE];  
  while (n) {
    int nbuf=BUFSIZE;  
    if (n>=0 && n<nbuf) nbuf=n;
    int nr=in->read(buf, nbuf);
    if (nr<0 || nr>BUFSIZE || nr>nbuf) error("invalid read size");
    if (nr<=0) return false;
    if (n>=0) n-=nr;
    for (int i=0; i<nr; ++i) {
      int ch=U8(buf[i]);
      enc.compress(ch);
      if (verify) {
        if (pz.hend) pz.run(ch);
        else sha1.put(ch);
      }
    }
  }
  return true;
}
void Compressor::endSegment(const char* sha1string) {
  if (state==SEG1)
    postProcess();
  assert(state==SEG2);
  enc.compress(-1);
  if (verify && pz.hend) {
    pz.run(-1);
    pz.flush();
  }
  enc.out->put(0);
  enc.out->put(0);
  enc.out->put(0);
  enc.out->put(0);
  if (sha1string) {
    enc.out->put(253);
    for (int i=0; i<20; ++i)
      enc.out->put(sha1string[i]);
  }
  else
    enc.out->put(254);
  state=BLOCK2;
}
char* Compressor::endSegmentChecksum(int64_t* size, bool dosha1) {
  if (state==SEG1)
    postProcess();
  assert(state==SEG2);
  enc.compress(-1);
  if (verify && pz.hend) {
    pz.run(-1);
    pz.flush();
  }
  enc.out->put(0);
  enc.out->put(0);
  enc.out->put(0);
  enc.out->put(0);
  if (verify) {
    if (size) *size=sha1.usize();
    memcpy(sha1result, sha1.result(), 20);
  }
  if (verify && dosha1) {
    enc.out->put(253);
    for (int i=0; i<20; ++i)
      enc.out->put(sha1result[i]);
  }
  else
    enc.out->put(254);
  state=BLOCK2;
  return verify ? sha1result : 0;
}
void Compressor::endBlock() {
  assert(state==BLOCK2);
  enc.out->put(255);
  state=INIT;
}
void compress(Reader* in, Writer* out, const char* method,
              const char* filename, const char* comment, bool dosha1) {
  int bs=4;
  if (method && method[0] && method[1]>='0' && method[1]<='9') {
    bs=method[1]-'0';
    if (method[2]>='0' && method[2]<='9') bs=bs*10+method[2]-'0';
    if (bs>11) bs=11;
  }
  bs=(0x100000<<bs)-4096;
  StringBuffer sb(bs);
  sb.write(0, bs);
  int n=0;
  while (in && (n=in->read((char*)sb.data(), bs))>0) {
    sb.resize(n);
    compressBlock(&sb, out, method, filename, comment, dosha1);
    filename=0;
    comment=0;
    sb.resize(0);
  }
}
static int flush1(ZPAQL* z) {
  try {
    z->flush();
    return 0;
  }
  catch(std::bad_alloc& x) {
    return 2;
  }
  catch(...) {
    return 3;
  }
}
static bool iserr(int op) {
  return op==0 || (op>=120 && op<=127) || (op>=240 && op<=254)
    || op==58 || (op<64 && (op%8==5 || op%8==6));
}
static int oplen(const U8* hcomp) {
  if (*hcomp==255) return 3;
  if (*hcomp%8==7) return 2;
  if (*hcomp<51 && (*hcomp%8-1)/2==0) {  
    int i;
    for (i=1; i<127 && hcomp[i]==hcomp[0]; ++i);
    return i;
  }
  return 1;
}
static void put(U8* rcode, int n, int& o, U32 x, int k) {
  while (k-->0) {
    if (o<n) rcode[o]=(x>>(k*8))&255;
    ++o;
  }
}
static void put4lsb(U8* rcode, int n, int& o, U32 x) {
  for (int k=0; k<4; ++k) {
    if (o<n) rcode[o]=(x>>(k*8))&255;
    ++o;
  }
}
#define put1(x) put(rcode, rcode_size, o, (x), 1)
#define put2(x) put(rcode, rcode_size, o, (x), 2)
#define put3(x) put(rcode, rcode_size, o, (x), 3)
#define put4(x) put(rcode, rcode_size, o, (x), 4)
#define put5(x,y) put4(x), put1(y)
#define put6(x,y) put4(x), put2(y)
#define put4r(x) put4lsb(rcode, rcode_size, o, x)
#define puta(x) t=U32(size_t(x)), put4r(t)
#define put1a(x,y) put1(x), puta(y)
#define put2a(x,y) put2(x), puta(y)
#define put3a(x,y) put3(x), puta(y)
#define put4a(x,y) put4(x), puta(y)
#define put5a(x,y,z) put4(x), put1(y), puta(z)
#define put2l(x,y) put2(x), t=U32(size_t(y)), put4r(t), \
  t=U32(size_t(y)>>(S*4)), put4r(t)
int ZPAQL::assemble() {
  const int S=sizeof(char*);      
  U32 t=0x12345678;
  if (*(char*)&t!=0x78 || (S!=4 && S!=8))
    error("JIT supported only for x86-32 and x86-64");
  const U8* hcomp=&header[hbegin];
  const int hlen=hend-hbegin+2;
  const int msize=m.size();
  const int hsize=h.size();
  static const int regcode[8]={2,6,7,5}; 
  Array<int> it(hlen);            
  int done=0;  
  int o=5;  
  const int halt=o;
  if (S==8) {
    put2l(0x48b9, &a);        
    put2(0x8911);             
    put2l(0x48b9, &b);        
    put2(0x8931);             
    put2l(0x48b9, &c);        
    put2(0x8939);             
    put2l(0x48b9, &d);        
    put2(0x8929);             
    put2l(0x48b9, &f);        
    put2(0x8919);             
    put4(0x4883c408);         
    put2(0x415f);             
    put2(0x415e);             
    put2(0x415d);             
    put2(0x415c);             
  }
  else {
    put2a(0x8915, &a);        
    put2a(0x8935, &b);        
    put2a(0x893d, &c);        
    put2a(0x892d, &d);        
    put2a(0x891d, &f);        
    put3(0x83c40c);           
  }
  put1(0x5b);                 
  put1(0x5f);                 
  put1(0x5e);                 
  put1(0x5d);                 
  put1(0xc3);                 
  const int outlabel=o;
  if (S==8) {
    put2l(0x48b8, &outbuf[0]);
    put2l(0x49ba, &bufptr);   
    put3(0x418b0a);           
    put3(0x881408);           
    put2(0xffc1);             
    put3(0x41890a);           
    put2a(0x81f9, outbuf.size());  
    put2(0x7403);             
    put2(0x31c0);             
    put1(0xc3);               
    put1(0x55);               
    put1(0x57);               
    put1(0x56);               
    put1(0x52);               
    put1(0x51);               
    put3(0x4889e5);           
    put4(0x4883c570);         
#if defined(unix) && !defined(__CYGWIN__)
    put2l(0x48bf, this);      
#else  
    put2l(0x48b9, this);      
#endif
    put2l(0x49bb, &flush1);   
    put3(0x41ffd3);           
    put1(0x59);               
    put1(0x5a);               
    put1(0x5e);               
    put1(0x5f);               
    put1(0x5d);               
  }
  else {
    put1a(0xb8, &outbuf[0]);  
    put2a(0x8b0d, &bufptr);   
    put3(0x881408);           
    put2(0xffc1);             
    put2a(0x890d, &bufptr);   
    put2a(0x81f9, outbuf.size());  
    put2(0x7403);             
    put2(0x31c0);             
    put1(0xc3);               
    put3(0x83ec0c);           
    put4(0x89542404);         
    put3a(0xc70424, this);    
    put1a(0xb8, &flush1);     
    put2(0xffd0);             
    put4(0x8b542404);         
    put3(0x83c40c);           
  }
  put1(0xc3);               
  it[0]=2;
  assert(hlen>0 && hcomp[hlen-1]==0);  
  do {
    done=0;
    const int NONE=0x80000000;
    for (int i=0; i<hlen; ++i) {
      int op=hcomp[i];
      if (it[i]) {
        int next1=i+oplen(hcomp+i), next2=NONE; 
        if (iserr(op)) next1=NONE;  
        if (op==56) next1=NONE, next2=0;  
        if (op==255) next1=NONE, next2=hcomp[i+1]+256*hcomp[i+2]; 
        if (op==39||op==47||op==63)next2=i+2+(hcomp[i+1]<<24>>24);
        if (op==63) next1=NONE;  
        if ((next2<0 || next2>=hlen) && next2!=NONE) next2=hlen-1; 
        if (next1>=0 && next1<hlen && !(it[next1]&1)) it[next1]|=1, ++done;
        if (next2>=0 && next2<hlen && !(it[next2]&2)) it[next2]|=2, ++done;
      }
    }
  } while (done>0);
  for (int i=0; i<hlen; ++i) {
    const int op1=hcomp[i]; 
    const int i2=i+1+(op1%8==7);  
    const int op2=hcomp[i2];  
    if (it[i] && op1>=216 && op1<240 && (op2==39 || op2==47)
        && it[i2]==1 && (i2==i+1 || it[i+1]==0)) {
      int code=(op1-208)/8*4; 
      it[i2]+=code;  
      for (int j=0; j<2 && code; ++j) {  
        int k=i2+2; 
        if (j==1) k=i2+2+(hcomp[i2+1]<<24>>24);  
        for (int l=0; l<hlen && code; ++l) {  
          if (k<0 || k>=hlen) break;  
          const int op=hcomp[k];
          if (op==39 || op==47) code=0;  
          else if (op>=216 && op<240) break;  
          else if (iserr(op)) break;  
          else if (op==255) k=hcomp[k+1]+256*hcomp[k+2]; 
          else if (op==63) k=k+2+(hcomp[k+1]<<24>>24);  
          else if (op==56) k=0;  
          else k=k+1+(op%8==7);  
        }
      }
      it[i]+=code;  
    }
  }
  const int start=o;
  assert(start>=16);
  put1(0x55);          
  put1(0x56);          
  put1(0x57);          
  put1(0x53);          
  if (S==8) {
    put2(0x4154);      
    put2(0x4155);      
    put2(0x4156);      
    put2(0x4157);      
    put4(0x4883ec08);  
    put2l(0x48b8, &a); 
    put2(0x8b10);      
    put2l(0x48b8, &b); 
    put2(0x8b30);      
    put2l(0x48b8, &c); 
    put2(0x8b38);      
    put2l(0x48b8, &d); 
    put2(0x8b28);      
    put2l(0x48b8, &f); 
    put2(0x8b18);      
    put2l(0x49bc, &h[0]);   
    put2l(0x49bd, &outbuf[0]); 
    put2l(0x49be, &r[0]);   
    put2l(0x49bf, &m[0]);   
  }
  else {
    put3(0x83ec0c);    
    put2a(0x8b15, &a); 
    put2a(0x8b35, &b); 
    put2a(0x8b3d, &c); 
    put2a(0x8b2d, &d); 
    put2a(0x8b1d, &f); 
  }
  for (int istart=0; istart<hlen; ++istart) {
    int inc=0;
    for (int i=istart; i<hlen && it[i]; i+=inc) {
      const int code=it[i];
      inc=oplen(hcomp+i);
      U32 t;
      assert(it.isize()>i);
      assert(i>=0 && i<hlen);
      if (code>=16) {
        if (i>istart) {
          int a=code-o;
          if (a>-120 && a<120)
            put2(0xeb00+((a-2)&255)); 
          else
            put1a(0xe9, a-5);  
        }
        break;
      }
      else {
        assert(i>=0 && i<it.isize());
        assert(it[i]>0 && it[i]<16);
        assert(o>=16);
        it[i]=o;
        ++done;
        const int op=hcomp[i];
        const int arg=hcomp[i+1]+((op==255)?256*hcomp[i+2]:0);
        const int ddd=op/8%8;
        const int sss=op%8;
        if (iserr(op)) {
          put1a(0xb8, 1);         
          put1a(0xe9, halt-o-4);  
          continue;
        }
        if (op==59 || (op>=64 && op<240 && op%8>=4 && op%8<7)) {
          put2(0x89c0+8*regcode[sss-3+(op==59)]);  
          const int sz=(sss==6?hsize:msize)-1;
          if (sz>=128) put1a(0x25, sz);            
          else put3(0x83e000+sz);                  
          const int move=(op>=64 && op<112); 
          if (sss<6) { 
            if (S==8) put5(0x410fb604+8*move*regcode[ddd],0x07);
            else put3a(0x0fb680+8*move*regcode[ddd], &m[0]);
          }
          else if ((0x06587000>>(op/8))&1) {
            if (S==8) put4(0x418b0484);            
            else put3a(0x8b0485, &h[0]);           
          }
        }
        if ((op>=32 && op<56 && op%8<5) || (op>=96 && op<120) || op==60) {
          put2(0x89c1+8*regcode[op/8%8-3-(op==60)]);
          const int sz=(ddd==6||op==60?hsize:msize)-1;
          if (sz>=128) put2a(0x81e1, sz);   
          else put3(0x83e100+sz);           
          if (op/8%8==6 || op==60) { 
            if (S==8) put4(0x498d0c8c);     
            else put3a(0x8d0c8d, &h[0]);    
          }
          else { 
            if (S==8) put4(0x498d0c0f);     
            else put2a(0x8d89, &m[0]);      
          }
        }
        switch((op/8)&31) {
          case 0:  
          case 1:  
          case 2:  
          case 3:  
            switch(sss) {
              case 0:  
                put2(0x87d0+regcode[ddd]);   
                break;
              case 1:  
                put3(0x83c000+256*regcode[ddd]+inc); 
                break;
              case 2:  
                put3(0x83e800+256*regcode[ddd]+inc); 
                break;
              case 3:  
                put2(0xf7d0+regcode[ddd]);   
                break;
              case 4:  
                put2(0x31c0+9*regcode[ddd]); 
                break;
              case 7:  
                if (S==8)
                  put3a(0x418b86+8*regcode[ddd], arg*4); 
                else
                  put2a(0x8b05+8*regcode[ddd], (&r[arg]));
                break;
            }
            break;
          case 4:  
          case 5:  
            switch(sss) {
              case 0:  
                put2(0x8611);                
                break;
              case 1:  
                put3(0x800100+inc);          
                break;
              case 2:  
                put3(0x802900+inc);          
                break;
              case 3:  
                put2(0xf611);                
                break;
              case 4:  
                put2(0x31c0);                
                put2(0x8801);                
                break;
              case 7:  
              {
                assert(code>=0 && code<16);
                static const unsigned char jtab[2][4]={{5,4,2,7},{4,5,3,6}};
                if (code<4) put2(0x84db);    
                if (arg>=128 && arg-257-i>=0 && o-it[arg-257-i]<120)
                  put2(0x7000+256*jtab[op==47][code/4]); 
                else
                  put2a(0x0f80+jtab[op==47][code/4], 0); 
                break;
              }
            }
            break;
          case 6:  
            switch(sss) {
              case 0:  
                put2(0x8711);             
                break;
              case 1:  
                put3(0x830100+inc);       
                break;
              case 2:  
                put3(0x832900+inc);       
                break;
              case 3:  
                put2(0xf711);             
                break;
              case 4:  
                put2(0x31c0);             
                put2(0x8901);             
                break;
              case 7:  
                if (S==8)
                  put3a(0x418996, arg*4); 
                else
                  put2a(0x8915, &r[arg]); 
                break;
            }
            break;
          case 7:  
            switch(op) {
              case 56: 
                put2(0x31c0);             
                put1a(0xe9, halt-o-4);    
                break;
              case 57:  
                put1a(0xe8, outlabel-o-4);
                put3(0x83f800);           
                put2(0x7405);             
                put1a(0xe9, halt-o-4);    
                break;
              case 59:  
                put3a(0x8d8410, 512);     
                put2a(0x69d0, 773);       
                break;
              case 60:  
                put2(0x8b01);             
                put3a(0x8d8410, 512);     
                put2a(0x69c0, 773);       
                put2(0x8901);             
                break;
              case 63:  
                put1a(0xe9, 0);           
                break;
            }
            break;
          case 8:   
          case 9:   
          case 10:  
          case 11:  
            if (sss==7)  
              put1a(0xb8+regcode[ddd], arg);         
            else if (sss==6) { 
              if (S==8)
                put4(0x418b0484+(regcode[ddd]<<11)); 
              else
                put3a(0x8b0485+(regcode[ddd]<<11),&h[0]);
            }
            else if (sss<4) 
              put2(0x89c0+regcode[ddd]+8*regcode[sss]);
            break;
          case 12:  
          case 13:  
            if (sss==7) put3(0xc60100+arg);          
            else if (sss==0) put2(0x8811);           
            else {
              if (sss<4) put2(0x89c0+8*regcode[sss]);
              put2(0x8801);                          
            }
            break;
          case 14:  
            if (sss<7) put2(0x8901+8*regcode[sss]);  
            else put2a(0xc701, arg);                 
            break;
          case 15: break; 
          case 16:  
            if (sss==6) {
              if (S==8) put4(0x41031484);            
              else put3a(0x031485, &h[0]);           
            }
            else if (sss<7) put2(0x01c2+8*regcode[sss]);
            else if (arg>=128) put2a(0x81c2, arg);   
            else put3(0x83c200+arg);                 
            break;
          case 17:  
            if (sss==6) {
              if (S==8) put4(0x412b1484);            
              else put3a(0x2b1485, &h[0]);           
            }
            else if (sss<7) put2(0x29c2+8*regcode[sss]);
            else if (arg>=128) put2a(0x81ea, arg);   
            else put3(0x83ea00+arg);                 
            break;
          case 18:  
            if (sss==6) {
              if (S==8) put5(0x410faf14,0x84);       
              else put4a(0x0faf1485, &h[0]);         
            }
            else if (sss<7) put3(0x0fafd0+regcode[sss]);
            else if (arg>=128) put2a(0x69d2, arg);   
            else put3(0x6bd200+arg);                 
            break;
          case 19:  
          case 20:  
            if (sss<7) put2(0x89c1+8*regcode[sss]);  
            else put1a(0xb9, arg);                   
            put2(0x85c9);                            
            put3(0x0f44d1);                          
            put2(0x7408-2*(op/8==20));               
            put2(0x89d0);                            
            put2(0x31d2);                            
            put2(0xf7f1);                            
            if (op/8==19) put2(0x89c2);              
            break;
          case 21:  
            if (sss==6) {
              if (S==8) put4(0x41231484);            
              else put3a(0x231485, &h[0]);           
            }
            else if (sss<7) put2(0x21c2+8*regcode[sss]);
            else if (arg>=128) put2a(0x81e2, arg);   
            else put3(0x83e200+arg);                 
            break;
          case 22:  
            if (sss==7) {
              if (arg<128) put3(0x83e200+(~arg&255));
              else put2a(0x81e2, ~arg);              
            }
            else {
              if (sss<4) put2(0x89c0+8*regcode[sss]);
              put2(0xf7d0);                          
              put2(0x21c2);                          
            }
            break;
          case 23:  
            if (sss==6) {
              if (S==8) put4(0x410b1484);            
              else put3a(0x0b1485, &h[0]);           
            }
            else if (sss<7) put2(0x09c2+8*regcode[sss]);
            else if (arg>=128) put2a(0x81ca, arg);   
            else put3(0x83ca00+arg);                 
            break;
          case 24:  
            if (sss==6) {
              if (S==8) put4(0x41331484);            
              else put3a(0x331485, &h[0]);           
            }
            else if (sss<7) put2(0x31c2+8*regcode[sss]);
            else if (arg>=128) put2a(0x81f2, arg);   
            else put3(0x83f200+arg);                 
            break;
          case 25:  
          case 26:  
            if (sss==7)  
              put3(0xc1e200+8*256*(op/8==26)+arg);   
            else {
              put2(0x89c1+8*regcode[sss]);           
              put2(0xd3e2+8*(op/8==26));             
            }
            break;
          case 27:  
          case 28:  
          case 29:  
            if (sss==6) {
              if (S==8) put4(0x413b1484);            
              else put3a(0x3b1485, &h[0]);           
            }
            else if (sss==7)  
              put2a(0x81fa, arg);                    
            else
              put2(0x39c2+8*regcode[sss]);           
            if (code<4) {
              if (op/8==27) put3(0x0f94c3);          
              if (op/8==28) put3(0x0f92c3);          
              if (op/8==29) put3(0x0f97c3);          
            }
            break;
          case 30:  
          case 31:  
            if (op==255) put1a(0xe9, 0);             
            break;
        }
      }
    }
  }
  const int rsize=o;
  if (o>rcode_size) return rsize;
  for (int i=0; i<hlen; ++i) {
    if (it[i]<16) continue;
    int op=hcomp[i];
    if (op==39 || op==47 || op==63 || op==255) {  
      int target=hcomp[i+1];
      if (op==255) target+=hcomp[i+2]*256;  
      else {
        if (target>=128) target-=256;
        target+=i+2;
      }
      if (target<0 || target>=hlen) target=hlen-1;  
      o=it[i];
      assert(o>=16 && o<rcode_size);
      if ((op==39 || op==47) && rcode[o]==0x84) o+=2;  
      assert(o>=16 && o<rcode_size);
      if (rcode[o]==0x0f) ++o;  
      assert(o<rcode_size);
      op=rcode[o++];  
      target=it[target]-o;
      if ((op>=0x72 && op<0x78) || op==0xeb) {  
        --target;
        if (target<-128 || target>127)
          error("Cannot code x86 short jump");
        assert(o<rcode_size);
        rcode[o]=target&255;
      }
      else if ((op>=0x82 && op<0x88) || op==0xe9) 
      {
        target-=4;
        puta(target);
      }
      else assert(false);  
    }
  }
  o=0;
  put1a(0xe9, start-5);  
  return rsize;
}
int Predictor::assemble_p() {
  Predictor& pr=*this;
  U8* rcode=pr.pcode;         
  int rcode_size=pcode_size;  
  int o=0;                    
  const int S=sizeof(char*);  
  U8* hcomp=&pr.z.header[0];  
#define off(x)  ((char*)&(pr.x)-(char*)&pr)
#define offc(x) ((char*)&(pr.comp[i].x)-(char*)&pr)
  U32 t=0x12345678;
  if (*(char*)&t!=0x78 || (S!=4 && S!=8))
    error("JIT supported only for x86-32 and x86-64");
  put1a(0xe9, 5);             
  put1a(0, 0x90909000);       
  put1(0x53);                 
  put1(0x55);                 
  put1(0x56);                 
  put1(0x57);                 
  if (S==4)
    put4(0x8b7c2414);         
  else {
#if !defined(unix) || defined(__CYGWIN__)
    put3(0x4889cf);           
#endif
  }
  const int n=hcomp[6];  
  U8* cp=hcomp+7;
  for (int i=0; i<n; ++i, cp+=compsize[cp[0]]) {
    if (cp-hcomp>=pr.z.cend) error("comp too big");
    if (cp[0]<1 || cp[0]>9) error("invalid component");
    assert(compsize[cp[0]]>0 && compsize[cp[0]]<8);
    switch (cp[0]) {
      case CONS:  
        break;
      case CM:  
        put2a(0x8b87, off(h[i]));              
        put2a(0x3387, off(hmap4));             
        put1a(0x25, (1<<cp[1])-1);             
        put2a(0x8987, offc(cxt));              
        if (S==8) put1(0x48);                  
        put2a(0x8bb7, offc(cm));               
        put3(0x8b0486);                        
        put3(0xc1e811);                        
        put4a(0x0fbf8447, off(stretcht));      
        put2a(0x8987, off(p[i]));              
        break;
      case ISSE:  
      case ICM: 
        if (S==8) put1(0x48);                  
        put2a(0x8bb7, offc(ht));               
        put2(0x8b07);                          
        put2(0x89c1);                          
        put3(0x83f801);                        
        put2(0x740a);                          
        put1a(0x25, 240);                      
        put3(0x83f810);                        
        put2(0x7576);                          
        put3(0xc1e104);                        
        put2a(0x038f, off(h[i]));              
        put2(0x89c8);                          
        put3(0xc1e902+cp[1]);                  
        put2a(0x81e1, 255);                    
        put3(0xc1e004);                        
        put1a(0x25, (64<<cp[1])-16);           
        put3(0x3a0c06);                        
        put2(0x744d);                          
        put3(0x83f010);                        
        put3(0x3a0c06);                        
        put2(0x7445);                          
        put3(0x83f030);                        
        put3(0x3a0c06);                        
        put2(0x743d);                          
        put3(0x83f021);                        
        put3(0x8a1c06);                        
        put2(0x89c2);                          
        put3(0x83f220);                        
        put3(0x3a1c16);                        
        put2(0x7708);                          
        put3(0x83f230);                        
        put3(0x3a1c16);                        
        put2(0x7611);                          
        put3(0x83f010);                        
        put3(0x8a1c06);                        
        put3(0x83f030);                        
        put3(0x3a1c06);                        
        put2(0x7303);                          
        put3(0x83f030);                        
        put3(0x83f001);                        
        put3(0x890c06);                        
        put2(0x31c9);                          
        put4(0x894c0604);                      
        put4(0x894c0608);                      
        put4(0x894c060c);                      
        put2a(0x8987, offc(c));                
        put2(0xeb06);                          
        put2a(0x8b87, offc(c));                
        put2a(0x8b97, off(hmap4));             
        put3(0x83e20f);                        
        put2(0x01d0);                          
        put4(0x0fb61406);                      
        put2a(0x8997, offc(cxt));              
        if (S==8) put1(0x48);                  
        put2a(0x8bb7, offc(cm));               
        if (cp[0]==ICM) {
          put3(0x8b0496);                      
          put3(0xc1e808);                      
          put4a(0x0fbf8447, off(stretcht));    
        }
        else {  
          put2a(0x8b87, off(p[cp[2]]));        
          put4(0x0faf04d6);                    
          put4(0x8b4cd604);                    
          put3(0xc1e106);                      
          put2(0x01c8);                        
          put3(0xc1f810);                      
          put1a(0xb9, 2047);                   
          put2(0x39c8);                        
          put3(0x0f4fc1);                      
          put1a(0xb9, -2048);                  
          put2(0x39c8);                        
          put3(0x0f4cc1);                      
        }
        put2a(0x8987, off(p[i]));              
        break;
      case MATCH: 
        if (S==8) put1(0x48);          
        put2a(0x8bb7, offc(ht));       
        put2a(0x8b87, offc(a));        
        put2(0x85c0);                  
        put2(0x7449);                  
        put1a(0xb9, 7);                
        put2a(0x2b8f, offc(cxt));      
        put2a(0x8b87, offc(limit));    
        put2a(0x2b87, offc(b));        
        put1a(0x25, (1<<cp[2])-1);     
        put4(0x0fb60406);              
        put2(0xd3e8);                  
        put3(0x83e001);                
        put2a(0x8987, offc(c));        
        put2a(0x8b87, offc(a));        
        put3a(0x8b8487, off(dt2k));    
        put2(0x7402);                  
        put2(0xf7d8);                  
        put1a(0x25, 0x7fff);           
        put4a(0x0fbf8447, off(stretcht)); 
        put2a(0x8987, off(p[i]));      
        break;
      case AVG: 
        put2a(0x8b87, off(p[cp[1]]));  
        put2a(0x2b87, off(p[cp[2]]));  
        put2a(0x69c0, cp[3]);          
        put3(0xc1f808);                
        put2a(0x0387, off(p[cp[2]]));  
        put2a(0x8987, off(p[i]));      
        break;
      case MIX2:   
        put2(0x8b07);                  
        put1a(0x25, cp[5]);            
        put2a(0x0387, off(h[i]));      
        put1a(0x25, (1<<cp[1])-1);     
        put2a(0x8987, offc(cxt));      
        if (S==8) put1(0x48);          
        put2a(0x8bb7, offc(a16));      
        put4(0x0fb70446);              
        put2a(0x8b8f, off(p[cp[2]]));  
        put2a(0x8b97, off(p[cp[3]]));  
        put2(0x29d1);                  
        put3(0x0fafc8);                
        put3(0xc1e210);                
        put2(0x01d1);                  
        put3(0xc1f910);                
        put2a(0x898f, off(p[i]));      
        break;
      case MIX:    
        put2(0x8b07);                          
        put1a(0x25, cp[5]);                    
        put2a(0x0387, off(h[i]));              
        put1a(0x25, (1<<cp[1])-1);             
        put2a(0x69c0, cp[3]);                  
        put2a(0x8987, offc(cxt));              
        if (S==8) put1(0x48);                  
        put2a(0x8bb7, offc(cm));               
        if (S==8) put1(0x48);                  
        put3(0x8d3486);                        
        for (int k=0; k<cp[3]; k+=8) {
          const int tail=cp[3]-k;  
          put4a(0xf30f6f8e, k*4);              
          if (tail>3) put4a(0xf30f6f96, k*4+16);
          put5(0x660f72e1,0x08);               
          if (tail>3) put5(0x660f72e2,0x08);   
          put4(0x660f6bca);                    
          put4a(0xf30f6f9f, off(p[cp[2]+k]));  
          if (tail>3)
            put4a(0xf30f6fa7,off(p[cp[2]+k+4]));
          put4(0x660f6bdc);                    
          if (tail>0 && tail<8) {  
            put4(0x660f76ed);                  
            put5(0x660f73dd, 16-tail*2);       
            put4(0x660fdbcd);                  
          }
          if (k==0) {  
            put4(0xf30f6fc1);                  
            put4(0x660ff5c3);                  
          }
          else {  
            put4(0x660ff5cb);                  
            put4(0x660ffec1);                  
          }
        }
        put4(0xf30f6fc8);                      
        put5(0x660f73d9,0x08);                 
        put4(0x660ffec1);                      
        put4(0xf30f6fc8);                      
        put5(0x660f73d9,0x04);                 
        put4(0x660ffec1);                      
        put4(0x660f7ec0);                      
        put3(0xc1f808);                        
        put1a(0x3d, 2047);                     
        put2(0x7e05);                          
        put1a(0xb8, 2047);                     
        put1a(0x3d, -2048);                    
        put2(0x7d05);                          
        put1a(0xb8, -2048);                    
        put2a(0x8987, off(p[i]));              
        break;
      case SSE:  
        put2a(0x8b8f, off(h[i]));      
        put2(0x030f);                  
        put2a(0x81e1, (1<<cp[1])-1);   
        put3(0xc1e105);                
        put2a(0x8b87, off(p[cp[2]]));  
        put1a(0x05, 992);              
        put2(0x31d2);                  
        put2(0x39d0);                  
        put3(0x0f4cc2);                
        put1a(0xba, 1983);             
        put2(0x39d0);                  
        put3(0x0f4fc2);                
        put2(0x89c2);                  
        put3(0x83e23f);                
        put3(0xc1e806);                
        put2(0x01c1);                  
        if (S==8) put1(0x48);          
        put2a(0x8bb7, offc(cm));       
        put3(0x8b048e);                
        put4(0x8b5c8e04);              
        put3(0x83fa20);                
        put3(0x83d9ff);                
        put2a(0x898f, offc(cxt));      
        put3(0xc1e80a);                
        put3(0xc1eb0a);                
        put2(0x29c3);                  
        put3(0x0fafda);                
        put3(0xc1e006);                
        put2(0x01d8);                  
        put3(0xc1e80d);                
        put4a(0x0fbf8447, off(stretcht));  
        put2a(0x8987, off(p[i]));      
        break;
      default:
        error("invalid ZPAQ component");
    }
  }
  put2a(0x8b87, off(p[n-1]));          
  put1a(0x05, 0x800);                  
  put4a(0x0fbf8447, off(squasht[0]));  
  put1(0x5f);                          
  put1(0x5e);                          
  put1(0x5d);                          
  put1(0x5b);                          
  put1(0xc3);                          
  int save_o=o;
  o=5;
  put1a(0xe9, save_o-10);      
  o=save_o;
  put1(0x53);                  
  put1(0x55);                  
  put1(0x56);                  
  put1(0x57);                  
  if (S==4) {
    put4(0x8b7c2414);          
    put4(0x8b6c2418);          
  }
  else {
#if defined(unix) && !defined(__CYGWIN__)  
    put3(0x4889f5);            
#else
    put3(0x4889cf);            
    put3(0x4889d5);            
#endif
  }
  cp=hcomp+7;
  for (int i=0; i<n; ++i, cp+=compsize[cp[0]]) {
    assert(cp-hcomp<pr.z.cend);
    assert (cp[0]>=1 && cp[0]<=9);
    assert(compsize[cp[0]]>0 && compsize[cp[0]]<8);
    switch (cp[0]) {
      case CONS:  
        break;
      case SSE:  
      case CM:   
        if (S==8) put1(0x48);          
        put2a(0x8bb7, offc(cm));       
        put2a(0x8b87, offc(cxt));      
        put1a(0x25, pr.comp[i].cm.size()-1);  
        if (S==8) put1(0x48);          
        put3(0x8d3486);                
        put2(0x8b06);                  
        put2(0x89c2);                  
        put3(0xc1e811);                
        put2(0x89e9);                  
        put3(0xc1e10f);                
        put2(0x29e9);                  
        put2(0x29c1);                  
        put2a(0x81e2, 0x3ff);          
        put3a(0x8b8497, off(dt));      
        put3(0x0fafc8);                
        put2a(0x81e1, 0xfffffc00);     
        put2a(0x81fa, cp[2+2*(cp[0]==SSE)]*4); 
        put2(0x110e);                  
        break;
      case ICM:   
      case ISSE:  
        put3(0x8b4700+off(hmap4));     
        put3(0x83e00f);                
        put2a(0x0387, offc(c));        
        if (S==8) put1(0x48);          
        put2a(0x8bb7, offc(ht));       
        put4(0x0fb61406);              
        put4(0x8d5c9500);              
        put4a(0x0fb69c1f, off(st));    
        put3(0x881c06);                
        if (S==8) put1(0x48);          
        put2a(0x8bb7, offc(cm));       
        if (cp[0]==ICM) {
          if (S==8) put1(0x48);        
          put3(0x8d3496);              
          put2(0x8b06);                
          put3(0xc1e808);              
          put2(0x89e9);                
          put3(0xc1e10f);              
          put2(0x29e9);                
          put2(0x29c1);                
          put3(0xc1f902);              
          put2(0x010e);                
        }
        else {
          put2a(0x8b87, off(p[i]));    
          put1a(0x05, 2048);           
          put4a(0x0fb78447, off(squasht)); 
          put2(0x89e9);                
          put3(0xc1e10f);              
          put2(0x29e9);                
          put2(0x29c1);                
          put2a(0x8b87, off(p[cp[2]]));
          put3(0x0fafc1);              
          put1a(0x05, (1<<12));        
          put3(0xc1f80d);              
          put3(0x0304d6);              
          put1a(0x3d, (1<<19)-1);      
          put2(0x7e05);                
          put1a(0xb8, (1<<19)-1);      
          put1a(0x3d, 0xfff80000);     
          put2(0x7d05);                
          put1a(0xb8, 0xfff80000);     
          put3(0x8904d6);              
          put3(0x83c110);              
          put3(0xc1f905);              
          put4(0x034cd604);            
          put2a(0x81f9, (1<<19)-1);    
          put2(0x7e05);                
          put1a(0xb9, (1<<19)-1);      
          put2a(0x81f9, 0xfff80000);   
          put2(0x7d05);                
          put1a(0xb9, 0xfff80000);     
          put4(0x894cd604);            
        }
        break;
      case MATCH: 
        if (S==8) put1(0x48);          
        put2a(0x8bb7, offc(ht));       
        if (S==8) put1(0x48);          
        put2a(0x8b9f, offc(cm));       
        put2a(0x8b87, offc(c));        
        put2(0x39e8);                  
        put2(0x7408);                  
        put2(0x31c0);                  
        put2a(0x8987, offc(a));        
        put2a(0x8b87, offc(limit));    
        put4(0x0fb60c06);              
        put2(0x01c9);                  
        put2(0x01e9);                  
        put3(0x880c06);                
        put2a(0x8b87, offc(cxt));      
        put2(0xffc0);                  
        put3(0x83e007);                
        put2a(0x8987, offc(cxt));      
        put2a(0x0f85, 0x9b);           
        put2a(0x8b87, offc(limit));    
        put2(0xffc0);                  
        put1a(0x25, (1<<cp[2])-1);     
        put2a(0x8987, offc(limit));    
        put2a(0x8b87, offc(a));        
        put2(0x85c0);                  
        put2(0x755c);                  
        put2a(0x8b8f, off(h[i]));      
        put2a(0x81e1, (1<<cp[1])-1);   
        put2a(0x8b87, offc(limit));    
        put3(0x2b048b);                
        put2a(0x8987, offc(b));        
        put1a(0xa9, (1<<cp[2])-1);     
        put2(0x7448);                  
        put1(0x53);                    
        put2a(0x8b9f, offc(limit));    
        put2(0x89da);                  
        put2(0x29c3);                  
        put2(0x31c9);                  
        put2a(0x81f9, 0xff);           
        put2(0x741c);                  
        put2(0xffca);                  
        put2(0xffcb);                  
        put2a(0x81e2, (1<<cp[2])-1);   
        put2a(0x81e3, (1<<cp[2])-1);   
        put3(0x8a0416);                
        put3(0x3a041e);                
        put2(0x7504);                  
        put2(0xffc1);                  
        put2(0xebdc);                  
        put1(0x5b);                    
        put2a(0x898f, offc(a));        
        put2(0xeb0e);                  
        put1a(0x3d, 0xff);             
        put3(0x83d000);                
        put2a(0x8987, offc(a));        
        put2a(0x8b87, off(h[i]));      
        put1a(0x25, (1<<cp[1])-1);     
        put2a(0x8b8f, offc(limit));    
        put3(0x890c83);                
        break;
      case AVG:  
        break;
      case MIX2: 
        put2a(0x8b87, off(p[i]));      
        put1a(0x05, 2048);             
        put4a(0x0fb78447, off(squasht));
        put2(0x89e9);                  
        put3(0xc1e10f);                
        put2(0x29e9);                  
        put2(0x29c1);                  
        put2a(0x69c9, cp[4]);          
        put3(0xc1f905);                
        put2a(0x8b87, offc(cxt));      
        if (S==8) put1(0x48);          
        put2a(0x8bb7, offc(a16));      
        if (S==8) put1(0x48);          
        put3(0x8d3446);                
        put2a(0x8b87, off(p[cp[2]]));  
        put2a(0x2b87, off(p[cp[3]]));  
        put3(0x0fafc1);                
        put1a(0x05, 1<<12);            
        put3(0xc1f80d);                
        put3(0x0fb716);                
        put2(0x01d0);                  
        put1a(0xba, 0xffff);           
        put2(0x39d0);                  
        put3(0x0f4fc2);                
        put2(0x31d2);                  
        put2(0x39d0);                  
        put3(0x0f4cc2);                
        put3(0x668906);                
        break;
      case MIX: 
        put2a(0x8b87, off(p[i]));      
        put1a(0x05, 2048);             
        put4a(0x0fb78447, off(squasht));
        put2(0x89e9);                  
        put3(0xc1e10f);                
        put2(0x29e9);                  
        put2(0x29c1);                  
        put2a(0x69c9, cp[4]);          
        put3(0xc1f904);                
        put2a(0x8b87, offc(cxt));      
        if (S==8) put1(0x48);          
        put2a(0x8bb7, offc(cm));       
        if (S==8) put1(0x48);          
        put3(0x8d3486);                
        for (int k=0; k<cp[3]; ++k) {
          put2a(0x8b87,off(p[cp[2]+k]));
          put3(0x0fafc1);              
          put1a(0x05, 1<<12);          
          put3(0xc1f80d);              
          put2(0x0306);                
          put1a(0x3d, (1<<19)-1);      
          put2(0x7e05);                
          put1a(0xb8, (1<<19)-1);      
          put1a(0x3d, 0xfff80000);     
          put2(0x7d05);                
          put1a(0xb8, 0xfff80000);     
          put2(0x8906);                
          if (k<cp[3]-1) {
            if (S==8) put1(0x48);      
            put3(0x83c604);            
          }
        }
        break;
      default:
        error("invalid ZPAQ component");
    }
  }
  put1(0x5f);                 
  put1(0x5e);                 
  put1(0x5d);                 
  put1(0x5b);                 
  put1(0xc3);                 
  return o;
}
int Predictor::predict() {
  if (!pcode) {
    allocx(pcode, pcode_size, (z.cend*100+4096)&-4096);
    int n=assemble_p();
    if (n>pcode_size) {
      allocx(pcode, pcode_size, n);
      n=assemble_p();
    }
    if (!pcode || n<15 || pcode_size<15)
      error("run JIT failed");
  }
  assert(pcode && pcode[0]);
  return ((int(*)(Predictor*))&pcode[10])(this);
}
void Predictor::update(int y) {
  assert(pcode && pcode[5]);
  ((void(*)(Predictor*, int))&pcode[5])(this, y);
  c8+=c8+y;
  if (c8>=256) {
    z.run(c8-256);
    hmap4=1;
    c8=1;
    for (int i=0; i<z.header[6]; ++i) h[i]=z.H(i);
  }
  else if (c8>=16 && c8<32)
    hmap4=(hmap4&0xf)<<5|y<<4|1;
  else
    hmap4=(hmap4&0x1f0)|(((hmap4&0xf)*2+y)&0xf);
}
void ZPAQL::run(U32 input) {
  if (!rcode) {
    allocx(rcode, rcode_size, (hend*10+4096)&-4096);
    int n=assemble();
    if (n>rcode_size) {
      allocx(rcode, rcode_size, n);
      n=assemble();
    }
    if (!rcode || n<10 || rcode_size<10)
      error("run JIT failed");
  }
  a=input;
  const U32 rc=((int(*)())(&rcode[0]))();
  if (rc==0) return;
  else if (rc==1) libzpaq::error("Bad ZPAQL opcode");
  else if (rc==2) libzpaq::error("Out of memory");
  else if (rc==3) libzpaq::error("Write error");
  else libzpaq::error("ZPAQL execution error");
}
#define INLINE_divsuf __inline
#if defined(ALPHABET_SIZE) && (ALPHABET_SIZE < 1)
# undef ALPHABET_SIZE
#endif
#if !defined(ALPHABET_SIZE)
# define ALPHABET_SIZE (256)
#endif
#define BUCKET_A_SIZE (ALPHABET_SIZE)
#define BUCKET_B_SIZE (ALPHABET_SIZE * ALPHABET_SIZE)
#if defined(SS_INSERTIONSORT_THRESHOLD)
# if SS_INSERTIONSORT_THRESHOLD < 1
#  undef SS_INSERTIONSORT_THRESHOLD
#  define SS_INSERTIONSORT_THRESHOLD (1)
# endif
#else
# define SS_INSERTIONSORT_THRESHOLD (8)
#endif
#if defined(SS_BLOCKSIZE)
# if SS_BLOCKSIZE < 0
#  undef SS_BLOCKSIZE
#  define SS_BLOCKSIZE (0)
# elif 32768 <= SS_BLOCKSIZE
#  undef SS_BLOCKSIZE
#  define SS_BLOCKSIZE (32767)
# endif
#else
# define SS_BLOCKSIZE (1024)
#endif
#if SS_BLOCKSIZE == 0
# define SS_MISORT_STACKSIZE (96)
#elif SS_BLOCKSIZE <= 4096
# define SS_MISORT_STACKSIZE (16)
#else
# define SS_MISORT_STACKSIZE (24)
#endif
#define SS_SMERGE_STACKSIZE (32)
#define TR_INSERTIONSORT_THRESHOLD (8)
#define TR_STACKSIZE (64)
#ifndef SWAP
# define SWAP(_a, _b) do { t = (_a); (_a) = (_b); (_b) = t; } while(0)
#endif 
#ifndef MIN
# define MIN(_a, _b) (((_a) < (_b)) ? (_a) : (_b))
#endif 
#ifndef MAX
# define MAX(_a, _b) (((_a) > (_b)) ? (_a) : (_b))
#endif 
#define STACK_PUSH(_a, _b, _c, _d)\
  do {\
    assert(ssize < STACK_SIZE);\
    stack[ssize].a = (_a), stack[ssize].b = (_b),\
    stack[ssize].c = (_c), stack[ssize++].d = (_d);\
  } while(0)
#define STACK_PUSH5(_a, _b, _c, _d, _e)\
  do {\
    assert(ssize < STACK_SIZE);\
    stack[ssize].a = (_a), stack[ssize].b = (_b),\
    stack[ssize].c = (_c), stack[ssize].d = (_d), stack[ssize++].e = (_e);\
  } while(0)
#define STACK_POP(_a, _b, _c, _d)\
  do {\
    assert(0 <= ssize);\
    if(ssize == 0) { return; }\
    (_a) = stack[--ssize].a, (_b) = stack[ssize].b,\
    (_c) = stack[ssize].c, (_d) = stack[ssize].d;\
  } while(0)
#define STACK_POP5(_a, _b, _c, _d, _e)\
  do {\
    assert(0 <= ssize);\
    if(ssize == 0) { return; }\
    (_a) = stack[--ssize].a, (_b) = stack[ssize].b,\
    (_c) = stack[ssize].c, (_d) = stack[ssize].d, (_e) = stack[ssize].e;\
  } while(0)
#define BUCKET_A(_c0) bucket_A[(_c0)]
#if ALPHABET_SIZE == 256
#define BUCKET_B(_c0, _c1) (bucket_B[((_c1) << 8) | (_c0)])
#define BUCKET_BSTAR(_c0, _c1) (bucket_B[((_c0) << 8) | (_c1)])
#else
#define BUCKET_B(_c0, _c1) (bucket_B[(_c1) * ALPHABET_SIZE + (_c0)])
#define BUCKET_BSTAR(_c0, _c1) (bucket_B[(_c0) * ALPHABET_SIZE + (_c1)])
#endif
static const int lg_table[256]= {
 -1,0,1,1,2,2,2,2,3,3,3,3,3,3,3,3,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,
  5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
  6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,
  6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,
  7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,
  7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,
  7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,
  7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7
};
#if (SS_BLOCKSIZE == 0) || (SS_INSERTIONSORT_THRESHOLD < SS_BLOCKSIZE)
static INLINE_divsuf
int
ss_ilg(int n) {
#if SS_BLOCKSIZE == 0
  return (n & 0xffff0000) ?
          ((n & 0xff000000) ?
            24 + lg_table[(n >> 24) & 0xff] :
            16 + lg_table[(n >> 16) & 0xff]) :
          ((n & 0x0000ff00) ?
             8 + lg_table[(n >>  8) & 0xff] :
             0 + lg_table[(n >>  0) & 0xff]);
#elif SS_BLOCKSIZE < 256
  return lg_table[n];
#else
  return (n & 0xff00) ?
          8 + lg_table[(n >> 8) & 0xff] :
          0 + lg_table[(n >> 0) & 0xff];
#endif
}
#endif 
#if SS_BLOCKSIZE != 0
static const int sqq_table[256] = {
  0,  16,  22,  27,  32,  35,  39,  42,  45,  48,  50,  53,  55,  57,  59,  61,
 64,  65,  67,  69,  71,  73,  75,  76,  78,  80,  81,  83,  84,  86,  87,  89,
 90,  91,  93,  94,  96,  97,  98,  99, 101, 102, 103, 104, 106, 107, 108, 109,
110, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126,
128, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142,
143, 144, 144, 145, 146, 147, 148, 149, 150, 150, 151, 152, 153, 154, 155, 155,
156, 157, 158, 159, 160, 160, 161, 162, 163, 163, 164, 165, 166, 167, 167, 168,
169, 170, 170, 171, 172, 173, 173, 174, 175, 176, 176, 177, 178, 178, 179, 180,
181, 181, 182, 183, 183, 184, 185, 185, 186, 187, 187, 188, 189, 189, 190, 191,
192, 192, 193, 193, 194, 195, 195, 196, 197, 197, 198, 199, 199, 200, 201, 201,
202, 203, 203, 204, 204, 205, 206, 206, 207, 208, 208, 209, 209, 210, 211, 211,
212, 212, 213, 214, 214, 215, 215, 216, 217, 217, 218, 218, 219, 219, 220, 221,
221, 222, 222, 223, 224, 224, 225, 225, 226, 226, 227, 227, 228, 229, 229, 230,
230, 231, 231, 232, 232, 233, 234, 234, 235, 235, 236, 236, 237, 237, 238, 238,
239, 240, 240, 241, 241, 242, 242, 243, 243, 244, 244, 245, 245, 246, 246, 247,
247, 248, 248, 249, 249, 250, 250, 251, 251, 252, 252, 253, 253, 254, 254, 255
};
static INLINE_divsuf
int
ss_isqrt(int x) {
  int y, e;
  if(x >= (SS_BLOCKSIZE * SS_BLOCKSIZE)) { return SS_BLOCKSIZE; }
  e = (x & 0xffff0000) ?
        ((x & 0xff000000) ?
          24 + lg_table[(x >> 24) & 0xff] :
          16 + lg_table[(x >> 16) & 0xff]) :
        ((x & 0x0000ff00) ?
           8 + lg_table[(x >>  8) & 0xff] :
           0 + lg_table[(x >>  0) & 0xff]);
  if(e >= 16) {
    y = sqq_table[x >> ((e - 6) - (e & 1))] << ((e >> 1) - 7);
    if(e >= 24) { y = (y + 1 + x / y) >> 1; }
    y = (y + 1 + x / y) >> 1;
  } else if(e >= 8) {
    y = (sqq_table[x >> ((e - 6) - (e & 1))] >> (7 - (e >> 1))) + 1;
  } else {
    return sqq_table[x] >> 4;
  }
  return (x < (y * y)) ? y - 1 : y;
}
#endif 
static INLINE_divsuf
int
ss_compare(const unsigned char *T,
           const int *p1, const int *p2,
           int depth) {
  const unsigned char *U1, *U2, *U1n, *U2n;
  for(U1 = T + depth + *p1,
      U2 = T + depth + *p2,
      U1n = T + *(p1 + 1) + 2,
      U2n = T + *(p2 + 1) + 2;
      (U1 < U1n) && (U2 < U2n) && (*U1 == *U2);
      ++U1, ++U2) {
  }
  return U1 < U1n ?
        (U2 < U2n ? *U1 - *U2 : 1) :
        (U2 < U2n ? -1 : 0);
}
#if (SS_BLOCKSIZE != 1) && (SS_INSERTIONSORT_THRESHOLD != 1)
static
void
ss_insertionsort(const unsigned char *T, const int *PA,
                 int *first, int *last, int depth) {
  int *i, *j;
  int t;
  int r;
  for(i = last - 2; first <= i; --i) {
    for(t = *i, j = i + 1; 0 < (r = ss_compare(T, PA + t, PA + *j, depth));) {
      do { *(j - 1) = *j; } while((++j < last) && (*j < 0));
      if(last <= j) { break; }
    }
    if(r == 0) { *j = ~*j; }
    *(j - 1) = t;
  }
}
#endif 
#if (SS_BLOCKSIZE == 0) || (SS_INSERTIONSORT_THRESHOLD < SS_BLOCKSIZE)
static INLINE_divsuf
void
ss_fixdown(const unsigned char *Td, const int *PA,
           int *SA, int i, int size) {
  int j, k;
  int v;
  int c, d, e;
  for(v = SA[i], c = Td[PA[v]]; (j = 2 * i + 1) < size; SA[i] = SA[k], i = k) {
    d = Td[PA[SA[k = j++]]];
    if(d < (e = Td[PA[SA[j]]])) { k = j; d = e; }
    if(d <= c) { break; }
  }
  SA[i] = v;
}
static
void
ss_heapsort(const unsigned char *Td, const int *PA, int *SA, int size) {
  int i, m;
  int t;
  m = size;
  if((size % 2) == 0) {
    m--;
    if(Td[PA[SA[m / 2]]] < Td[PA[SA[m]]]) { SWAP(SA[m], SA[m / 2]); }
  }
  for(i = m / 2 - 1; 0 <= i; --i) { ss_fixdown(Td, PA, SA, i, m); }
  if((size % 2) == 0) { SWAP(SA[0], SA[m]); ss_fixdown(Td, PA, SA, 0, m); }
  for(i = m - 1; 0 < i; --i) {
    t = SA[0], SA[0] = SA[i];
    ss_fixdown(Td, PA, SA, 0, i);
    SA[i] = t;
  }
}
static INLINE_divsuf
int *
ss_median3(const unsigned char *Td, const int *PA,
           int *v1, int *v2, int *v3) {
  int *t;
  if(Td[PA[*v1]] > Td[PA[*v2]]) { SWAP(v1, v2); }
  if(Td[PA[*v2]] > Td[PA[*v3]]) {
    if(Td[PA[*v1]] > Td[PA[*v3]]) { return v1; }
    else { return v3; }
  }
  return v2;
}
static INLINE_divsuf
int *
ss_median5(const unsigned char *Td, const int *PA,
           int *v1, int *v2, int *v3, int *v4, int *v5) {
  int *t;
  if(Td[PA[*v2]] > Td[PA[*v3]]) { SWAP(v2, v3); }
  if(Td[PA[*v4]] > Td[PA[*v5]]) { SWAP(v4, v5); }
  if(Td[PA[*v2]] > Td[PA[*v4]]) { SWAP(v2, v4); SWAP(v3, v5); }
  if(Td[PA[*v1]] > Td[PA[*v3]]) { SWAP(v1, v3); }
  if(Td[PA[*v1]] > Td[PA[*v4]]) { SWAP(v1, v4); SWAP(v3, v5); }
  if(Td[PA[*v3]] > Td[PA[*v4]]) { return v4; }
  return v3;
}
static INLINE_divsuf
int *
ss_pivot(const unsigned char *Td, const int *PA, int *first, int *last) {
  int *middle;
  int t;
  t = last - first;
  middle = first + t / 2;
  if(t <= 512) {
    if(t <= 32) {
      return ss_median3(Td, PA, first, middle, last - 1);
    } else {
      t >>= 2;
      return ss_median5(Td, PA, first, first + t, middle, last - 1 - t, last - 1);
    }
  }
  t >>= 3;
  first  = ss_median3(Td, PA, first, first + t, first + (t << 1));
  middle = ss_median3(Td, PA, middle - t, middle, middle + t);
  last   = ss_median3(Td, PA, last - 1 - (t << 1), last - 1 - t, last - 1);
  return ss_median3(Td, PA, first, middle, last);
}
static INLINE_divsuf
int *
ss_partition(const int *PA,
                    int *first, int *last, int depth) {
  int *a, *b;
  int t;
  for(a = first - 1, b = last;;) {
    for(; (++a < b) && ((PA[*a] + depth) >= (PA[*a + 1] + 1));) { *a = ~*a; }
    for(; (a < --b) && ((PA[*b] + depth) <  (PA[*b + 1] + 1));) { }
    if(b <= a) { break; }
    t = ~*b;
    *b = *a;
    *a = t;
  }
  if(first < a) { *first = ~*first; }
  return a;
}
static
void
ss_mintrosort(const unsigned char *T, const int *PA,
              int *first, int *last,
              int depth) {
#define STACK_SIZE SS_MISORT_STACKSIZE
  struct { int *a, *b, c; int d; } stack[STACK_SIZE];
  const unsigned char *Td;
  int *a, *b, *c, *d, *e, *f;
  int s, t;
  int ssize;
  int limit;
  int v, x = 0;
  for(ssize = 0, limit = ss_ilg(last - first);;) {
    if((last - first) <= SS_INSERTIONSORT_THRESHOLD) {
#if 1 < SS_INSERTIONSORT_THRESHOLD
      if(1 < (last - first)) { ss_insertionsort(T, PA, first, last, depth); }
#endif
      STACK_POP(first, last, depth, limit);
      continue;
    }
    Td = T + depth;
    if(limit-- == 0) { ss_heapsort(Td, PA, first, last - first); }
    if(limit < 0) {
      for(a = first + 1, v = Td[PA[*first]]; a < last; ++a) {
        if((x = Td[PA[*a]]) != v) {
          if(1 < (a - first)) { break; }
          v = x;
          first = a;
        }
      }
      if(Td[PA[*first] - 1] < v) {
        first = ss_partition(PA, first, a, depth);
      }
      if((a - first) <= (last - a)) {
        if(1 < (a - first)) {
          STACK_PUSH(a, last, depth, -1);
          last = a, depth += 1, limit = ss_ilg(a - first);
        } else {
          first = a, limit = -1;
        }
      } else {
        if(1 < (last - a)) {
          STACK_PUSH(first, a, depth + 1, ss_ilg(a - first));
          first = a, limit = -1;
        } else {
          last = a, depth += 1, limit = ss_ilg(a - first);
        }
      }
      continue;
    }
    a = ss_pivot(Td, PA, first, last);
    v = Td[PA[*a]];
    SWAP(*first, *a);
    for(b = first; (++b < last) && ((x = Td[PA[*b]]) == v);) { }
    if(((a = b) < last) && (x < v)) {
      for(; (++b < last) && ((x = Td[PA[*b]]) <= v);) {
        if(x == v) { SWAP(*b, *a); ++a; }
      }
    }
    for(c = last; (b < --c) && ((x = Td[PA[*c]]) == v);) { }
    if((b < (d = c)) && (x > v)) {
      for(; (b < --c) && ((x = Td[PA[*c]]) >= v);) {
        if(x == v) { SWAP(*c, *d); --d; }
      }
    }
    for(; b < c;) {
      SWAP(*b, *c);
      for(; (++b < c) && ((x = Td[PA[*b]]) <= v);) {
        if(x == v) { SWAP(*b, *a); ++a; }
      }
      for(; (b < --c) && ((x = Td[PA[*c]]) >= v);) {
        if(x == v) { SWAP(*c, *d); --d; }
      }
    }
    if(a <= d) {
      c = b - 1;
      if((s = a - first) > (t = b - a)) { s = t; }
      for(e = first, f = b - s; 0 < s; --s, ++e, ++f) { SWAP(*e, *f); }
      if((s = d - c) > (t = last - d - 1)) { s = t; }
      for(e = b, f = last - s; 0 < s; --s, ++e, ++f) { SWAP(*e, *f); }
      a = first + (b - a), c = last - (d - c);
      b = (v <= Td[PA[*a] - 1]) ? a : ss_partition(PA, a, c, depth);
      if((a - first) <= (last - c)) {
        if((last - c) <= (c - b)) {
          STACK_PUSH(b, c, depth + 1, ss_ilg(c - b));
          STACK_PUSH(c, last, depth, limit);
          last = a;
        } else if((a - first) <= (c - b)) {
          STACK_PUSH(c, last, depth, limit);
          STACK_PUSH(b, c, depth + 1, ss_ilg(c - b));
          last = a;
        } else {
          STACK_PUSH(c, last, depth, limit);
          STACK_PUSH(first, a, depth, limit);
          first = b, last = c, depth += 1, limit = ss_ilg(c - b);
        }
      } else {
        if((a - first) <= (c - b)) {
          STACK_PUSH(b, c, depth + 1, ss_ilg(c - b));
          STACK_PUSH(first, a, depth, limit);
          first = c;
        } else if((last - c) <= (c - b)) {
          STACK_PUSH(first, a, depth, limit);
          STACK_PUSH(b, c, depth + 1, ss_ilg(c - b));
          first = c;
        } else {
          STACK_PUSH(first, a, depth, limit);
          STACK_PUSH(c, last, depth, limit);
          first = b, last = c, depth += 1, limit = ss_ilg(c - b);
        }
      }
    } else {
      limit += 1;
      if(Td[PA[*first] - 1] < v) {
        first = ss_partition(PA, first, last, depth);
        limit = ss_ilg(last - first);
      }
      depth += 1;
    }
  }
#undef STACK_SIZE
}
#endif 
#if SS_BLOCKSIZE != 0
static INLINE_divsuf
void
ss_blockswap(int *a, int *b, int n) {
  int t;
  for(; 0 < n; --n, ++a, ++b) {
    t = *a, *a = *b, *b = t;
  }
}
static INLINE_divsuf
void
ss_rotate(int *first, int *middle, int *last) {
  int *a, *b, t;
  int l, r;
  l = middle - first, r = last - middle;
  for(; (0 < l) && (0 < r);) {
    if(l == r) { ss_blockswap(first, middle, l); break; }
    if(l < r) {
      a = last - 1, b = middle - 1;
      t = *a;
      do {
        *a-- = *b, *b-- = *a;
        if(b < first) {
          *a = t;
          last = a;
          if((r -= l + 1) <= l) { break; }
          a -= 1, b = middle - 1;
          t = *a;
        }
      } while(1);
    } else {
      a = first, b = middle;
      t = *a;
      do {
        *a++ = *b, *b++ = *a;
        if(last <= b) {
          *a = t;
          first = a + 1;
          if((l -= r + 1) <= r) { break; }
          a += 1, b = middle;
          t = *a;
        }
      } while(1);
    }
  }
}
static
void
ss_inplacemerge(const unsigned char *T, const int *PA,
                int *first, int *middle, int *last,
                int depth) {
  const int *p;
  int *a, *b;
  int len, half;
  int q, r;
  int x;
  for(;;) {
    if(*(last - 1) < 0) { x = 1; p = PA + ~*(last - 1); }
    else                { x = 0; p = PA +  *(last - 1); }
    for(a = first, len = middle - first, half = len >> 1, r = -1;
        0 < len;
        len = half, half >>= 1) {
      b = a + half;
      q = ss_compare(T, PA + ((0 <= *b) ? *b : ~*b), p, depth);
      if(q < 0) {
        a = b + 1;
        half -= (len & 1) ^ 1;
      } else {
        r = q;
      }
    }
    if(a < middle) {
      if(r == 0) { *a = ~*a; }
      ss_rotate(a, middle, last);
      last -= middle - a;
      middle = a;
      if(first == middle) { break; }
    }
    --last;
    if(x != 0) { while(*--last < 0) { } }
    if(middle == last) { break; }
  }
}
static
void
ss_mergeforward(const unsigned char *T, const int *PA,
                int *first, int *middle, int *last,
                int *buf, int depth) {
  int *a, *b, *c, *bufend;
  int t;
  int r;
  bufend = buf + (middle - first) - 1;
  ss_blockswap(buf, first, middle - first);
  for(t = *(a = first), b = buf, c = middle;;) {
    r = ss_compare(T, PA + *b, PA + *c, depth);
    if(r < 0) {
      do {
        *a++ = *b;
        if(bufend <= b) { *bufend = t; return; }
        *b++ = *a;
      } while(*b < 0);
    } else if(r > 0) {
      do {
        *a++ = *c, *c++ = *a;
        if(last <= c) {
          while(b < bufend) { *a++ = *b, *b++ = *a; }
          *a = *b, *b = t;
          return;
        }
      } while(*c < 0);
    } else {
      *c = ~*c;
      do {
        *a++ = *b;
        if(bufend <= b) { *bufend = t; return; }
        *b++ = *a;
      } while(*b < 0);
      do {
        *a++ = *c, *c++ = *a;
        if(last <= c) {
          while(b < bufend) { *a++ = *b, *b++ = *a; }
          *a = *b, *b = t;
          return;
        }
      } while(*c < 0);
    }
  }
}
static
void
ss_mergebackward(const unsigned char *T, const int *PA,
                 int *first, int *middle, int *last,
                 int *buf, int depth) {
  const int *p1, *p2;
  int *a, *b, *c, *bufend;
  int t;
  int r;
  int x;
  bufend = buf + (last - middle) - 1;
  ss_blockswap(buf, middle, last - middle);
  x = 0;
  if(*bufend < 0)       { p1 = PA + ~*bufend; x |= 1; }
  else                  { p1 = PA +  *bufend; }
  if(*(middle - 1) < 0) { p2 = PA + ~*(middle - 1); x |= 2; }
  else                  { p2 = PA +  *(middle - 1); }
  for(t = *(a = last - 1), b = bufend, c = middle - 1;;) {
    r = ss_compare(T, p1, p2, depth);
    if(0 < r) {
      if(x & 1) { do { *a-- = *b, *b-- = *a; } while(*b < 0); x ^= 1; }
      *a-- = *b;
      if(b <= buf) { *buf = t; break; }
      *b-- = *a;
      if(*b < 0) { p1 = PA + ~*b; x |= 1; }
      else       { p1 = PA +  *b; }
    } else if(r < 0) {
      if(x & 2) { do { *a-- = *c, *c-- = *a; } while(*c < 0); x ^= 2; }
      *a-- = *c, *c-- = *a;
      if(c < first) {
        while(buf < b) { *a-- = *b, *b-- = *a; }
        *a = *b, *b = t;
        break;
      }
      if(*c < 0) { p2 = PA + ~*c; x |= 2; }
      else       { p2 = PA +  *c; }
    } else {
      if(x & 1) { do { *a-- = *b, *b-- = *a; } while(*b < 0); x ^= 1; }
      *a-- = ~*b;
      if(b <= buf) { *buf = t; break; }
      *b-- = *a;
      if(x & 2) { do { *a-- = *c, *c-- = *a; } while(*c < 0); x ^= 2; }
      *a-- = *c, *c-- = *a;
      if(c < first) {
        while(buf < b) { *a-- = *b, *b-- = *a; }
        *a = *b, *b = t;
        break;
      }
      if(*b < 0) { p1 = PA + ~*b; x |= 1; }
      else       { p1 = PA +  *b; }
      if(*c < 0) { p2 = PA + ~*c; x |= 2; }
      else       { p2 = PA +  *c; }
    }
  }
}
static
void
ss_swapmerge(const unsigned char *T, const int *PA,
             int *first, int *middle, int *last,
             int *buf, int bufsize, int depth) {
#define STACK_SIZE SS_SMERGE_STACKSIZE
#define GETIDX(a) ((0 <= (a)) ? (a) : (~(a)))
#define MERGE_CHECK(a, b, c)\
  do {\
    if(((c) & 1) ||\
       (((c) & 2) && (ss_compare(T, PA + GETIDX(*((a) - 1)), PA + *(a), depth) == 0))) {\
      *(a) = ~*(a);\
    }\
    if(((c) & 4) && ((ss_compare(T, PA + GETIDX(*((b) - 1)), PA + *(b), depth) == 0))) {\
      *(b) = ~*(b);\
    }\
  } while(0)
  struct { int *a, *b, *c; int d; } stack[STACK_SIZE];
  int *l, *r, *lm, *rm;
  int m, len, half;
  int ssize;
  int check, next;
  for(check = 0, ssize = 0;;) {
    if((last - middle) <= bufsize) {
      if((first < middle) && (middle < last)) {
        ss_mergebackward(T, PA, first, middle, last, buf, depth);
      }
      MERGE_CHECK(first, last, check);
      STACK_POP(first, middle, last, check);
      continue;
    }
    if((middle - first) <= bufsize) {
      if(first < middle) {
        ss_mergeforward(T, PA, first, middle, last, buf, depth);
      }
      MERGE_CHECK(first, last, check);
      STACK_POP(first, middle, last, check);
      continue;
    }
    for(m = 0, len = MIN(middle - first, last - middle), half = len >> 1;
        0 < len;
        len = half, half >>= 1) {
      if(ss_compare(T, PA + GETIDX(*(middle + m + half)),
                       PA + GETIDX(*(middle - m - half - 1)), depth) < 0) {
        m += half + 1;
        half -= (len & 1) ^ 1;
      }
    }
    if(0 < m) {
      lm = middle - m, rm = middle + m;
      ss_blockswap(lm, middle, m);
      l = r = middle, next = 0;
      if(rm < last) {
        if(*rm < 0) {
          *rm = ~*rm;
          if(first < lm) { for(; *--l < 0;) { } next |= 4; }
          next |= 1;
        } else if(first < lm) {
          for(; *r < 0; ++r) { }
          next |= 2;
        }
      }
      if((l - first) <= (last - r)) {
        STACK_PUSH(r, rm, last, (next & 3) | (check & 4));
        middle = lm, last = l, check = (check & 3) | (next & 4);
      } else {
        if((next & 2) && (r == middle)) { next ^= 6; }
        STACK_PUSH(first, lm, l, (check & 3) | (next & 4));
        first = r, middle = rm, check = (next & 3) | (check & 4);
      }
    } else {
      if(ss_compare(T, PA + GETIDX(*(middle - 1)), PA + *middle, depth) == 0) {
        *middle = ~*middle;
      }
      MERGE_CHECK(first, last, check);
      STACK_POP(first, middle, last, check);
    }
  }
#undef STACK_SIZE
}
#endif 
static
void
sssort(const unsigned char *T, const int *PA,
       int *first, int *last,
       int *buf, int bufsize,
       int depth, int n, int lastsuffix) {
  int *a;
#if SS_BLOCKSIZE != 0
  int *b, *middle, *curbuf;
  int j, k, curbufsize, limit;
#endif
  int i;
  if(lastsuffix != 0) { ++first; }
#if SS_BLOCKSIZE == 0
  ss_mintrosort(T, PA, first, last, depth);
#else
  if((bufsize < SS_BLOCKSIZE) &&
      (bufsize < (last - first)) &&
      (bufsize < (limit = ss_isqrt(last - first)))) {
    if(SS_BLOCKSIZE < limit) { limit = SS_BLOCKSIZE; }
    buf = middle = last - limit, bufsize = limit;
  } else {
    middle = last, limit = 0;
  }
  for(a = first, i = 0; SS_BLOCKSIZE < (middle - a); a += SS_BLOCKSIZE, ++i) {
#if SS_INSERTIONSORT_THRESHOLD < SS_BLOCKSIZE
    ss_mintrosort(T, PA, a, a + SS_BLOCKSIZE, depth);
#elif 1 < SS_BLOCKSIZE
    ss_insertionsort(T, PA, a, a + SS_BLOCKSIZE, depth);
#endif
    curbufsize = last - (a + SS_BLOCKSIZE);
    curbuf = a + SS_BLOCKSIZE;
    if(curbufsize <= bufsize) { curbufsize = bufsize, curbuf = buf; }
    for(b = a, k = SS_BLOCKSIZE, j = i; j & 1; b -= k, k <<= 1, j >>= 1) {
      ss_swapmerge(T, PA, b - k, b, b + k, curbuf, curbufsize, depth);
    }
  }
#if SS_INSERTIONSORT_THRESHOLD < SS_BLOCKSIZE
  ss_mintrosort(T, PA, a, middle, depth);
#elif 1 < SS_BLOCKSIZE
  ss_insertionsort(T, PA, a, middle, depth);
#endif
  for(k = SS_BLOCKSIZE; i != 0; k <<= 1, i >>= 1) {
    if(i & 1) {
      ss_swapmerge(T, PA, a - k, a, middle, buf, bufsize, depth);
      a -= k;
    }
  }
  if(limit != 0) {
#if SS_INSERTIONSORT_THRESHOLD < SS_BLOCKSIZE
    ss_mintrosort(T, PA, middle, last, depth);
#elif 1 < SS_BLOCKSIZE
    ss_insertionsort(T, PA, middle, last, depth);
#endif
    ss_inplacemerge(T, PA, first, middle, last, depth);
  }
#endif
  if(lastsuffix != 0) {
    int PAi[2]; PAi[0] = PA[*(first - 1)], PAi[1] = n - 2;
    for(a = first, i = *(first - 1);
        (a < last) && ((*a < 0) || (0 < ss_compare(T, &(PAi[0]), PA + *a, depth)));
        ++a) {
      *(a - 1) = *a;
    }
    *(a - 1) = i;
  }
}
static INLINE_divsuf
int
tr_ilg(int n) {
  return (n & 0xffff0000) ?
          ((n & 0xff000000) ?
            24 + lg_table[(n >> 24) & 0xff] :
            16 + lg_table[(n >> 16) & 0xff]) :
          ((n & 0x0000ff00) ?
             8 + lg_table[(n >>  8) & 0xff] :
             0 + lg_table[(n >>  0) & 0xff]);
}
static
void
tr_insertionsort(const int *ISAd, int *first, int *last) {
  int *a, *b;
  int t, r;
  for(a = first + 1; a < last; ++a) {
    for(t = *a, b = a - 1; 0 > (r = ISAd[t] - ISAd[*b]);) {
      do { *(b + 1) = *b; } while((first <= --b) && (*b < 0));
      if(b < first) { break; }
    }
    if(r == 0) { *b = ~*b; }
    *(b + 1) = t;
  }
}
static INLINE_divsuf
void
tr_fixdown(const int *ISAd, int *SA, int i, int size) {
  int j, k;
  int v;
  int c, d, e;
  for(v = SA[i], c = ISAd[v]; (j = 2 * i + 1) < size; SA[i] = SA[k], i = k) {
    d = ISAd[SA[k = j++]];
    if(d < (e = ISAd[SA[j]])) { k = j; d = e; }
    if(d <= c) { break; }
  }
  SA[i] = v;
}
static
void
tr_heapsort(const int *ISAd, int *SA, int size) {
  int i, m;
  int t;
  m = size;
  if((size % 2) == 0) {
    m--;
    if(ISAd[SA[m / 2]] < ISAd[SA[m]]) { SWAP(SA[m], SA[m / 2]); }
  }
  for(i = m / 2 - 1; 0 <= i; --i) { tr_fixdown(ISAd, SA, i, m); }
  if((size % 2) == 0) { SWAP(SA[0], SA[m]); tr_fixdown(ISAd, SA, 0, m); }
  for(i = m - 1; 0 < i; --i) {
    t = SA[0], SA[0] = SA[i];
    tr_fixdown(ISAd, SA, 0, i);
    SA[i] = t;
  }
}
static INLINE_divsuf
int *
tr_median3(const int *ISAd, int *v1, int *v2, int *v3) {
  int *t;
  if(ISAd[*v1] > ISAd[*v2]) { SWAP(v1, v2); }
  if(ISAd[*v2] > ISAd[*v3]) {
    if(ISAd[*v1] > ISAd[*v3]) { return v1; }
    else { return v3; }
  }
  return v2;
}
static INLINE_divsuf
int *
tr_median5(const int *ISAd,
           int *v1, int *v2, int *v3, int *v4, int *v5) {
  int *t;
  if(ISAd[*v2] > ISAd[*v3]) { SWAP(v2, v3); }
  if(ISAd[*v4] > ISAd[*v5]) { SWAP(v4, v5); }
  if(ISAd[*v2] > ISAd[*v4]) { SWAP(v2, v4); SWAP(v3, v5); }
  if(ISAd[*v1] > ISAd[*v3]) { SWAP(v1, v3); }
  if(ISAd[*v1] > ISAd[*v4]) { SWAP(v1, v4); SWAP(v3, v5); }
  if(ISAd[*v3] > ISAd[*v4]) { return v4; }
  return v3;
}
static INLINE_divsuf
int *
tr_pivot(const int *ISAd, int *first, int *last) {
  int *middle;
  int t;
  t = last - first;
  middle = first + t / 2;
  if(t <= 512) {
    if(t <= 32) {
      return tr_median3(ISAd, first, middle, last - 1);
    } else {
      t >>= 2;
      return tr_median5(ISAd, first, first + t, middle, last - 1 - t, last - 1);
    }
  }
  t >>= 3;
  first  = tr_median3(ISAd, first, first + t, first + (t << 1));
  middle = tr_median3(ISAd, middle - t, middle, middle + t);
  last   = tr_median3(ISAd, last - 1 - (t << 1), last - 1 - t, last - 1);
  return tr_median3(ISAd, first, middle, last);
}
typedef struct _trbudget_t trbudget_t;
struct _trbudget_t {
  int chance;
  int remain;
  int incval;
  int count;
};
static INLINE_divsuf
void
trbudget_init(trbudget_t *budget, int chance, int incval) {
  budget->chance = chance;
  budget->remain = budget->incval = incval;
}
static INLINE_divsuf
int
trbudget_check(trbudget_t *budget, int size) {
  if(size <= budget->remain) { budget->remain -= size; return 1; }
  if(budget->chance == 0) { budget->count += size; return 0; }
  budget->remain += budget->incval - size;
  budget->chance -= 1;
  return 1;
}
static INLINE_divsuf
void
tr_partition(const int *ISAd,
             int *first, int *middle, int *last,
             int **pa, int **pb, int v) {
  int *a, *b, *c, *d, *e, *f;
  int t, s;
  int x = 0;
  for(b = middle - 1; (++b < last) && ((x = ISAd[*b]) == v);) { }
  if(((a = b) < last) && (x < v)) {
    for(; (++b < last) && ((x = ISAd[*b]) <= v);) {
      if(x == v) { SWAP(*b, *a); ++a; }
    }
  }
  for(c = last; (b < --c) && ((x = ISAd[*c]) == v);) { }
  if((b < (d = c)) && (x > v)) {
    for(; (b < --c) && ((x = ISAd[*c]) >= v);) {
      if(x == v) { SWAP(*c, *d); --d; }
    }
  }
  for(; b < c;) {
    SWAP(*b, *c);
    for(; (++b < c) && ((x = ISAd[*b]) <= v);) {
      if(x == v) { SWAP(*b, *a); ++a; }
    }
    for(; (b < --c) && ((x = ISAd[*c]) >= v);) {
      if(x == v) { SWAP(*c, *d); --d; }
    }
  }
  if(a <= d) {
    c = b - 1;
    if((s = a - first) > (t = b - a)) { s = t; }
    for(e = first, f = b - s; 0 < s; --s, ++e, ++f) { SWAP(*e, *f); }
    if((s = d - c) > (t = last - d - 1)) { s = t; }
    for(e = b, f = last - s; 0 < s; --s, ++e, ++f) { SWAP(*e, *f); }
    first += (b - a), last -= (d - c);
  }
  *pa = first, *pb = last;
}
static
void
tr_copy(int *ISA, const int *SA,
        int *first, int *a, int *b, int *last,
        int depth) {
  int *c, *d, *e;
  int s, v;
  v = b - SA - 1;
  for(c = first, d = a - 1; c <= d; ++c) {
    if((0 <= (s = *c - depth)) && (ISA[s] == v)) {
      *++d = s;
      ISA[s] = d - SA;
    }
  }
  for(c = last - 1, e = d + 1, d = b; e < d; --c) {
    if((0 <= (s = *c - depth)) && (ISA[s] == v)) {
      *--d = s;
      ISA[s] = d - SA;
    }
  }
}
static
void
tr_partialcopy(int *ISA, const int *SA,
               int *first, int *a, int *b, int *last,
               int depth) {
  int *c, *d, *e;
  int s, v;
  int rank, lastrank, newrank = -1;
  v = b - SA - 1;
  lastrank = -1;
  for(c = first, d = a - 1; c <= d; ++c) {
    if((0 <= (s = *c - depth)) && (ISA[s] == v)) {
      *++d = s;
      rank = ISA[s + depth];
      if(lastrank != rank) { lastrank = rank; newrank = d - SA; }
      ISA[s] = newrank;
    }
  }
  lastrank = -1;
  for(e = d; first <= e; --e) {
    rank = ISA[*e];
    if(lastrank != rank) { lastrank = rank; newrank = e - SA; }
    if(newrank != rank) { ISA[*e] = newrank; }
  }
  lastrank = -1;
  for(c = last - 1, e = d + 1, d = b; e < d; --c) {
    if((0 <= (s = *c - depth)) && (ISA[s] == v)) {
      *--d = s;
      rank = ISA[s + depth];
      if(lastrank != rank) { lastrank = rank; newrank = d - SA; }
      ISA[s] = newrank;
    }
  }
}
static
void
tr_introsort(int *ISA, const int *ISAd,
             int *SA, int *first, int *last,
             trbudget_t *budget) {
#define STACK_SIZE TR_STACKSIZE
  struct { const int *a; int *b, *c; int d, e; }stack[STACK_SIZE];
  int *a, *b, *c;
  int t;
  int v, x = 0;
  int incr = ISAd - ISA;
  int limit, next;
  int ssize, trlink = -1;
  for(ssize = 0, limit = tr_ilg(last - first);;) {
    if(limit < 0) {
      if(limit == -1) {
        tr_partition(ISAd - incr, first, first, last, &a, &b, last - SA - 1);
        if(a < last) {
          for(c = first, v = a - SA - 1; c < a; ++c) { ISA[*c] = v; }
        }
        if(b < last) {
          for(c = a, v = b - SA - 1; c < b; ++c) { ISA[*c] = v; }
        }
        if(1 < (b - a)) {
          STACK_PUSH5(NULL, a, b, 0, 0);
          STACK_PUSH5(ISAd - incr, first, last, -2, trlink);
          trlink = ssize - 2;
        }
        if((a - first) <= (last - b)) {
          if(1 < (a - first)) {
            STACK_PUSH5(ISAd, b, last, tr_ilg(last - b), trlink);
            last = a, limit = tr_ilg(a - first);
          } else if(1 < (last - b)) {
            first = b, limit = tr_ilg(last - b);
          } else {
            STACK_POP5(ISAd, first, last, limit, trlink);
          }
        } else {
          if(1 < (last - b)) {
            STACK_PUSH5(ISAd, first, a, tr_ilg(a - first), trlink);
            first = b, limit = tr_ilg(last - b);
          } else if(1 < (a - first)) {
            last = a, limit = tr_ilg(a - first);
          } else {
            STACK_POP5(ISAd, first, last, limit, trlink);
          }
        }
      } else if(limit == -2) {
        a = stack[--ssize].b, b = stack[ssize].c;
        if(stack[ssize].d == 0) {
          tr_copy(ISA, SA, first, a, b, last, ISAd - ISA);
        } else {
          if(0 <= trlink) { stack[trlink].d = -1; }
          tr_partialcopy(ISA, SA, first, a, b, last, ISAd - ISA);
        }
        STACK_POP5(ISAd, first, last, limit, trlink);
      } else {
        if(0 <= *first) {
          a = first;
          do { ISA[*a] = a - SA; } while((++a < last) && (0 <= *a));
          first = a;
        }
        if(first < last) {
          a = first; do { *a = ~*a; } while(*++a < 0);
          next = (ISA[*a] != ISAd[*a]) ? tr_ilg(a - first + 1) : -1;
          if(++a < last) { for(b = first, v = a - SA - 1; b < a; ++b) { ISA[*b] = v; } }
          if(trbudget_check(budget, a - first)) {
            if((a - first) <= (last - a)) {
              STACK_PUSH5(ISAd, a, last, -3, trlink);
              ISAd += incr, last = a, limit = next;
            } else {
              if(1 < (last - a)) {
                STACK_PUSH5(ISAd + incr, first, a, next, trlink);
                first = a, limit = -3;
              } else {
                ISAd += incr, last = a, limit = next;
              }
            }
          } else {
            if(0 <= trlink) { stack[trlink].d = -1; }
            if(1 < (last - a)) {
              first = a, limit = -3;
            } else {
              STACK_POP5(ISAd, first, last, limit, trlink);
            }
          }
        } else {
          STACK_POP5(ISAd, first, last, limit, trlink);
        }
      }
      continue;
    }
    if((last - first) <= TR_INSERTIONSORT_THRESHOLD) {
      tr_insertionsort(ISAd, first, last);
      limit = -3;
      continue;
    }
    if(limit-- == 0) {
      tr_heapsort(ISAd, first, last - first);
      for(a = last - 1; first < a; a = b) {
        for(x = ISAd[*a], b = a - 1; (first <= b) && (ISAd[*b] == x); --b) { *b = ~*b; }
      }
      limit = -3;
      continue;
    }
    a = tr_pivot(ISAd, first, last);
    SWAP(*first, *a);
    v = ISAd[*first];
    tr_partition(ISAd, first, first + 1, last, &a, &b, v);
    if((last - first) != (b - a)) {
      next = (ISA[*a] != v) ? tr_ilg(b - a) : -1;
      for(c = first, v = a - SA - 1; c < a; ++c) { ISA[*c] = v; }
      if(b < last) { for(c = a, v = b - SA - 1; c < b; ++c) { ISA[*c] = v; } }
      if((1 < (b - a)) && (trbudget_check(budget, b - a))) {
        if((a - first) <= (last - b)) {
          if((last - b) <= (b - a)) {
            if(1 < (a - first)) {
              STACK_PUSH5(ISAd + incr, a, b, next, trlink);
              STACK_PUSH5(ISAd, b, last, limit, trlink);
              last = a;
            } else if(1 < (last - b)) {
              STACK_PUSH5(ISAd + incr, a, b, next, trlink);
              first = b;
            } else {
              ISAd += incr, first = a, last = b, limit = next;
            }
          } else if((a - first) <= (b - a)) {
            if(1 < (a - first)) {
              STACK_PUSH5(ISAd, b, last, limit, trlink);
              STACK_PUSH5(ISAd + incr, a, b, next, trlink);
              last = a;
            } else {
              STACK_PUSH5(ISAd, b, last, limit, trlink);
              ISAd += incr, first = a, last = b, limit = next;
            }
          } else {
            STACK_PUSH5(ISAd, b, last, limit, trlink);
            STACK_PUSH5(ISAd, first, a, limit, trlink);
            ISAd += incr, first = a, last = b, limit = next;
          }
        } else {
          if((a - first) <= (b - a)) {
            if(1 < (last - b)) {
              STACK_PUSH5(ISAd + incr, a, b, next, trlink);
              STACK_PUSH5(ISAd, first, a, limit, trlink);
              first = b;
            } else if(1 < (a - first)) {
              STACK_PUSH5(ISAd + incr, a, b, next, trlink);
              last = a;
            } else {
              ISAd += incr, first = a, last = b, limit = next;
            }
          } else if((last - b) <= (b - a)) {
            if(1 < (last - b)) {
              STACK_PUSH5(ISAd, first, a, limit, trlink);
              STACK_PUSH5(ISAd + incr, a, b, next, trlink);
              first = b;
            } else {
              STACK_PUSH5(ISAd, first, a, limit, trlink);
              ISAd += incr, first = a, last = b, limit = next;
            }
          } else {
            STACK_PUSH5(ISAd, first, a, limit, trlink);
            STACK_PUSH5(ISAd, b, last, limit, trlink);
            ISAd += incr, first = a, last = b, limit = next;
          }
        }
      } else {
        if((1 < (b - a)) && (0 <= trlink)) { stack[trlink].d = -1; }
        if((a - first) <= (last - b)) {
          if(1 < (a - first)) {
            STACK_PUSH5(ISAd, b, last, limit, trlink);
            last = a;
          } else if(1 < (last - b)) {
            first = b;
          } else {
            STACK_POP5(ISAd, first, last, limit, trlink);
          }
        } else {
          if(1 < (last - b)) {
            STACK_PUSH5(ISAd, first, a, limit, trlink);
            first = b;
          } else if(1 < (a - first)) {
            last = a;
          } else {
            STACK_POP5(ISAd, first, last, limit, trlink);
          }
        }
      }
    } else {
      if(trbudget_check(budget, last - first)) {
        limit = tr_ilg(last - first), ISAd += incr;
      } else {
        if(0 <= trlink) { stack[trlink].d = -1; }
        STACK_POP5(ISAd, first, last, limit, trlink);
      }
    }
  }
#undef STACK_SIZE
}
static
void
trsort(int *ISA, int *SA, int n, int depth) {
  int *ISAd;
  int *first, *last;
  trbudget_t budget;
  int t, skip, unsorted;
  trbudget_init(&budget, tr_ilg(n) * 2 / 3, n);
  for(ISAd = ISA + depth; -n < *SA; ISAd += ISAd - ISA) {
    first = SA;
    skip = 0;
    unsorted = 0;
    do {
      if((t = *first) < 0) { first -= t; skip += t; }
      else {
        if(skip != 0) { *(first + skip) = skip; skip = 0; }
        last = SA + ISA[t] + 1;
        if(1 < (last - first)) {
          budget.count = 0;
          tr_introsort(ISA, ISAd, SA, first, last, &budget);
          if(budget.count != 0) { unsorted += budget.count; }
          else { skip = first - last; }
        } else if((last - first) == 1) {
          skip = -1;
        }
        first = last;
      }
    } while(first < (SA + n));
    if(skip != 0) { *(first + skip) = skip; }
    if(unsorted == 0) { break; }
  }
}
static
int
sort_typeBstar(const unsigned char *T, int *SA,
               int *bucket_A, int *bucket_B,
               int n) {
  int *PAb, *ISAb, *buf;
  int i, j, k, t, m, bufsize;
  int c0, c1;
  for(i = 0; i < BUCKET_A_SIZE; ++i) { bucket_A[i] = 0; }
  for(i = 0; i < BUCKET_B_SIZE; ++i) { bucket_B[i] = 0; }
  for(i = n - 1, m = n, c0 = T[n - 1]; 0 <= i;) {
    do { ++BUCKET_A(c1 = c0); } while((0 <= --i) && ((c0 = T[i]) >= c1));
    if(0 <= i) {
      ++BUCKET_BSTAR(c0, c1);
      SA[--m] = i;
      for(--i, c1 = c0; (0 <= i) && ((c0 = T[i]) <= c1); --i, c1 = c0) {
        ++BUCKET_B(c0, c1);
      }
    }
  }
  m = n - m;
  for(c0 = 0, i = 0, j = 0; c0 < ALPHABET_SIZE; ++c0) {
    t = i + BUCKET_A(c0);
    BUCKET_A(c0) = i + j; 
    i = t + BUCKET_B(c0, c0);
    for(c1 = c0 + 1; c1 < ALPHABET_SIZE; ++c1) {
      j += BUCKET_BSTAR(c0, c1);
      BUCKET_BSTAR(c0, c1) = j; 
      i += BUCKET_B(c0, c1);
    }
  }
  if(0 < m) {
    PAb = SA + n - m; ISAb = SA + m;
    for(i = m - 2; 0 <= i; --i) {
      t = PAb[i], c0 = T[t], c1 = T[t + 1];
      SA[--BUCKET_BSTAR(c0, c1)] = i;
    }
    t = PAb[m - 1], c0 = T[t], c1 = T[t + 1];
    SA[--BUCKET_BSTAR(c0, c1)] = m - 1;
    buf = SA + m, bufsize = n - (2 * m);
    for(c0 = ALPHABET_SIZE - 2, j = m; 0 < j; --c0) {
      for(c1 = ALPHABET_SIZE - 1; c0 < c1; j = i, --c1) {
        i = BUCKET_BSTAR(c0, c1);
        if(1 < (j - i)) {
          sssort(T, PAb, SA + i, SA + j,
                 buf, bufsize, 2, n, *(SA + i) == (m - 1));
        }
      }
    }
    for(i = m - 1; 0 <= i; --i) {
      if(0 <= SA[i]) {
        j = i;
        do { ISAb[SA[i]] = i; } while((0 <= --i) && (0 <= SA[i]));
        SA[i + 1] = i - j;
        if(i <= 0) { break; }
      }
      j = i;
      do { ISAb[SA[i] = ~SA[i]] = j; } while(SA[--i] < 0);
      ISAb[SA[i]] = j;
    }
    trsort(ISAb, SA, m, 1);
    for(i = n - 1, j = m, c0 = T[n - 1]; 0 <= i;) {
      for(--i, c1 = c0; (0 <= i) && ((c0 = T[i]) >= c1); --i, c1 = c0) { }
      if(0 <= i) {
        t = i;
        for(--i, c1 = c0; (0 <= i) && ((c0 = T[i]) <= c1); --i, c1 = c0) { }
        SA[ISAb[--j]] = ((t == 0) || (1 < (t - i))) ? t : ~t;
      }
    }
    BUCKET_B(ALPHABET_SIZE - 1, ALPHABET_SIZE - 1) = n; 
    for(c0 = ALPHABET_SIZE - 2, k = m - 1; 0 <= c0; --c0) {
      i = BUCKET_A(c0 + 1) - 1;
      for(c1 = ALPHABET_SIZE - 1; c0 < c1; --c1) {
        t = i - BUCKET_B(c0, c1);
        BUCKET_B(c0, c1) = i; 
        for(i = t, j = BUCKET_BSTAR(c0, c1);
            j <= k;
            --i, --k) { SA[i] = SA[k]; }
      }
      BUCKET_BSTAR(c0, c0 + 1) = i - BUCKET_B(c0, c0) + 1; 
      BUCKET_B(c0, c0) = i; 
    }
  }
  return m;
}
static
void
construct_SA(const unsigned char *T, int *SA,
             int *bucket_A, int *bucket_B,
             int n, int m) {
  int *i, *j, *k;
  int s;
  int c0, c1, c2;
  if(0 < m) {
    for(c1 = ALPHABET_SIZE - 2; 0 <= c1; --c1) {
      for(i = SA + BUCKET_BSTAR(c1, c1 + 1),
          j = SA + BUCKET_A(c1 + 1) - 1, k = NULL, c2 = -1;
          i <= j;
          --j) {
        if(0 < (s = *j)) {
          assert(T[s] == c1);
          assert(((s + 1) < n) && (T[s] <= T[s + 1]));
          assert(T[s - 1] <= T[s]);
          *j = ~s;
          c0 = T[--s];
          if((0 < s) && (T[s - 1] > c0)) { s = ~s; }
          if(c0 != c2) {
            if(0 <= c2) { BUCKET_B(c2, c1) = k - SA; }
            k = SA + BUCKET_B(c2 = c0, c1);
          }
          assert(k < j);
          *k-- = s;
        } else {
          assert(((s == 0) && (T[s] == c1)) || (s < 0));
          *j = ~s;
        }
      }
    }
  }
  k = SA + BUCKET_A(c2 = T[n - 1]);
  *k++ = (T[n - 2] < c2) ? ~(n - 1) : (n - 1);
  for(i = SA, j = SA + n; i < j; ++i) {
    if(0 < (s = *i)) {
      assert(T[s - 1] >= T[s]);
      c0 = T[--s];
      if((s == 0) || (T[s - 1] < c0)) { s = ~s; }
      if(c0 != c2) {
        BUCKET_A(c2) = k - SA;
        k = SA + BUCKET_A(c2 = c0);
      }
      assert(i < k);
      *k++ = s;
    } else {
      assert(s < 0);
      *i = ~s;
    }
  }
}
static
int
construct_BWT(const unsigned char *T, int *SA,
              int *bucket_A, int *bucket_B,
              int n, int m) {
  int *i, *j, *k, *orig;
  int s;
  int c0, c1, c2;
  if(0 < m) {
    for(c1 = ALPHABET_SIZE - 2; 0 <= c1; --c1) {
      for(i = SA + BUCKET_BSTAR(c1, c1 + 1),
          j = SA + BUCKET_A(c1 + 1) - 1, k = NULL, c2 = -1;
          i <= j;
          --j) {
        if(0 < (s = *j)) {
          assert(T[s] == c1);
          assert(((s + 1) < n) && (T[s] <= T[s + 1]));
          assert(T[s - 1] <= T[s]);
          c0 = T[--s];
          *j = ~((int)c0);
          if((0 < s) && (T[s - 1] > c0)) { s = ~s; }
          if(c0 != c2) {
            if(0 <= c2) { BUCKET_B(c2, c1) = k - SA; }
            k = SA + BUCKET_B(c2 = c0, c1);
          }
          assert(k < j);
          *k-- = s;
        } else if(s != 0) {
          *j = ~s;
#ifndef NDEBUG
        } else {
          assert(T[s] == c1);
#endif
        }
      }
    }
  }
  k = SA + BUCKET_A(c2 = T[n - 1]);
  *k++ = (T[n - 2] < c2) ? ~((int)T[n - 2]) : (n - 1);
  for(i = SA, j = SA + n, orig = SA; i < j; ++i) {
    if(0 < (s = *i)) {
      assert(T[s - 1] >= T[s]);
      c0 = T[--s];
      *i = c0;
      if((0 < s) && (T[s - 1] < c0)) { s = ~((int)T[s - 1]); }
      if(c0 != c2) {
        BUCKET_A(c2) = k - SA;
        k = SA + BUCKET_A(c2 = c0);
      }
      assert(i < k);
      *k++ = s;
    } else if(s != 0) {
      *i = ~s;
    } else {
      orig = i;
    }
  }
  return orig - SA;
}
int
divsufsort(const unsigned char *T, int *SA, int n) {
  int *bucket_A, *bucket_B;
  int m;
  int err = 0;
  if((T == NULL) || (SA == NULL) || (n < 0)) { return -1; }
  else if(n == 0) { return 0; }
  else if(n == 1) { SA[0] = 0; return 0; }
  else if(n == 2) { m = (T[0] < T[1]); SA[m ^ 1] = 0, SA[m] = 1; return 0; }
  bucket_A = (int *)malloc(BUCKET_A_SIZE * sizeof(int));
  bucket_B = (int *)malloc(BUCKET_B_SIZE * sizeof(int));
  if((bucket_A != NULL) && (bucket_B != NULL)) {
    m = sort_typeBstar(T, SA, bucket_A, bucket_B, n);
    construct_SA(T, SA, bucket_A, bucket_B, n, m);
  } else {
    err = -2;
  }
  free(bucket_B);
  free(bucket_A);
  return err;
}
int
divbwt(const unsigned char *T, unsigned char *U, int *A, int n) {
  int *B;
  int *bucket_A, *bucket_B;
  int m, pidx, i;
  if((T == NULL) || (U == NULL) || (n < 0)) { return -1; }
  else if(n <= 1) { if(n == 1) { U[0] = T[0]; } return n; }
  if((B = A) == NULL) { B = (int *)malloc((size_t)(n + 1) * sizeof(int)); }
  bucket_A = (int *)malloc(BUCKET_A_SIZE * sizeof(int));
  bucket_B = (int *)malloc(BUCKET_B_SIZE * sizeof(int));
  if((B != NULL) && (bucket_A != NULL) && (bucket_B != NULL)) {
    m = sort_typeBstar(T, B, bucket_A, bucket_B, n);
    pidx = construct_BWT(T, B, bucket_A, bucket_B, n, m);
    U[0] = T[n - 1];
    for(i = 0; i < pidx; ++i) { U[i + 1] = (unsigned char)B[i]; }
    for(i += 1; i < n; ++i) { U[i] = (unsigned char)B[i]; }
    pidx += 1;
  } else {
    pidx = -2;
  }
  free(bucket_B);
  free(bucket_A);
  if(A == NULL) { free(B); }
  return pidx;
}
std::string itos(int64_t x, int n=1) {
  assert(x>=0);
  assert(n>=0);
  std::string r;
  for (; x || n>0; x/=10, --n) r=std::string(1, '0'+x%10)+r;
  return r;
}
void e8e9(unsigned char* buf, int n) {
  for (int i=n-5; i>=0; --i) {
    if (((buf[i]&254)==0xe8) && ((buf[i+4]+1)&254)==0) {
      unsigned a=(buf[i+1]|buf[i+2]<<8|buf[i+3]<<16)+i;
      buf[i+1]=a;
      buf[i+2]=a>>8;
      buf[i+3]=a>>16;
    }
  }
}
class LZBuffer: public libzpaq::Reader {
  libzpaq::Array<unsigned> ht;
  const unsigned char* in;    
  const int checkbits;        
  const int level;            
  const unsigned htsize;      
  const unsigned n;           
  unsigned i;                 
  const unsigned minMatch;    
  const unsigned minMatch2;   
  const unsigned maxMatch;    
  const unsigned maxLiteral;  
  const unsigned lookahead;   
  unsigned h1, h2;            
  const unsigned bucket;      
  const unsigned shift1, shift2;  
  const int minMatchBoth;     
  const unsigned rb;          
  unsigned bits;              
  unsigned nbits;             
  unsigned rpos, wpos;        
  unsigned idx;               
  const unsigned* sa;         
  unsigned* isa;              
  enum {BUFSIZE=1<<14};       
  unsigned char buf[BUFSIZE]; 
  void write_literal(unsigned i, unsigned& lit);
  void write_match(unsigned len, unsigned off);
  void fill();  
  void putb(unsigned x, int k) {
    x&=(1<<k)-1;
    bits|=x<<nbits;
    nbits+=k;
    while (nbits>7) {
      assert(wpos<BUFSIZE);
      buf[wpos++]=bits, bits>>=8, nbits-=8;
    }
  }
  void flush() {
    assert(wpos<BUFSIZE);
    if (nbits>0) buf[wpos++]=bits;
    bits=nbits=0;
  }
  void put(int c) {
    assert(wpos<BUFSIZE);
    buf[wpos++]=c;
  }
public:
  LZBuffer(StringBuffer& inbuf, int args[], const unsigned* sap=0);
  int get() {
    int c=-1;
    if (rpos==wpos) fill();
    if (rpos<wpos) c=buf[rpos++];
    if (rpos==wpos) rpos=wpos=0;
    return c;
  }
  int read(char* p, int n);
};
int lg(unsigned x) {
  unsigned r=0;
  if (x>=65536) r=16, x>>=16;
  if (x>=256) r+=8, x>>=8;
  if (x>=16) r+=4, x>>=4;
  assert(x>=0 && x<16);
  return
    "\x00\x01\x02\x02\x03\x03\x03\x03\x04\x04\x04\x04\x04\x04\x04\x04"[x]+r;
}
int nbits(unsigned x) {
  int r;
  for (r=0; x; x>>=1) r+=x&1;
  return r;
}
int LZBuffer::read(char* p, int n) {
  if (rpos==wpos) fill();
  int nr=n;
  if (nr>int(wpos-rpos)) nr=wpos-rpos;
  if (nr) memcpy(p, buf+rpos, nr);
  rpos+=nr;
  assert(rpos<=wpos);
  if (rpos==wpos) rpos=wpos=0;
  return nr;
}
LZBuffer::LZBuffer(StringBuffer& inbuf, int args[], const unsigned* sap):
    ht((args[1]&3)==3 ? (inbuf.size()+1)*!sap      
        : args[5]-args[0]<21 ? 1u<<args[5]         
        : (inbuf.size()*!sap)+(1u<<17<<args[0])),  
    in(inbuf.data()),
    checkbits(args[5]-args[0]<21 ? 12-args[0] : 17+args[0]),
    level(args[1]&3),
    htsize(ht.size()),
    n(inbuf.size()),
    i(0),
    minMatch(args[2]),
    minMatch2(args[3]),
    maxMatch(BUFSIZE*3),
    maxLiteral(BUFSIZE/4),
    lookahead(args[6]),
    h1(0), h2(0),
    bucket((1<<args[4])-1), 
    shift1(minMatch>0 ? (args[5]-1)/minMatch+1 : 1),
    shift2(minMatch2>0 ? (args[5]-1)/minMatch2+1 : 0),
    minMatchBoth(MAX(minMatch, minMatch2+lookahead)+4),
    rb(args[0]>4 ? args[0]-4 : 0),
    bits(0), nbits(0), rpos(0), wpos(0),
    idx(0), sa(0), isa(0) {
  assert(args[0]>=0);
  assert(n<=(1u<<20<<args[0]));
  assert(args[1]>=1 && args[1]<=7 && args[1]!=4);
  assert(level>=1 && level<=3);
  if ((minMatch<4 && level==1) || (minMatch<1 && level==2))
    error("match length $3 too small");
  if (args[1]>4 && !sap) e8e9(inbuf.data(), n);
  if (args[5]-args[0]>=21 || level==3) {  
    if (sap)
      sa=sap;
    else {
      assert(ht.size()>=n);
      assert(ht.size()>0);
      sa=&ht[0];
      if (n>0) divsufsort((const unsigned char*)in, (int*)sa, n);
    }
    if (level<3) {
      assert(ht.size()>=(n*(sap==0))+(1u<<17<<args[0]));
      isa=&ht[n*(sap==0)];
    }
  }
}
void LZBuffer::fill() {
  if (level==3) {
    assert(in || n==0);
    assert(sa);
    for (; wpos<BUFSIZE && i<n+5; ++i) {
      if (i==0) put(n>0 ? in[n-1] : 255);
      else if (i>n) put(idx&255), idx>>=8;
      else if (sa[i-1]==0) idx=i, put(255);
      else put(in[sa[i-1]-1]);
    }
    return;
  }
  unsigned lit=0;  
  const unsigned mask=(1<<checkbits)-1;
  while (i<n && wpos*2<BUFSIZE) {
    unsigned blen=minMatch-1;  
    unsigned bp=0;  
    unsigned blit=0;  
    int bscore=0;  
    if (isa) {
      if (sa[isa[i&mask]]!=i) 
        for (unsigned j=0; j<n; ++j)
          if ((sa[j]&~mask)==(i&~mask))
            isa[sa[j]&mask]=j;
      for (unsigned h=0; h<=lookahead; ++h) {
        unsigned q=isa[(h+i)&mask];  
        assert(q<n);
        if (sa[q]!=h+i) continue;
        for (int j=-1; j<=1; j+=2) {  
          for (unsigned k=1; k<=bucket; ++k) {
            unsigned p;  
            if (q+j*k<n && (p=sa[q+j*k]-h)<i) {
              assert(p<n);
              unsigned l, l1;  
              for (l=h; i+l<n && l<maxMatch && in[p+l]==in[i+l]; ++l);
              for (l1=h; l1>0 && in[p+l1-1]==in[i+l1-1]; --l1);
              int score=int(l-l1)*8-lg(i-p)-4*(lit==0 && l1>0)-11;
              for (unsigned a=0; a<h; ++a) score=score*5/8;
              if (score>bscore) blen=l, bp=p, blit=l1, bscore=score;
              if (l<blen || l<minMatch || l>255) break;
            }
          }
        }
        if (bscore<=0 || blen<minMatch) break;
      }
    }
    else if (level==1 || minMatch<=64) {
      if (minMatch2>0) {
        for (unsigned k=0; k<=bucket; ++k) {
          unsigned p=ht[h2^k];
          if (p && (p&mask)==(in[i+3]&mask)) {
            p>>=checkbits;
            if (p<i && i+blen<=n && in[p+blen-1]==in[i+blen-1]) {
              unsigned l;  
              for (l=lookahead; i+l<n && l<maxMatch && in[p+l]==in[i+l]; ++l);
              if (l>=minMatch2+lookahead) {
                int l1;  
                for (l1=lookahead; l1>0 && in[p+l1-1]==in[i+l1-1]; --l1);
                assert(l1>=0 && l1<=int(lookahead));
                int score=int(l-l1)*8-lg(i-p)-8*(lit==0 && l1>0)-11;
                if (score>bscore) blen=l, bp=p, blit=l1, bscore=score;
              }
            }
          }
          if (blen>=128) break;
        }
      }
      if (!minMatch2 || blen<minMatch2) {
        for (unsigned k=0; k<=bucket; ++k) {
          unsigned p=ht[h1^k];
          if (p && i+3<n && (p&mask)==(in[i+3]&mask)) {
            p>>=checkbits;
            if (p<i && i+blen<=n && in[p+blen-1]==in[i+blen-1]) {
              unsigned l;
              for (l=0; i+l<n && l<maxMatch && in[p+l]==in[i+l]; ++l);
              int score=l*8-lg(i-p)-2*(lit>0)-11;
              if (score>bscore) blen=l, bp=p, blit=0, bscore=score;
            }
          }
          if (blen>=128) break;
        }
      }
    }
    assert(i>=bp);
    const unsigned off=i-bp;  
    if (off>0 && bscore>0
        && blen-blit>=minMatch+(level==2)*((off>=(1<<16))+(off>=(1<<24)))) {
      lit+=blit;
      write_literal(i+blit, lit);
      write_match(blen-blit, off);
    }
    else {
      blen=1;
      ++lit;
    }
    if (isa)
      i+=blen;
    else {
      while (blen--) {
        if (i+minMatchBoth<n) {
          unsigned ih=((i*1234547)>>19)&bucket;
          const unsigned p=(i<<checkbits)|(in[i+3]&mask);
          assert(ih<=bucket);
          if (minMatch2) {
            ht[h2^ih]=p;
            h2=(((h2*9)<<shift2)
                +(in[i+minMatch2+lookahead]+1)*23456789u)&(htsize-1);
          }
          ht[h1^ih]=p;
          h1=(((h1*5)<<shift1)+(in[i+minMatch]+1)*123456791u)&(htsize-1);
        }
        ++i;
      }
    }
    if (lit>=maxLiteral)
      write_literal(i, lit);
  }
  assert(i<=n);
  if (i==n) {
    write_literal(n, lit);
    flush();
  }
}
void LZBuffer::write_literal(unsigned i, unsigned& lit) {
  assert(lit>=0);
  assert(i>=0 && i<=n);
  assert(i>=lit);
  if (level==1) {
    if (lit<1) return;
    int ll=lg(lit);
    assert(ll>=1 && ll<=24);
    putb(0, 2);
    --ll;
    while (--ll>=0) {
      putb(1, 1);
      putb((lit>>ll)&1, 1);
    }
    putb(0, 1);
    while (lit) putb(in[i-lit--], 8);
  }
  else {
    assert(level==2);
    while (lit>0) {
      unsigned lit1=lit;
      if (lit1>64) lit1=64;
      put(lit1-1);
      for (unsigned j=i-lit; j<i-lit+lit1; ++j) put(in[j]);
      lit-=lit1;
    }
  }
}
void LZBuffer::write_match(unsigned len, unsigned off) {
  if (level==1) {
    assert(len>=minMatch && len<=maxMatch);
    assert(off>0);
    assert(len>=4);
    assert(rb>=0 && rb<=8);
    int ll=lg(len)-1;
    assert(ll>=2);
    off+=(1<<rb)-1;
    int lo=lg(off)-1-rb;
    assert(lo>=0 && lo<=23);
    putb((lo+8)>>3, 2);
    putb(lo&7, 3);     
    while (--ll>=2) {  
      putb(1, 1);
      putb((len>>ll)&1, 1);
    }
    putb(0, 1);
    putb(len&3, 2);    
    putb(off, rb);     
    putb(off>>rb, lo); 
  }
  else {
    assert(level==2);
    assert(minMatch>=1 && minMatch<=64);
    --off;
    while (len>0) {  
      const unsigned len1=len>minMatch*2+63 ? minMatch+63 :
          len>minMatch+63 ? len-minMatch : len;
      assert(wpos<BUFSIZE-5);
      assert(len1>=minMatch && len1<minMatch+64);
      if (off<(1<<16)) {
        put(64+len1-minMatch);
        put(off>>8);
        put(off);
      }
      else if (off<(1<<24)) {
        put(128+len1-minMatch);
        put(off>>16);
        put(off>>8);
        put(off);
      }
      else {
        put(192+len1-minMatch);
        put(off>>24);
        put(off>>16);
        put(off>>8);
        put(off);
      }
      len-=len1;
    }
  }
}
std::string makeConfig(const char* method, int args[]) {
  assert(method);
  const char type=method[0];
  assert(type=='x' || type=='s' || type=='0' || type=='i');
  args[0]=0;  
  args[1]=0;  
  args[2]=0;  
  args[3]=0;  
  args[4]=0;  
  args[5]=0;  
  args[6]=0;  
  args[7]=0;  
  args[8]=0;  
  if (isdigit(*++method)) args[0]=0;
  for (int i=0; i<9 && (isdigit(*method) || *method==',' || *method=='.');) {
    if (isdigit(*method))
      args[i]=args[i]*10+*method-'0';
    else if (++i<9)
      args[i]=0;
    ++method;
  }
  if (type=='0')
    return "comp 0 0 0 0 0 hcomp end\n";
  std::string hdr, pcomp;
  const int level=args[1]&3;
  const bool doe8=args[1]>=4 && args[1]<=7;
  if (level==1) {
    const int rb=args[0]>4 ? args[0]-4 : 0;
    hdr="comp 9 16 0 $1+20 ";
    pcomp=
    "pcomp lazy2 3 ;\n"
    " (r1 = state\n"
    "  r2 = len - match or literal length\n"
    "  r3 = m - number of offset bits expected\n"
    "  r4 = ptr to buf\n"
    "  r5 = r - low bits of offset\n"
    "  c = bits - input buffer\n"
    "  d = n - number of bits in c)\n"
    "\n"
    "  a> 255 if\n";
    if (doe8)
      pcomp+=
      "    b=0 d=r 4 do (for b=0..d-1, d = end of buf)\n"
      "      a=b a==d ifnot\n"
      "        a+= 4 a<d if\n"
      "          a=*b a&= 254 a== 232 if (e8 or e9?)\n"
      "            c=b b++ b++ b++ b++ a=*b a++ a&= 254 a== 0 if (00 or ff)\n"
      "              b-- a=*b\n"
      "              b-- a<<= 8 a+=*b\n"
      "              b-- a<<= 8 a+=*b\n"
      "              a-=b a++\n"
      "              *b=a a>>= 8 b++\n"
      "              *b=a a>>= 8 b++\n"
      "              *b=a b++\n"
      "            endif\n"
      "            b=c\n"
      "          endif\n"
      "        endif\n"
      "        a=*b out b++\n"
      "      forever\n"
      "    endif\n"
      "\n";
    pcomp+=
    "    (reset state)\n"
    "    a=0 b=0 c=0 d=0 r=a 1 r=a 2 r=a 3 r=a 4\n"
    "    halt\n"
    "  endif\n"
    "\n"
    "  a<<=d a+=c c=a               (bits+=a<<n)\n"
    "  a= 8 a+=d d=a                (n+=8)\n"
    "\n"
    "  (if state==0 (expect new code))\n"
    "  a=r 1 a== 0 if (match code mm,mmm)\n"
    "    a= 1 r=a 2                 (len=1)\n"
    "    a=c a&= 3 a> 0 if          (if (bits&3))\n"
    "      a-- a<<= 3 r=a 3           (m=((bits&3)-1)*8)\n"
    "      a=c a>>= 2 c=a             (bits>>=2)\n"
    "      b=r 3 a&= 7 a+=b r=a 3     (m+=bits&7)\n"
    "      a=c a>>= 3 c=a             (bits>>=3)\n"
    "      a=d a-= 5 d=a              (n-=5)\n"
    "      a= 1 r=a 1                 (state=1)\n"
    "    else (literal, discard 00)\n"
    "      a=c a>>= 2 c=a             (bits>>=2)\n"
    "      d-- d--                    (n-=2)\n"
    "      a= 3 r=a 1                 (state=3)\n"
    "    endif\n"
    "  endif\n"
    "\n"
    "  (while state==1 && n>=3 (expect match length n*4+ll -> r2))\n"
    "  do a=r 1 a== 1 if a=d a> 2 if\n"
    "    a=c a&= 1 a== 1 if         (if bits&1)\n"
    "      a=c a>>= 1 c=a             (bits>>=1)\n"
    "      b=r 2 a=c a&= 1 a+=b a+=b r=a 2 (len+=len+(bits&1))\n"
    "      a=c a>>= 1 c=a             (bits>>=1)\n"
    "      d-- d--                    (n-=2)\n"
    "    else\n"
    "      a=c a>>= 1 c=a             (bits>>=1)\n"
    "      a=r 2 a<<= 2 b=a           (len<<=2)\n"
    "      a=c a&= 3 a+=b r=a 2       (len+=bits&3)\n"
    "      a=c a>>= 2 c=a             (bits>>=2)\n"
    "      d-- d-- d--                (n-=3)\n";
    if (rb)
      pcomp+="      a= 5 r=a 1                 (state=5)\n";
    else
      pcomp+="      a= 2 r=a 1                 (state=2)\n";
    pcomp+=
    "    endif\n"
    "  forever endif endif\n"
    "\n";
    if (rb) pcomp+=  
      "  (if state==5 && n>=8) (expect low bits of offset to put in r5)\n"
      "  a=r 1 a== 5 if a=d a> "+itos(rb-1)+" if\n"
      "    a=c a&= "+itos((1<<rb)-1)+" r=a 5            (save r in r5)\n"
      "    a=c a>>= "+itos(rb)+" c=a\n"
      "    a=d a-= "+itos(rb)+ " d=a\n"
      "    a= 2 r=a 1                   (go to state 2)\n"
      "  endif endif\n"
      "\n";
    pcomp+=
    "  (if state==2 && n>=m) (expect m offset bits)\n"
    "  a=r 1 a== 2 if a=r 3 a>d ifnot\n"
    "    a=c r=a 6 a=d r=a 7          (save c=bits, d=n in r6,r7)\n"
    "    b=r 3 a= 1 a<<=b d=a         (d=1<<m)\n"
    "    a-- a&=c a+=d                (d=offset=bits&((1<<m)-1)|(1<<m))\n";
    if (rb)
      pcomp+=  
      "    a<<= "+itos(rb)+" d=r 5 a+=d a-= "+itos((1<<rb)-1)+"\n";
    pcomp+=
    "    d=a b=r 4 a=b a-=d c=a       (c=p=(b=ptr)-offset)\n"
    "\n"
    "    (while len-- (copy and output match d bytes from *c to *b))\n"
    "    d=r 2 do a=d a> 0 if d--\n"
    "      a=*c *b=a c++ b++          (buf[ptr++]-buf[p++])\n";
    if (!doe8) pcomp+=" out\n";
    pcomp+=
    "    forever endif\n"
    "    a=b r=a 4\n"
    "\n"
    "    a=r 6 b=r 3 a>>=b c=a        (bits>>=m)\n"
    "    a=r 7 a-=b d=a               (n-=m)\n"
    "    a=0 r=a 1                    (state=0)\n"
    "  endif endif\n"
    "\n"
    "  (while state==3 && n>=2 (expect literal length))\n"
    "  do a=r 1 a== 3 if a=d a> 1 if\n"
    "    a=c a&= 1 a== 1 if         (if bits&1)\n"
    "      a=c a>>= 1 c=a              (bits>>=1)\n"
    "      b=r 2 a&= 1 a+=b a+=b r=a 2 (len+=len+(bits&1))\n"
    "      a=c a>>= 1 c=a              (bits>>=1)\n"
    "      d-- d--                     (n-=2)\n"
    "    else\n"
    "      a=c a>>= 1 c=a              (bits>>=1)\n"
    "      d--                         (--n)\n"
    "      a= 4 r=a 1                  (state=4)\n"
    "    endif\n"
    "  forever endif endif\n"
    "\n"
    "  (if state==4 && n>=8 (expect len literals))\n"
    "  a=r 1 a== 4 if a=d a> 7 if\n"
    "    b=r 4 a=c *b=a\n";
    if (!doe8) pcomp+=" out\n";
    pcomp+=
    "    b++ a=b r=a 4                 (buf[ptr++]=bits)\n"
    "    a=c a>>= 8 c=a                (bits>>=8)\n"
    "    a=d a-= 8 d=a                 (n-=8)\n"
    "    a=r 2 a-- r=a 2 a== 0 if      (if --len<1)\n"
    "      a=0 r=a 1                     (state=0)\n"
    "    endif\n"
    "  endif endif\n"
    "  halt\n"
    "end\n";
  }
  else if (level==2) {
    hdr="comp 9 16 0 $1+20 ";
    pcomp=
    "pcomp lzpre c ;\n"
    "  (Decode LZ77: d=state, M=output buffer, b=size)\n"
    "  a> 255 if (at EOF decode e8e9 and output)\n";
    if (doe8)
      pcomp+=
      "    d=b b=0 do (for b=0..d-1, d = end of buf)\n"
      "      a=b a==d ifnot\n"
      "        a+= 4 a<d if\n"
      "          a=*b a&= 254 a== 232 if (e8 or e9?)\n"
      "            c=b b++ b++ b++ b++ a=*b a++ a&= 254 a== 0 if (00 or ff)\n"
      "              b-- a=*b\n"
      "              b-- a<<= 8 a+=*b\n"
      "              b-- a<<= 8 a+=*b\n"
      "              a-=b a++\n"
      "              *b=a a>>= 8 b++\n"
      "              *b=a a>>= 8 b++\n"
      "              *b=a b++\n"
      "            endif\n"
      "            b=c\n"
      "          endif\n"
      "        endif\n"
      "        a=*b out b++\n"
      "      forever\n"
      "    endif\n";
    pcomp+=
    "    b=0 c=0 d=0 a=0 r=a 1 r=a 2 (reset state)\n"
    "  halt\n"
    "  endif\n"
    "\n"
    "  (in state d==0, expect a new code)\n"
    "  (put length in r1 and inital part of offset in r2)\n"
    "  c=a a=d a== 0 if\n"
    "    a=c a>>= 6 a++ d=a\n"
    "    a== 1 if (literal?)\n"
    "      a+=c r=a 1 a=0 r=a 2\n"
    "    else (3 to 5 byte match)\n"
    "      d++ a=c a&= 63 a+= $3 r=a 1 a=0 r=a 2\n"
    "    endif\n"
    "  else\n"
    "    a== 1 if (writing literal)\n"
    "      a=c *b=a b++\n";
    if (!doe8) pcomp+=" out\n";
    pcomp+=
    "      a=r 1 a-- a== 0 if d=0 endif r=a 1 (if (--len==0) state=0)\n"
    "    else\n"
    "      a> 2 if (reading offset)\n"
    "        a=r 2 a<<= 8 a|=c r=a 2 d-- (off=off<<8|c, --state)\n"
    "      else (state==2, write match)\n"
    "        a=r 2 a<<= 8 a|=c c=a a=b a-=c a-- c=a (c=i-off-1)\n"
    "        d=r 1 (d=len)\n"
    "        do (copy and output d=len bytes)\n"
    "          a=*c *b=a c++ b++\n";
    if (!doe8) pcomp+=" out\n";
    pcomp+=
    "        d-- a=d a> 0 while\n"
    "        (d=state=0. off, len don\'t matter)\n"
    "      endif\n"
    "    endif\n"
    "  endif\n"
    "  halt\n"
    "end\n";
  }
  else if (level==3) {  
    hdr="comp 9 16 $1+20 $1+20 ";  
    pcomp=
    "pcomp bwtrle c ;\n"
    "\n"
    "  (read BWT, index into M, size in b)\n"
    "  a> 255 ifnot\n"
    "    *b=a b++\n"
    "\n"
    "  (inverse BWT)\n"
    "  elsel\n"
    "\n"
    "    (index in last 4 bytes, put in c and R1)\n"
    "    b-- a=*b\n"
    "    b-- a<<= 8 a+=*b\n"
    "    b-- a<<= 8 a+=*b\n"
    "    b-- a<<= 8 a+=*b c=a r=a 1\n"
    "\n"
    "    (save size in R2)\n"
    "    a=b r=a 2\n"
    "\n"
    "    (count bytes in H[~1..~255, ~0])\n"
    "    do\n"
    "      a=b a> 0 if\n"
    "        b-- a=*b a++ a&= 255 d=a d! *d++\n"
    "      forever\n"
    "    endif\n"
    "\n"
    "    (cumulative counts: H[~i=0..255] = count of bytes before i)\n"
    "    d=0 d! *d= 1 a=0\n"
    "    do\n"
    "      a+=*d *d=a d--\n"
    "    d<>a a! a> 255 a! d<>a until\n"
    "\n"
    "    (build first part of linked list in H[0..idx-1])\n"
    "    b=0 do\n"
    "      a=c a>b if\n"
    "        d=*b d! *d++ d=*d d-- *d=b\n"
    "      b++ forever\n"
    "    endif\n"
    "\n"
    "    (rest of list in H[idx+1..n-1])\n"
    "    b=c b++ c=r 2 do\n"
    "      a=c a>b if\n"
    "        d=*b d! *d++ d=*d d-- *d=b\n"
    "      b++ forever\n"
    "    endif\n"
    "\n";
    if (args[0]<=4) {  
      pcomp+=
      "    (copy M to low 8 bits of H to reduce cache misses in next loop)\n"
      "    b=0 do\n"
      "      a=c a>b if\n"
      "        d=b a=*d a<<= 8 a+=*b *d=a\n"
      "      b++ forever\n"
      "    endif\n"
      "\n"
      "    (traverse list and output or copy to M)\n"
      "    d=r 1 b=0 do\n"
      "      a=d a== 0 ifnot\n"
      "        a=*d a>>= 8 d=a\n";
      if (doe8) pcomp+=" *b=*d b++\n";
      else      pcomp+=" a=*d out\n";
      pcomp+=
      "      forever\n"
      "    endif\n"
      "\n";
      if (doe8)  
        pcomp+=
        "    (e8e9 transform to out)\n"
        "    d=b b=0 do (for b=0..d-1, d = end of buf)\n"
        "      a=b a==d ifnot\n"
        "        a+= 4 a<d if\n"
        "          a=*b a&= 254 a== 232 if\n"
        "            c=b b++ b++ b++ b++ a=*b a++ a&= 254 a== 0 if\n"
        "              b-- a=*b\n"
        "              b-- a<<= 8 a+=*b\n"
        "              b-- a<<= 8 a+=*b\n"
        "              a-=b a++\n"
        "              *b=a a>>= 8 b++\n"
        "              *b=a a>>= 8 b++\n"
        "              *b=a b++\n"
        "            endif\n"
        "            b=c\n"
        "          endif\n"
        "        endif\n"
        "        a=*b out b++\n"
        "      forever\n"
        "    endif\n";
      pcomp+=
      "  endif\n"
      "  halt\n"
      "end\n";
    }
    else {  
      if (doe8) {  
        pcomp+=
        "    (R2 = output size without EOS)\n"
        "    a=r 2 a-- r=a 2\n"
        "\n"
        "    (traverse list (d = IBWT pointer) and output inverse e8e9)\n"
        "    (C = offset = 0..R2-1)\n"
        "    (R4 = last 4 bytes shifted in from MSB end)\n"
        "    (R5 = temp pending output byte)\n"
        "    c=0 d=r 1 do\n"
        "      a=d a== 0 ifnot\n"
        "        d=*d\n"
        "\n"
        "        (store byte in R4 and shift out to R5)\n"
        "        b=d a=*b a<<= 24 b=a\n"
        "        a=r 4 r=a 5 a>>= 8 a|=b r=a 4\n"
        "\n"
        "        (if E8|E9 xx xx xx 00|FF in R4:R5 then subtract c from x)\n"
        "        a=c a> 3 if\n"
        "          a=r 5 a&= 254 a== 232 if\n"
        "            a=r 4 a>>= 24 b=a a++ a&= 254 a< 2 if\n"
        "              a=r 4 a-=c a+= 4 a<<= 8 a>>= 8 \n"
        "              b<>a a<<= 24 a+=b r=a 4\n"
        "            endif\n"
        "          endif\n"
        "        endif\n"
        "\n"
        "        (output buffered byte)\n"
        "        a=c a> 3 if a=r 5 out endif c++\n"
        "\n"
        "      forever\n"
        "    endif\n"
        "\n"
        "    (output up to 4 pending bytes in R4)\n"
        "    b=r 4\n"
        "    a=c a> 3 a=b if out endif a>>= 8 b=a\n"
        "    a=c a> 2 a=b if out endif a>>= 8 b=a\n"
        "    a=c a> 1 a=b if out endif a>>= 8 b=a\n"
        "    a=c a> 0 a=b if out endif\n"
        "\n"
        "  endif\n"
        "  halt\n"
        "end\n";
      }
      else {
        pcomp+=
        "    (traverse list and output)\n"
        "    d=r 1 do\n"
        "      a=d a== 0 ifnot\n"
        "        d=*d\n"
        "        b=d a=*b out\n"
        "      forever\n"
        "    endif\n"
        "  endif\n"
        "  halt\n"
        "end\n";
      }
    }
  }
  else if (level==0) {
    hdr="comp 9 16 0 0 ";
    if (doe8) { 
      pcomp=
      "pcomp e8e9 d ;\n"
      "  a> 255 if\n"
      "    a=c a> 4 if\n"
      "      c= 4\n"
      "    else\n"
      "      a! a+= 5 a<<= 3 d=a a=b a>>=d b=a\n"
      "    endif\n"
      "    do a=c a> 0 if\n"
      "      a=b out a>>= 8 b=a c--\n"
      "    forever endif\n"
      "  else\n"
      "    *b=b a<<= 24 d=a a=b a>>= 8 a+=d b=a c++\n"
      "    a=c a> 4 if\n"
      "      a=*b out\n"
      "      a&= 254 a== 232 if\n"
      "        a=b a>>= 24 a++ a&= 254 a== 0 if\n"
      "          a=b a>>= 24 a<<= 24 d=a\n"
      "          a=b a-=c a+= 5\n"
      "          a<<= 8 a>>= 8 a|=d b=a\n"
      "        endif\n"
      "      endif\n"
      "    endif\n"
      "  endif\n"
      "  halt\n"
      "end\n";
    }
    else
      pcomp="end\n";
  }
  else
    error("Unsupported method");
  int ncomp=0;  
  const int membits=args[0]+20;
  int sb=5;  
  std::string comp;
  std::string hcomp="hcomp\n"
    "c-- *c=a a+= 255 d=a *d=c\n";
  if (level==2) {  
    hcomp+=
    "  (decode lz77 into M. Codes:\n"
    "  00xxxxxx = literal length xxxxxx+1\n"
    "  xx......, xx > 0 = match with xx offset bytes to follow)\n"
    "\n"
    "  a=r 1 a== 0 if (init)\n"
    "    a= "+itos(111+57*doe8)+" (skip post code)\n"
    "  else a== 1 if  (new code?)\n"
    "    a=*c r=a 2  (save code in R2)\n"
    "    a> 63 if a>>= 6 a++ a++  (match)\n"
    "    else a++ a++ endif  (literal)\n"
    "  else (read rest of code)\n"
    "    a--\n"
    "  endif endif\n"
    "  r=a 1  (R1 = 1+expected bytes to next code)\n";
  }
  while (*method && ncomp<254) {
    std::vector<int> v;
    v.push_back(*method++);
    if (isdigit(*method)) {
      v.push_back(*method++-'0');
      while (isdigit(*method) || *method==',' || *method=='.') {
        if (isdigit(*method))
          v.back()=v.back()*10+*method++-'0';
        else {
          v.push_back(0);
          ++method;
        }
      }
    }
    if (v[0]=='c') {
      while (v.size()<3) v.push_back(0);
      comp+=itos(ncomp)+" ";
      sb=11;  
      if (v[2]<256) sb+=lg(v[2]);
      else sb+=6;
      for (unsigned i=3; i<v.size(); ++i)
        if (v[i]<512) sb+=nbits(v[i])*3/4;
      if (sb>membits) sb=membits;
      if (v[1]%1000==0) comp+="icm "+itos(sb-6-v[1]/1000)+"\n";
      else comp+="cm "+itos(sb-2-v[1]/1000)+" "+itos(v[1]%1000-1)+"\n";
      hcomp+="d= "+itos(ncomp)+" *d=0\n";
      if (v[2]>1 && v[2]<=255) {  
        if (lg(v[2])!=lg(v[2]-1))
          hcomp+="a=c a&= "+itos(v[2]-1)+" hashd\n";
        else
          hcomp+="a=c a%= "+itos(v[2])+" hashd\n";
      }
      else if (v[2]>=1000 && v[2]<=1255)  
        hcomp+="a= 255 a+= "+itos(v[2]-1000)+
               " d=a a=*d a-=c a> 255 if a= 255 endif d= "+
               itos(ncomp)+" hashd\n";
      for (unsigned i=3; i<v.size(); ++i) {
        if (i==3) hcomp+="b=c ";
        if (v[i]==255)
          hcomp+="a=*b hashd\n";  
        else if (v[i]>0 && v[i]<255)
          hcomp+="a=*b a&= "+itos(v[i])+" hashd\n";  
        else if (v[i]>=256 && v[i]<512) { 
          hcomp+=
          "a=r 1 a> 1 if\n"  
          "  a=r 2 a< 64 if\n"  
          "    a=*b ";
          if (v[i]<511) hcomp+="a&= "+itos(v[i]-256);
          hcomp+=" hashd\n"
          "  else\n"  
          "    a>>= 6 hashd a=r 1 hashd\n"
          "  endif\n"
          "else\n"  
          "  a= 255 hashd a=r 2 hashd\n"
          "endif\n";
        }
        else if (v[i]>=1256)  
          hcomp+="a= "+itos(((v[i]-1000)>>8)&255)+" a<<= 8 a+= "
               +itos((v[i]-1000)&255)+
          " a+=b b=a\n";
        else if (v[i]>1000)
          hcomp+="a= "+itos(v[i]-1000)+" a+=b b=a\n";
        if (v[i]<512 && i<v.size()-1)
          hcomp+="b++ ";
      }
      ++ncomp;
    }
    if (strchr("mts", v[0]) && ncomp>int(v[0]=='t')) {
      if (v.size()<=1) v.push_back(8);
      if (v.size()<=2) v.push_back(24+8*(v[0]=='s'));
      if (v[0]=='s' && v.size()<=3) v.push_back(255);
      comp+=itos(ncomp);
      sb=5+v[1]*3/4;
      if (v[0]=='m')
        comp+=" mix "+itos(v[1])+" 0 "+itos(ncomp)+" "+itos(v[2])+" 255\n";
      else if (v[0]=='t')
        comp+=" mix2 "+itos(v[1])+" "+itos(ncomp-1)+" "+itos(ncomp-2)
            +" "+itos(v[2])+" 255\n";
      else 
        comp+=" sse "+itos(v[1])+" "+itos(ncomp-1)+" "+itos(v[2])+" "
            +itos(v[3])+"\n";
      if (v[1]>8) {
        hcomp+="d= "+itos(ncomp)+" *d=0 b=c a=0\n";
        for (; v[1]>=16; v[1]-=8) {
          hcomp+="a<<= 8 a+=*b";
          if (v[1]>16) hcomp+=" b++";
          hcomp+="\n";
        }
        if (v[1]>8)
          hcomp+="a<<= 8 a+=*b a>>= "+itos(16-v[1])+"\n";
        hcomp+="a<<= 8 *d=a\n";
      }
      ++ncomp;
    }
    if (v[0]=='i' && ncomp>0) {
      assert(sb>=5);
      hcomp+="d= "+itos(ncomp-1)+" b=c a=*d d++\n";
      for (unsigned i=1; i<v.size() && ncomp<254; ++i) {
        for (int j=0; j<v[i]%10; ++j) {
          hcomp+="hash ";
          if (i<v.size()-1 || j<v[i]%10-1) hcomp+="b++ ";
          sb+=6;
        }
        hcomp+="*d=a";
        if (i<v.size()-1) hcomp+=" d++";
        hcomp+="\n";
        if (sb>membits) sb=membits;
        comp+=itos(ncomp)+" isse "+itos(sb-6-v[i]/10)+" "+itos(ncomp-1)+"\n";
        ++ncomp;
      }
    }
    if (v[0]=='a') {
      if (v.size()<=1) v.push_back(24);
      while (v.size()<4) v.push_back(0);
      comp+=itos(ncomp)+" match "+itos(membits-v[3]-2)+" "
          +itos(membits-v[2])+"\n";
      hcomp+="d= "+itos(ncomp)+" a=*d a*= "+itos(v[1])
           +" a+=*c a++ *d=a\n";
      sb=5+(membits-v[2])*3/4;
      ++ncomp;
    }
    if (v[0]=='w') {
      if (v.size()<=1) v.push_back(1);
      if (v.size()<=2) v.push_back(65);
      if (v.size()<=3) v.push_back(26);
      if (v.size()<=4) v.push_back(223);
      if (v.size()<=5) v.push_back(20);
      if (v.size()<=6) v.push_back(0);
      comp+=itos(ncomp)+" icm "+itos(membits-6-v[6])+"\n";
      for (int i=1; i<v[1]; ++i)
        comp+=itos(ncomp+i)+" isse "+itos(membits-6-v[6])+" "
            +itos(ncomp+i-1)+"\n";
      hcomp+="a=*c a&= "+itos(v[4])+" a-= "+itos(v[2])+" a&= 255 a< "
           +itos(v[3])+" if\n";
      for (int i=0; i<v[1]; ++i) {
        if (i==0) hcomp+="  d= "+itos(ncomp);
        else hcomp+="  d++";
        hcomp+=" a=*d a*= "+itos(v[5])+" a+=*c a++ *d=a\n";
      }
      hcomp+="else\n";
      for (int i=v[1]-1; i>0; --i)
        hcomp+="  d= "+itos(ncomp+i-1)+" a=*d d++ *d=a\n";
      hcomp+="  d= "+itos(ncomp)+" *d=0\n"
           "endif\n";
      ncomp+=v[1]-1;
      sb=membits-v[6];
      ++ncomp;
    }
  }
  return hdr+itos(ncomp)+"\n"+comp+hcomp+"halt\n"+pcomp;
}
void compressBlock(StringBuffer* in, Writer* out, const char* method_,
                   const char* filename, const char* comment, bool dosha1) {
  assert(in);
  assert(out);
  assert(method_);
  assert(method_[0]);
  std::string method=method_;
  const unsigned n=in->size();  
  const int arg0=MAX(lg(n+4095)-20, 0);  
  assert((1u<<(arg0+20))>=n+4096);
  unsigned type=0;
  if (isdigit(method[0])) {
    int commas=0, arg[4]={0};
    for (int i=1; i<int(method.size()) && commas<4; ++i) {
      if (method[i]==',' || method[i]=='.') ++commas;
      else if (isdigit(method[i])) arg[commas]=arg[commas]*10+method[i]-'0';
    }
    if (commas==0) type=512;
    else type=arg[1]*4+arg[2];
  }
  libzpaq::SHA1 sha1;
  const char* sha1ptr=0;
#ifdef DEBUG
  if (true) {
#else
  if (dosha1) {
#endif
    sha1.write(in->c_str(), n);
    sha1ptr=sha1.result();
  }
  if (isdigit(method[0])) {
    const int level=method[0]-'0';
    assert(level>=0 && level<=9);
    const int doe8=(type&2)*2;
    method="x"+itos(arg0);
    std::string htsz=","+itos(19+arg0+(arg0<=6));  
    std::string sasz=","+itos(21+arg0);            
    if (level==0)
      method="0"+itos(arg0)+",0";
    else if (level==1) {
      if (type<40) method+=",0";
      else {
        method+=","+itos(1+doe8)+",";
        if      (type<80)  method+="4,0,1,15";
        else if (type<128) method+="4,0,2,16";
        else if (type<256) method+="4,0,2"+htsz;
        else if (type<960) method+="5,0,3"+htsz;
        else               method+="6,0,3"+htsz;
      }
    }
    else if (level==2) {
      if (type<32) method+=",0";
      else {
        method+=","+itos(1+doe8)+",";
        if (type<64) method+="4,0,3"+htsz;
        else method+="4,0,7"+sasz+",1";
      }
    }
    else if (level==3) {
      if (type<20)  
        method+=",0";
      else if (type<48)  
        method+=","+itos(1+doe8)+",4,0,3"+htsz;
      else if (type>=640 || (type&1))  
        method+=","+itos(3+doe8)+"ci1";
      else  
        method+=","+itos(2+doe8)+",12,0,7"+sasz+",1c0,0,511i2";
    }
    else if (level==4) {
      if (type<12)
        method+=",0";
      else if (type<24)
        method+=","+itos(1+doe8)+",4,0,3"+htsz;
      else if (type<48)
        method+=","+itos(2+doe8)+",5,0,7"+sasz+"1c0,0,511";
      else if (type<900) {
        method+=","+itos(doe8)+"ci1,1,1,1,2a";
        if (type&1) method+="w";
        method+="m";
      }
      else
        method+=","+itos(3+doe8)+"ci1";
    }
    else {  
      method+=","+itos(doe8);
      if (type&1) method+="w2c0,1010,255i1";
      else method+="w1i1";
      method+="c256ci1,1,1,1,1,1,2a";
      const int NR=1<<12;
      int pt[256]={0};  
      int r[NR]={0};    
      const unsigned char* p=in->data();
      if (level>0) {
        for (unsigned i=0; i<n; ++i) {
          const int k=i-pt[p[i]];
          if (k>0 && k<NR) ++r[k];
          pt[p[i]]=i;
        }
      }
      int n1=n-r[1]-r[2]-r[3];
      for (int i=0; i<2; ++i) {
        int period=0;
        double score=0;
        int t=0;
        for (int j=5; j<NR && t<n1; ++j) {
          const double s=r[j]/(256.0+n1-t);
          if (s>score) score=s, period=j;
          t+=r[j];
        }
        if (period>4 && score>0.1) {
          method+="c0,0,"+itos(999+period)+",255i1";
          if (period<=255)
            method+="c0,"+itos(period)+"i1";
          n1-=r[period];
          r[period]=0;
        }
        else
          break;
      }
      method+="c0,2,0,255i1c0,3,0,0,255i1c0,4,0,0,0,255i1mm16ts19t0";
    }
  }
  std::string config;
  int args[9]={0};
  config=makeConfig(method.c_str(), args);
  assert(n<=(0x100000u<<args[0])-4096);
  libzpaq::Compressor co;
  co.setOutput(out);
#ifdef DEBUG
  co.setVerify(true);
#endif
  StringBuffer pcomp_cmd;
  co.writeTag();
  co.startBlock(config.c_str(), args, &pcomp_cmd);
  std::string cs=itos(n);
  if (comment) cs=cs+" "+comment;
  co.startSegment(filename, cs.c_str());
  if (args[1]>=1 && args[1]<=7 && args[1]!=4) {  
    LZBuffer lz(*in, args);
    co.setInput(&lz);
    co.compress();
  }
  else {  
    if (args[1]>=4 && args[1]<=7)
      e8e9(in->data(), in->size());
    co.setInput(in);
    co.compress();
  }
#ifdef DEBUG  
  int64_t outsize;
  const char* sha1result=co.endSegmentChecksum(&outsize, dosha1);
  assert(sha1result);
  assert(sha1ptr);
  if (memcmp(sha1result, sha1ptr, 20)!=0)
    error("Pre/post-processor test failed");
#else
  co.endSegment(sha1ptr);
#endif
  co.endBlock();
}
}  
using std::string;
using std::vector;
using std::map;
using libzpaq::StringBuffer;
int unz(const char * archive,const char * key); 
typedef void (*voidhelpfunction)(bool i_usage,bool i_example); 
typedef map<string, voidhelpfunction> 	MAPPAHELP;
typedef map<int, 	string> 			MAPPACOMMENTI;
typedef map<string, string> 			MAPPAFILEHASH;
typedef map<string, string> 			MAPPASTRINGASTRINGA;
typedef map<int64_t,string> 			MAPPAINT64STRING;
struct	hash_check
{
	int		algotype;
	int		checkedok;
	int		checkedfailed;
	int		checkednotfound;
	int64_t checksize;
	hash_check(): algotype(0), checkedok(0),checkedfailed(0),checkednotfound(0),checksize(0) {};
};
typedef map<string, hash_check> MAPPACHECK;
enum ealgoritmi		{ ALGO_SHA1,ALGO_CRC32C,ALGO_CRC32,ALGO_XXH3,ALGO_SHA256,ALGO_WYHASH,ALGO_XXHASH64,ALGO_BLAKE3,ALGO_WHIRLPOOL,ALGO_MD5,ALGO_SHA3,ALGO_NILSIMSA,ALGO_ENTROPY,ALGO_LAST };
typedef std::map<int,std::string> algoritmi;
const algoritmi::value_type rawData[] = 
{
   algoritmi::value_type(ALGO_SHA1,"sha1"),
   algoritmi::value_type(ALGO_CRC32,"crc32"),
   algoritmi::value_type(ALGO_CRC32C,"crc32c"),
   algoritmi::value_type(ALGO_XXH3,"xxh3"),
   algoritmi::value_type(ALGO_XXHASH64,"xxhash"),
   algoritmi::value_type(ALGO_SHA256,"sha256"),
   algoritmi::value_type(ALGO_WYHASH,"wyhash"),
   algoritmi::value_type(ALGO_BLAKE3,"blake3"),
   algoritmi::value_type(ALGO_WHIRLPOOL,"whirlpool"),
   algoritmi::value_type(ALGO_MD5,"md5"),
   algoritmi::value_type(ALGO_MD5,"sha3"),
   algoritmi::value_type(ALGO_NILSIMSA,"nilsimsa"),
   algoritmi::value_type(ALGO_ENTROPY,"entropy"),
};
const int numElems = sizeof rawData / sizeof rawData[0];
algoritmi myalgoritmi(rawData, rawData + numElems);
struct s_crc32block
{
	string	filename;
	uint64_t crc32start;
	uint64_t crc32size;
	uint32_t crc32;
	s_crc32block(): crc32start(0),crc32size(0),crc32(0) {}
};
struct s_error
{
	int				counter;
	string			text;
	vector<string>	filenames;
	vector<int32_t>	attrs;
	s_error(): counter(0) {text="";}
};
typedef map<int,s_error> 	MAPPAERRORS;
pthread_mutex_t g_mylock = PTHREAD_MUTEX_INITIALIZER;
vector<s_crc32block> 	g_crc32;
vector<uint64_t> 		g_arraybytescanned;
vector<uint64_t> 		g_arrayfilescanned;
MAPPAERRORS g_errors;
char 	command;             			
string	g_franzsnap;
string 	g_vss_shadow;
string 	g_copy;
string 	g_freeze;
string 	g_exec_error;
string  g_exec_warn;
string 	g_exec_ok;
string 	g_exec_text;
string 	g_exec;
int 	g_255;
string 	g_output;
string 	g_sfx;
string 	g_sfxto;
string 	g_sfxnot;
string 	g_sfxonly;
string 	g_sfxuntil;
bool 	g_sfxflagall;
bool  	g_sfxflagforce;
string 	g_archive; 
FILE* 	g_output_handle;
int64_t g_robocopy_check_sorgente;
int64_t g_robocopy_check_destinazione;
int64_t g_start			=0;  	
int64_t g_dimensione	=0;
int64_t g_scritti		=0;
int64_t g_zerotime		=0;
int64_t g_bytescanned	=0;
int64_t g_filescanned	=0;
int64_t g_worked		=0;
int64_t g_fwritten		=0;
int64_t g_fexpected		=0;
int64_t g_ramdisksize	=0;
int32_t g_rd			=0;
int32_t g_rd_expected	=0;
int64_t g_startrd		=0;
int 	g_rd_ultimotempo=0;
uint64_t minsize;
uint64_t maxsize;
bool 	flagdonotforcexls;
bool 	flagfilelist;
bool 	flag715;
bool 	flagzero;
bool 	flagforcezfs;
bool	flagspace;
bool 	flagdebug;
bool	flagutc;
bool 	flagnoeta;
bool 	flagpakka;
bool 	flagvss;
bool 	flagverbose;
bool 	flagverify;
bool 	flagkill;
bool 	flagchecksum;					
bool 	flagutf;
bool 	flagflat;
bool 	flagparanoid;
bool 	flagfix255;
bool	flagfixcase;
bool 	flagfixeml;
bool 	flagbarraod;
bool 	flagbarraon;
bool 	flagbarraos;
bool 	flagcrc32c;
bool	flagentropy;
bool 	flagsha1;
bool 	flagxxh3;
bool 	flagcrc32;
bool 	flagsha256;
bool 	flagwyhash; 
bool 	flagxxhash64;
bool 	flagblake3;
bool 	flagwhirlpool;
bool 	flagmd5;
bool	flagnilsimsa;
bool 	flagsha3;
bool 	flagmm;
bool 	flagappend;
bool 	flaghw;
bool	flagdesc;
bool	flagnodedup;
bool	flagtar;
bool	flagramdisk;
bool	flagssd;
bool 	flagtouch;
bool	flagstat;
bool	flagfrugal;
bool	flagsilent;
bool	flagnorecursion;
int 	g_franzotype; 
string 	g_optional;
string orderby;
vector<string> g_theorderby;
MAPPACHECK	g_mychecks;
void seppuku()
{
	if (g_output_handle)
		fclose(g_output_handle);
	exit(0);
}
void myprintf(const char *fmt, ...)
{
	char buffer[4096];
	va_list args;
    va_start(args, fmt);
    vsnprintf(buffer,sizeof(buffer),fmt,args);	
	if (!flagsilent)
		printf("%s",buffer);
	if (g_output_handle!=0)
		fprintf(g_output_handle,"%s",buffer);
   va_end(args);
}
string	binarytohex(const unsigned char* i_risultato,const int i_lunghezza)
{
	string risultato="";
	char myhex[4];
	if (i_risultato!=NULL)
		if (i_lunghezza>0)
			for (int j=0;j<i_lunghezza;j++)
			{
				sprintf(myhex,"%02X", (unsigned char)i_risultato[j]);
				risultato.push_back(myhex[0]);
				risultato.push_back(myhex[1]);
			}
	return risultato;
}
string decodefranzoffset(int franzotype)
{
	if (franzotype==FRANZO_NONE)
		return "NOTHING (LIKE 7.15)";
	if (franzotype==FRANZO_CRC_32) 
		return "CRC-32";
	if (franzotype==FRANZO_XXHASH64)
		return "XXHASH64+CRC-32";
	if (franzotype==FRANZO_SHA_1)
		return "SHA-1+CRC-32";
	if (franzotype==FRANZO_SHA_256)
		return "SHA-256+CRC-32";
	if (franzotype==FRANZO_XXH3)
		return "XXH3+CRC-32";
	if (franzotype==FRANZO_BLAKE3)
		return "BLAKE3+CRC-32";
	if (franzotype==FRANZO_SHA3)
		return "SHA-3+CRC-32";
	if (franzotype==FRANZO_MD5)
		return "MD5+CRC-32";
	return "BYPASSWARNING";
}
string mygetalgo()
{
	if (flagblake3)
		return "BLAKE3";
	else
	if (flagxxhash64)
		return "XXHASH64";
	else
	if (flagwyhash)
		return "WYHASH";
	else
	if (flagcrc32)
		return "CRC-32";
	else
	if (flagentropy)
		return "ENTROPY";
	else
	if (flagcrc32c)
		return "CRC-32C";
	else
	if (flagxxh3)
		return "XXH3";
	else
	if (flagsha256)
		return "SHA-256";
	else
	if (flagwhirlpool)
		return "WHIRLPOOL";
	else
	if (flagmd5)
		return "MD5";
	else
	if (flagnilsimsa)
		return "NILSIMSA";
	else
	if (flagsha3)
		return "SHA-3";
	else
		return "SHA-1";
}
int flag2algo()
{
	if (flagblake3)
		return ALGO_BLAKE3;
	else
	if (flagxxhash64)
		return ALGO_XXHASH64;
	else
	if (flagwyhash)
		return ALGO_WYHASH;
	else
	if (flagwhirlpool)
		return ALGO_WHIRLPOOL;
	else
	if (flagmd5)
		return ALGO_MD5;
	else
	if (flagnilsimsa)
		return ALGO_NILSIMSA;
	else
	if (flagsha3)
		return ALGO_SHA3;
	else
	if (flagcrc32)
		return ALGO_CRC32;
	else
	if (flagcrc32c)
		return ALGO_CRC32C;
	else
	if (flagxxh3)
		return ALGO_XXH3;
	else
	if (flagsha256)
		return ALGO_SHA256;
	else
		return ALGO_SHA1;
}
string emptyalgo(const string i_string)
{
	if (i_string=="BLAKE3")
		return "AF1349B9F5F9A1A6A0404DEA36DCC9499BCB25C9ADC112B7CC9A93CAE41F3262";
	else
	if (i_string=="XXHASH64")
		return "EF46DB3751D8E999";
	else
	if (i_string=="WYHASH")
		return "";
	else
	if (i_string=="CRC-32")
		return "00000000";
	else
	if (i_string=="ENTROPY")
		return "00000000";
	else
	if (i_string=="CRC-32C")
		return "00000000";
	else
	if (i_string=="XXH3")
		return "99AA06D3014798D86001C324468D497F";
	else
	if (i_string=="SHA-256")
		return "E3B0C44298FC1C149AFBF4C8996FB92427AE41E4649B934CA495991B7852B855";
	else
	if (i_string=="WHIRLPOOL")
		return "19FA61D75522A4669B44E39C1D2E1726C530232130D407F89AFEE0964997F7A73E83BE698B288FEBCF88E3E03C4F0757EA8964E59B63D93708B138CC42A66EB3";
	else
	if (i_string=="MD5")
		return "D41D8CD98F00B204E9800998ECF8427E";
	else
	if (i_string=="NILSIMSA")
		return "VUOTO";
	else
	if (i_string=="SHA-3")
		return "A7FFC6F8BF1ED76651C14756A061D662F580FF4DE43B49FA82D80A4B80F8434A";
	else
		return "DA39A3EE5E6B4B0D3255BFEF95601890AFD80709"; 
}
int string2algo(string i_string)
{
	if (i_string=="BLAKE3")
		return ALGO_BLAKE3;
	else
	if (i_string=="XXHASH64")
		return ALGO_XXHASH64;
	else
	if (i_string=="WYHASH")
		return ALGO_WYHASH;
	else
	if (i_string=="CRC-32")
		return ALGO_CRC32;
	else
	if (i_string=="ENTROPY")
		return ALGO_ENTROPY;
	else
	if (i_string=="CRC-32C")
		return ALGO_CRC32C;
	else
	if (i_string=="XXH3")
		return ALGO_XXH3;
	else
	if (i_string=="SHA-256")
		return ALGO_SHA256;
	else
	if (i_string=="WHIRLPOOL")
		return ALGO_WHIRLPOOL;
	else
	if (i_string=="MD5")
		return ALGO_MD5;
	else
	if (i_string=="NILSIMSA")
		return ALGO_NILSIMSA;
	else
	if (i_string=="SHA-3")
		return ALGO_SHA3;
	else
		return ALGO_SHA1;
}
void nilsimsa_compute(const char* data, int size, char* out);
int nilsimsa_compare(const char* lhs, const char* rhs);
static int __score(int num);
static int __tran3(int a, int b, int c, int n);
static int __hexchar_to_int(char digit);
static const char* __int_to_hexchar(int num);
#define ACCUM_LENGTH 256
#define DIGEST_LENGTH 32
#define WINDOW_LENGTH 4 
void nilsimsa_compute(const char* data, int n, char* out)
{
    int accum[ACCUM_LENGTH] = { 0 };
    int digest[DIGEST_LENGTH] = { 0 };
    int window[WINDOW_LENGTH] = { -1, -1, -1, -1 };
    for (int i = 0; i < n; ++i)
    {
        int ch = data[i] & 0xFF;
        if (window[1] > -1)
        {
            accum[__tran3(ch, window[0], window[1], 0)] += 1;
        }
        if (window[2] > -1)
        {
            accum[__tran3(ch, window[0], window[2], 1)] += 1;
            accum[__tran3(ch, window[1], window[2], 2)] += 1;
        }
        if (window[3] > -1)
        {
            accum[__tran3(ch, window[0], window[3], 3)] += 1;
            accum[__tran3(ch, window[1], window[3], 4)] += 1;
            accum[__tran3(ch, window[2], window[3], 5)] += 1;
            accum[__tran3(window[3], window[0], ch, 6)] += 1;
            accum[__tran3(window[3], window[2], ch, 7)] += 1;
        }
        window[3] = window[2];
        window[2] = window[1];
        window[1] = window[0];
        window[0] = ch;
    }
    int total = 0;
    if (n == 3)
        total = 1;
    else if (n == 4)
        total = 4;
    else if (n > 4)
        total = 8 * n - 28;
    int threshold = total / ACCUM_LENGTH;
    for (int i = 0; i < ACCUM_LENGTH; i++)
        if (accum[i] > threshold)
            digest[i >> 3] += 1 << (i & 7);
    int rev_index = 0;
    for (int i = 0; i < DIGEST_LENGTH; ++i)
    {
        rev_index = DIGEST_LENGTH - i - 1;
        out[2*i  ] = __int_to_hexchar(digest[rev_index])[0];
        out[2*i+1] = __int_to_hexchar(digest[rev_index])[1];
    }
    out[2 * DIGEST_LENGTH] = '\0';
}
int nilsimsa_compare(const char* hash1, const char* hash2)
{
    int digest1[DIGEST_LENGTH] = { 0 };
    int digest2[DIGEST_LENGTH] = { 0 };
    for (int i = 0; i < DIGEST_LENGTH; ++i)
    {
        digest1[i] = (__hexchar_to_int(hash1[2 * i]) << 4) + __hexchar_to_int(hash1[2 * i + 1]);
        digest2[i] = (__hexchar_to_int(hash2[2 * i]) << 4) + __hexchar_to_int(hash2[2 * i + 1]);
    }
    int bits = 0;
    for (int i = 0; i < DIGEST_LENGTH; i++)
        bits += __score(255 & (digest1[i] ^ digest2[i]));
    return 128 - bits;
}
static const int __TRAN53[] =
{
    0x02, 0xD6, 0x9E, 0x6F, 0xF9, 0x1D, 0x04, 0xAB, 0xD0, 0x22, 0x16, 0x1F, 0xD8, 0x73, 0xA1, 0xAC,
    0x3B, 0x70, 0x62, 0x96, 0x1E, 0x6E, 0x8F, 0x39, 0x9D, 0x05, 0x14, 0x4A, 0xA6, 0xBE, 0xAE, 0x0E,
    0xCF, 0xB9, 0x9C, 0x9A, 0xC7, 0x68, 0x13, 0xE1, 0x2D, 0xA4, 0xEB, 0x51, 0x8D, 0x64, 0x6B, 0x50,
    0x23, 0x80, 0x03, 0x41, 0xEC, 0xBB, 0x71, 0xCC, 0x7A, 0x86, 0x7F, 0x98, 0xF2, 0x36, 0x5E, 0xEE,
    0x8E, 0xCE, 0x4F, 0xB8, 0x32, 0xB6, 0x5F, 0x59, 0xDC, 0x1B, 0x31, 0x4C, 0x7B, 0xF0, 0x63, 0x01,
    0x6C, 0xBA, 0x07, 0xE8, 0x12, 0x77, 0x49, 0x3C, 0xDA, 0x46, 0xFE, 0x2F, 0x79, 0x1C, 0x9B, 0x30,
    0xE3, 0x00, 0x06, 0x7E, 0x2E, 0x0F, 0x38, 0x33, 0x21, 0xAD, 0xA5, 0x54, 0xCA, 0xA7, 0x29, 0xFC,
    0x5A, 0x47, 0x69, 0x7D, 0xC5, 0x95, 0xB5, 0xF4, 0x0B, 0x90, 0xA3, 0x81, 0x6D, 0x25, 0x55, 0x35,
    0xF5, 0x75, 0x74, 0x0A, 0x26, 0xBF, 0x19, 0x5C, 0x1A, 0xC6, 0xFF, 0x99, 0x5D, 0x84, 0xAA, 0x66,
    0x3E, 0xAF, 0x78, 0xB3, 0x20, 0x43, 0xC1, 0xED, 0x24, 0xEA, 0xE6, 0x3F, 0x18, 0xF3, 0xA0, 0x42,
    0x57, 0x08, 0x53, 0x60, 0xC3, 0xC0, 0x83, 0x40, 0x82, 0xD7, 0x09, 0xBD, 0x44, 0x2A, 0x67, 0xA8,
    0x93, 0xE0, 0xC2, 0x56, 0x9F, 0xD9, 0xDD, 0x85, 0x15, 0xB4, 0x8A, 0x27, 0x28, 0x92, 0x76, 0xDE,
    0xEF, 0xF8, 0xB2, 0xB7, 0xC9, 0x3D, 0x45, 0x94, 0x4B, 0x11, 0x0D, 0x65, 0xD5, 0x34, 0x8B, 0x91,
    0x0C, 0xFA, 0x87, 0xE9, 0x7C, 0x5B, 0xB1, 0x4D, 0xE5, 0xD4, 0xCB, 0x10, 0xA2, 0x17, 0x89, 0xBC,
    0xDB, 0xB0, 0xE2, 0x97, 0x88, 0x52, 0xF7, 0x48, 0xD3, 0x61, 0x2C, 0x3A, 0x2B, 0xD1, 0x8C, 0xFB,
    0xF1, 0xCD, 0xE4, 0x6A, 0xE7, 0xA9, 0xFD, 0xC4, 0x37, 0xC8, 0xD2, 0xF6, 0xDF, 0x58, 0x72, 0x4E
};
static const int __POPC[] =
{
    0x00, 0x01, 0x01, 0x02, 0x01, 0x02, 0x02, 0x03, 0x01, 0x02, 0x02, 0x03, 0x02, 0x03, 0x03, 0x04,
    0x01, 0x02, 0x02, 0x03, 0x02, 0x03, 0x03, 0x04, 0x02, 0x03, 0x03, 0x04, 0x03, 0x04, 0x04, 0x05,
    0x01, 0x02, 0x02, 0x03, 0x02, 0x03, 0x03, 0x04, 0x02, 0x03, 0x03, 0x04, 0x03, 0x04, 0x04, 0x05,
    0x02, 0x03, 0x03, 0x04, 0x03, 0x04, 0x04, 0x05, 0x03, 0x04, 0x04, 0x05, 0x04, 0x05, 0x05, 0x06,
    0x01, 0x02, 0x02, 0x03, 0x02, 0x03, 0x03, 0x04, 0x02, 0x03, 0x03, 0x04, 0x03, 0x04, 0x04, 0x05,
    0x02, 0x03, 0x03, 0x04, 0x03, 0x04, 0x04, 0x05, 0x03, 0x04, 0x04, 0x05, 0x04, 0x05, 0x05, 0x06,
    0x02, 0x03, 0x03, 0x04, 0x03, 0x04, 0x04, 0x05, 0x03, 0x04, 0x04, 0x05, 0x04, 0x05, 0x05, 0x06,
    0x03, 0x04, 0x04, 0x05, 0x04, 0x05, 0x05, 0x06, 0x04, 0x05, 0x05, 0x06, 0x05, 0x06, 0x06, 0x07,
    0x01, 0x02, 0x02, 0x03, 0x02, 0x03, 0x03, 0x04, 0x02, 0x03, 0x03, 0x04, 0x03, 0x04, 0x04, 0x05,
    0x02, 0x03, 0x03, 0x04, 0x03, 0x04, 0x04, 0x05, 0x03, 0x04, 0x04, 0x05, 0x04, 0x05, 0x05, 0x06,
    0x02, 0x03, 0x03, 0x04, 0x03, 0x04, 0x04, 0x05, 0x03, 0x04, 0x04, 0x05, 0x04, 0x05, 0x05, 0x06,
    0x03, 0x04, 0x04, 0x05, 0x04, 0x05, 0x05, 0x06, 0x04, 0x05, 0x05, 0x06, 0x05, 0x06, 0x06, 0x07,
    0x02, 0x03, 0x03, 0x04, 0x03, 0x04, 0x04, 0x05, 0x03, 0x04, 0x04, 0x05, 0x04, 0x05, 0x05, 0x06,
    0x03, 0x04, 0x04, 0x05, 0x04, 0x05, 0x05, 0x06, 0x04, 0x05, 0x05, 0x06, 0x05, 0x06, 0x06, 0x07,
    0x03, 0x04, 0x04, 0x05, 0x04, 0x05, 0x05, 0x06, 0x04, 0x05, 0x05, 0x06, 0x05, 0x06, 0x06, 0x07,
    0x04, 0x05, 0x05, 0x06, 0x05, 0x06, 0x06, 0x07, 0x05, 0x06, 0x06, 0x07, 0x06, 0x07, 0x07, 0x08
};
static const char* __HEX_BYTE_DIGITS[] =
{
    "00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "0A", "0B", "0C", "0D", "0E", "0F",
    "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "1A", "1B", "1C", "1D", "1E", "1F",
    "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "2A", "2B", "2C", "2D", "2E", "2F",
    "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "3A", "3B", "3C", "3D", "3E", "3F",
    "40", "41", "42", "43", "44", "45", "46", "47", "48", "49", "4A", "4B", "4C", "4D", "4E", "4F",
    "50", "51", "52", "53", "54", "55", "56", "57", "58", "59", "5A", "5B", "5C", "5D", "5E", "5F",
    "60", "61", "62", "63", "64", "65", "66", "67", "68", "69", "6A", "6B", "6C", "6D", "6E", "6F",
    "70", "71", "72", "73", "74", "75", "76", "77", "78", "79", "7A", "7B", "7C", "7D", "7E", "7F",
    "80", "81", "82", "83", "84", "85", "86", "87", "88", "89", "8A", "8B", "8C", "8D", "8E", "8F",
    "90", "91", "92", "93", "94", "95", "96", "97", "98", "99", "9A", "9B", "9C", "9D", "9E", "9F",
    "A0", "A1", "A2", "A3", "A4", "A5", "A6", "A7", "A8", "A9", "AA", "AB", "AC", "AD", "AE", "AF",
    "B0", "B1", "B2", "B3", "B4", "B5", "B6", "B7", "B8", "B9", "BA", "BB", "BC", "BD", "BE", "BF",
    "C0", "C1", "C2", "C3", "C4", "C5", "C6", "C7", "C8", "C9", "CA", "CB", "CC", "CD", "CE", "CF",
    "D0", "D1", "D2", "D3", "D4", "D5", "D6", "D7", "D8", "D9", "DA", "DB", "DC", "DD", "DE", "DF",
    "E0", "E1", "E2", "E3", "E4", "E5", "E6", "E7", "E8", "E9", "EA", "EB", "EC", "ED", "EE", "EF",
    "F0", "F1", "F2", "F3", "F4", "F5", "F6", "F7", "F8", "F9", "FA", "FB", "FC", "FD", "FE", "FF"
};
static int __tran3(int a, int b, int c, int n)
{
    return (((__TRAN53[(a + n) & 255] ^ __TRAN53[b] * (n + n + 1)) + __TRAN53[c ^ __TRAN53[n]]) & 255);
}
static int __hexchar_to_int(char digit)
{
    return ((digit | 432) * 239217992 & 0xffffffff) >> 28;
}
static const char* __int_to_hexchar(int num)
{
    return __HEX_BYTE_DIGITS[num];
}
static int __score(int num)
{
    return __POPC[num];
}
static uint32_t Kappa[] = {
		0x428a2f98,0x71374491,0xb5c0fbcf,0xe9b5dba5,
		0x3956c25b,0x59f111f1,0x923f82a4,0xab1c5ed5,
		0xd807aa98,0x12835b01,0x243185be,0x550c7dc3,
		0x72be5d74,0x80deb1fe,0x9bdc06a7,0xc19bf174,
		0xe49b69c1,0xefbe4786,0x0fc19dc6,0x240ca1cc,
		0x2de92c6f,0x4a7484aa,0x5cb0a9dc,0x76f988da,
		0x983e5152,0xa831c66d,0xb00327c8,0xbf597fc7,
		0xc6e00bf3,0xd5a79147,0x06ca6351,0x14292967,
		0x27b70a85,0x2e1b2138,0x4d2c6dfc,0x53380d13,
		0x650a7354,0x766a0abb,0x81c2c92e,0x92722c85,
		0xa2bfe8a1,0xa81a664b,0xc24b8b70,0xc76c51a3,
		0xd192e819,0xd6990624,0xf40e3585,0x106aa070,
		0x19a4c116,0x1e376c08,0x2748774c,0x34b0bcb5,
		0x391c0cb3,0x4ed8aa4a,0x5b9cca4f,0x682e6ff3,
		0x748f82ee,0x78a5636f,0x84c87814,0x8cc70208,
		0x90befffa,0xa4506ceb,0xbef9a3f7,0xc67178f2
	};
class franzSHA256 {
public:
	franzSHA256();
	void update(const uint8_t * data, size_t length);
	std::string gethex();
private:
	uint8_t  m_data[64];
	uint32_t m_blocklen;
	uint64_t m_bitlen;
	uint32_t m_state[8]; 
	static uint32_t rotr(uint32_t x, uint32_t n);
	static uint32_t choose(uint32_t e, uint32_t f, uint32_t g);
	static uint32_t majority(uint32_t a, uint32_t b, uint32_t c);
	static uint32_t sig0(uint32_t x);
	static uint32_t sig1(uint32_t x);
	void transform();
	void pad();
	void revert(uint8_t * hash);
};
franzSHA256::franzSHA256(): m_blocklen(0), m_bitlen(0) {
	m_state[0] = 0x6a09e667;
	m_state[1] = 0xbb67ae85;
	m_state[2] = 0x3c6ef372;
	m_state[3] = 0xa54ff53a;
	m_state[4] = 0x510e527f;
	m_state[5] = 0x9b05688c;
	m_state[6] = 0x1f83d9ab;
	m_state[7] = 0x5be0cd19;
}
void franzSHA256::update(const uint8_t * data, size_t length) {
	for (size_t i = 0 ; i < length ; i++) {
		m_data[m_blocklen++] = data[i];
		if (m_blocklen == 64) {
			transform();
			m_bitlen += 512;
			m_blocklen = 0;
		}
	}
}
uint32_t franzSHA256::rotr(uint32_t x, uint32_t n) {
	return (x >> n) | (x << (32 - n));
}
uint32_t franzSHA256::choose(uint32_t e, uint32_t f, uint32_t g) {
	return (e & f) ^ (~e & g);
}
uint32_t franzSHA256::majority(uint32_t a, uint32_t b, uint32_t c) {
	return (a & (b | c)) | (b & c);
}
uint32_t franzSHA256::sig0(uint32_t x) {
	return franzSHA256::rotr(x, 7) ^ franzSHA256::rotr(x, 18) ^ (x >> 3);
}
uint32_t franzSHA256::sig1(uint32_t x) {
	return franzSHA256::rotr(x, 17) ^ franzSHA256::rotr(x, 19) ^ (x >> 10);
}
void franzSHA256::transform() {
	uint32_t maj, xorA, ch, xorE, sum, newA, newE, m[64];
	uint32_t state[8];
	for (uint8_t i = 0, j = 0; i < 16; i++, j += 4) { 
		m[i] = (m_data[j] << 24) | (m_data[j + 1] << 16) | (m_data[j + 2] << 8) | (m_data[j + 3]);
	}
	for (uint8_t k = 16 ; k < 64; k++) { 
		m[k] = franzSHA256::sig1(m[k - 2]) + m[k - 7] + franzSHA256::sig0(m[k - 15]) + m[k - 16];
	}
	for(uint8_t i = 0 ; i < 8 ; i++) {
		state[i] = m_state[i];
	}
	for (uint8_t i = 0; i < 64; i++) {
		maj   = franzSHA256::majority(state[0], state[1], state[2]);
		xorA  = franzSHA256::rotr(state[0], 2) ^ franzSHA256::rotr(state[0], 13) ^ franzSHA256::rotr(state[0], 22);
		ch = choose(state[4], state[5], state[6]);
		xorE  = franzSHA256::rotr(state[4], 6) ^ franzSHA256::rotr(state[4], 11) ^ franzSHA256::rotr(state[4], 25);
		sum  = m[i] + Kappa[i] + state[7] + ch + xorE;
		newA = xorA + maj + sum;
		newE = state[3] + sum;
		state[7] = state[6];
		state[6] = state[5];
		state[5] = state[4];
		state[4] = newE;
		state[3] = state[2];
		state[2] = state[1];
		state[1] = state[0];
		state[0] = newA;
	}
	for(uint8_t i = 0 ; i < 8 ; i++) {
		m_state[i] += state[i];
	}
}
void franzSHA256::pad() 
{
	uint64_t i = m_blocklen;
	uint8_t end = m_blocklen < 56 ? 56 : 64;
	m_data[i++] = 0x80; 
	while (i < end) {
		m_data[i++] = 0x00; 
	}
	if(m_blocklen >= 56) {
		transform();
		memset(m_data, 0, 56);
	}
	m_bitlen += m_blocklen * 8;
	m_data[63] = m_bitlen;
	m_data[62] = m_bitlen >> 8;
	m_data[61] = m_bitlen >> 16;
	m_data[60] = m_bitlen >> 24;
	m_data[59] = m_bitlen >> 32;
	m_data[58] = m_bitlen >> 40;
	m_data[57] = m_bitlen >> 48;
	m_data[56] = m_bitlen >> 56;
	transform();
}
void franzSHA256::revert(uint8_t * hash) 
{
	for (uint8_t i = 0 ; i < 4 ; i++) {
		for(uint8_t j = 0 ; j < 8 ; j++) {
			hash[i + (j * 4)] = (m_state[j] >> (24 - i * 8)) & 0x000000ff;
		}
	}
}
std::string franzSHA256::gethex()
{
	uint8_t * hash = new uint8_t[32];
	pad();
	revert(hash);
	string risultato=binarytohex((const unsigned char*)hash,32);
	delete[] hash;
	return risultato;
}
class SHA3
{
public:
  enum Bits { Bits224 = 224, Bits256 = 256, Bits384 = 384, Bits512 = 512 };
  explicit SHA3(Bits bits = Bits256);
  void add(const void* data, size_t numBytes);
  std::string getHash();
  void reset();
private:
  void processBlock(const void* data);
  void processBuffer();
  enum { StateSize    = 1600 / (8 * 8),
         MaxBlockSize =  200 - 2 * (224 / 8) };
  uint64_t m_hash[StateSize];
  uint64_t m_numBytes;
  size_t   m_blockSize;
  size_t   m_bufferSize;
  uint8_t  m_buffer[MaxBlockSize];
  Bits     m_bits;
};
SHA3::SHA3(Bits bits)
: m_blockSize(200 - 2 * (bits / 8)),
  m_bits(bits)
{
  reset();
}
void SHA3::reset()
{
  for (size_t i = 0; i < StateSize; i++)
    m_hash[i] = 0;
  m_numBytes   = 0;
  m_bufferSize = 0;
}
namespace
{
  const unsigned int Rounds = 24;
  const uint64_t XorMasks[Rounds] =
  {
    0x0000000000000001ULL, 0x0000000000008082ULL, 0x800000000000808aULL,
    0x8000000080008000ULL, 0x000000000000808bULL, 0x0000000080000001ULL,
    0x8000000080008081ULL, 0x8000000000008009ULL, 0x000000000000008aULL,
    0x0000000000000088ULL, 0x0000000080008009ULL, 0x000000008000000aULL,
    0x000000008000808bULL, 0x800000000000008bULL, 0x8000000000008089ULL,
    0x8000000000008003ULL, 0x8000000000008002ULL, 0x8000000000000080ULL,
    0x000000000000800aULL, 0x800000008000000aULL, 0x8000000080008081ULL,
    0x8000000000008080ULL, 0x0000000080000001ULL, 0x8000000080008008ULL
  };
  inline uint64_t rotateLeft(uint64_t x, uint8_t numBits)
  {
    return (x << numBits) | (x >> (64 - numBits));
  }
  inline uint64_t swap(uint64_t x)
  {
#if defined(__GNUC__) || defined(__clang__)
    return __builtin_bswap64(x);
#endif
#ifdef _MSC_VER
    return _byteswap_uint64(x);
#endif
    return  (x >> 56) |
           ((x >> 40) & 0x000000000000FF00ULL) |
           ((x >> 24) & 0x0000000000FF0000ULL) |
           ((x >>  8) & 0x00000000FF000000ULL) |
           ((x <<  8) & 0x000000FF00000000ULL) |
           ((x << 24) & 0x0000FF0000000000ULL) |
           ((x << 40) & 0x00FF000000000000ULL) |
            (x << 56);
  }
  unsigned int mod5(unsigned int x)
  {
    if (x < 5)
      return x;
    return x - 5;
  }
}
void SHA3::processBlock(const void* data)
{
#if defined(__BYTE_ORDER) && (__BYTE_ORDER != 0) && (__BYTE_ORDER == __BIG_ENDIAN)
#define LITTLEENDIAN(x) swap(x)
#else
#define LITTLEENDIAN(x) (x)
#endif
  const uint64_t* data64 = (const uint64_t*) data;
  for (unsigned int i = 0; i < m_blockSize / 8; i++)
    m_hash[i] ^= LITTLEENDIAN(data64[i]);
  for (unsigned int round = 0; round < Rounds; round++)
  {
    uint64_t coefficients[5];
    for (unsigned int i = 0; i < 5; i++)
      coefficients[i] = m_hash[i] ^ m_hash[i + 5] ^ m_hash[i + 10] ^ m_hash[i + 15] ^ m_hash[i + 20];
    for (unsigned int i = 0; i < 5; i++)
    {
      uint64_t one = coefficients[mod5(i + 4)] ^ rotateLeft(coefficients[mod5(i + 1)], 1);
      m_hash[i     ] ^= one;
      m_hash[i +  5] ^= one;
      m_hash[i + 10] ^= one;
      m_hash[i + 15] ^= one;
      m_hash[i + 20] ^= one;
    }
    uint64_t one;
    uint64_t last = m_hash[1];
    one = m_hash[10]; m_hash[10] = rotateLeft(last,  1); last = one;
    one = m_hash[ 7]; m_hash[ 7] = rotateLeft(last,  3); last = one;
    one = m_hash[11]; m_hash[11] = rotateLeft(last,  6); last = one;
    one = m_hash[17]; m_hash[17] = rotateLeft(last, 10); last = one;
    one = m_hash[18]; m_hash[18] = rotateLeft(last, 15); last = one;
    one = m_hash[ 3]; m_hash[ 3] = rotateLeft(last, 21); last = one;
    one = m_hash[ 5]; m_hash[ 5] = rotateLeft(last, 28); last = one;
    one = m_hash[16]; m_hash[16] = rotateLeft(last, 36); last = one;
    one = m_hash[ 8]; m_hash[ 8] = rotateLeft(last, 45); last = one;
    one = m_hash[21]; m_hash[21] = rotateLeft(last, 55); last = one;
    one = m_hash[24]; m_hash[24] = rotateLeft(last,  2); last = one;
    one = m_hash[ 4]; m_hash[ 4] = rotateLeft(last, 14); last = one;
    one = m_hash[15]; m_hash[15] = rotateLeft(last, 27); last = one;
    one = m_hash[23]; m_hash[23] = rotateLeft(last, 41); last = one;
    one = m_hash[19]; m_hash[19] = rotateLeft(last, 56); last = one;
    one = m_hash[13]; m_hash[13] = rotateLeft(last,  8); last = one;
    one = m_hash[12]; m_hash[12] = rotateLeft(last, 25); last = one;
    one = m_hash[ 2]; m_hash[ 2] = rotateLeft(last, 43); last = one;
    one = m_hash[20]; m_hash[20] = rotateLeft(last, 62); last = one;
    one = m_hash[14]; m_hash[14] = rotateLeft(last, 18); last = one;
    one = m_hash[22]; m_hash[22] = rotateLeft(last, 39); last = one;
    one = m_hash[ 9]; m_hash[ 9] = rotateLeft(last, 61); last = one;
    one = m_hash[ 6]; m_hash[ 6] = rotateLeft(last, 20); last = one;
                      m_hash[ 1] = rotateLeft(last, 44);
    for (unsigned int j = 0; j < StateSize; j += 5)
    {
      uint64_t one = m_hash[j];
      uint64_t two = m_hash[j + 1];
      m_hash[j]     ^= m_hash[j + 2] & ~two;
      m_hash[j + 1] ^= m_hash[j + 3] & ~m_hash[j + 2];
      m_hash[j + 2] ^= m_hash[j + 4] & ~m_hash[j + 3];
      m_hash[j + 3] ^=      one      & ~m_hash[j + 4];
      m_hash[j + 4] ^=      two      & ~one;
    }
    m_hash[0] ^= XorMasks[round];
  }
}
void SHA3::add(const void* data, size_t numBytes)
{
  const uint8_t* current = (const uint8_t*) data;
  if (m_bufferSize > 0)
    while (numBytes > 0 && m_bufferSize < m_blockSize)
    {
      m_buffer[m_bufferSize++] = *current++;
      numBytes--;
    }
  if (m_bufferSize == m_blockSize)
  {
    processBlock((void*)m_buffer);
    m_numBytes  += m_blockSize;
    m_bufferSize = 0;
  }
  if (numBytes == 0)
    return;
  while (numBytes >= m_blockSize)
  {
    processBlock(current);
    current    += m_blockSize;
    m_numBytes += m_blockSize;
    numBytes   -= m_blockSize;
  }
  while (numBytes > 0)
  {
    m_buffer[m_bufferSize++] = *current++;
    numBytes--;
  }
}
void SHA3::processBuffer()
{
  size_t offset = m_bufferSize;
  m_buffer[offset++] = 0x06;
  while (offset < m_blockSize)
    m_buffer[offset++] = 0;
  m_buffer[offset - 1] |= 0x80;
  processBlock(m_buffer);
}
std::string SHA3::getHash()
{
  uint64_t oldHash[StateSize];
  for (unsigned int i = 0; i < StateSize; i++)
    oldHash[i] = m_hash[i];
  processBuffer();
  static const char dec2hex[16 + 1] = "0123456789ABCDEF";
  unsigned int hashLength = m_bits / 64;
  std::string result;
  result.reserve(m_bits / 4);
  for (unsigned int i = 0; i < hashLength; i++)
    for (unsigned int j = 0; j < 8; j++) 
    {
      unsigned char oneByte = (unsigned char) (m_hash[i] >> (8 * j));
      result += dec2hex[oneByte >> 4];
      result += dec2hex[oneByte & 15];
    }
  unsigned int remainder = m_bits - hashLength * 64;
  unsigned int processed = 0;
  while (processed < remainder)
  {
    unsigned char oneByte = (unsigned char) (m_hash[hashLength] >> processed);
    result += dec2hex[oneByte >> 4];
    result += dec2hex[oneByte & 15];
    processed += 8;
  }
  for (unsigned int i = 0; i < StateSize; i++)
    m_hash[i] = oldHash[i];
  return result;
}
class MD5
{
public:
  enum { BlockSize = 512 / 8, HashBytes = 16 };
  MD5();
  void add(const void* data, size_t numBytes);
  std::string getHash();
  void getHash(unsigned char buffer[HashBytes]);
  void reset();
private:
  void processBlock(const void* data);
  void processBuffer();
  uint64_t m_numBytes;
  size_t   m_bufferSize;
  uint8_t  m_buffer[BlockSize];
  enum { HashValues = HashBytes / 4 };
  uint32_t m_hash[HashValues];
};
MD5::MD5()
{
  reset();
}
void MD5::reset()
{
  m_numBytes   = 0;
  m_bufferSize = 0;
  m_hash[0] = 0x67452301;
  m_hash[1] = 0xefcdab89;
  m_hash[2] = 0x98badcfe;
  m_hash[3] = 0x10325476;
}
namespace
{
  inline uint32_t f1(uint32_t b, uint32_t c, uint32_t d)
  {
    return d ^ (b & (c ^ d)); 
  }
  inline uint32_t f2(uint32_t b, uint32_t c, uint32_t d)
  {
    return c ^ (d & (b ^ c)); 
  }
  inline uint32_t f3(uint32_t b, uint32_t c, uint32_t d)
  {
    return b ^ c ^ d;
  }
  inline uint32_t f4(uint32_t b, uint32_t c, uint32_t d)
  {
    return c ^ (b | ~d);
  }
  inline uint32_t rotate(uint32_t a, uint32_t c)
  {
    return (a << c) | (a >> (32 - c));
  }
#if defined(__BYTE_ORDER) && (__BYTE_ORDER != 0) && (__BYTE_ORDER == __BIG_ENDIAN)
  inline uint32_t swap(uint32_t x)
  {
#if defined(__GNUC__) || defined(__clang__)
    return __builtin_bswap32(x);
#endif
#ifdef MSC_VER
    return _byteswap_ulong(x);
#endif
    return (x >> 24) |
          ((x >>  8) & 0x0000FF00) |
          ((x <<  8) & 0x00FF0000) |
           (x << 24);
  }
#endif
}
void MD5::processBlock(const void* data)
{
  uint32_t a = m_hash[0];
  uint32_t b = m_hash[1];
  uint32_t c = m_hash[2];
  uint32_t d = m_hash[3];
  const uint32_t* words = (uint32_t*) data;
#if defined(__BYTE_ORDER) && (__BYTE_ORDER != 0) && (__BYTE_ORDER == __BIG_ENDIAN)
#define LITTLEENDIAN(x) swap(x)
#else
#define LITTLEENDIAN(x) (x)
#endif
  uint32_t word0  = LITTLEENDIAN(words[ 0]);
  a = rotate(a + f1(b,c,d) + word0  + 0xd76aa478,  7) + b;
  uint32_t word1  = LITTLEENDIAN(words[ 1]);
  d = rotate(d + f1(a,b,c) + word1  + 0xe8c7b756, 12) + a;
  uint32_t word2  = LITTLEENDIAN(words[ 2]);
  c = rotate(c + f1(d,a,b) + word2  + 0x242070db, 17) + d;
  uint32_t word3  = LITTLEENDIAN(words[ 3]);
  b = rotate(b + f1(c,d,a) + word3  + 0xc1bdceee, 22) + c;
  uint32_t word4  = LITTLEENDIAN(words[ 4]);
  a = rotate(a + f1(b,c,d) + word4  + 0xf57c0faf,  7) + b;
  uint32_t word5  = LITTLEENDIAN(words[ 5]);
  d = rotate(d + f1(a,b,c) + word5  + 0x4787c62a, 12) + a;
  uint32_t word6  = LITTLEENDIAN(words[ 6]);
  c = rotate(c + f1(d,a,b) + word6  + 0xa8304613, 17) + d;
  uint32_t word7  = LITTLEENDIAN(words[ 7]);
  b = rotate(b + f1(c,d,a) + word7  + 0xfd469501, 22) + c;
  uint32_t word8  = LITTLEENDIAN(words[ 8]);
  a = rotate(a + f1(b,c,d) + word8  + 0x698098d8,  7) + b;
  uint32_t word9  = LITTLEENDIAN(words[ 9]);
  d = rotate(d + f1(a,b,c) + word9  + 0x8b44f7af, 12) + a;
  uint32_t word10 = LITTLEENDIAN(words[10]);
  c = rotate(c + f1(d,a,b) + word10 + 0xffff5bb1, 17) + d;
  uint32_t word11 = LITTLEENDIAN(words[11]);
  b = rotate(b + f1(c,d,a) + word11 + 0x895cd7be, 22) + c;
  uint32_t word12 = LITTLEENDIAN(words[12]);
  a = rotate(a + f1(b,c,d) + word12 + 0x6b901122,  7) + b;
  uint32_t word13 = LITTLEENDIAN(words[13]);
  d = rotate(d + f1(a,b,c) + word13 + 0xfd987193, 12) + a;
  uint32_t word14 = LITTLEENDIAN(words[14]);
  c = rotate(c + f1(d,a,b) + word14 + 0xa679438e, 17) + d;
  uint32_t word15 = LITTLEENDIAN(words[15]);
  b = rotate(b + f1(c,d,a) + word15 + 0x49b40821, 22) + c;
  a = rotate(a + f2(b,c,d) + word1  + 0xf61e2562,  5) + b;
  d = rotate(d + f2(a,b,c) + word6  + 0xc040b340,  9) + a;
  c = rotate(c + f2(d,a,b) + word11 + 0x265e5a51, 14) + d;
  b = rotate(b + f2(c,d,a) + word0  + 0xe9b6c7aa, 20) + c;
  a = rotate(a + f2(b,c,d) + word5  + 0xd62f105d,  5) + b;
  d = rotate(d + f2(a,b,c) + word10 + 0x02441453,  9) + a;
  c = rotate(c + f2(d,a,b) + word15 + 0xd8a1e681, 14) + d;
  b = rotate(b + f2(c,d,a) + word4  + 0xe7d3fbc8, 20) + c;
  a = rotate(a + f2(b,c,d) + word9  + 0x21e1cde6,  5) + b;
  d = rotate(d + f2(a,b,c) + word14 + 0xc33707d6,  9) + a;
  c = rotate(c + f2(d,a,b) + word3  + 0xf4d50d87, 14) + d;
  b = rotate(b + f2(c,d,a) + word8  + 0x455a14ed, 20) + c;
  a = rotate(a + f2(b,c,d) + word13 + 0xa9e3e905,  5) + b;
  d = rotate(d + f2(a,b,c) + word2  + 0xfcefa3f8,  9) + a;
  c = rotate(c + f2(d,a,b) + word7  + 0x676f02d9, 14) + d;
  b = rotate(b + f2(c,d,a) + word12 + 0x8d2a4c8a, 20) + c;
  a = rotate(a + f3(b,c,d) + word5  + 0xfffa3942,  4) + b;
  d = rotate(d + f3(a,b,c) + word8  + 0x8771f681, 11) + a;
  c = rotate(c + f3(d,a,b) + word11 + 0x6d9d6122, 16) + d;
  b = rotate(b + f3(c,d,a) + word14 + 0xfde5380c, 23) + c;
  a = rotate(a + f3(b,c,d) + word1  + 0xa4beea44,  4) + b;
  d = rotate(d + f3(a,b,c) + word4  + 0x4bdecfa9, 11) + a;
  c = rotate(c + f3(d,a,b) + word7  + 0xf6bb4b60, 16) + d;
  b = rotate(b + f3(c,d,a) + word10 + 0xbebfbc70, 23) + c;
  a = rotate(a + f3(b,c,d) + word13 + 0x289b7ec6,  4) + b;
  d = rotate(d + f3(a,b,c) + word0  + 0xeaa127fa, 11) + a;
  c = rotate(c + f3(d,a,b) + word3  + 0xd4ef3085, 16) + d;
  b = rotate(b + f3(c,d,a) + word6  + 0x04881d05, 23) + c;
  a = rotate(a + f3(b,c,d) + word9  + 0xd9d4d039,  4) + b;
  d = rotate(d + f3(a,b,c) + word12 + 0xe6db99e5, 11) + a;
  c = rotate(c + f3(d,a,b) + word15 + 0x1fa27cf8, 16) + d;
  b = rotate(b + f3(c,d,a) + word2  + 0xc4ac5665, 23) + c;
  a = rotate(a + f4(b,c,d) + word0  + 0xf4292244,  6) + b;
  d = rotate(d + f4(a,b,c) + word7  + 0x432aff97, 10) + a;
  c = rotate(c + f4(d,a,b) + word14 + 0xab9423a7, 15) + d;
  b = rotate(b + f4(c,d,a) + word5  + 0xfc93a039, 21) + c;
  a = rotate(a + f4(b,c,d) + word12 + 0x655b59c3,  6) + b;
  d = rotate(d + f4(a,b,c) + word3  + 0x8f0ccc92, 10) + a;
  c = rotate(c + f4(d,a,b) + word10 + 0xffeff47d, 15) + d;
  b = rotate(b + f4(c,d,a) + word1  + 0x85845dd1, 21) + c;
  a = rotate(a + f4(b,c,d) + word8  + 0x6fa87e4f,  6) + b;
  d = rotate(d + f4(a,b,c) + word15 + 0xfe2ce6e0, 10) + a;
  c = rotate(c + f4(d,a,b) + word6  + 0xa3014314, 15) + d;
  b = rotate(b + f4(c,d,a) + word13 + 0x4e0811a1, 21) + c;
  a = rotate(a + f4(b,c,d) + word4  + 0xf7537e82,  6) + b;
  d = rotate(d + f4(a,b,c) + word11 + 0xbd3af235, 10) + a;
  c = rotate(c + f4(d,a,b) + word2  + 0x2ad7d2bb, 15) + d;
  b = rotate(b + f4(c,d,a) + word9  + 0xeb86d391, 21) + c;
  m_hash[0] += a;
  m_hash[1] += b;
  m_hash[2] += c;
  m_hash[3] += d;
}
void MD5::add(const void* data, size_t numBytes)
{
  const uint8_t* current = (const uint8_t*) data;
  if (m_bufferSize > 0)
  {
    while (numBytes > 0 && m_bufferSize < BlockSize)
    {
      m_buffer[m_bufferSize++] = *current++;
      numBytes--;
    }
  }
  if (m_bufferSize == BlockSize)
  {
    processBlock(m_buffer);
    m_numBytes  += BlockSize;
    m_bufferSize = 0;
  }
  if (numBytes == 0)
    return;
  while (numBytes >= BlockSize)
  {
    processBlock(current);
    current    += BlockSize;
    m_numBytes += BlockSize;
    numBytes   -= BlockSize;
  }
  while (numBytes > 0)
  {
    m_buffer[m_bufferSize++] = *current++;
    numBytes--;
  }
}
void MD5::processBuffer()
{
  size_t paddedLength = m_bufferSize * 8;
  paddedLength++;
  size_t lower11Bits = paddedLength & 511;
  if (lower11Bits <= 448)
    paddedLength +=       448 - lower11Bits;
  else
    paddedLength += 512 + 448 - lower11Bits;
  paddedLength /= 8;
  unsigned char extra[BlockSize];
  if (m_bufferSize < BlockSize)
    m_buffer[m_bufferSize] = 128;
  else
    extra[0] = 128;
  size_t i;
  for (i = m_bufferSize + 1; i < BlockSize; i++)
    m_buffer[i] = 0;
  for (; i < paddedLength; i++)
    extra[i - BlockSize] = 0;
  uint64_t msgBits = 8 * (m_numBytes + m_bufferSize);
  unsigned char* addLength;
  if (paddedLength < BlockSize)
    addLength = m_buffer + paddedLength;
  else
    addLength = extra + paddedLength - BlockSize;
  *addLength++ = msgBits & 0xFF; msgBits >>= 8;
  *addLength++ = msgBits & 0xFF; msgBits >>= 8;
  *addLength++ = msgBits & 0xFF; msgBits >>= 8;
  *addLength++ = msgBits & 0xFF; msgBits >>= 8;
  *addLength++ = msgBits & 0xFF; msgBits >>= 8;
  *addLength++ = msgBits & 0xFF; msgBits >>= 8;
  *addLength++ = msgBits & 0xFF; msgBits >>= 8;
  *addLength++ = msgBits & 0xFF;
  processBlock(m_buffer);
  if (paddedLength > BlockSize)
    processBlock(extra);
}
std::string MD5::getHash()
{
  unsigned char rawHash[HashBytes];
  getHash(rawHash);
  std::string result;
  result.reserve(2 * HashBytes);
  for (int i = 0; i < HashBytes; i++)
  {
    static const char dec2hex[16+1] = "0123456789ABCDEF";
    result += dec2hex[(rawHash[i] >> 4) & 15];
    result += dec2hex[ rawHash[i]       & 15];
  }
  return result;
}
void MD5::getHash(unsigned char buffer[MD5::HashBytes])
{
  uint32_t oldHash[HashValues];
  for (int i = 0; i < HashValues; i++)
    oldHash[i] = m_hash[i];
  processBuffer();
  unsigned char* current = buffer;
  for (int i = 0; i < HashValues; i++)
  {
    *current++ =  m_hash[i]        & 0xFF;
    *current++ = (m_hash[i] >>  8) & 0xFF;
    *current++ = (m_hash[i] >> 16) & 0xFF;
    *current++ = (m_hash[i] >> 24) & 0xFF;
    m_hash[i] = oldHash[i];
  }
}
#define BLAKE3_VERSION_STRING "1.0.0"
#define BLAKE3_KEY_LEN 32
#define BLAKE3_OUT_LEN 32
#define BLAKE3_BLOCK_LEN 64
#define BLAKE3_CHUNK_LEN 1024
#define BLAKE3_MAX_DEPTH 54
typedef struct {
  uint32_t cv[8];
  uint64_t chunk_counter;
  uint8_t buf[BLAKE3_BLOCK_LEN];
  uint8_t buf_len;
  uint8_t blocks_compressed;
  uint8_t flags;
} blake3_chunk_state;
typedef struct {
  uint32_t key[8];
  blake3_chunk_state chunk;
  uint8_t cv_stack_len;
  uint8_t cv_stack[(BLAKE3_MAX_DEPTH + 1) * BLAKE3_OUT_LEN];
} blake3_hasher;
const char *blake3_version(void);
void blake3_hasher_init(blake3_hasher *self);
void blake3_hasher_update(blake3_hasher *self, const void *input,
                          size_t input_len);
void blake3_hasher_finalize(const blake3_hasher *self, uint8_t *out,
                            size_t out_len);
void blake3_hasher_finalize_seek(const blake3_hasher *self, uint64_t seek,
                                 uint8_t *out, size_t out_len);
enum blake3_flags {
  CHUNK_START         = 1 << 0,
  CHUNK_END           = 1 << 1,
  PARENT              = 1 << 2,
  ROOT                = 1 << 3,
  KEYED_HASH          = 1 << 4,
  DERIVE_KEY_CONTEXT  = 1 << 5,
  DERIVE_KEY_MATERIAL = 1 << 6,
};
#define MAX_SIMD_DEGREE 1
#define MAX_SIMD_DEGREE_OR_2 (MAX_SIMD_DEGREE > 2 ? MAX_SIMD_DEGREE : 2)
static const uint32_t IV[8] = {0x6A09E667UL, 0xBB67AE85UL, 0x3C6EF372UL,
                               0xA54FF53AUL, 0x510E527FUL, 0x9B05688CUL,
                               0x1F83D9ABUL, 0x5BE0CD19UL};
static const uint8_t MSG_SCHEDULE[7][16] = {
    {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15},
    {2, 6, 3, 10, 7, 0, 4, 13, 1, 11, 12, 5, 9, 14, 15, 8},
    {3, 4, 10, 12, 13, 2, 7, 14, 6, 5, 9, 0, 11, 15, 8, 1},
    {10, 7, 12, 9, 14, 3, 13, 15, 4, 0, 11, 2, 5, 8, 1, 6},
    {12, 13, 9, 11, 15, 10, 14, 8, 7, 2, 5, 3, 0, 1, 6, 4},
    {9, 14, 11, 5, 8, 12, 15, 1, 13, 3, 0, 10, 2, 6, 4, 7},
    {11, 15, 5, 0, 1, 9, 8, 6, 14, 10, 2, 12, 3, 4, 7, 13},
};
static unsigned int highest_one(uint64_t x) {
#if defined(__GNUC__) || defined(__clang__)
  return 63 ^ __builtin_clzll(x);
#elif defined(_MSC_VER) && defined(IS_X86_64)
  unsigned long index;
  _BitScanReverse64(&index, x);
  return index;
#elif defined(_MSC_VER) && defined(IS_X86_32)
  if(x >> 32) {
    unsigned long index;
    _BitScanReverse(&index, x >> 32);
    return 32 + index;
  } else {
    unsigned long index;
    _BitScanReverse(&index, x);
    return index;
  }
#else
  unsigned int c = 0;
  if(x & 0xffffffff00000000ULL) { x >>= 32; c += 32; }
  if(x & 0x00000000ffff0000ULL) { x >>= 16; c += 16; }
  if(x & 0x000000000000ff00ULL) { x >>=  8; c +=  8; }
  if(x & 0x00000000000000f0ULL) { x >>=  4; c +=  4; }
  if(x & 0x000000000000000cULL) { x >>=  2; c +=  2; }
  if(x & 0x0000000000000002ULL) {           c +=  1; }
  return c;
#endif
}
INLINE_divsuf unsigned int popcnt(uint64_t x) {
#if defined(__GNUC__) || defined(__clang__)
  return __builtin_popcountll(x);
#else
  unsigned int count = 0;
  while (x != 0) {
    count += 1;
    x &= x - 1;
  }
  return count;
#endif
}
INLINE_divsuf uint64_t round_down_to_power_of_2(uint64_t x) {
  return 1ULL << highest_one(x | 1);
}
INLINE_divsuf uint32_t counter_low(uint64_t counter) { return (uint32_t)counter; }
INLINE_divsuf uint32_t counter_high(uint64_t counter) {
  return (uint32_t)(counter >> 32);
}
INLINE_divsuf uint32_t load32(const void *src) {
  const uint8_t *p = (const uint8_t *)src;
  return ((uint32_t)(p[0]) << 0) | ((uint32_t)(p[1]) << 8) |
         ((uint32_t)(p[2]) << 16) | ((uint32_t)(p[3]) << 24);
}
INLINE_divsuf void load_key_words(const uint8_t key[BLAKE3_KEY_LEN],
                           uint32_t key_words[8]) {
  key_words[0] = load32(&key[0 * 4]);
  key_words[1] = load32(&key[1 * 4]);
  key_words[2] = load32(&key[2 * 4]);
  key_words[3] = load32(&key[3 * 4]);
  key_words[4] = load32(&key[4 * 4]);
  key_words[5] = load32(&key[5 * 4]);
  key_words[6] = load32(&key[6 * 4]);
  key_words[7] = load32(&key[7 * 4]);
}
INLINE_divsuf void store32(void *dst, uint32_t w) {
  uint8_t *p = (uint8_t *)dst;
  p[0] = (uint8_t)(w >> 0);
  p[1] = (uint8_t)(w >> 8);
  p[2] = (uint8_t)(w >> 16);
  p[3] = (uint8_t)(w >> 24);
}
INLINE_divsuf void store_cv_words(uint8_t bytes_out[32], uint32_t cv_words[8]) {
  store32(&bytes_out[0 * 4], cv_words[0]);
  store32(&bytes_out[1 * 4], cv_words[1]);
  store32(&bytes_out[2 * 4], cv_words[2]);
  store32(&bytes_out[3 * 4], cv_words[3]);
  store32(&bytes_out[4 * 4], cv_words[4]);
  store32(&bytes_out[5 * 4], cv_words[5]);
  store32(&bytes_out[6 * 4], cv_words[6]);
  store32(&bytes_out[7 * 4], cv_words[7]);
}
void blake3_compress_in_place(uint32_t cv[8],
                              const uint8_t block[BLAKE3_BLOCK_LEN],
                              uint8_t block_len, uint64_t counter,
                              uint8_t flags);
void blake3_compress_xof(const uint32_t cv[8],
                         const uint8_t block[BLAKE3_BLOCK_LEN],
                         uint8_t block_len, uint64_t counter, uint8_t flags,
                         uint8_t out[64]);
void blake3_hash_many(const uint8_t *const *inputs, size_t num_inputs,
                      size_t blocks, const uint32_t key[8], uint64_t counter,
                      bool increment_counter, uint8_t flags,
                      uint8_t flags_start, uint8_t flags_end, uint8_t *out);
size_t blake3_simd_degree(void);
void blake3_compress_in_place_portable(uint32_t cv[8],
                                       const uint8_t block[BLAKE3_BLOCK_LEN],
                                       uint8_t block_len, uint64_t counter,
                                       uint8_t flags);
void blake3_compress_xof_portable(const uint32_t cv[8],
                                  const uint8_t block[BLAKE3_BLOCK_LEN],
                                  uint8_t block_len, uint64_t counter,
                                  uint8_t flags, uint8_t out[64]);
void blake3_hash_many_portable(const uint8_t *const *inputs, size_t num_inputs,
                               size_t blocks, const uint32_t key[8],
                               uint64_t counter, bool increment_counter,
                               uint8_t flags, uint8_t flags_start,
                               uint8_t flags_end, uint8_t *out);
const char *blake3_version(void) { return BLAKE3_VERSION_STRING; }
INLINE_divsuf void chunk_state_init(blake3_chunk_state *self, const uint32_t key[8],
                             uint8_t flags) {
  memcpy(self->cv, key, BLAKE3_KEY_LEN);
  self->chunk_counter = 0;
  memset(self->buf, 0, BLAKE3_BLOCK_LEN);
  self->buf_len = 0;
  self->blocks_compressed = 0;
  self->flags = flags;
}
INLINE_divsuf void chunk_state_reset(blake3_chunk_state *self, const uint32_t key[8],
                              uint64_t chunk_counter) {
  memcpy(self->cv, key, BLAKE3_KEY_LEN);
  self->chunk_counter = chunk_counter;
  self->blocks_compressed = 0;
  memset(self->buf, 0, BLAKE3_BLOCK_LEN);
  self->buf_len = 0;
}
INLINE_divsuf size_t chunk_state_len(const blake3_chunk_state *self) {
  return (BLAKE3_BLOCK_LEN * (size_t)self->blocks_compressed) +
         ((size_t)self->buf_len);
}
INLINE_divsuf size_t chunk_state_fill_buf(blake3_chunk_state *self,
                                   const uint8_t *input, size_t input_len) {
  size_t take = BLAKE3_BLOCK_LEN - ((size_t)self->buf_len);
  if (take > input_len) {
    take = input_len;
  }
  uint8_t *dest = self->buf + ((size_t)self->buf_len);
  memcpy(dest, input, take);
  self->buf_len += (uint8_t)take;
  return take;
}
INLINE_divsuf uint8_t chunk_state_maybe_start_flag(const blake3_chunk_state *self) {
  if (self->blocks_compressed == 0) {
    return CHUNK_START;
  } else {
    return 0;
  }
}
typedef struct {
  uint32_t input_cv[8];
  uint64_t counter;
  uint8_t block[BLAKE3_BLOCK_LEN];
  uint8_t block_len;
  uint8_t flags;
} output_t;
INLINE_divsuf output_t make_output(const uint32_t input_cv[8],
                            const uint8_t block[BLAKE3_BLOCK_LEN],
                            uint8_t block_len, uint64_t counter,
                            uint8_t flags) {
  output_t ret;
  memcpy(ret.input_cv, input_cv, 32);
  memcpy(ret.block, block, BLAKE3_BLOCK_LEN);
  ret.block_len = block_len;
  ret.counter = counter;
  ret.flags = flags;
  return ret;
}
INLINE_divsuf void output_chaining_value(const output_t *self, uint8_t cv[32]) {
  uint32_t cv_words[8];
  memcpy(cv_words, self->input_cv, 32);
  blake3_compress_in_place(cv_words, self->block, self->block_len,
                           self->counter, self->flags);
  store_cv_words(cv, cv_words);
}
INLINE_divsuf void output_root_bytes(const output_t *self, uint64_t seek, uint8_t *out,
                              size_t out_len) {
  uint64_t output_block_counter = seek / 64;
  size_t offset_within_block = seek % 64;
  uint8_t wide_buf[64];
  while (out_len > 0) {
    blake3_compress_xof(self->input_cv, self->block, self->block_len,
                        output_block_counter, self->flags | ROOT, wide_buf);
    size_t available_bytes = 64 - offset_within_block;
    size_t memcpy_len;
    if (out_len > available_bytes) {
      memcpy_len = available_bytes;
    } else {
      memcpy_len = out_len;
    }
    memcpy(out, wide_buf + offset_within_block, memcpy_len);
    out += memcpy_len;
    out_len -= memcpy_len;
    output_block_counter += 1;
    offset_within_block = 0;
  }
}
INLINE_divsuf void chunk_state_update(blake3_chunk_state *self, const uint8_t *input,
                               size_t input_len) {
  if (self->buf_len > 0) {
    size_t take = chunk_state_fill_buf(self, input, input_len);
    input += take;
    input_len -= take;
    if (input_len > 0) {
      blake3_compress_in_place(
          self->cv, self->buf, BLAKE3_BLOCK_LEN, self->chunk_counter,
          self->flags | chunk_state_maybe_start_flag(self));
      self->blocks_compressed += 1;
      self->buf_len = 0;
      memset(self->buf, 0, BLAKE3_BLOCK_LEN);
    }
  }
  while (input_len > BLAKE3_BLOCK_LEN) {
    blake3_compress_in_place(self->cv, input, BLAKE3_BLOCK_LEN,
                             self->chunk_counter,
                             self->flags | chunk_state_maybe_start_flag(self));
    self->blocks_compressed += 1;
    input += BLAKE3_BLOCK_LEN;
    input_len -= BLAKE3_BLOCK_LEN;
  }
  size_t take = chunk_state_fill_buf(self, input, input_len);
  input += take;
  input_len -= take;
}
INLINE_divsuf output_t chunk_state_output(const blake3_chunk_state *self) {
  uint8_t block_flags =
      self->flags | chunk_state_maybe_start_flag(self) | CHUNK_END;
  return make_output(self->cv, self->buf, self->buf_len, self->chunk_counter,
                     block_flags);
}
INLINE_divsuf output_t parent_output(const uint8_t block[BLAKE3_BLOCK_LEN],
                              const uint32_t key[8], uint8_t flags) {
  return make_output(key, block, BLAKE3_BLOCK_LEN, 0, flags | PARENT);
}
INLINE_divsuf size_t left_len(size_t content_len) {
  size_t full_chunks = (content_len - 1) / BLAKE3_CHUNK_LEN;
  return round_down_to_power_of_2(full_chunks) * BLAKE3_CHUNK_LEN;
}
INLINE_divsuf size_t compress_chunks_parallel(const uint8_t *input, size_t input_len,
                                       const uint32_t key[8],
                                       uint64_t chunk_counter, uint8_t flags,
                                       uint8_t *out) {
#if defined(BLAKE3_TESTING)
  assert(0 < input_len);
  assert(input_len <= MAX_SIMD_DEGREE * BLAKE3_CHUNK_LEN);
#endif
  const uint8_t *chunks_array[MAX_SIMD_DEGREE];
  size_t input_position = 0;
  size_t chunks_array_len = 0;
  while (input_len - input_position >= BLAKE3_CHUNK_LEN) {
    chunks_array[chunks_array_len] = &input[input_position];
    input_position += BLAKE3_CHUNK_LEN;
    chunks_array_len += 1;
  }
  blake3_hash_many(chunks_array, chunks_array_len,
                   BLAKE3_CHUNK_LEN / BLAKE3_BLOCK_LEN, key, chunk_counter,
                   true, flags, CHUNK_START, CHUNK_END, out);
  if (input_len > input_position) {
    uint64_t counter = chunk_counter + (uint64_t)chunks_array_len;
    blake3_chunk_state chunk_state;
    chunk_state_init(&chunk_state, key, flags);
    chunk_state.chunk_counter = counter;
    chunk_state_update(&chunk_state, &input[input_position],
                       input_len - input_position);
    output_t output = chunk_state_output(&chunk_state);
    output_chaining_value(&output, &out[chunks_array_len * BLAKE3_OUT_LEN]);
    return chunks_array_len + 1;
  } else {
    return chunks_array_len;
  }
}
INLINE_divsuf size_t compress_parents_parallel(const uint8_t *child_chaining_values,
                                        size_t num_chaining_values,
                                        const uint32_t key[8], uint8_t flags,
                                        uint8_t *out) {
#if defined(BLAKE3_TESTING)
  assert(2 <= num_chaining_values);
  assert(num_chaining_values <= 2 * MAX_SIMD_DEGREE_OR_2);
#endif
  const uint8_t *parents_array[MAX_SIMD_DEGREE_OR_2];
  size_t parents_array_len = 0;
  while (num_chaining_values - (2 * parents_array_len) >= 2) {
    parents_array[parents_array_len] =
        &child_chaining_values[2 * parents_array_len * BLAKE3_OUT_LEN];
    parents_array_len += 1;
  }
  blake3_hash_many(parents_array, parents_array_len, 1, key,
                   0, 
                   false, flags | PARENT,
                   0, 
                   0, 
                   out);
  if (num_chaining_values > 2 * parents_array_len) {
	  memcpy(&out+(parents_array_len * BLAKE3_OUT_LEN),
           &child_chaining_values+(2 * parents_array_len * BLAKE3_OUT_LEN),
           BLAKE3_OUT_LEN);
    return parents_array_len + 1;
  } else {
    return parents_array_len;
  }
}
static size_t blake3_compress_subtree_wide(const uint8_t *input,
                                           size_t input_len,
                                           const uint32_t key[8],
                                           uint64_t chunk_counter,
                                           uint8_t flags, uint8_t *out) {
  if (input_len <= blake3_simd_degree() * BLAKE3_CHUNK_LEN) {
    return compress_chunks_parallel(input, input_len, key, chunk_counter, flags,
                                    out);
  }
  size_t left_input_len = left_len(input_len);
  size_t right_input_len = input_len - left_input_len;
  const uint8_t *right_input = &input[left_input_len];
  uint64_t right_chunk_counter =
      chunk_counter + (uint64_t)(left_input_len / BLAKE3_CHUNK_LEN);
  uint8_t cv_array[2 * MAX_SIMD_DEGREE_OR_2 * BLAKE3_OUT_LEN];
  size_t degree = blake3_simd_degree();
  if (left_input_len > BLAKE3_CHUNK_LEN && degree == 1) {
    degree = 2;
  }
  uint8_t *right_cvs = &cv_array[degree * BLAKE3_OUT_LEN];
  size_t left_n = blake3_compress_subtree_wide(input, left_input_len, key,
                                               chunk_counter, flags, cv_array);
  size_t right_n = blake3_compress_subtree_wide(
      right_input, right_input_len, key, right_chunk_counter, flags, right_cvs);
  if (left_n == 1) {
    memcpy(out, cv_array, 2 * BLAKE3_OUT_LEN);
    return 2;
  }
  size_t num_chaining_values = left_n + right_n;
  return compress_parents_parallel(cv_array, num_chaining_values, key, flags,
                                   out);
}
INLINE_divsuf void compress_subtree_to_parent_node(
    const uint8_t *input, size_t input_len, const uint32_t key[8],
    uint64_t chunk_counter, uint8_t flags, uint8_t out[2 * BLAKE3_OUT_LEN]) {
#if defined(BLAKE3_TESTING)
  assert(input_len > BLAKE3_CHUNK_LEN);
#endif
  uint8_t cv_array[MAX_SIMD_DEGREE_OR_2 * BLAKE3_OUT_LEN];
  size_t num_cvs = blake3_compress_subtree_wide(input, input_len, key,
                                                chunk_counter, flags, cv_array);
  uint8_t out_array[MAX_SIMD_DEGREE_OR_2 * BLAKE3_OUT_LEN ];
  while (num_cvs > 2) {
    num_cvs =
        compress_parents_parallel(cv_array, num_cvs, key, flags, out_array);
    memcpy(cv_array, out_array, num_cvs * BLAKE3_OUT_LEN);
  }
  memcpy(out, cv_array, 2 * BLAKE3_OUT_LEN);
}
INLINE_divsuf void hasher_init_base(blake3_hasher *self, const uint32_t key[8],
                             uint8_t flags) {
  memcpy(self->key, key, BLAKE3_KEY_LEN);
  chunk_state_init(&self->chunk, key, flags);
  self->cv_stack_len = 0;
}
void blake3_hasher_init(blake3_hasher *self) { hasher_init_base(self, IV, 0); }
INLINE_divsuf void hasher_merge_cv_stack(blake3_hasher *self, uint64_t total_len) {
  size_t post_merge_stack_len = (size_t)popcnt(total_len);
  while (self->cv_stack_len > post_merge_stack_len) {
    uint8_t *parent_node =
        &self->cv_stack[(self->cv_stack_len - 2) * BLAKE3_OUT_LEN];
    output_t output = parent_output(parent_node, self->key, self->chunk.flags);
    output_chaining_value(&output, parent_node);
    self->cv_stack_len -= 1;
  }
}
INLINE_divsuf void hasher_push_cv(blake3_hasher *self, uint8_t new_cv[BLAKE3_OUT_LEN],
                           uint64_t chunk_counter) {
  hasher_merge_cv_stack(self, chunk_counter);
  memcpy(&self->cv_stack[self->cv_stack_len * BLAKE3_OUT_LEN], new_cv,
         BLAKE3_OUT_LEN);
  self->cv_stack_len += 1;
}
void blake3_hasher_update(blake3_hasher *self, const void *input,
                          size_t input_len) {
  if (input_len == 0) {
    return;
  }
  const uint8_t *input_bytes = (const uint8_t *)input;
  if (chunk_state_len(&self->chunk) > 0) {
    size_t take = BLAKE3_CHUNK_LEN - chunk_state_len(&self->chunk);
    if (take > input_len) {
      take = input_len;
    }
    chunk_state_update(&self->chunk, input_bytes, take);
    input_bytes += take;
    input_len -= take;
    if (input_len > 0) {
      output_t output = chunk_state_output(&self->chunk);
      uint8_t chunk_cv[32];
      output_chaining_value(&output, chunk_cv);
      hasher_push_cv(self, chunk_cv, self->chunk.chunk_counter);
      chunk_state_reset(&self->chunk, self->key, self->chunk.chunk_counter + 1);
    } else {
      return;
    }
  }
  while (input_len > BLAKE3_CHUNK_LEN) {
    size_t subtree_len = round_down_to_power_of_2(input_len);
    uint64_t count_so_far = self->chunk.chunk_counter * BLAKE3_CHUNK_LEN;
    while ((((uint64_t)(subtree_len - 1)) & count_so_far) != 0) {
      subtree_len /= 2;
    }
    uint64_t subtree_chunks = subtree_len / BLAKE3_CHUNK_LEN;
    if (subtree_len <= BLAKE3_CHUNK_LEN) {
      blake3_chunk_state chunk_state;
      chunk_state_init(&chunk_state, self->key, self->chunk.flags);
      chunk_state.chunk_counter = self->chunk.chunk_counter;
      chunk_state_update(&chunk_state, input_bytes, subtree_len);
      output_t output = chunk_state_output(&chunk_state);
      uint8_t cv[BLAKE3_OUT_LEN];
      output_chaining_value(&output, cv);
      hasher_push_cv(self, cv, chunk_state.chunk_counter);
    } else {
      uint8_t cv_pair[2 * BLAKE3_OUT_LEN];
      compress_subtree_to_parent_node(input_bytes, subtree_len, self->key,
                                      self->chunk.chunk_counter,
                                      self->chunk.flags, cv_pair);
      hasher_push_cv(self, cv_pair, self->chunk.chunk_counter);
      hasher_push_cv(self, &cv_pair[BLAKE3_OUT_LEN],
                     self->chunk.chunk_counter + (subtree_chunks / 2));
    }
    self->chunk.chunk_counter += subtree_chunks;
    input_bytes += subtree_len;
    input_len -= subtree_len;
  }
  if (input_len > 0) {
    chunk_state_update(&self->chunk, input_bytes, input_len);
    hasher_merge_cv_stack(self, self->chunk.chunk_counter);
  }
}
void blake3_hasher_finalize(const blake3_hasher *self, uint8_t *out,
                            size_t out_len) {
  blake3_hasher_finalize_seek(self, 0, out, out_len);
}
void blake3_hasher_finalize_seek(const blake3_hasher *self, uint64_t seek,
                                 uint8_t *out, size_t out_len) {
  if (out_len == 0) {
    return;
  }
  if (self->cv_stack_len == 0) {
    output_t output = chunk_state_output(&self->chunk);
    output_root_bytes(&output, seek, out, out_len);
    return;
  }
  output_t output;
  size_t cvs_remaining;
  if (chunk_state_len(&self->chunk) > 0) {
    cvs_remaining = self->cv_stack_len;
    output = chunk_state_output(&self->chunk);
  } else {
    cvs_remaining = self->cv_stack_len - 2;
    output = parent_output(&self->cv_stack[cvs_remaining * 32], self->key,
                           self->chunk.flags);
  }
  while (cvs_remaining > 0) {
    cvs_remaining -= 1;
    uint8_t parent_block[BLAKE3_BLOCK_LEN];
    memcpy(parent_block, &self->cv_stack[cvs_remaining * 32], 32);
    output_chaining_value(&output, &parent_block[32]);
    output = parent_output(parent_block, self->key, self->chunk.flags);
  }
  output_root_bytes(&output, seek, out, out_len);
}
#define MAYBE_UNUSED(x) (void)((x))
#if defined(IS_X86)
static uint64_t xgetbv() {
#if defined(_MSC_VER)
  return _xgetbv(0);
#else
  uint32_t eax = 0, edx = 0;
  __asm__ __volatile__("xgetbv\n" : "=a"(eax), "=d"(edx) : "c"(0));
  return ((uint64_t)edx << 32) | eax;
#endif
}
static void cpuid(uint32_t out[4], uint32_t id) {
#if defined(_MSC_VER)
  __cpuid((int *)out, id);
#elif defined(__i386__) || defined(_M_IX86)
  __asm__ __volatile__("movl %%ebx, %1\n"
                       "cpuid\n"
                       "xchgl %1, %%ebx\n"
                       : "=a"(out[0]), "=r"(out[1]), "=c"(out[2]), "=d"(out[3])
                       : "a"(id));
#else
  __asm__ __volatile__("cpuid\n"
                       : "=a"(out[0]), "=b"(out[1]), "=c"(out[2]), "=d"(out[3])
                       : "a"(id));
#endif
}
static void cpuidex(uint32_t out[4], uint32_t id, uint32_t sid) {
#if defined(_MSC_VER)
  __cpuidex((int *)out, id, sid);
#elif defined(__i386__) || defined(_M_IX86)
  __asm__ __volatile__("movl %%ebx, %1\n"
                       "cpuid\n"
                       "xchgl %1, %%ebx\n"
                       : "=a"(out[0]), "=r"(out[1]), "=c"(out[2]), "=d"(out[3])
                       : "a"(id), "c"(sid));
#else
  __asm__ __volatile__("cpuid\n"
                       : "=a"(out[0]), "=b"(out[1]), "=c"(out[2]), "=d"(out[3])
                       : "a"(id), "c"(sid));
#endif
}
#endif
void blake3_compress_in_place(uint32_t cv[8],
                              const uint8_t block[BLAKE3_BLOCK_LEN],
                              uint8_t block_len, uint64_t counter,
                              uint8_t flags) {
  blake3_compress_in_place_portable(cv, block, block_len, counter, flags);
}
void blake3_compress_xof(const uint32_t cv[8],
                         const uint8_t block[BLAKE3_BLOCK_LEN],
                         uint8_t block_len, uint64_t counter, uint8_t flags,
                         uint8_t out[64]) {
  blake3_compress_xof_portable(cv, block, block_len, counter, flags, out);
}
void blake3_hash_many(const uint8_t *const *inputs, size_t num_inputs,
                      size_t blocks, const uint32_t key[8], uint64_t counter,
                      bool increment_counter, uint8_t flags,
                      uint8_t flags_start, uint8_t flags_end, uint8_t *out) {
  blake3_hash_many_portable(inputs, num_inputs, blocks, key, counter,
                            increment_counter, flags, flags_start, flags_end,
                            out);
}
size_t blake3_simd_degree(void) 
{
  return 1;
}
INLINE_divsuf uint32_t rotr32(uint32_t w, uint32_t c) {
  return (w >> c) | (w << (32 - c));
}
INLINE_divsuf void g(uint32_t *state, size_t a, size_t b, size_t c, size_t d,
              uint32_t x, uint32_t y) {
  state[a] = state[a] + state[b] + x;
  state[d] = rotr32(state[d] ^ state[a], 16);
  state[c] = state[c] + state[d];
  state[b] = rotr32(state[b] ^ state[c], 12);
  state[a] = state[a] + state[b] + y;
  state[d] = rotr32(state[d] ^ state[a], 8);
  state[c] = state[c] + state[d];
  state[b] = rotr32(state[b] ^ state[c], 7);
}
INLINE_divsuf void round_fn(uint32_t state[16], const uint32_t *msg, size_t round) {
  const uint8_t *schedule = MSG_SCHEDULE[round];
  g(state, 0, 4, 8, 12, msg[schedule[0]], msg[schedule[1]]);
  g(state, 1, 5, 9, 13, msg[schedule[2]], msg[schedule[3]]);
  g(state, 2, 6, 10, 14, msg[schedule[4]], msg[schedule[5]]);
  g(state, 3, 7, 11, 15, msg[schedule[6]], msg[schedule[7]]);
  g(state, 0, 5, 10, 15, msg[schedule[8]], msg[schedule[9]]);
  g(state, 1, 6, 11, 12, msg[schedule[10]], msg[schedule[11]]);
  g(state, 2, 7, 8, 13, msg[schedule[12]], msg[schedule[13]]);
  g(state, 3, 4, 9, 14, msg[schedule[14]], msg[schedule[15]]);
}
INLINE_divsuf void compress_pre(uint32_t state[16], const uint32_t cv[8],
                         const uint8_t block[BLAKE3_BLOCK_LEN],
                         uint8_t block_len, uint64_t counter, uint8_t flags) {
  uint32_t block_words[16];
  block_words[0] = load32(block + 4 * 0);
  block_words[1] = load32(block + 4 * 1);
  block_words[2] = load32(block + 4 * 2);
  block_words[3] = load32(block + 4 * 3);
  block_words[4] = load32(block + 4 * 4);
  block_words[5] = load32(block + 4 * 5);
  block_words[6] = load32(block + 4 * 6);
  block_words[7] = load32(block + 4 * 7);
  block_words[8] = load32(block + 4 * 8);
  block_words[9] = load32(block + 4 * 9);
  block_words[10] = load32(block + 4 * 10);
  block_words[11] = load32(block + 4 * 11);
  block_words[12] = load32(block + 4 * 12);
  block_words[13] = load32(block + 4 * 13);
  block_words[14] = load32(block + 4 * 14);
  block_words[15] = load32(block + 4 * 15);
  state[0] = cv[0];
  state[1] = cv[1];
  state[2] = cv[2];
  state[3] = cv[3];
  state[4] = cv[4];
  state[5] = cv[5];
  state[6] = cv[6];
  state[7] = cv[7];
  state[8] = IV[0];
  state[9] = IV[1];
  state[10] = IV[2];
  state[11] = IV[3];
  state[12] = counter_low(counter);
  state[13] = counter_high(counter);
  state[14] = (uint32_t)block_len;
  state[15] = (uint32_t)flags;
  round_fn(state, &block_words[0], 0);
  round_fn(state, &block_words[0], 1);
  round_fn(state, &block_words[0], 2);
  round_fn(state, &block_words[0], 3);
  round_fn(state, &block_words[0], 4);
  round_fn(state, &block_words[0], 5);
  round_fn(state, &block_words[0], 6);
}
void blake3_compress_in_place_portable(uint32_t cv[8],
                                       const uint8_t block[BLAKE3_BLOCK_LEN],
                                       uint8_t block_len, uint64_t counter,
                                       uint8_t flags) {
  uint32_t state[16];
  compress_pre(state, cv, block, block_len, counter, flags);
  cv[0] = state[0] ^ state[8];
  cv[1] = state[1] ^ state[9];
  cv[2] = state[2] ^ state[10];
  cv[3] = state[3] ^ state[11];
  cv[4] = state[4] ^ state[12];
  cv[5] = state[5] ^ state[13];
  cv[6] = state[6] ^ state[14];
  cv[7] = state[7] ^ state[15];
}
void blake3_compress_xof_portable(const uint32_t cv[8],
                                  const uint8_t block[BLAKE3_BLOCK_LEN],
                                  uint8_t block_len, uint64_t counter,
                                  uint8_t flags, uint8_t out[64]) {
  uint32_t state[16];
  compress_pre(state, cv, block, block_len, counter, flags);
  store32(&out[0 * 4], state[0] ^ state[8]);
  store32(&out[1 * 4], state[1] ^ state[9]);
  store32(&out[2 * 4], state[2] ^ state[10]);
  store32(&out[3 * 4], state[3] ^ state[11]);
  store32(&out[4 * 4], state[4] ^ state[12]);
  store32(&out[5 * 4], state[5] ^ state[13]);
  store32(&out[6 * 4], state[6] ^ state[14]);
  store32(&out[7 * 4], state[7] ^ state[15]);
  store32(&out[8 * 4], state[8] ^ cv[0]);
  store32(&out[9 * 4], state[9] ^ cv[1]);
  store32(&out[10 * 4], state[10] ^ cv[2]);
  store32(&out[11 * 4], state[11] ^ cv[3]);
  store32(&out[12 * 4], state[12] ^ cv[4]);
  store32(&out[13 * 4], state[13] ^ cv[5]);
  store32(&out[14 * 4], state[14] ^ cv[6]);
  store32(&out[15 * 4], state[15] ^ cv[7]);
}
INLINE_divsuf void hash_one_portable(const uint8_t *input, size_t blocks,
                              const uint32_t key[8], uint64_t counter,
                              uint8_t flags, uint8_t flags_start,
                              uint8_t flags_end, uint8_t out[BLAKE3_OUT_LEN]) {
  uint32_t cv[8];
  memcpy(cv, key, BLAKE3_KEY_LEN);
  uint8_t block_flags = flags | flags_start;
  while (blocks > 0) {
    if (blocks == 1) {
      block_flags |= flags_end;
    }
    blake3_compress_in_place_portable(cv, input, BLAKE3_BLOCK_LEN, counter,
                                      block_flags);
    input = &input[BLAKE3_BLOCK_LEN];
    blocks -= 1;
    block_flags = flags;
  }
  store_cv_words(out, cv);
}
void blake3_hash_many_portable(const uint8_t *const *inputs, size_t num_inputs,
                               size_t blocks, const uint32_t key[8],
                               uint64_t counter, bool increment_counter,
                               uint8_t flags, uint8_t flags_start,
                               uint8_t flags_end, uint8_t *out) {
  while (num_inputs > 0) {
    hash_one_portable(inputs[0], blocks, key, counter, flags, flags_start,
                      flags_end, out);
    if (increment_counter) {
      counter += 1;
    }
    inputs += 1;
    num_inputs -= 1;
    out = &out[BLAKE3_OUT_LEN];
  }
}
typedef signed char s8;
typedef unsigned char u8;
#if UINT_MAX >= 4294967295UL
typedef signed short s16;
typedef signed int s32;
typedef unsigned short u16;
typedef unsigned int u32;
#define ONE32   0xffffffffU
#else
typedef signed int s16;
typedef signed long s32;
typedef unsigned int u16;
typedef unsigned long u32;
#define ONE32   0xffffffffUL
#endif
#define ONE8    0xffU
#define ONE16   0xffffU
#define T8(x)   ((x) & ONE8)
#define T16(x)  ((x) & ONE16)
#define T32(x)  ((x) & ONE32)
#ifdef _MSC_VER
typedef unsigned __int64 u64;
typedef signed __int64 s64;
#define LL(v)   (v##i64)
#define ONE64   LL(0xffffffffffffffff)
#else  
typedef unsigned long long u64;
typedef signed long long s64;
#define LL(v)   (v##ULL)
#define ONE64   LL(0xffffffffffffffff)
#endif 
#define T64(x)  ((x) & ONE64)
#define ROTR64(v, n)   (((v) >> (n)) | T64((v) << (64 - (n))))
#define U8TO32_BIG(c)  (((u32)T8(*(c)) << 24) | ((u32)T8(*((c) + 1)) << 16) | ((u32)T8(*((c) + 2)) << 8) | ((u32)T8(*((c) + 3))))
#define U8TO32_LITTLE(c)  (((u32)T8(*(c))) | ((u32)T8(*((c) + 1)) << 8) | (u32)T8(*((c) + 2)) << 16) | ((u32)T8(*((c) + 3)) << 24))
#define U32TO8_BIG(c, v)    do { u32 x = (v); u8 *d = (c); d[0] = T8(x >> 24); d[1] = T8(x >> 16); d[2] = T8(x >> 8); d[3] = T8(x); } while (0)
#define U32TO8_LITTLE(c, v)    do { u32 x = (v); u8 *d = (c); d[0] = T8(x); d[1] = T8(x >> 8); d[2] = T8(x >> 16); d[3] = T8(x >> 24); } while (0)
#define ROTL32(v, n)   (T32((v) << (n)) | ((v) >> (32 - (n))))
#define DIGESTBYTES 64
#define DIGESTBITS  (8*DIGESTBYTES) 
#define WBLOCKBYTES 64
#define WBLOCKBITS  (8*WBLOCKBYTES) 
#define LENGTHBYTES 32
#define LENGTHBITS  (8*LENGTHBYTES) 
typedef struct NESSIEstruct {
	u8  bitLength[LENGTHBYTES]; 
	u8  buffer[WBLOCKBYTES];	
	int bufferBits;		        
	int bufferPos;		        
	u64 hash[DIGESTBYTES/8];    
} NESSIEstruct;
#define WHIRLPOOL_R 10
static const u64 C0[256] = {
    LL(0x18186018c07830d8), LL(0x23238c2305af4626), LL(0xc6c63fc67ef991b8), LL(0xe8e887e8136fcdfb),
    LL(0x878726874ca113cb), LL(0xb8b8dab8a9626d11), LL(0x0101040108050209), LL(0x4f4f214f426e9e0d),
    LL(0x3636d836adee6c9b), LL(0xa6a6a2a6590451ff), LL(0xd2d26fd2debdb90c), LL(0xf5f5f3f5fb06f70e),
    LL(0x7979f979ef80f296), LL(0x6f6fa16f5fcede30), LL(0x91917e91fcef3f6d), LL(0x52525552aa07a4f8),
    LL(0x60609d6027fdc047), LL(0xbcbccabc89766535), LL(0x9b9b569baccd2b37), LL(0x8e8e028e048c018a),
    LL(0xa3a3b6a371155bd2), LL(0x0c0c300c603c186c), LL(0x7b7bf17bff8af684), LL(0x3535d435b5e16a80),
    LL(0x1d1d741de8693af5), LL(0xe0e0a7e05347ddb3), LL(0xd7d77bd7f6acb321), LL(0xc2c22fc25eed999c),
    LL(0x2e2eb82e6d965c43), LL(0x4b4b314b627a9629), LL(0xfefedffea321e15d), LL(0x575741578216aed5),
    LL(0x15155415a8412abd), LL(0x7777c1779fb6eee8), LL(0x3737dc37a5eb6e92), LL(0xe5e5b3e57b56d79e),
    LL(0x9f9f469f8cd92313), LL(0xf0f0e7f0d317fd23), LL(0x4a4a354a6a7f9420), LL(0xdada4fda9e95a944),
    LL(0x58587d58fa25b0a2), LL(0xc9c903c906ca8fcf), LL(0x2929a429558d527c), LL(0x0a0a280a5022145a),
    LL(0xb1b1feb1e14f7f50), LL(0xa0a0baa0691a5dc9), LL(0x6b6bb16b7fdad614), LL(0x85852e855cab17d9),
    LL(0xbdbdcebd8173673c), LL(0x5d5d695dd234ba8f), LL(0x1010401080502090), LL(0xf4f4f7f4f303f507),
    LL(0xcbcb0bcb16c08bdd), LL(0x3e3ef83eedc67cd3), LL(0x0505140528110a2d), LL(0x676781671fe6ce78),
    LL(0xe4e4b7e47353d597), LL(0x27279c2725bb4e02), LL(0x4141194132588273), LL(0x8b8b168b2c9d0ba7),
    LL(0xa7a7a6a7510153f6), LL(0x7d7de97dcf94fab2), LL(0x95956e95dcfb3749), LL(0xd8d847d88e9fad56),
    LL(0xfbfbcbfb8b30eb70), LL(0xeeee9fee2371c1cd), LL(0x7c7ced7cc791f8bb), LL(0x6666856617e3cc71),
    LL(0xdddd53dda68ea77b), LL(0x17175c17b84b2eaf), LL(0x4747014702468e45), LL(0x9e9e429e84dc211a),
    LL(0xcaca0fca1ec589d4), LL(0x2d2db42d75995a58), LL(0xbfbfc6bf9179632e), LL(0x07071c07381b0e3f),
    LL(0xadad8ead012347ac), LL(0x5a5a755aea2fb4b0), LL(0x838336836cb51bef), LL(0x3333cc3385ff66b6),
    LL(0x636391633ff2c65c), LL(0x02020802100a0412), LL(0xaaaa92aa39384993), LL(0x7171d971afa8e2de),
    LL(0xc8c807c80ecf8dc6), LL(0x19196419c87d32d1), LL(0x494939497270923b), LL(0xd9d943d9869aaf5f),
    LL(0xf2f2eff2c31df931), LL(0xe3e3abe34b48dba8), LL(0x5b5b715be22ab6b9), LL(0x88881a8834920dbc),
    LL(0x9a9a529aa4c8293e), LL(0x262698262dbe4c0b), LL(0x3232c8328dfa64bf), LL(0xb0b0fab0e94a7d59),
    LL(0xe9e983e91b6acff2), LL(0x0f0f3c0f78331e77), LL(0xd5d573d5e6a6b733), LL(0x80803a8074ba1df4),
    LL(0xbebec2be997c6127), LL(0xcdcd13cd26de87eb), LL(0x3434d034bde46889), LL(0x48483d487a759032),
    LL(0xffffdbffab24e354), LL(0x7a7af57af78ff48d), LL(0x90907a90f4ea3d64), LL(0x5f5f615fc23ebe9d),
    LL(0x202080201da0403d), LL(0x6868bd6867d5d00f), LL(0x1a1a681ad07234ca), LL(0xaeae82ae192c41b7),
    LL(0xb4b4eab4c95e757d), LL(0x54544d549a19a8ce), LL(0x93937693ece53b7f), LL(0x222288220daa442f),
    LL(0x64648d6407e9c863), LL(0xf1f1e3f1db12ff2a), LL(0x7373d173bfa2e6cc), LL(0x12124812905a2482),
    LL(0x40401d403a5d807a), LL(0x0808200840281048), LL(0xc3c32bc356e89b95), LL(0xecec97ec337bc5df),
    LL(0xdbdb4bdb9690ab4d), LL(0xa1a1bea1611f5fc0), LL(0x8d8d0e8d1c830791), LL(0x3d3df43df5c97ac8),
    LL(0x97976697ccf1335b), LL(0x0000000000000000), LL(0xcfcf1bcf36d483f9), LL(0x2b2bac2b4587566e),
    LL(0x7676c57697b3ece1), LL(0x8282328264b019e6), LL(0xd6d67fd6fea9b128), LL(0x1b1b6c1bd87736c3),
    LL(0xb5b5eeb5c15b7774), LL(0xafaf86af112943be), LL(0x6a6ab56a77dfd41d), LL(0x50505d50ba0da0ea),
    LL(0x45450945124c8a57), LL(0xf3f3ebf3cb18fb38), LL(0x3030c0309df060ad), LL(0xefef9bef2b74c3c4),
    LL(0x3f3ffc3fe5c37eda), LL(0x55554955921caac7), LL(0xa2a2b2a2791059db), LL(0xeaea8fea0365c9e9),
    LL(0x656589650fecca6a), LL(0xbabad2bab9686903), LL(0x2f2fbc2f65935e4a), LL(0xc0c027c04ee79d8e),
    LL(0xdede5fdebe81a160), LL(0x1c1c701ce06c38fc), LL(0xfdfdd3fdbb2ee746), LL(0x4d4d294d52649a1f),
    LL(0x92927292e4e03976), LL(0x7575c9758fbceafa), LL(0x06061806301e0c36), LL(0x8a8a128a249809ae),
    LL(0xb2b2f2b2f940794b), LL(0xe6e6bfe66359d185), LL(0x0e0e380e70361c7e), LL(0x1f1f7c1ff8633ee7),
    LL(0x6262956237f7c455), LL(0xd4d477d4eea3b53a), LL(0xa8a89aa829324d81), LL(0x96966296c4f43152),
    LL(0xf9f9c3f99b3aef62), LL(0xc5c533c566f697a3), LL(0x2525942535b14a10), LL(0x59597959f220b2ab),
    LL(0x84842a8454ae15d0), LL(0x7272d572b7a7e4c5), LL(0x3939e439d5dd72ec), LL(0x4c4c2d4c5a619816),
    LL(0x5e5e655eca3bbc94), LL(0x7878fd78e785f09f), LL(0x3838e038ddd870e5), LL(0x8c8c0a8c14860598),
    LL(0xd1d163d1c6b2bf17), LL(0xa5a5aea5410b57e4), LL(0xe2e2afe2434dd9a1), LL(0x616199612ff8c24e),
    LL(0xb3b3f6b3f1457b42), LL(0x2121842115a54234), LL(0x9c9c4a9c94d62508), LL(0x1e1e781ef0663cee),
    LL(0x4343114322528661), LL(0xc7c73bc776fc93b1), LL(0xfcfcd7fcb32be54f), LL(0x0404100420140824),
    LL(0x51515951b208a2e3), LL(0x99995e99bcc72f25), LL(0x6d6da96d4fc4da22), LL(0x0d0d340d68391a65),
    LL(0xfafacffa8335e979), LL(0xdfdf5bdfb684a369), LL(0x7e7ee57ed79bfca9), LL(0x242490243db44819),
    LL(0x3b3bec3bc5d776fe), LL(0xabab96ab313d4b9a), LL(0xcece1fce3ed181f0), LL(0x1111441188552299),
    LL(0x8f8f068f0c890383), LL(0x4e4e254e4a6b9c04), LL(0xb7b7e6b7d1517366), LL(0xebeb8beb0b60cbe0),
    LL(0x3c3cf03cfdcc78c1), LL(0x81813e817cbf1ffd), LL(0x94946a94d4fe3540), LL(0xf7f7fbf7eb0cf31c),
    LL(0xb9b9deb9a1676f18), LL(0x13134c13985f268b), LL(0x2c2cb02c7d9c5851), LL(0xd3d36bd3d6b8bb05),
    LL(0xe7e7bbe76b5cd38c), LL(0x6e6ea56e57cbdc39), LL(0xc4c437c46ef395aa), LL(0x03030c03180f061b),
    LL(0x565645568a13acdc), LL(0x44440d441a49885e), LL(0x7f7fe17fdf9efea0), LL(0xa9a99ea921374f88),
    LL(0x2a2aa82a4d825467), LL(0xbbbbd6bbb16d6b0a), LL(0xc1c123c146e29f87), LL(0x53535153a202a6f1),
    LL(0xdcdc57dcae8ba572), LL(0x0b0b2c0b58271653), LL(0x9d9d4e9d9cd32701), LL(0x6c6cad6c47c1d82b),
    LL(0x3131c43195f562a4), LL(0x7474cd7487b9e8f3), LL(0xf6f6fff6e309f115), LL(0x464605460a438c4c),
    LL(0xacac8aac092645a5), LL(0x89891e893c970fb5), LL(0x14145014a04428b4), LL(0xe1e1a3e15b42dfba),
    LL(0x16165816b04e2ca6), LL(0x3a3ae83acdd274f7), LL(0x6969b9696fd0d206), LL(0x09092409482d1241),
    LL(0x7070dd70a7ade0d7), LL(0xb6b6e2b6d954716f), LL(0xd0d067d0ceb7bd1e), LL(0xeded93ed3b7ec7d6),
    LL(0xcccc17cc2edb85e2), LL(0x424215422a578468), LL(0x98985a98b4c22d2c), LL(0xa4a4aaa4490e55ed),
    LL(0x2828a0285d885075), LL(0x5c5c6d5cda31b886), LL(0xf8f8c7f8933fed6b), LL(0x8686228644a411c2),
};
static const u64 C1[256] = {
    LL(0xd818186018c07830), LL(0x2623238c2305af46), LL(0xb8c6c63fc67ef991), LL(0xfbe8e887e8136fcd),
    LL(0xcb878726874ca113), LL(0x11b8b8dab8a9626d), LL(0x0901010401080502), LL(0x0d4f4f214f426e9e),
    LL(0x9b3636d836adee6c), LL(0xffa6a6a2a6590451), LL(0x0cd2d26fd2debdb9), LL(0x0ef5f5f3f5fb06f7),
    LL(0x967979f979ef80f2), LL(0x306f6fa16f5fcede), LL(0x6d91917e91fcef3f), LL(0xf852525552aa07a4),
    LL(0x4760609d6027fdc0), LL(0x35bcbccabc897665), LL(0x379b9b569baccd2b), LL(0x8a8e8e028e048c01),
    LL(0xd2a3a3b6a371155b), LL(0x6c0c0c300c603c18), LL(0x847b7bf17bff8af6), LL(0x803535d435b5e16a),
    LL(0xf51d1d741de8693a), LL(0xb3e0e0a7e05347dd), LL(0x21d7d77bd7f6acb3), LL(0x9cc2c22fc25eed99),
    LL(0x432e2eb82e6d965c), LL(0x294b4b314b627a96), LL(0x5dfefedffea321e1), LL(0xd5575741578216ae),
    LL(0xbd15155415a8412a), LL(0xe87777c1779fb6ee), LL(0x923737dc37a5eb6e), LL(0x9ee5e5b3e57b56d7),
    LL(0x139f9f469f8cd923), LL(0x23f0f0e7f0d317fd), LL(0x204a4a354a6a7f94), LL(0x44dada4fda9e95a9),
    LL(0xa258587d58fa25b0), LL(0xcfc9c903c906ca8f), LL(0x7c2929a429558d52), LL(0x5a0a0a280a502214),
    LL(0x50b1b1feb1e14f7f), LL(0xc9a0a0baa0691a5d), LL(0x146b6bb16b7fdad6), LL(0xd985852e855cab17),
    LL(0x3cbdbdcebd817367), LL(0x8f5d5d695dd234ba), LL(0x9010104010805020), LL(0x07f4f4f7f4f303f5),
    LL(0xddcbcb0bcb16c08b), LL(0xd33e3ef83eedc67c), LL(0x2d0505140528110a), LL(0x78676781671fe6ce),
    LL(0x97e4e4b7e47353d5), LL(0x0227279c2725bb4e), LL(0x7341411941325882), LL(0xa78b8b168b2c9d0b),
    LL(0xf6a7a7a6a7510153), LL(0xb27d7de97dcf94fa), LL(0x4995956e95dcfb37), LL(0x56d8d847d88e9fad),
    LL(0x70fbfbcbfb8b30eb), LL(0xcdeeee9fee2371c1), LL(0xbb7c7ced7cc791f8), LL(0x716666856617e3cc),
    LL(0x7bdddd53dda68ea7), LL(0xaf17175c17b84b2e), LL(0x454747014702468e), LL(0x1a9e9e429e84dc21),
    LL(0xd4caca0fca1ec589), LL(0x582d2db42d75995a), LL(0x2ebfbfc6bf917963), LL(0x3f07071c07381b0e),
    LL(0xacadad8ead012347), LL(0xb05a5a755aea2fb4), LL(0xef838336836cb51b), LL(0xb63333cc3385ff66),
    LL(0x5c636391633ff2c6), LL(0x1202020802100a04), LL(0x93aaaa92aa393849), LL(0xde7171d971afa8e2),
    LL(0xc6c8c807c80ecf8d), LL(0xd119196419c87d32), LL(0x3b49493949727092), LL(0x5fd9d943d9869aaf),
    LL(0x31f2f2eff2c31df9), LL(0xa8e3e3abe34b48db), LL(0xb95b5b715be22ab6), LL(0xbc88881a8834920d),
    LL(0x3e9a9a529aa4c829), LL(0x0b262698262dbe4c), LL(0xbf3232c8328dfa64), LL(0x59b0b0fab0e94a7d),
    LL(0xf2e9e983e91b6acf), LL(0x770f0f3c0f78331e), LL(0x33d5d573d5e6a6b7), LL(0xf480803a8074ba1d),
    LL(0x27bebec2be997c61), LL(0xebcdcd13cd26de87), LL(0x893434d034bde468), LL(0x3248483d487a7590),
    LL(0x54ffffdbffab24e3), LL(0x8d7a7af57af78ff4), LL(0x6490907a90f4ea3d), LL(0x9d5f5f615fc23ebe),
    LL(0x3d202080201da040), LL(0x0f6868bd6867d5d0), LL(0xca1a1a681ad07234), LL(0xb7aeae82ae192c41),
    LL(0x7db4b4eab4c95e75), LL(0xce54544d549a19a8), LL(0x7f93937693ece53b), LL(0x2f222288220daa44),
    LL(0x6364648d6407e9c8), LL(0x2af1f1e3f1db12ff), LL(0xcc7373d173bfa2e6), LL(0x8212124812905a24),
    LL(0x7a40401d403a5d80), LL(0x4808082008402810), LL(0x95c3c32bc356e89b), LL(0xdfecec97ec337bc5),
    LL(0x4ddbdb4bdb9690ab), LL(0xc0a1a1bea1611f5f), LL(0x918d8d0e8d1c8307), LL(0xc83d3df43df5c97a),
    LL(0x5b97976697ccf133), LL(0x0000000000000000), LL(0xf9cfcf1bcf36d483), LL(0x6e2b2bac2b458756),
    LL(0xe17676c57697b3ec), LL(0xe68282328264b019), LL(0x28d6d67fd6fea9b1), LL(0xc31b1b6c1bd87736),
    LL(0x74b5b5eeb5c15b77), LL(0xbeafaf86af112943), LL(0x1d6a6ab56a77dfd4), LL(0xea50505d50ba0da0),
    LL(0x5745450945124c8a), LL(0x38f3f3ebf3cb18fb), LL(0xad3030c0309df060), LL(0xc4efef9bef2b74c3),
    LL(0xda3f3ffc3fe5c37e), LL(0xc755554955921caa), LL(0xdba2a2b2a2791059), LL(0xe9eaea8fea0365c9),
    LL(0x6a656589650fecca), LL(0x03babad2bab96869), LL(0x4a2f2fbc2f65935e), LL(0x8ec0c027c04ee79d),
    LL(0x60dede5fdebe81a1), LL(0xfc1c1c701ce06c38), LL(0x46fdfdd3fdbb2ee7), LL(0x1f4d4d294d52649a),
    LL(0x7692927292e4e039), LL(0xfa7575c9758fbcea), LL(0x3606061806301e0c), LL(0xae8a8a128a249809),
    LL(0x4bb2b2f2b2f94079), LL(0x85e6e6bfe66359d1), LL(0x7e0e0e380e70361c), LL(0xe71f1f7c1ff8633e),
    LL(0x556262956237f7c4), LL(0x3ad4d477d4eea3b5), LL(0x81a8a89aa829324d), LL(0x5296966296c4f431),
    LL(0x62f9f9c3f99b3aef), LL(0xa3c5c533c566f697), LL(0x102525942535b14a), LL(0xab59597959f220b2),
    LL(0xd084842a8454ae15), LL(0xc57272d572b7a7e4), LL(0xec3939e439d5dd72), LL(0x164c4c2d4c5a6198),
    LL(0x945e5e655eca3bbc), LL(0x9f7878fd78e785f0), LL(0xe53838e038ddd870), LL(0x988c8c0a8c148605),
    LL(0x17d1d163d1c6b2bf), LL(0xe4a5a5aea5410b57), LL(0xa1e2e2afe2434dd9), LL(0x4e616199612ff8c2),
    LL(0x42b3b3f6b3f1457b), LL(0x342121842115a542), LL(0x089c9c4a9c94d625), LL(0xee1e1e781ef0663c),
    LL(0x6143431143225286), LL(0xb1c7c73bc776fc93), LL(0x4ffcfcd7fcb32be5), LL(0x2404041004201408),
    LL(0xe351515951b208a2), LL(0x2599995e99bcc72f), LL(0x226d6da96d4fc4da), LL(0x650d0d340d68391a),
    LL(0x79fafacffa8335e9), LL(0x69dfdf5bdfb684a3), LL(0xa97e7ee57ed79bfc), LL(0x19242490243db448),
    LL(0xfe3b3bec3bc5d776), LL(0x9aabab96ab313d4b), LL(0xf0cece1fce3ed181), LL(0x9911114411885522),
    LL(0x838f8f068f0c8903), LL(0x044e4e254e4a6b9c), LL(0x66b7b7e6b7d15173), LL(0xe0ebeb8beb0b60cb),
    LL(0xc13c3cf03cfdcc78), LL(0xfd81813e817cbf1f), LL(0x4094946a94d4fe35), LL(0x1cf7f7fbf7eb0cf3),
    LL(0x18b9b9deb9a1676f), LL(0x8b13134c13985f26), LL(0x512c2cb02c7d9c58), LL(0x05d3d36bd3d6b8bb),
    LL(0x8ce7e7bbe76b5cd3), LL(0x396e6ea56e57cbdc), LL(0xaac4c437c46ef395), LL(0x1b03030c03180f06),
    LL(0xdc565645568a13ac), LL(0x5e44440d441a4988), LL(0xa07f7fe17fdf9efe), LL(0x88a9a99ea921374f),
    LL(0x672a2aa82a4d8254), LL(0x0abbbbd6bbb16d6b), LL(0x87c1c123c146e29f), LL(0xf153535153a202a6),
    LL(0x72dcdc57dcae8ba5), LL(0x530b0b2c0b582716), LL(0x019d9d4e9d9cd327), LL(0x2b6c6cad6c47c1d8),
    LL(0xa43131c43195f562), LL(0xf37474cd7487b9e8), LL(0x15f6f6fff6e309f1), LL(0x4c464605460a438c),
    LL(0xa5acac8aac092645), LL(0xb589891e893c970f), LL(0xb414145014a04428), LL(0xbae1e1a3e15b42df),
    LL(0xa616165816b04e2c), LL(0xf73a3ae83acdd274), LL(0x066969b9696fd0d2), LL(0x4109092409482d12),
    LL(0xd77070dd70a7ade0), LL(0x6fb6b6e2b6d95471), LL(0x1ed0d067d0ceb7bd), LL(0xd6eded93ed3b7ec7),
    LL(0xe2cccc17cc2edb85), LL(0x68424215422a5784), LL(0x2c98985a98b4c22d), LL(0xeda4a4aaa4490e55),
    LL(0x752828a0285d8850), LL(0x865c5c6d5cda31b8), LL(0x6bf8f8c7f8933fed), LL(0xc28686228644a411),
};
static const u64 C2[256] = {
    LL(0x30d818186018c078), LL(0x462623238c2305af), LL(0x91b8c6c63fc67ef9), LL(0xcdfbe8e887e8136f),
    LL(0x13cb878726874ca1), LL(0x6d11b8b8dab8a962), LL(0x0209010104010805), LL(0x9e0d4f4f214f426e),
    LL(0x6c9b3636d836adee), LL(0x51ffa6a6a2a65904), LL(0xb90cd2d26fd2debd), LL(0xf70ef5f5f3f5fb06),
    LL(0xf2967979f979ef80), LL(0xde306f6fa16f5fce), LL(0x3f6d91917e91fcef), LL(0xa4f852525552aa07),
    LL(0xc04760609d6027fd), LL(0x6535bcbccabc8976), LL(0x2b379b9b569baccd), LL(0x018a8e8e028e048c),
    LL(0x5bd2a3a3b6a37115), LL(0x186c0c0c300c603c), LL(0xf6847b7bf17bff8a), LL(0x6a803535d435b5e1),
    LL(0x3af51d1d741de869), LL(0xddb3e0e0a7e05347), LL(0xb321d7d77bd7f6ac), LL(0x999cc2c22fc25eed),
    LL(0x5c432e2eb82e6d96), LL(0x96294b4b314b627a), LL(0xe15dfefedffea321), LL(0xaed5575741578216),
    LL(0x2abd15155415a841), LL(0xeee87777c1779fb6), LL(0x6e923737dc37a5eb), LL(0xd79ee5e5b3e57b56),
    LL(0x23139f9f469f8cd9), LL(0xfd23f0f0e7f0d317), LL(0x94204a4a354a6a7f), LL(0xa944dada4fda9e95),
    LL(0xb0a258587d58fa25), LL(0x8fcfc9c903c906ca), LL(0x527c2929a429558d), LL(0x145a0a0a280a5022),
    LL(0x7f50b1b1feb1e14f), LL(0x5dc9a0a0baa0691a), LL(0xd6146b6bb16b7fda), LL(0x17d985852e855cab),
    LL(0x673cbdbdcebd8173), LL(0xba8f5d5d695dd234), LL(0x2090101040108050), LL(0xf507f4f4f7f4f303),
    LL(0x8bddcbcb0bcb16c0), LL(0x7cd33e3ef83eedc6), LL(0x0a2d050514052811), LL(0xce78676781671fe6),
    LL(0xd597e4e4b7e47353), LL(0x4e0227279c2725bb), LL(0x8273414119413258), LL(0x0ba78b8b168b2c9d),
    LL(0x53f6a7a7a6a75101), LL(0xfab27d7de97dcf94), LL(0x374995956e95dcfb), LL(0xad56d8d847d88e9f),
    LL(0xeb70fbfbcbfb8b30), LL(0xc1cdeeee9fee2371), LL(0xf8bb7c7ced7cc791), LL(0xcc716666856617e3),
    LL(0xa77bdddd53dda68e), LL(0x2eaf17175c17b84b), LL(0x8e45474701470246), LL(0x211a9e9e429e84dc),
    LL(0x89d4caca0fca1ec5), LL(0x5a582d2db42d7599), LL(0x632ebfbfc6bf9179), LL(0x0e3f07071c07381b),
    LL(0x47acadad8ead0123), LL(0xb4b05a5a755aea2f), LL(0x1bef838336836cb5), LL(0x66b63333cc3385ff),
    LL(0xc65c636391633ff2), LL(0x041202020802100a), LL(0x4993aaaa92aa3938), LL(0xe2de7171d971afa8),
    LL(0x8dc6c8c807c80ecf), LL(0x32d119196419c87d), LL(0x923b494939497270), LL(0xaf5fd9d943d9869a),
    LL(0xf931f2f2eff2c31d), LL(0xdba8e3e3abe34b48), LL(0xb6b95b5b715be22a), LL(0x0dbc88881a883492),
    LL(0x293e9a9a529aa4c8), LL(0x4c0b262698262dbe), LL(0x64bf3232c8328dfa), LL(0x7d59b0b0fab0e94a),
    LL(0xcff2e9e983e91b6a), LL(0x1e770f0f3c0f7833), LL(0xb733d5d573d5e6a6), LL(0x1df480803a8074ba),
    LL(0x6127bebec2be997c), LL(0x87ebcdcd13cd26de), LL(0x68893434d034bde4), LL(0x903248483d487a75),
    LL(0xe354ffffdbffab24), LL(0xf48d7a7af57af78f), LL(0x3d6490907a90f4ea), LL(0xbe9d5f5f615fc23e),
    LL(0x403d202080201da0), LL(0xd00f6868bd6867d5), LL(0x34ca1a1a681ad072), LL(0x41b7aeae82ae192c),
    LL(0x757db4b4eab4c95e), LL(0xa8ce54544d549a19), LL(0x3b7f93937693ece5), LL(0x442f222288220daa),
    LL(0xc86364648d6407e9), LL(0xff2af1f1e3f1db12), LL(0xe6cc7373d173bfa2), LL(0x248212124812905a),
    LL(0x807a40401d403a5d), LL(0x1048080820084028), LL(0x9b95c3c32bc356e8), LL(0xc5dfecec97ec337b),
    LL(0xab4ddbdb4bdb9690), LL(0x5fc0a1a1bea1611f), LL(0x07918d8d0e8d1c83), LL(0x7ac83d3df43df5c9),
    LL(0x335b97976697ccf1), LL(0x0000000000000000), LL(0x83f9cfcf1bcf36d4), LL(0x566e2b2bac2b4587),
    LL(0xece17676c57697b3), LL(0x19e68282328264b0), LL(0xb128d6d67fd6fea9), LL(0x36c31b1b6c1bd877),
    LL(0x7774b5b5eeb5c15b), LL(0x43beafaf86af1129), LL(0xd41d6a6ab56a77df), LL(0xa0ea50505d50ba0d),
    LL(0x8a5745450945124c), LL(0xfb38f3f3ebf3cb18), LL(0x60ad3030c0309df0), LL(0xc3c4efef9bef2b74),
    LL(0x7eda3f3ffc3fe5c3), LL(0xaac755554955921c), LL(0x59dba2a2b2a27910), LL(0xc9e9eaea8fea0365),
    LL(0xca6a656589650fec), LL(0x6903babad2bab968), LL(0x5e4a2f2fbc2f6593), LL(0x9d8ec0c027c04ee7),
    LL(0xa160dede5fdebe81), LL(0x38fc1c1c701ce06c), LL(0xe746fdfdd3fdbb2e), LL(0x9a1f4d4d294d5264),
    LL(0x397692927292e4e0), LL(0xeafa7575c9758fbc), LL(0x0c3606061806301e), LL(0x09ae8a8a128a2498),
    LL(0x794bb2b2f2b2f940), LL(0xd185e6e6bfe66359), LL(0x1c7e0e0e380e7036), LL(0x3ee71f1f7c1ff863),
    LL(0xc4556262956237f7), LL(0xb53ad4d477d4eea3), LL(0x4d81a8a89aa82932), LL(0x315296966296c4f4),
    LL(0xef62f9f9c3f99b3a), LL(0x97a3c5c533c566f6), LL(0x4a102525942535b1), LL(0xb2ab59597959f220),
    LL(0x15d084842a8454ae), LL(0xe4c57272d572b7a7), LL(0x72ec3939e439d5dd), LL(0x98164c4c2d4c5a61),
    LL(0xbc945e5e655eca3b), LL(0xf09f7878fd78e785), LL(0x70e53838e038ddd8), LL(0x05988c8c0a8c1486),
    LL(0xbf17d1d163d1c6b2), LL(0x57e4a5a5aea5410b), LL(0xd9a1e2e2afe2434d), LL(0xc24e616199612ff8),
    LL(0x7b42b3b3f6b3f145), LL(0x42342121842115a5), LL(0x25089c9c4a9c94d6), LL(0x3cee1e1e781ef066),
    LL(0x8661434311432252), LL(0x93b1c7c73bc776fc), LL(0xe54ffcfcd7fcb32b), LL(0x0824040410042014),
    LL(0xa2e351515951b208), LL(0x2f2599995e99bcc7), LL(0xda226d6da96d4fc4), LL(0x1a650d0d340d6839),
    LL(0xe979fafacffa8335), LL(0xa369dfdf5bdfb684), LL(0xfca97e7ee57ed79b), LL(0x4819242490243db4),
    LL(0x76fe3b3bec3bc5d7), LL(0x4b9aabab96ab313d), LL(0x81f0cece1fce3ed1), LL(0x2299111144118855),
    LL(0x03838f8f068f0c89), LL(0x9c044e4e254e4a6b), LL(0x7366b7b7e6b7d151), LL(0xcbe0ebeb8beb0b60),
    LL(0x78c13c3cf03cfdcc), LL(0x1ffd81813e817cbf), LL(0x354094946a94d4fe), LL(0xf31cf7f7fbf7eb0c),
    LL(0x6f18b9b9deb9a167), LL(0x268b13134c13985f), LL(0x58512c2cb02c7d9c), LL(0xbb05d3d36bd3d6b8),
    LL(0xd38ce7e7bbe76b5c), LL(0xdc396e6ea56e57cb), LL(0x95aac4c437c46ef3), LL(0x061b03030c03180f),
    LL(0xacdc565645568a13), LL(0x885e44440d441a49), LL(0xfea07f7fe17fdf9e), LL(0x4f88a9a99ea92137),
    LL(0x54672a2aa82a4d82), LL(0x6b0abbbbd6bbb16d), LL(0x9f87c1c123c146e2), LL(0xa6f153535153a202),
    LL(0xa572dcdc57dcae8b), LL(0x16530b0b2c0b5827), LL(0x27019d9d4e9d9cd3), LL(0xd82b6c6cad6c47c1),
    LL(0x62a43131c43195f5), LL(0xe8f37474cd7487b9), LL(0xf115f6f6fff6e309), LL(0x8c4c464605460a43),
    LL(0x45a5acac8aac0926), LL(0x0fb589891e893c97), LL(0x28b414145014a044), LL(0xdfbae1e1a3e15b42),
    LL(0x2ca616165816b04e), LL(0x74f73a3ae83acdd2), LL(0xd2066969b9696fd0), LL(0x124109092409482d),
    LL(0xe0d77070dd70a7ad), LL(0x716fb6b6e2b6d954), LL(0xbd1ed0d067d0ceb7), LL(0xc7d6eded93ed3b7e),
    LL(0x85e2cccc17cc2edb), LL(0x8468424215422a57), LL(0x2d2c98985a98b4c2), LL(0x55eda4a4aaa4490e),
    LL(0x50752828a0285d88), LL(0xb8865c5c6d5cda31), LL(0xed6bf8f8c7f8933f), LL(0x11c28686228644a4),
};
static const u64 C3[256] = {
    LL(0x7830d818186018c0), LL(0xaf462623238c2305), LL(0xf991b8c6c63fc67e), LL(0x6fcdfbe8e887e813),
    LL(0xa113cb878726874c), LL(0x626d11b8b8dab8a9), LL(0x0502090101040108), LL(0x6e9e0d4f4f214f42),
    LL(0xee6c9b3636d836ad), LL(0x0451ffa6a6a2a659), LL(0xbdb90cd2d26fd2de), LL(0x06f70ef5f5f3f5fb),
    LL(0x80f2967979f979ef), LL(0xcede306f6fa16f5f), LL(0xef3f6d91917e91fc), LL(0x07a4f852525552aa),
    LL(0xfdc04760609d6027), LL(0x766535bcbccabc89), LL(0xcd2b379b9b569bac), LL(0x8c018a8e8e028e04),
    LL(0x155bd2a3a3b6a371), LL(0x3c186c0c0c300c60), LL(0x8af6847b7bf17bff), LL(0xe16a803535d435b5),
    LL(0x693af51d1d741de8), LL(0x47ddb3e0e0a7e053), LL(0xacb321d7d77bd7f6), LL(0xed999cc2c22fc25e),
    LL(0x965c432e2eb82e6d), LL(0x7a96294b4b314b62), LL(0x21e15dfefedffea3), LL(0x16aed55757415782),
    LL(0x412abd15155415a8), LL(0xb6eee87777c1779f), LL(0xeb6e923737dc37a5), LL(0x56d79ee5e5b3e57b),
    LL(0xd923139f9f469f8c), LL(0x17fd23f0f0e7f0d3), LL(0x7f94204a4a354a6a), LL(0x95a944dada4fda9e),
    LL(0x25b0a258587d58fa), LL(0xca8fcfc9c903c906), LL(0x8d527c2929a42955), LL(0x22145a0a0a280a50),
    LL(0x4f7f50b1b1feb1e1), LL(0x1a5dc9a0a0baa069), LL(0xdad6146b6bb16b7f), LL(0xab17d985852e855c),
    LL(0x73673cbdbdcebd81), LL(0x34ba8f5d5d695dd2), LL(0x5020901010401080), LL(0x03f507f4f4f7f4f3),
    LL(0xc08bddcbcb0bcb16), LL(0xc67cd33e3ef83eed), LL(0x110a2d0505140528), LL(0xe6ce78676781671f),
    LL(0x53d597e4e4b7e473), LL(0xbb4e0227279c2725), LL(0x5882734141194132), LL(0x9d0ba78b8b168b2c),
    LL(0x0153f6a7a7a6a751), LL(0x94fab27d7de97dcf), LL(0xfb374995956e95dc), LL(0x9fad56d8d847d88e),
    LL(0x30eb70fbfbcbfb8b), LL(0x71c1cdeeee9fee23), LL(0x91f8bb7c7ced7cc7), LL(0xe3cc716666856617),
    LL(0x8ea77bdddd53dda6), LL(0x4b2eaf17175c17b8), LL(0x468e454747014702), LL(0xdc211a9e9e429e84),
    LL(0xc589d4caca0fca1e), LL(0x995a582d2db42d75), LL(0x79632ebfbfc6bf91), LL(0x1b0e3f07071c0738),
    LL(0x2347acadad8ead01), LL(0x2fb4b05a5a755aea), LL(0xb51bef838336836c), LL(0xff66b63333cc3385),
    LL(0xf2c65c636391633f), LL(0x0a04120202080210), LL(0x384993aaaa92aa39), LL(0xa8e2de7171d971af),
    LL(0xcf8dc6c8c807c80e), LL(0x7d32d119196419c8), LL(0x70923b4949394972), LL(0x9aaf5fd9d943d986),
    LL(0x1df931f2f2eff2c3), LL(0x48dba8e3e3abe34b), LL(0x2ab6b95b5b715be2), LL(0x920dbc88881a8834),
    LL(0xc8293e9a9a529aa4), LL(0xbe4c0b262698262d), LL(0xfa64bf3232c8328d), LL(0x4a7d59b0b0fab0e9),
    LL(0x6acff2e9e983e91b), LL(0x331e770f0f3c0f78), LL(0xa6b733d5d573d5e6), LL(0xba1df480803a8074),
    LL(0x7c6127bebec2be99), LL(0xde87ebcdcd13cd26), LL(0xe468893434d034bd), LL(0x75903248483d487a),
    LL(0x24e354ffffdbffab), LL(0x8ff48d7a7af57af7), LL(0xea3d6490907a90f4), LL(0x3ebe9d5f5f615fc2),
    LL(0xa0403d202080201d), LL(0xd5d00f6868bd6867), LL(0x7234ca1a1a681ad0), LL(0x2c41b7aeae82ae19),
    LL(0x5e757db4b4eab4c9), LL(0x19a8ce54544d549a), LL(0xe53b7f93937693ec), LL(0xaa442f222288220d),
    LL(0xe9c86364648d6407), LL(0x12ff2af1f1e3f1db), LL(0xa2e6cc7373d173bf), LL(0x5a24821212481290),
    LL(0x5d807a40401d403a), LL(0x2810480808200840), LL(0xe89b95c3c32bc356), LL(0x7bc5dfecec97ec33),
    LL(0x90ab4ddbdb4bdb96), LL(0x1f5fc0a1a1bea161), LL(0x8307918d8d0e8d1c), LL(0xc97ac83d3df43df5),
    LL(0xf1335b97976697cc), LL(0x0000000000000000), LL(0xd483f9cfcf1bcf36), LL(0x87566e2b2bac2b45),
    LL(0xb3ece17676c57697), LL(0xb019e68282328264), LL(0xa9b128d6d67fd6fe), LL(0x7736c31b1b6c1bd8),
    LL(0x5b7774b5b5eeb5c1), LL(0x2943beafaf86af11), LL(0xdfd41d6a6ab56a77), LL(0x0da0ea50505d50ba),
    LL(0x4c8a574545094512), LL(0x18fb38f3f3ebf3cb), LL(0xf060ad3030c0309d), LL(0x74c3c4efef9bef2b),
    LL(0xc37eda3f3ffc3fe5), LL(0x1caac75555495592), LL(0x1059dba2a2b2a279), LL(0x65c9e9eaea8fea03),
    LL(0xecca6a656589650f), LL(0x686903babad2bab9), LL(0x935e4a2f2fbc2f65), LL(0xe79d8ec0c027c04e),
    LL(0x81a160dede5fdebe), LL(0x6c38fc1c1c701ce0), LL(0x2ee746fdfdd3fdbb), LL(0x649a1f4d4d294d52),
    LL(0xe0397692927292e4), LL(0xbceafa7575c9758f), LL(0x1e0c360606180630), LL(0x9809ae8a8a128a24),
    LL(0x40794bb2b2f2b2f9), LL(0x59d185e6e6bfe663), LL(0x361c7e0e0e380e70), LL(0x633ee71f1f7c1ff8),
    LL(0xf7c4556262956237), LL(0xa3b53ad4d477d4ee), LL(0x324d81a8a89aa829), LL(0xf4315296966296c4),
    LL(0x3aef62f9f9c3f99b), LL(0xf697a3c5c533c566), LL(0xb14a102525942535), LL(0x20b2ab59597959f2),
    LL(0xae15d084842a8454), LL(0xa7e4c57272d572b7), LL(0xdd72ec3939e439d5), LL(0x6198164c4c2d4c5a),
    LL(0x3bbc945e5e655eca), LL(0x85f09f7878fd78e7), LL(0xd870e53838e038dd), LL(0x8605988c8c0a8c14),
    LL(0xb2bf17d1d163d1c6), LL(0x0b57e4a5a5aea541), LL(0x4dd9a1e2e2afe243), LL(0xf8c24e616199612f),
    LL(0x457b42b3b3f6b3f1), LL(0xa542342121842115), LL(0xd625089c9c4a9c94), LL(0x663cee1e1e781ef0),
    LL(0x5286614343114322), LL(0xfc93b1c7c73bc776), LL(0x2be54ffcfcd7fcb3), LL(0x1408240404100420),
    LL(0x08a2e351515951b2), LL(0xc72f2599995e99bc), LL(0xc4da226d6da96d4f), LL(0x391a650d0d340d68),
    LL(0x35e979fafacffa83), LL(0x84a369dfdf5bdfb6), LL(0x9bfca97e7ee57ed7), LL(0xb44819242490243d),
    LL(0xd776fe3b3bec3bc5), LL(0x3d4b9aabab96ab31), LL(0xd181f0cece1fce3e), LL(0x5522991111441188),
    LL(0x8903838f8f068f0c), LL(0x6b9c044e4e254e4a), LL(0x517366b7b7e6b7d1), LL(0x60cbe0ebeb8beb0b),
    LL(0xcc78c13c3cf03cfd), LL(0xbf1ffd81813e817c), LL(0xfe354094946a94d4), LL(0x0cf31cf7f7fbf7eb),
    LL(0x676f18b9b9deb9a1), LL(0x5f268b13134c1398), LL(0x9c58512c2cb02c7d), LL(0xb8bb05d3d36bd3d6),
    LL(0x5cd38ce7e7bbe76b), LL(0xcbdc396e6ea56e57), LL(0xf395aac4c437c46e), LL(0x0f061b03030c0318),
    LL(0x13acdc565645568a), LL(0x49885e44440d441a), LL(0x9efea07f7fe17fdf), LL(0x374f88a9a99ea921),
    LL(0x8254672a2aa82a4d), LL(0x6d6b0abbbbd6bbb1), LL(0xe29f87c1c123c146), LL(0x02a6f153535153a2),
    LL(0x8ba572dcdc57dcae), LL(0x2716530b0b2c0b58), LL(0xd327019d9d4e9d9c), LL(0xc1d82b6c6cad6c47),
    LL(0xf562a43131c43195), LL(0xb9e8f37474cd7487), LL(0x09f115f6f6fff6e3), LL(0x438c4c464605460a),
    LL(0x2645a5acac8aac09), LL(0x970fb589891e893c), LL(0x4428b414145014a0), LL(0x42dfbae1e1a3e15b),
    LL(0x4e2ca616165816b0), LL(0xd274f73a3ae83acd), LL(0xd0d2066969b9696f), LL(0x2d12410909240948),
    LL(0xade0d77070dd70a7), LL(0x54716fb6b6e2b6d9), LL(0xb7bd1ed0d067d0ce), LL(0x7ec7d6eded93ed3b),
    LL(0xdb85e2cccc17cc2e), LL(0x578468424215422a), LL(0xc22d2c98985a98b4), LL(0x0e55eda4a4aaa449),
    LL(0x8850752828a0285d), LL(0x31b8865c5c6d5cda), LL(0x3fed6bf8f8c7f893), LL(0xa411c28686228644),
};
static const u64 C4[256] = {
    LL(0xc07830d818186018), LL(0x05af462623238c23), LL(0x7ef991b8c6c63fc6), LL(0x136fcdfbe8e887e8),
    LL(0x4ca113cb87872687), LL(0xa9626d11b8b8dab8), LL(0x0805020901010401), LL(0x426e9e0d4f4f214f),
    LL(0xadee6c9b3636d836), LL(0x590451ffa6a6a2a6), LL(0xdebdb90cd2d26fd2), LL(0xfb06f70ef5f5f3f5),
    LL(0xef80f2967979f979), LL(0x5fcede306f6fa16f), LL(0xfcef3f6d91917e91), LL(0xaa07a4f852525552),
    LL(0x27fdc04760609d60), LL(0x89766535bcbccabc), LL(0xaccd2b379b9b569b), LL(0x048c018a8e8e028e),
    LL(0x71155bd2a3a3b6a3), LL(0x603c186c0c0c300c), LL(0xff8af6847b7bf17b), LL(0xb5e16a803535d435),
    LL(0xe8693af51d1d741d), LL(0x5347ddb3e0e0a7e0), LL(0xf6acb321d7d77bd7), LL(0x5eed999cc2c22fc2),
    LL(0x6d965c432e2eb82e), LL(0x627a96294b4b314b), LL(0xa321e15dfefedffe), LL(0x8216aed557574157),
    LL(0xa8412abd15155415), LL(0x9fb6eee87777c177), LL(0xa5eb6e923737dc37), LL(0x7b56d79ee5e5b3e5),
    LL(0x8cd923139f9f469f), LL(0xd317fd23f0f0e7f0), LL(0x6a7f94204a4a354a), LL(0x9e95a944dada4fda),
    LL(0xfa25b0a258587d58), LL(0x06ca8fcfc9c903c9), LL(0x558d527c2929a429), LL(0x5022145a0a0a280a),
    LL(0xe14f7f50b1b1feb1), LL(0x691a5dc9a0a0baa0), LL(0x7fdad6146b6bb16b), LL(0x5cab17d985852e85),
    LL(0x8173673cbdbdcebd), LL(0xd234ba8f5d5d695d), LL(0x8050209010104010), LL(0xf303f507f4f4f7f4),
    LL(0x16c08bddcbcb0bcb), LL(0xedc67cd33e3ef83e), LL(0x28110a2d05051405), LL(0x1fe6ce7867678167),
    LL(0x7353d597e4e4b7e4), LL(0x25bb4e0227279c27), LL(0x3258827341411941), LL(0x2c9d0ba78b8b168b),
    LL(0x510153f6a7a7a6a7), LL(0xcf94fab27d7de97d), LL(0xdcfb374995956e95), LL(0x8e9fad56d8d847d8),
    LL(0x8b30eb70fbfbcbfb), LL(0x2371c1cdeeee9fee), LL(0xc791f8bb7c7ced7c), LL(0x17e3cc7166668566),
    LL(0xa68ea77bdddd53dd), LL(0xb84b2eaf17175c17), LL(0x02468e4547470147), LL(0x84dc211a9e9e429e),
    LL(0x1ec589d4caca0fca), LL(0x75995a582d2db42d), LL(0x9179632ebfbfc6bf), LL(0x381b0e3f07071c07),
    LL(0x012347acadad8ead), LL(0xea2fb4b05a5a755a), LL(0x6cb51bef83833683), LL(0x85ff66b63333cc33),
    LL(0x3ff2c65c63639163), LL(0x100a041202020802), LL(0x39384993aaaa92aa), LL(0xafa8e2de7171d971),
    LL(0x0ecf8dc6c8c807c8), LL(0xc87d32d119196419), LL(0x7270923b49493949), LL(0x869aaf5fd9d943d9),
    LL(0xc31df931f2f2eff2), LL(0x4b48dba8e3e3abe3), LL(0xe22ab6b95b5b715b), LL(0x34920dbc88881a88),
    LL(0xa4c8293e9a9a529a), LL(0x2dbe4c0b26269826), LL(0x8dfa64bf3232c832), LL(0xe94a7d59b0b0fab0),
    LL(0x1b6acff2e9e983e9), LL(0x78331e770f0f3c0f), LL(0xe6a6b733d5d573d5), LL(0x74ba1df480803a80),
    LL(0x997c6127bebec2be), LL(0x26de87ebcdcd13cd), LL(0xbde468893434d034), LL(0x7a75903248483d48),
    LL(0xab24e354ffffdbff), LL(0xf78ff48d7a7af57a), LL(0xf4ea3d6490907a90), LL(0xc23ebe9d5f5f615f),
    LL(0x1da0403d20208020), LL(0x67d5d00f6868bd68), LL(0xd07234ca1a1a681a), LL(0x192c41b7aeae82ae),
    LL(0xc95e757db4b4eab4), LL(0x9a19a8ce54544d54), LL(0xece53b7f93937693), LL(0x0daa442f22228822),
    LL(0x07e9c86364648d64), LL(0xdb12ff2af1f1e3f1), LL(0xbfa2e6cc7373d173), LL(0x905a248212124812),
    LL(0x3a5d807a40401d40), LL(0x4028104808082008), LL(0x56e89b95c3c32bc3), LL(0x337bc5dfecec97ec),
    LL(0x9690ab4ddbdb4bdb), LL(0x611f5fc0a1a1bea1), LL(0x1c8307918d8d0e8d), LL(0xf5c97ac83d3df43d),
    LL(0xccf1335b97976697), LL(0x0000000000000000), LL(0x36d483f9cfcf1bcf), LL(0x4587566e2b2bac2b),
    LL(0x97b3ece17676c576), LL(0x64b019e682823282), LL(0xfea9b128d6d67fd6), LL(0xd87736c31b1b6c1b),
    LL(0xc15b7774b5b5eeb5), LL(0x112943beafaf86af), LL(0x77dfd41d6a6ab56a), LL(0xba0da0ea50505d50),
    LL(0x124c8a5745450945), LL(0xcb18fb38f3f3ebf3), LL(0x9df060ad3030c030), LL(0x2b74c3c4efef9bef),
    LL(0xe5c37eda3f3ffc3f), LL(0x921caac755554955), LL(0x791059dba2a2b2a2), LL(0x0365c9e9eaea8fea),
    LL(0x0fecca6a65658965), LL(0xb9686903babad2ba), LL(0x65935e4a2f2fbc2f), LL(0x4ee79d8ec0c027c0),
    LL(0xbe81a160dede5fde), LL(0xe06c38fc1c1c701c), LL(0xbb2ee746fdfdd3fd), LL(0x52649a1f4d4d294d),
    LL(0xe4e0397692927292), LL(0x8fbceafa7575c975), LL(0x301e0c3606061806), LL(0x249809ae8a8a128a),
    LL(0xf940794bb2b2f2b2), LL(0x6359d185e6e6bfe6), LL(0x70361c7e0e0e380e), LL(0xf8633ee71f1f7c1f),
    LL(0x37f7c45562629562), LL(0xeea3b53ad4d477d4), LL(0x29324d81a8a89aa8), LL(0xc4f4315296966296),
    LL(0x9b3aef62f9f9c3f9), LL(0x66f697a3c5c533c5), LL(0x35b14a1025259425), LL(0xf220b2ab59597959),
    LL(0x54ae15d084842a84), LL(0xb7a7e4c57272d572), LL(0xd5dd72ec3939e439), LL(0x5a6198164c4c2d4c),
    LL(0xca3bbc945e5e655e), LL(0xe785f09f7878fd78), LL(0xddd870e53838e038), LL(0x148605988c8c0a8c),
    LL(0xc6b2bf17d1d163d1), LL(0x410b57e4a5a5aea5), LL(0x434dd9a1e2e2afe2), LL(0x2ff8c24e61619961),
    LL(0xf1457b42b3b3f6b3), LL(0x15a5423421218421), LL(0x94d625089c9c4a9c), LL(0xf0663cee1e1e781e),
    LL(0x2252866143431143), LL(0x76fc93b1c7c73bc7), LL(0xb32be54ffcfcd7fc), LL(0x2014082404041004),
    LL(0xb208a2e351515951), LL(0xbcc72f2599995e99), LL(0x4fc4da226d6da96d), LL(0x68391a650d0d340d),
    LL(0x8335e979fafacffa), LL(0xb684a369dfdf5bdf), LL(0xd79bfca97e7ee57e), LL(0x3db4481924249024),
    LL(0xc5d776fe3b3bec3b), LL(0x313d4b9aabab96ab), LL(0x3ed181f0cece1fce), LL(0x8855229911114411),
    LL(0x0c8903838f8f068f), LL(0x4a6b9c044e4e254e), LL(0xd1517366b7b7e6b7), LL(0x0b60cbe0ebeb8beb),
    LL(0xfdcc78c13c3cf03c), LL(0x7cbf1ffd81813e81), LL(0xd4fe354094946a94), LL(0xeb0cf31cf7f7fbf7),
    LL(0xa1676f18b9b9deb9), LL(0x985f268b13134c13), LL(0x7d9c58512c2cb02c), LL(0xd6b8bb05d3d36bd3),
    LL(0x6b5cd38ce7e7bbe7), LL(0x57cbdc396e6ea56e), LL(0x6ef395aac4c437c4), LL(0x180f061b03030c03),
    LL(0x8a13acdc56564556), LL(0x1a49885e44440d44), LL(0xdf9efea07f7fe17f), LL(0x21374f88a9a99ea9),
    LL(0x4d8254672a2aa82a), LL(0xb16d6b0abbbbd6bb), LL(0x46e29f87c1c123c1), LL(0xa202a6f153535153),
    LL(0xae8ba572dcdc57dc), LL(0x582716530b0b2c0b), LL(0x9cd327019d9d4e9d), LL(0x47c1d82b6c6cad6c),
    LL(0x95f562a43131c431), LL(0x87b9e8f37474cd74), LL(0xe309f115f6f6fff6), LL(0x0a438c4c46460546),
    LL(0x092645a5acac8aac), LL(0x3c970fb589891e89), LL(0xa04428b414145014), LL(0x5b42dfbae1e1a3e1),
    LL(0xb04e2ca616165816), LL(0xcdd274f73a3ae83a), LL(0x6fd0d2066969b969), LL(0x482d124109092409),
    LL(0xa7ade0d77070dd70), LL(0xd954716fb6b6e2b6), LL(0xceb7bd1ed0d067d0), LL(0x3b7ec7d6eded93ed),
    LL(0x2edb85e2cccc17cc), LL(0x2a57846842421542), LL(0xb4c22d2c98985a98), LL(0x490e55eda4a4aaa4),
    LL(0x5d8850752828a028), LL(0xda31b8865c5c6d5c), LL(0x933fed6bf8f8c7f8), LL(0x44a411c286862286),
};
static const u64 C5[256] = {
    LL(0x18c07830d8181860), LL(0x2305af462623238c), LL(0xc67ef991b8c6c63f), LL(0xe8136fcdfbe8e887),
    LL(0x874ca113cb878726), LL(0xb8a9626d11b8b8da), LL(0x0108050209010104), LL(0x4f426e9e0d4f4f21),
    LL(0x36adee6c9b3636d8), LL(0xa6590451ffa6a6a2), LL(0xd2debdb90cd2d26f), LL(0xf5fb06f70ef5f5f3),
    LL(0x79ef80f2967979f9), LL(0x6f5fcede306f6fa1), LL(0x91fcef3f6d91917e), LL(0x52aa07a4f8525255),
    LL(0x6027fdc04760609d), LL(0xbc89766535bcbcca), LL(0x9baccd2b379b9b56), LL(0x8e048c018a8e8e02),
    LL(0xa371155bd2a3a3b6), LL(0x0c603c186c0c0c30), LL(0x7bff8af6847b7bf1), LL(0x35b5e16a803535d4),
    LL(0x1de8693af51d1d74), LL(0xe05347ddb3e0e0a7), LL(0xd7f6acb321d7d77b), LL(0xc25eed999cc2c22f),
    LL(0x2e6d965c432e2eb8), LL(0x4b627a96294b4b31), LL(0xfea321e15dfefedf), LL(0x578216aed5575741),
    LL(0x15a8412abd151554), LL(0x779fb6eee87777c1), LL(0x37a5eb6e923737dc), LL(0xe57b56d79ee5e5b3),
    LL(0x9f8cd923139f9f46), LL(0xf0d317fd23f0f0e7), LL(0x4a6a7f94204a4a35), LL(0xda9e95a944dada4f),
    LL(0x58fa25b0a258587d), LL(0xc906ca8fcfc9c903), LL(0x29558d527c2929a4), LL(0x0a5022145a0a0a28),
    LL(0xb1e14f7f50b1b1fe), LL(0xa0691a5dc9a0a0ba), LL(0x6b7fdad6146b6bb1), LL(0x855cab17d985852e),
    LL(0xbd8173673cbdbdce), LL(0x5dd234ba8f5d5d69), LL(0x1080502090101040), LL(0xf4f303f507f4f4f7),
    LL(0xcb16c08bddcbcb0b), LL(0x3eedc67cd33e3ef8), LL(0x0528110a2d050514), LL(0x671fe6ce78676781),
    LL(0xe47353d597e4e4b7), LL(0x2725bb4e0227279c), LL(0x4132588273414119), LL(0x8b2c9d0ba78b8b16),
    LL(0xa7510153f6a7a7a6), LL(0x7dcf94fab27d7de9), LL(0x95dcfb374995956e), LL(0xd88e9fad56d8d847),
    LL(0xfb8b30eb70fbfbcb), LL(0xee2371c1cdeeee9f), LL(0x7cc791f8bb7c7ced), LL(0x6617e3cc71666685),
    LL(0xdda68ea77bdddd53), LL(0x17b84b2eaf17175c), LL(0x4702468e45474701), LL(0x9e84dc211a9e9e42),
    LL(0xca1ec589d4caca0f), LL(0x2d75995a582d2db4), LL(0xbf9179632ebfbfc6), LL(0x07381b0e3f07071c),
    LL(0xad012347acadad8e), LL(0x5aea2fb4b05a5a75), LL(0x836cb51bef838336), LL(0x3385ff66b63333cc),
    LL(0x633ff2c65c636391), LL(0x02100a0412020208), LL(0xaa39384993aaaa92), LL(0x71afa8e2de7171d9),
    LL(0xc80ecf8dc6c8c807), LL(0x19c87d32d1191964), LL(0x497270923b494939), LL(0xd9869aaf5fd9d943),
    LL(0xf2c31df931f2f2ef), LL(0xe34b48dba8e3e3ab), LL(0x5be22ab6b95b5b71), LL(0x8834920dbc88881a),
    LL(0x9aa4c8293e9a9a52), LL(0x262dbe4c0b262698), LL(0x328dfa64bf3232c8), LL(0xb0e94a7d59b0b0fa),
    LL(0xe91b6acff2e9e983), LL(0x0f78331e770f0f3c), LL(0xd5e6a6b733d5d573), LL(0x8074ba1df480803a),
    LL(0xbe997c6127bebec2), LL(0xcd26de87ebcdcd13), LL(0x34bde468893434d0), LL(0x487a75903248483d),
    LL(0xffab24e354ffffdb), LL(0x7af78ff48d7a7af5), LL(0x90f4ea3d6490907a), LL(0x5fc23ebe9d5f5f61),
    LL(0x201da0403d202080), LL(0x6867d5d00f6868bd), LL(0x1ad07234ca1a1a68), LL(0xae192c41b7aeae82),
    LL(0xb4c95e757db4b4ea), LL(0x549a19a8ce54544d), LL(0x93ece53b7f939376), LL(0x220daa442f222288),
    LL(0x6407e9c86364648d), LL(0xf1db12ff2af1f1e3), LL(0x73bfa2e6cc7373d1), LL(0x12905a2482121248),
    LL(0x403a5d807a40401d), LL(0x0840281048080820), LL(0xc356e89b95c3c32b), LL(0xec337bc5dfecec97),
    LL(0xdb9690ab4ddbdb4b), LL(0xa1611f5fc0a1a1be), LL(0x8d1c8307918d8d0e), LL(0x3df5c97ac83d3df4),
    LL(0x97ccf1335b979766), LL(0x0000000000000000), LL(0xcf36d483f9cfcf1b), LL(0x2b4587566e2b2bac),
    LL(0x7697b3ece17676c5), LL(0x8264b019e6828232), LL(0xd6fea9b128d6d67f), LL(0x1bd87736c31b1b6c),
    LL(0xb5c15b7774b5b5ee), LL(0xaf112943beafaf86), LL(0x6a77dfd41d6a6ab5), LL(0x50ba0da0ea50505d),
    LL(0x45124c8a57454509), LL(0xf3cb18fb38f3f3eb), LL(0x309df060ad3030c0), LL(0xef2b74c3c4efef9b),
    LL(0x3fe5c37eda3f3ffc), LL(0x55921caac7555549), LL(0xa2791059dba2a2b2), LL(0xea0365c9e9eaea8f),
    LL(0x650fecca6a656589), LL(0xbab9686903babad2), LL(0x2f65935e4a2f2fbc), LL(0xc04ee79d8ec0c027),
    LL(0xdebe81a160dede5f), LL(0x1ce06c38fc1c1c70), LL(0xfdbb2ee746fdfdd3), LL(0x4d52649a1f4d4d29),
    LL(0x92e4e03976929272), LL(0x758fbceafa7575c9), LL(0x06301e0c36060618), LL(0x8a249809ae8a8a12),
    LL(0xb2f940794bb2b2f2), LL(0xe66359d185e6e6bf), LL(0x0e70361c7e0e0e38), LL(0x1ff8633ee71f1f7c),
    LL(0x6237f7c455626295), LL(0xd4eea3b53ad4d477), LL(0xa829324d81a8a89a), LL(0x96c4f43152969662),
    LL(0xf99b3aef62f9f9c3), LL(0xc566f697a3c5c533), LL(0x2535b14a10252594), LL(0x59f220b2ab595979),
    LL(0x8454ae15d084842a), LL(0x72b7a7e4c57272d5), LL(0x39d5dd72ec3939e4), LL(0x4c5a6198164c4c2d),
    LL(0x5eca3bbc945e5e65), LL(0x78e785f09f7878fd), LL(0x38ddd870e53838e0), LL(0x8c148605988c8c0a),
    LL(0xd1c6b2bf17d1d163), LL(0xa5410b57e4a5a5ae), LL(0xe2434dd9a1e2e2af), LL(0x612ff8c24e616199),
    LL(0xb3f1457b42b3b3f6), LL(0x2115a54234212184), LL(0x9c94d625089c9c4a), LL(0x1ef0663cee1e1e78),
    LL(0x4322528661434311), LL(0xc776fc93b1c7c73b), LL(0xfcb32be54ffcfcd7), LL(0x0420140824040410),
    LL(0x51b208a2e3515159), LL(0x99bcc72f2599995e), LL(0x6d4fc4da226d6da9), LL(0x0d68391a650d0d34),
    LL(0xfa8335e979fafacf), LL(0xdfb684a369dfdf5b), LL(0x7ed79bfca97e7ee5), LL(0x243db44819242490),
    LL(0x3bc5d776fe3b3bec), LL(0xab313d4b9aabab96), LL(0xce3ed181f0cece1f), LL(0x1188552299111144),
    LL(0x8f0c8903838f8f06), LL(0x4e4a6b9c044e4e25), LL(0xb7d1517366b7b7e6), LL(0xeb0b60cbe0ebeb8b),
    LL(0x3cfdcc78c13c3cf0), LL(0x817cbf1ffd81813e), LL(0x94d4fe354094946a), LL(0xf7eb0cf31cf7f7fb),
    LL(0xb9a1676f18b9b9de), LL(0x13985f268b13134c), LL(0x2c7d9c58512c2cb0), LL(0xd3d6b8bb05d3d36b),
    LL(0xe76b5cd38ce7e7bb), LL(0x6e57cbdc396e6ea5), LL(0xc46ef395aac4c437), LL(0x03180f061b03030c),
    LL(0x568a13acdc565645), LL(0x441a49885e44440d), LL(0x7fdf9efea07f7fe1), LL(0xa921374f88a9a99e),
    LL(0x2a4d8254672a2aa8), LL(0xbbb16d6b0abbbbd6), LL(0xc146e29f87c1c123), LL(0x53a202a6f1535351),
    LL(0xdcae8ba572dcdc57), LL(0x0b582716530b0b2c), LL(0x9d9cd327019d9d4e), LL(0x6c47c1d82b6c6cad),
    LL(0x3195f562a43131c4), LL(0x7487b9e8f37474cd), LL(0xf6e309f115f6f6ff), LL(0x460a438c4c464605),
    LL(0xac092645a5acac8a), LL(0x893c970fb589891e), LL(0x14a04428b4141450), LL(0xe15b42dfbae1e1a3),
    LL(0x16b04e2ca6161658), LL(0x3acdd274f73a3ae8), LL(0x696fd0d2066969b9), LL(0x09482d1241090924),
    LL(0x70a7ade0d77070dd), LL(0xb6d954716fb6b6e2), LL(0xd0ceb7bd1ed0d067), LL(0xed3b7ec7d6eded93),
    LL(0xcc2edb85e2cccc17), LL(0x422a578468424215), LL(0x98b4c22d2c98985a), LL(0xa4490e55eda4a4aa),
    LL(0x285d8850752828a0), LL(0x5cda31b8865c5c6d), LL(0xf8933fed6bf8f8c7), LL(0x8644a411c2868622),
};
static const u64 C6[256] = {
    LL(0x6018c07830d81818), LL(0x8c2305af46262323), LL(0x3fc67ef991b8c6c6), LL(0x87e8136fcdfbe8e8),
    LL(0x26874ca113cb8787), LL(0xdab8a9626d11b8b8), LL(0x0401080502090101), LL(0x214f426e9e0d4f4f),
    LL(0xd836adee6c9b3636), LL(0xa2a6590451ffa6a6), LL(0x6fd2debdb90cd2d2), LL(0xf3f5fb06f70ef5f5),
    LL(0xf979ef80f2967979), LL(0xa16f5fcede306f6f), LL(0x7e91fcef3f6d9191), LL(0x5552aa07a4f85252),
    LL(0x9d6027fdc0476060), LL(0xcabc89766535bcbc), LL(0x569baccd2b379b9b), LL(0x028e048c018a8e8e),
    LL(0xb6a371155bd2a3a3), LL(0x300c603c186c0c0c), LL(0xf17bff8af6847b7b), LL(0xd435b5e16a803535),
    LL(0x741de8693af51d1d), LL(0xa7e05347ddb3e0e0), LL(0x7bd7f6acb321d7d7), LL(0x2fc25eed999cc2c2),
    LL(0xb82e6d965c432e2e), LL(0x314b627a96294b4b), LL(0xdffea321e15dfefe), LL(0x41578216aed55757),
    LL(0x5415a8412abd1515), LL(0xc1779fb6eee87777), LL(0xdc37a5eb6e923737), LL(0xb3e57b56d79ee5e5),
    LL(0x469f8cd923139f9f), LL(0xe7f0d317fd23f0f0), LL(0x354a6a7f94204a4a), LL(0x4fda9e95a944dada),
    LL(0x7d58fa25b0a25858), LL(0x03c906ca8fcfc9c9), LL(0xa429558d527c2929), LL(0x280a5022145a0a0a),
    LL(0xfeb1e14f7f50b1b1), LL(0xbaa0691a5dc9a0a0), LL(0xb16b7fdad6146b6b), LL(0x2e855cab17d98585),
    LL(0xcebd8173673cbdbd), LL(0x695dd234ba8f5d5d), LL(0x4010805020901010), LL(0xf7f4f303f507f4f4),
    LL(0x0bcb16c08bddcbcb), LL(0xf83eedc67cd33e3e), LL(0x140528110a2d0505), LL(0x81671fe6ce786767),
    LL(0xb7e47353d597e4e4), LL(0x9c2725bb4e022727), LL(0x1941325882734141), LL(0x168b2c9d0ba78b8b),
    LL(0xa6a7510153f6a7a7), LL(0xe97dcf94fab27d7d), LL(0x6e95dcfb37499595), LL(0x47d88e9fad56d8d8),
    LL(0xcbfb8b30eb70fbfb), LL(0x9fee2371c1cdeeee), LL(0xed7cc791f8bb7c7c), LL(0x856617e3cc716666),
    LL(0x53dda68ea77bdddd), LL(0x5c17b84b2eaf1717), LL(0x014702468e454747), LL(0x429e84dc211a9e9e),
    LL(0x0fca1ec589d4caca), LL(0xb42d75995a582d2d), LL(0xc6bf9179632ebfbf), LL(0x1c07381b0e3f0707),
    LL(0x8ead012347acadad), LL(0x755aea2fb4b05a5a), LL(0x36836cb51bef8383), LL(0xcc3385ff66b63333),
    LL(0x91633ff2c65c6363), LL(0x0802100a04120202), LL(0x92aa39384993aaaa), LL(0xd971afa8e2de7171),
    LL(0x07c80ecf8dc6c8c8), LL(0x6419c87d32d11919), LL(0x39497270923b4949), LL(0x43d9869aaf5fd9d9),
    LL(0xeff2c31df931f2f2), LL(0xabe34b48dba8e3e3), LL(0x715be22ab6b95b5b), LL(0x1a8834920dbc8888),
    LL(0x529aa4c8293e9a9a), LL(0x98262dbe4c0b2626), LL(0xc8328dfa64bf3232), LL(0xfab0e94a7d59b0b0),
    LL(0x83e91b6acff2e9e9), LL(0x3c0f78331e770f0f), LL(0x73d5e6a6b733d5d5), LL(0x3a8074ba1df48080),
    LL(0xc2be997c6127bebe), LL(0x13cd26de87ebcdcd), LL(0xd034bde468893434), LL(0x3d487a7590324848),
    LL(0xdbffab24e354ffff), LL(0xf57af78ff48d7a7a), LL(0x7a90f4ea3d649090), LL(0x615fc23ebe9d5f5f),
    LL(0x80201da0403d2020), LL(0xbd6867d5d00f6868), LL(0x681ad07234ca1a1a), LL(0x82ae192c41b7aeae),
    LL(0xeab4c95e757db4b4), LL(0x4d549a19a8ce5454), LL(0x7693ece53b7f9393), LL(0x88220daa442f2222),
    LL(0x8d6407e9c8636464), LL(0xe3f1db12ff2af1f1), LL(0xd173bfa2e6cc7373), LL(0x4812905a24821212),
    LL(0x1d403a5d807a4040), LL(0x2008402810480808), LL(0x2bc356e89b95c3c3), LL(0x97ec337bc5dfecec),
    LL(0x4bdb9690ab4ddbdb), LL(0xbea1611f5fc0a1a1), LL(0x0e8d1c8307918d8d), LL(0xf43df5c97ac83d3d),
    LL(0x6697ccf1335b9797), LL(0x0000000000000000), LL(0x1bcf36d483f9cfcf), LL(0xac2b4587566e2b2b),
    LL(0xc57697b3ece17676), LL(0x328264b019e68282), LL(0x7fd6fea9b128d6d6), LL(0x6c1bd87736c31b1b),
    LL(0xeeb5c15b7774b5b5), LL(0x86af112943beafaf), LL(0xb56a77dfd41d6a6a), LL(0x5d50ba0da0ea5050),
    LL(0x0945124c8a574545), LL(0xebf3cb18fb38f3f3), LL(0xc0309df060ad3030), LL(0x9bef2b74c3c4efef),
    LL(0xfc3fe5c37eda3f3f), LL(0x4955921caac75555), LL(0xb2a2791059dba2a2), LL(0x8fea0365c9e9eaea),
    LL(0x89650fecca6a6565), LL(0xd2bab9686903baba), LL(0xbc2f65935e4a2f2f), LL(0x27c04ee79d8ec0c0),
    LL(0x5fdebe81a160dede), LL(0x701ce06c38fc1c1c), LL(0xd3fdbb2ee746fdfd), LL(0x294d52649a1f4d4d),
    LL(0x7292e4e039769292), LL(0xc9758fbceafa7575), LL(0x1806301e0c360606), LL(0x128a249809ae8a8a),
    LL(0xf2b2f940794bb2b2), LL(0xbfe66359d185e6e6), LL(0x380e70361c7e0e0e), LL(0x7c1ff8633ee71f1f),
    LL(0x956237f7c4556262), LL(0x77d4eea3b53ad4d4), LL(0x9aa829324d81a8a8), LL(0x6296c4f431529696),
    LL(0xc3f99b3aef62f9f9), LL(0x33c566f697a3c5c5), LL(0x942535b14a102525), LL(0x7959f220b2ab5959),
    LL(0x2a8454ae15d08484), LL(0xd572b7a7e4c57272), LL(0xe439d5dd72ec3939), LL(0x2d4c5a6198164c4c),
    LL(0x655eca3bbc945e5e), LL(0xfd78e785f09f7878), LL(0xe038ddd870e53838), LL(0x0a8c148605988c8c),
    LL(0x63d1c6b2bf17d1d1), LL(0xaea5410b57e4a5a5), LL(0xafe2434dd9a1e2e2), LL(0x99612ff8c24e6161),
    LL(0xf6b3f1457b42b3b3), LL(0x842115a542342121), LL(0x4a9c94d625089c9c), LL(0x781ef0663cee1e1e),
    LL(0x1143225286614343), LL(0x3bc776fc93b1c7c7), LL(0xd7fcb32be54ffcfc), LL(0x1004201408240404),
    LL(0x5951b208a2e35151), LL(0x5e99bcc72f259999), LL(0xa96d4fc4da226d6d), LL(0x340d68391a650d0d),
    LL(0xcffa8335e979fafa), LL(0x5bdfb684a369dfdf), LL(0xe57ed79bfca97e7e), LL(0x90243db448192424),
    LL(0xec3bc5d776fe3b3b), LL(0x96ab313d4b9aabab), LL(0x1fce3ed181f0cece), LL(0x4411885522991111),
    LL(0x068f0c8903838f8f), LL(0x254e4a6b9c044e4e), LL(0xe6b7d1517366b7b7), LL(0x8beb0b60cbe0ebeb),
    LL(0xf03cfdcc78c13c3c), LL(0x3e817cbf1ffd8181), LL(0x6a94d4fe35409494), LL(0xfbf7eb0cf31cf7f7),
    LL(0xdeb9a1676f18b9b9), LL(0x4c13985f268b1313), LL(0xb02c7d9c58512c2c), LL(0x6bd3d6b8bb05d3d3),
    LL(0xbbe76b5cd38ce7e7), LL(0xa56e57cbdc396e6e), LL(0x37c46ef395aac4c4), LL(0x0c03180f061b0303),
    LL(0x45568a13acdc5656), LL(0x0d441a49885e4444), LL(0xe17fdf9efea07f7f), LL(0x9ea921374f88a9a9),
    LL(0xa82a4d8254672a2a), LL(0xd6bbb16d6b0abbbb), LL(0x23c146e29f87c1c1), LL(0x5153a202a6f15353),
    LL(0x57dcae8ba572dcdc), LL(0x2c0b582716530b0b), LL(0x4e9d9cd327019d9d), LL(0xad6c47c1d82b6c6c),
    LL(0xc43195f562a43131), LL(0xcd7487b9e8f37474), LL(0xfff6e309f115f6f6), LL(0x05460a438c4c4646),
    LL(0x8aac092645a5acac), LL(0x1e893c970fb58989), LL(0x5014a04428b41414), LL(0xa3e15b42dfbae1e1),
    LL(0x5816b04e2ca61616), LL(0xe83acdd274f73a3a), LL(0xb9696fd0d2066969), LL(0x2409482d12410909),
    LL(0xdd70a7ade0d77070), LL(0xe2b6d954716fb6b6), LL(0x67d0ceb7bd1ed0d0), LL(0x93ed3b7ec7d6eded),
    LL(0x17cc2edb85e2cccc), LL(0x15422a5784684242), LL(0x5a98b4c22d2c9898), LL(0xaaa4490e55eda4a4),
    LL(0xa0285d8850752828), LL(0x6d5cda31b8865c5c), LL(0xc7f8933fed6bf8f8), LL(0x228644a411c28686),
};
static const u64 C7[256] = {
    LL(0x186018c07830d818), LL(0x238c2305af462623), LL(0xc63fc67ef991b8c6), LL(0xe887e8136fcdfbe8),
    LL(0x8726874ca113cb87), LL(0xb8dab8a9626d11b8), LL(0x0104010805020901), LL(0x4f214f426e9e0d4f),
    LL(0x36d836adee6c9b36), LL(0xa6a2a6590451ffa6), LL(0xd26fd2debdb90cd2), LL(0xf5f3f5fb06f70ef5),
    LL(0x79f979ef80f29679), LL(0x6fa16f5fcede306f), LL(0x917e91fcef3f6d91), LL(0x525552aa07a4f852),
    LL(0x609d6027fdc04760), LL(0xbccabc89766535bc), LL(0x9b569baccd2b379b), LL(0x8e028e048c018a8e),
    LL(0xa3b6a371155bd2a3), LL(0x0c300c603c186c0c), LL(0x7bf17bff8af6847b), LL(0x35d435b5e16a8035),
    LL(0x1d741de8693af51d), LL(0xe0a7e05347ddb3e0), LL(0xd77bd7f6acb321d7), LL(0xc22fc25eed999cc2),
    LL(0x2eb82e6d965c432e), LL(0x4b314b627a96294b), LL(0xfedffea321e15dfe), LL(0x5741578216aed557),
    LL(0x155415a8412abd15), LL(0x77c1779fb6eee877), LL(0x37dc37a5eb6e9237), LL(0xe5b3e57b56d79ee5),
    LL(0x9f469f8cd923139f), LL(0xf0e7f0d317fd23f0), LL(0x4a354a6a7f94204a), LL(0xda4fda9e95a944da),
    LL(0x587d58fa25b0a258), LL(0xc903c906ca8fcfc9), LL(0x29a429558d527c29), LL(0x0a280a5022145a0a),
    LL(0xb1feb1e14f7f50b1), LL(0xa0baa0691a5dc9a0), LL(0x6bb16b7fdad6146b), LL(0x852e855cab17d985),
    LL(0xbdcebd8173673cbd), LL(0x5d695dd234ba8f5d), LL(0x1040108050209010), LL(0xf4f7f4f303f507f4),
    LL(0xcb0bcb16c08bddcb), LL(0x3ef83eedc67cd33e), LL(0x05140528110a2d05), LL(0x6781671fe6ce7867),
    LL(0xe4b7e47353d597e4), LL(0x279c2725bb4e0227), LL(0x4119413258827341), LL(0x8b168b2c9d0ba78b),
    LL(0xa7a6a7510153f6a7), LL(0x7de97dcf94fab27d), LL(0x956e95dcfb374995), LL(0xd847d88e9fad56d8),
    LL(0xfbcbfb8b30eb70fb), LL(0xee9fee2371c1cdee), LL(0x7ced7cc791f8bb7c), LL(0x66856617e3cc7166),
    LL(0xdd53dda68ea77bdd), LL(0x175c17b84b2eaf17), LL(0x47014702468e4547), LL(0x9e429e84dc211a9e),
    LL(0xca0fca1ec589d4ca), LL(0x2db42d75995a582d), LL(0xbfc6bf9179632ebf), LL(0x071c07381b0e3f07),
    LL(0xad8ead012347acad), LL(0x5a755aea2fb4b05a), LL(0x8336836cb51bef83), LL(0x33cc3385ff66b633),
    LL(0x6391633ff2c65c63), LL(0x020802100a041202), LL(0xaa92aa39384993aa), LL(0x71d971afa8e2de71),
    LL(0xc807c80ecf8dc6c8), LL(0x196419c87d32d119), LL(0x4939497270923b49), LL(0xd943d9869aaf5fd9),
    LL(0xf2eff2c31df931f2), LL(0xe3abe34b48dba8e3), LL(0x5b715be22ab6b95b), LL(0x881a8834920dbc88),
    LL(0x9a529aa4c8293e9a), LL(0x2698262dbe4c0b26), LL(0x32c8328dfa64bf32), LL(0xb0fab0e94a7d59b0),
    LL(0xe983e91b6acff2e9), LL(0x0f3c0f78331e770f), LL(0xd573d5e6a6b733d5), LL(0x803a8074ba1df480),
    LL(0xbec2be997c6127be), LL(0xcd13cd26de87ebcd), LL(0x34d034bde4688934), LL(0x483d487a75903248),
    LL(0xffdbffab24e354ff), LL(0x7af57af78ff48d7a), LL(0x907a90f4ea3d6490), LL(0x5f615fc23ebe9d5f),
    LL(0x2080201da0403d20), LL(0x68bd6867d5d00f68), LL(0x1a681ad07234ca1a), LL(0xae82ae192c41b7ae),
    LL(0xb4eab4c95e757db4), LL(0x544d549a19a8ce54), LL(0x937693ece53b7f93), LL(0x2288220daa442f22),
    LL(0x648d6407e9c86364), LL(0xf1e3f1db12ff2af1), LL(0x73d173bfa2e6cc73), LL(0x124812905a248212),
    LL(0x401d403a5d807a40), LL(0x0820084028104808), LL(0xc32bc356e89b95c3), LL(0xec97ec337bc5dfec),
    LL(0xdb4bdb9690ab4ddb), LL(0xa1bea1611f5fc0a1), LL(0x8d0e8d1c8307918d), LL(0x3df43df5c97ac83d),
    LL(0x976697ccf1335b97), LL(0x0000000000000000), LL(0xcf1bcf36d483f9cf), LL(0x2bac2b4587566e2b),
    LL(0x76c57697b3ece176), LL(0x82328264b019e682), LL(0xd67fd6fea9b128d6), LL(0x1b6c1bd87736c31b),
    LL(0xb5eeb5c15b7774b5), LL(0xaf86af112943beaf), LL(0x6ab56a77dfd41d6a), LL(0x505d50ba0da0ea50),
    LL(0x450945124c8a5745), LL(0xf3ebf3cb18fb38f3), LL(0x30c0309df060ad30), LL(0xef9bef2b74c3c4ef),
    LL(0x3ffc3fe5c37eda3f), LL(0x554955921caac755), LL(0xa2b2a2791059dba2), LL(0xea8fea0365c9e9ea),
    LL(0x6589650fecca6a65), LL(0xbad2bab9686903ba), LL(0x2fbc2f65935e4a2f), LL(0xc027c04ee79d8ec0),
    LL(0xde5fdebe81a160de), LL(0x1c701ce06c38fc1c), LL(0xfdd3fdbb2ee746fd), LL(0x4d294d52649a1f4d),
    LL(0x927292e4e0397692), LL(0x75c9758fbceafa75), LL(0x061806301e0c3606), LL(0x8a128a249809ae8a),
    LL(0xb2f2b2f940794bb2), LL(0xe6bfe66359d185e6), LL(0x0e380e70361c7e0e), LL(0x1f7c1ff8633ee71f),
    LL(0x62956237f7c45562), LL(0xd477d4eea3b53ad4), LL(0xa89aa829324d81a8), LL(0x966296c4f4315296),
    LL(0xf9c3f99b3aef62f9), LL(0xc533c566f697a3c5), LL(0x25942535b14a1025), LL(0x597959f220b2ab59),
    LL(0x842a8454ae15d084), LL(0x72d572b7a7e4c572), LL(0x39e439d5dd72ec39), LL(0x4c2d4c5a6198164c),
    LL(0x5e655eca3bbc945e), LL(0x78fd78e785f09f78), LL(0x38e038ddd870e538), LL(0x8c0a8c148605988c),
    LL(0xd163d1c6b2bf17d1), LL(0xa5aea5410b57e4a5), LL(0xe2afe2434dd9a1e2), LL(0x6199612ff8c24e61),
    LL(0xb3f6b3f1457b42b3), LL(0x21842115a5423421), LL(0x9c4a9c94d625089c), LL(0x1e781ef0663cee1e),
    LL(0x4311432252866143), LL(0xc73bc776fc93b1c7), LL(0xfcd7fcb32be54ffc), LL(0x0410042014082404),
    LL(0x515951b208a2e351), LL(0x995e99bcc72f2599), LL(0x6da96d4fc4da226d), LL(0x0d340d68391a650d),
    LL(0xfacffa8335e979fa), LL(0xdf5bdfb684a369df), LL(0x7ee57ed79bfca97e), LL(0x2490243db4481924),
    LL(0x3bec3bc5d776fe3b), LL(0xab96ab313d4b9aab), LL(0xce1fce3ed181f0ce), LL(0x1144118855229911),
    LL(0x8f068f0c8903838f), LL(0x4e254e4a6b9c044e), LL(0xb7e6b7d1517366b7), LL(0xeb8beb0b60cbe0eb),
    LL(0x3cf03cfdcc78c13c), LL(0x813e817cbf1ffd81), LL(0x946a94d4fe354094), LL(0xf7fbf7eb0cf31cf7),
    LL(0xb9deb9a1676f18b9), LL(0x134c13985f268b13), LL(0x2cb02c7d9c58512c), LL(0xd36bd3d6b8bb05d3),
    LL(0xe7bbe76b5cd38ce7), LL(0x6ea56e57cbdc396e), LL(0xc437c46ef395aac4), LL(0x030c03180f061b03),
    LL(0x5645568a13acdc56), LL(0x440d441a49885e44), LL(0x7fe17fdf9efea07f), LL(0xa99ea921374f88a9),
    LL(0x2aa82a4d8254672a), LL(0xbbd6bbb16d6b0abb), LL(0xc123c146e29f87c1), LL(0x535153a202a6f153),
    LL(0xdc57dcae8ba572dc), LL(0x0b2c0b582716530b), LL(0x9d4e9d9cd327019d), LL(0x6cad6c47c1d82b6c),
    LL(0x31c43195f562a431), LL(0x74cd7487b9e8f374), LL(0xf6fff6e309f115f6), LL(0x4605460a438c4c46),
    LL(0xac8aac092645a5ac), LL(0x891e893c970fb589), LL(0x145014a04428b414), LL(0xe1a3e15b42dfbae1),
    LL(0x165816b04e2ca616), LL(0x3ae83acdd274f73a), LL(0x69b9696fd0d20669), LL(0x092409482d124109),
    LL(0x70dd70a7ade0d770), LL(0xb6e2b6d954716fb6), LL(0xd067d0ceb7bd1ed0), LL(0xed93ed3b7ec7d6ed),
    LL(0xcc17cc2edb85e2cc), LL(0x4215422a57846842), LL(0x985a98b4c22d2c98), LL(0xa4aaa4490e55eda4),
    LL(0x28a0285d88507528), LL(0x5c6d5cda31b8865c), LL(0xf8c7f8933fed6bf8), LL(0x86228644a411c286),
};
static const u64 rc[WHIRLPOOL_R + 1] = {
    LL(0x0000000000000000),
    LL(0x1823c6e887b8014f),
    LL(0x36a6d2f5796f9152),
    LL(0x60bc9b8ea30c7b35),
    LL(0x1de0d7c22e4bfe57),
    LL(0x157737e59ff04ada),
    LL(0x58c9290ab1a06b85),
    LL(0xbd5d10f4cb3e0567),
    LL(0xe427418ba77d95d8),
    LL(0xfbee7c66dd17479e),
    LL(0xca2dbf07ad5a8333),
};
static void processBuffer(struct NESSIEstruct * const structpointer) {
    int i, r;
    u64 K[8];        
    u64 block[8];    
    u64 state[8];    
    u64 L[8];
    u8 *buffer = structpointer->buffer;
    for (i = 0; i < 8; i++, buffer += 8) {
        block[i] =
            (((u64)buffer[0]        ) << 56) ^
            (((u64)buffer[1] & 0xffL) << 48) ^
            (((u64)buffer[2] & 0xffL) << 40) ^
            (((u64)buffer[3] & 0xffL) << 32) ^
            (((u64)buffer[4] & 0xffL) << 24) ^
            (((u64)buffer[5] & 0xffL) << 16) ^
            (((u64)buffer[6] & 0xffL) <<  8) ^
            (((u64)buffer[7] & 0xffL)      );
    }
    state[0] = block[0] ^ (K[0] = structpointer->hash[0]);
    state[1] = block[1] ^ (K[1] = structpointer->hash[1]);
    state[2] = block[2] ^ (K[2] = structpointer->hash[2]);
    state[3] = block[3] ^ (K[3] = structpointer->hash[3]);
    state[4] = block[4] ^ (K[4] = structpointer->hash[4]);
    state[5] = block[5] ^ (K[5] = structpointer->hash[5]);
    state[6] = block[6] ^ (K[6] = structpointer->hash[6]);
    state[7] = block[7] ^ (K[7] = structpointer->hash[7]);
    for (r = 1; r <= WHIRLPOOL_R; r++) {
        L[0] =
            C0[(int)(K[0] >> 56)       ] ^
            C1[(int)(K[7] >> 48) & 0xff] ^
            C2[(int)(K[6] >> 40) & 0xff] ^
            C3[(int)(K[5] >> 32) & 0xff] ^
            C4[(int)(K[4] >> 24) & 0xff] ^
            C5[(int)(K[3] >> 16) & 0xff] ^
            C6[(int)(K[2] >>  8) & 0xff] ^
            C7[(int)(K[1]      ) & 0xff] ^
            rc[r];
        L[1] =
            C0[(int)(K[1] >> 56)       ] ^
            C1[(int)(K[0] >> 48) & 0xff] ^
            C2[(int)(K[7] >> 40) & 0xff] ^
            C3[(int)(K[6] >> 32) & 0xff] ^
            C4[(int)(K[5] >> 24) & 0xff] ^
            C5[(int)(K[4] >> 16) & 0xff] ^
            C6[(int)(K[3] >>  8) & 0xff] ^
            C7[(int)(K[2]      ) & 0xff];
        L[2] =
            C0[(int)(K[2] >> 56)       ] ^
            C1[(int)(K[1] >> 48) & 0xff] ^
            C2[(int)(K[0] >> 40) & 0xff] ^
            C3[(int)(K[7] >> 32) & 0xff] ^
            C4[(int)(K[6] >> 24) & 0xff] ^
            C5[(int)(K[5] >> 16) & 0xff] ^
            C6[(int)(K[4] >>  8) & 0xff] ^
            C7[(int)(K[3]      ) & 0xff];
        L[3] =
            C0[(int)(K[3] >> 56)       ] ^
            C1[(int)(K[2] >> 48) & 0xff] ^
            C2[(int)(K[1] >> 40) & 0xff] ^
            C3[(int)(K[0] >> 32) & 0xff] ^
            C4[(int)(K[7] >> 24) & 0xff] ^
            C5[(int)(K[6] >> 16) & 0xff] ^
            C6[(int)(K[5] >>  8) & 0xff] ^
            C7[(int)(K[4]      ) & 0xff];
        L[4] =
            C0[(int)(K[4] >> 56)       ] ^
            C1[(int)(K[3] >> 48) & 0xff] ^
            C2[(int)(K[2] >> 40) & 0xff] ^
            C3[(int)(K[1] >> 32) & 0xff] ^
            C4[(int)(K[0] >> 24) & 0xff] ^
            C5[(int)(K[7] >> 16) & 0xff] ^
            C6[(int)(K[6] >>  8) & 0xff] ^
            C7[(int)(K[5]      ) & 0xff];
        L[5] =
            C0[(int)(K[5] >> 56)       ] ^
            C1[(int)(K[4] >> 48) & 0xff] ^
            C2[(int)(K[3] >> 40) & 0xff] ^
            C3[(int)(K[2] >> 32) & 0xff] ^
            C4[(int)(K[1] >> 24) & 0xff] ^
            C5[(int)(K[0] >> 16) & 0xff] ^
            C6[(int)(K[7] >>  8) & 0xff] ^
            C7[(int)(K[6]      ) & 0xff];
        L[6] =
            C0[(int)(K[6] >> 56)       ] ^
            C1[(int)(K[5] >> 48) & 0xff] ^
            C2[(int)(K[4] >> 40) & 0xff] ^
            C3[(int)(K[3] >> 32) & 0xff] ^
            C4[(int)(K[2] >> 24) & 0xff] ^
            C5[(int)(K[1] >> 16) & 0xff] ^
            C6[(int)(K[0] >>  8) & 0xff] ^
            C7[(int)(K[7]      ) & 0xff];
        L[7] =
            C0[(int)(K[7] >> 56)       ] ^
            C1[(int)(K[6] >> 48) & 0xff] ^
            C2[(int)(K[5] >> 40) & 0xff] ^
            C3[(int)(K[4] >> 32) & 0xff] ^
            C4[(int)(K[3] >> 24) & 0xff] ^
            C5[(int)(K[2] >> 16) & 0xff] ^
            C6[(int)(K[1] >>  8) & 0xff] ^
            C7[(int)(K[0]      ) & 0xff];
        K[0] = L[0];
        K[1] = L[1];
        K[2] = L[2];
        K[3] = L[3];
        K[4] = L[4];
        K[5] = L[5];
        K[6] = L[6];
        K[7] = L[7];
        L[0] =
            C0[(int)(state[0] >> 56)       ] ^
            C1[(int)(state[7] >> 48) & 0xff] ^
            C2[(int)(state[6] >> 40) & 0xff] ^
            C3[(int)(state[5] >> 32) & 0xff] ^
            C4[(int)(state[4] >> 24) & 0xff] ^
            C5[(int)(state[3] >> 16) & 0xff] ^
            C6[(int)(state[2] >>  8) & 0xff] ^
            C7[(int)(state[1]      ) & 0xff] ^
            K[0];
        L[1] =
            C0[(int)(state[1] >> 56)       ] ^
            C1[(int)(state[0] >> 48) & 0xff] ^
            C2[(int)(state[7] >> 40) & 0xff] ^
            C3[(int)(state[6] >> 32) & 0xff] ^
            C4[(int)(state[5] >> 24) & 0xff] ^
            C5[(int)(state[4] >> 16) & 0xff] ^
            C6[(int)(state[3] >>  8) & 0xff] ^
            C7[(int)(state[2]      ) & 0xff] ^
            K[1];
        L[2] =
            C0[(int)(state[2] >> 56)       ] ^
            C1[(int)(state[1] >> 48) & 0xff] ^
            C2[(int)(state[0] >> 40) & 0xff] ^
            C3[(int)(state[7] >> 32) & 0xff] ^
            C4[(int)(state[6] >> 24) & 0xff] ^
            C5[(int)(state[5] >> 16) & 0xff] ^
            C6[(int)(state[4] >>  8) & 0xff] ^
            C7[(int)(state[3]      ) & 0xff] ^
            K[2];
        L[3] =
            C0[(int)(state[3] >> 56)       ] ^
            C1[(int)(state[2] >> 48) & 0xff] ^
            C2[(int)(state[1] >> 40) & 0xff] ^
            C3[(int)(state[0] >> 32) & 0xff] ^
            C4[(int)(state[7] >> 24) & 0xff] ^
            C5[(int)(state[6] >> 16) & 0xff] ^
            C6[(int)(state[5] >>  8) & 0xff] ^
            C7[(int)(state[4]      ) & 0xff] ^
            K[3];
        L[4] =
            C0[(int)(state[4] >> 56)       ] ^
            C1[(int)(state[3] >> 48) & 0xff] ^
            C2[(int)(state[2] >> 40) & 0xff] ^
            C3[(int)(state[1] >> 32) & 0xff] ^
            C4[(int)(state[0] >> 24) & 0xff] ^
            C5[(int)(state[7] >> 16) & 0xff] ^
            C6[(int)(state[6] >>  8) & 0xff] ^
            C7[(int)(state[5]      ) & 0xff] ^
            K[4];
        L[5] =
            C0[(int)(state[5] >> 56)       ] ^
            C1[(int)(state[4] >> 48) & 0xff] ^
            C2[(int)(state[3] >> 40) & 0xff] ^
            C3[(int)(state[2] >> 32) & 0xff] ^
            C4[(int)(state[1] >> 24) & 0xff] ^
            C5[(int)(state[0] >> 16) & 0xff] ^
            C6[(int)(state[7] >>  8) & 0xff] ^
            C7[(int)(state[6]      ) & 0xff] ^
            K[5];
        L[6] =
            C0[(int)(state[6] >> 56)       ] ^
            C1[(int)(state[5] >> 48) & 0xff] ^
            C2[(int)(state[4] >> 40) & 0xff] ^
            C3[(int)(state[3] >> 32) & 0xff] ^
            C4[(int)(state[2] >> 24) & 0xff] ^
            C5[(int)(state[1] >> 16) & 0xff] ^
            C6[(int)(state[0] >>  8) & 0xff] ^
            C7[(int)(state[7]      ) & 0xff] ^
            K[6];
        L[7] =
            C0[(int)(state[7] >> 56)       ] ^
            C1[(int)(state[6] >> 48) & 0xff] ^
            C2[(int)(state[5] >> 40) & 0xff] ^
            C3[(int)(state[4] >> 32) & 0xff] ^
            C4[(int)(state[3] >> 24) & 0xff] ^
            C5[(int)(state[2] >> 16) & 0xff] ^
            C6[(int)(state[1] >>  8) & 0xff] ^
            C7[(int)(state[0]      ) & 0xff] ^
            K[7];
        state[0] = L[0];
        state[1] = L[1];
        state[2] = L[2];
        state[3] = L[3];
        state[4] = L[4];
        state[5] = L[5];
        state[6] = L[6];
        state[7] = L[7];
    }
    structpointer->hash[0] ^= state[0] ^ block[0];
    structpointer->hash[1] ^= state[1] ^ block[1];
    structpointer->hash[2] ^= state[2] ^ block[2];
    structpointer->hash[3] ^= state[3] ^ block[3];
    structpointer->hash[4] ^= state[4] ^ block[4];
    structpointer->hash[5] ^= state[5] ^ block[5];
    structpointer->hash[6] ^= state[6] ^ block[6];
    structpointer->hash[7] ^= state[7] ^ block[7];
}
void NESSIEinit(struct NESSIEstruct * const structpointer) {
    int i;
    memset(structpointer->bitLength, 0, 32);
    structpointer->bufferBits = structpointer->bufferPos = 0;
    structpointer->buffer[0] = 0; 
    for (i = 0; i < 8; i++) {
        structpointer->hash[i] = 0L; 
    }
}
void NESSIEadd(const unsigned char * const source,
			   unsigned long sourceBits,
               struct NESSIEstruct * const structpointer) {
    int sourcePos    = 0; 
    int sourceGap    = (8 - ((int)sourceBits & 7)) & 7; 
    int bufferRem    = structpointer->bufferBits & 7; 
    int i;
    u32 b, carry;
    u8 *buffer       = structpointer->buffer;
    u8 *bitLength    = structpointer->bitLength;
    int bufferBits   = structpointer->bufferBits;
    int bufferPos    = structpointer->bufferPos;
    u64 value = sourceBits;
    for (i = 31, carry = 0; i >= 0 && (carry != 0 || value != LL(0)); i--) {
        carry += bitLength[i] + ((u32)value & 0xff);
        bitLength[i] = (u8)carry;
        carry >>= 8;
        value >>= 8;
    }
    while (sourceBits > 8) {
        b = ((source[sourcePos] << sourceGap) & 0xff) |
            ((source[sourcePos + 1] & 0xff) >> (8 - sourceGap));
        buffer[bufferPos++] |= (u8)(b >> bufferRem);
        bufferBits += 8 - bufferRem; 
        if (bufferBits == DIGESTBITS) {
            processBuffer(structpointer);
            bufferBits = bufferPos = 0;
        }
        buffer[bufferPos] = b << (8 - bufferRem);
        bufferBits += bufferRem;
        sourceBits -= 8;
        sourcePos++;
    }
    if (sourceBits > 0) {
        b = (source[sourcePos] << sourceGap) & 0xff; 
        buffer[bufferPos] |= b >> bufferRem;
    } else {
        b = 0;
    }
    if (bufferRem + sourceBits < 8) {
        bufferBits += sourceBits;
    } else {
        bufferPos++;
        bufferBits += 8 - bufferRem; 
        sourceBits -= 8 - bufferRem;
        if (bufferBits == DIGESTBITS) {
            processBuffer(structpointer);
            bufferBits = bufferPos = 0;
        }
        buffer[bufferPos] = b << (8 - bufferRem);
        bufferBits += (int)sourceBits;
    }
    structpointer->bufferBits   = bufferBits;
    structpointer->bufferPos    = bufferPos;
}
void NESSIEadd64(const unsigned char * const source,
			   uint64_t sourceBits,
               struct NESSIEstruct * const structpointer) {
    int sourcePos    = 0; 
    int sourceGap    = (8 - ((int)sourceBits & 7)) & 7; 
    int bufferRem    = structpointer->bufferBits & 7; 
    int i;
    u32 b, carry;
    u8 *buffer       = structpointer->buffer;
    u8 *bitLength    = structpointer->bitLength;
    int bufferBits   = structpointer->bufferBits;
    int bufferPos    = structpointer->bufferPos;
    u64 value = sourceBits;
    for (i = 31, carry = 0; i >= 0 && (carry != 0 || value != LL(0)); i--) {
        carry += bitLength[i] + ((u32)value & 0xff);
        bitLength[i] = (u8)carry;
        carry >>= 8;
        value >>= 8;
    }
    while (sourceBits > 8) {
        b = ((source[sourcePos] << sourceGap) & 0xff) |
            ((source[sourcePos + 1] & 0xff) >> (8 - sourceGap));
        buffer[bufferPos++] |= (u8)(b >> bufferRem);
        bufferBits += 8 - bufferRem; 
        if (bufferBits == DIGESTBITS) {
            processBuffer(structpointer);
            bufferBits = bufferPos = 0;
        }
        buffer[bufferPos] = b << (8 - bufferRem);
        bufferBits += bufferRem;
        sourceBits -= 8;
        sourcePos++;
    }
    if (sourceBits > 0) {
        b = (source[sourcePos] << sourceGap) & 0xff; 
        buffer[bufferPos] |= b >> bufferRem;
    } else {
        b = 0;
    }
    if (bufferRem + sourceBits < 8) {
        bufferBits += sourceBits;
    } else {
        bufferPos++;
        bufferBits += 8 - bufferRem; 
        sourceBits -= 8 - bufferRem;
        if (bufferBits == DIGESTBITS) {
            processBuffer(structpointer);
            bufferBits = bufferPos = 0;
        }
        buffer[bufferPos] = b << (8 - bufferRem);
        bufferBits += (int)sourceBits;
    }
    structpointer->bufferBits   = bufferBits;
    structpointer->bufferPos    = bufferPos;
}
void NESSIEfinalize(struct NESSIEstruct * const structpointer,
                    unsigned char * const result) {
    int i;
    u8 *buffer      = structpointer->buffer;
    u8 *bitLength   = structpointer->bitLength;
    int bufferBits  = structpointer->bufferBits;
    int bufferPos   = structpointer->bufferPos;
    u8 *digest      = result;
    buffer[bufferPos] |= 0x80U >> (bufferBits & 7);
    bufferPos++; 
    if (bufferPos > WBLOCKBYTES - LENGTHBYTES) {
        if (bufferPos < WBLOCKBYTES) {
            memset(&buffer[bufferPos], 0, WBLOCKBYTES - bufferPos);
        }
        processBuffer(structpointer);
        bufferPos = 0;
    }
    if (bufferPos < WBLOCKBYTES - LENGTHBYTES) {
        memset(&buffer[bufferPos], 0, (WBLOCKBYTES - LENGTHBYTES) - bufferPos);
    }
    bufferPos = WBLOCKBYTES - LENGTHBYTES;
    memcpy(&buffer[WBLOCKBYTES - LENGTHBYTES], bitLength, LENGTHBYTES);
    processBuffer(structpointer);
    for (i = 0; i < DIGESTBYTES/8; i++) {
        digest[0] = (u8)(structpointer->hash[i] >> 56);
        digest[1] = (u8)(structpointer->hash[i] >> 48);
        digest[2] = (u8)(structpointer->hash[i] >> 40);
        digest[3] = (u8)(structpointer->hash[i] >> 32);
        digest[4] = (u8)(structpointer->hash[i] >> 24);
        digest[5] = (u8)(structpointer->hash[i] >> 16);
        digest[6] = (u8)(structpointer->hash[i] >>  8);
        digest[7] = (u8)(structpointer->hash[i]      );
        digest += 8;
    }
    structpointer->bufferBits   = bufferBits;
    structpointer->bufferPos    = bufferPos;
}
#define wyhash_final_version_3
#ifndef WYHASH_CONDOM
#define WYHASH_CONDOM 1
#endif
#ifndef WYHASH_32BIT_MUM
#define WYHASH_32BIT_MUM 0  
#endif
#include <stdint.h>
#include <string.h>
#if defined(_MSC_VER) && defined(_M_X64)
  #include <intrin.h>
  #pragma intrinsic(_umul128)
#endif
#if defined(__GNUC__) || defined(__INTEL_COMPILER) || defined(__clang__)
  #define _likely_(x)  __builtin_expect(x,1)
  #define _unlikely_(x)  __builtin_expect(x,0)
#else
  #define _likely_(x) (x)
  #define _unlikely_(x) (x)
#endif
static inline uint64_t _wyrot(uint64_t x) { return (x>>32)|(x<<32); }
static inline void _wymum(uint64_t *A, uint64_t *B){
#if(WYHASH_32BIT_MUM)
  uint64_t hh=(*A>>32)*(*B>>32), hl=(*A>>32)*(uint32_t)*B, lh=(uint32_t)*A*(*B>>32), ll=(uint64_t)(uint32_t)*A*(uint32_t)*B;
  #if(WYHASH_CONDOM>1)
  *A^=_wyrot(hl)^hh; *B^=_wyrot(lh)^ll;
  #else
  *A=_wyrot(hl)^hh; *B=_wyrot(lh)^ll;
  #endif
#elif defined(__SIZEOF_INT128__)
  __uint128_t r=*A; r*=*B; 
  #if(WYHASH_CONDOM>1)
  *A^=(uint64_t)r; *B^=(uint64_t)(r>>64);
  #else
  *A=(uint64_t)r; *B=(uint64_t)(r>>64);
  #endif
#elif defined(_MSC_VER) && defined(_M_X64)
  #if(WYHASH_CONDOM>1)
  uint64_t  a,  b;
  a=_umul128(*A,*B,&b);
  *A^=a;  *B^=b;
  #else
  *A=_umul128(*A,*B,B);
  #endif
#else
  uint64_t ha=*A>>32, hb=*B>>32, la=(uint32_t)*A, lb=(uint32_t)*B, hi, lo;
  uint64_t rh=ha*hb, rm0=ha*lb, rm1=hb*la, rl=la*lb, t=rl+(rm0<<32), c=t<rl;
  lo=t+(rm1<<32); c+=lo<t; hi=rh+(rm0>>32)+(rm1>>32)+c;
  #if(WYHASH_CONDOM>1)
  *A^=lo;  *B^=hi;
  #else
  *A=lo;  *B=hi;
  #endif
#endif
}
static inline uint64_t _wymix(uint64_t A, uint64_t B){ _wymum(&A,&B); return A^B; }
#ifndef WYHASH_LITTLE_ENDIAN
  #if defined(_WIN32) || defined(__LITTLE_ENDIAN__) || (defined(__BYTE_ORDER__) && __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__)
    #define WYHASH_LITTLE_ENDIAN 1
  #elif defined(__BIG_ENDIAN__) || (defined(__BYTE_ORDER__) && __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__)
    #define WYHASH_LITTLE_ENDIAN 0
  #else
    #warning could not determine endianness! Falling back to little endian.
    #define WYHASH_LITTLE_ENDIAN 1
  #endif
#endif
#if (WYHASH_LITTLE_ENDIAN)
static inline uint64_t _wyr8(const uint8_t *p) { uint64_t v; memcpy(&v, p, 8); return v;}
static inline uint64_t _wyr4(const uint8_t *p) { uint32_t v; memcpy(&v, p, 4); return v;}
#elif defined(__GNUC__) || defined(__INTEL_COMPILER) || defined(__clang__)
static inline uint64_t _wyr8(const uint8_t *p) { uint64_t v; memcpy(&v, p, 8); return __builtin_bswap64(v);}
static inline uint64_t _wyr4(const uint8_t *p) { uint32_t v; memcpy(&v, p, 4); return __builtin_bswap32(v);}
#elif defined(_MSC_VER)
static inline uint64_t _wyr8(const uint8_t *p) { uint64_t v; memcpy(&v, p, 8); return _byteswap_uint64(v);}
static inline uint64_t _wyr4(const uint8_t *p) { uint32_t v; memcpy(&v, p, 4); return _byteswap_ulong(v);}
#else
static inline uint64_t _wyr8(const uint8_t *p) {
  uint64_t v; memcpy(&v, p, 8);
  return (((v >> 56) & 0xff)| ((v >> 40) & 0xff00)| ((v >> 24) & 0xff0000)| ((v >>  8) & 0xff000000)| ((v <<  8) & 0xff00000000)| ((v << 24) & 0xff0000000000)| ((v << 40) & 0xff000000000000)| ((v << 56) & 0xff00000000000000));
}
static inline uint64_t _wyr4(const uint8_t *p) {
  uint32_t v; memcpy(&v, p, 4);
  return (((v >> 24) & 0xff)| ((v >>  8) & 0xff00)| ((v <<  8) & 0xff0000)| ((v << 24) & 0xff000000));
}
#endif
static inline uint64_t _wyr3(const uint8_t *p, size_t k) { return (((uint64_t)p[0])<<16)|(((uint64_t)p[k>>1])<<8)|p[k-1];}
static inline uint64_t wyhash(const void *key, size_t len, uint64_t seed, const uint64_t *secret){
  const uint8_t *p=(const uint8_t *)key; seed^=*secret;	uint64_t	a,	b;
  if(_likely_(len<=16)){
    if(_likely_(len>=4)){ a=(_wyr4(p)<<32)|_wyr4(p+((len>>3)<<2)); b=(_wyr4(p+len-4)<<32)|_wyr4(p+len-4-((len>>3)<<2)); }
    else if(_likely_(len>0)){ a=_wyr3(p,len); b=0;}
    else a=b=0;
  }
  else{
    size_t i=len; 
    if(_unlikely_(i>48)){
      uint64_t see1=seed, see2=seed;
      do{
        seed=_wymix(_wyr8(p)^secret[1],_wyr8(p+8)^seed);
        see1=_wymix(_wyr8(p+16)^secret[2],_wyr8(p+24)^see1);
        see2=_wymix(_wyr8(p+32)^secret[3],_wyr8(p+40)^see2);
        p+=48; i-=48;
      }while(_likely_(i>48));
      seed^=see1^see2;
    }
    while(_unlikely_(i>16)){  seed=_wymix(_wyr8(p)^secret[1],_wyr8(p+8)^seed);  i-=16; p+=16;  }
    a=_wyr8(p+i-16);  b=_wyr8(p+i-8);
  }
  return _wymix(secret[1]^len,_wymix(a^secret[1],b^seed));
}
static const uint64_t _wyp[4] = {0xa0761d6478bd642full, 0xe7037ed1a0b428dbull, 0x8ebc6af09c88c6e3ull, 0x589965cc75374cc3ull};
static inline uint64_t wyhash64(uint64_t A, uint64_t B){ A^=0xa0761d6478bd642full; B^=0xe7037ed1a0b428dbull; _wymum(&A,&B); return _wymix(A^0xa0761d6478bd642full,B^0xe7037ed1a0b428dbull);}
static inline uint64_t wyrand(uint64_t *seed){ *seed+=0xa0761d6478bd642full; return _wymix(*seed,*seed^0xe7037ed1a0b428dbull);}
static inline double wy2u01(uint64_t r){ const double _wynorm=1.0/(1ull<<52); return (r>>12)*_wynorm;}
static inline double wy2gau(uint64_t r){ const double _wynorm=1.0/(1ull<<20); return ((r&0x1fffff)+((r>>21)&0x1fffff)+((r>>42)&0x1fffff))*_wynorm-3.0;}
#if(!WYHASH_32BIT_MUM)
static inline uint64_t wy2u0k(uint64_t r, uint64_t k){ _wymum(&r,&k); return k; }
#endif
static inline void make_secret(uint64_t seed, uint64_t *secret){
  uint8_t c[] = {15, 23, 27, 29, 30, 39, 43, 45, 46, 51, 53, 54, 57, 58, 60, 71, 75, 77, 78, 83, 85, 86, 89, 90, 92, 99, 101, 102, 105, 106, 108, 113, 114, 116, 120, 135, 139, 141, 142, 147, 149, 150, 153, 154, 156, 163, 165, 166, 169, 170, 172, 177, 178, 180, 184, 195, 197, 198, 201, 202, 204, 209, 210, 212, 216, 225, 226, 228, 232, 240 };
  for(size_t i=0;i<4;i++){
    uint8_t ok;
    do{
      ok=1; secret[i]=0;
      for(size_t j=0;j<64;j+=8) secret[i]|=((uint64_t)c[wyrand(&seed)%sizeof(c)])<<j;
      if(secret[i]%2==0){ ok=0; continue; }
      for(size_t j=0;j<i;j++) {
#if defined(__GNUC__) || defined(__INTEL_COMPILER) || defined(__clang__)
        if(__builtin_popcountll(secret[j]^secret[i])!=32){ ok=0; break; }
#elif defined(_MSC_VER) && defined(_M_X64)
        if(_mm_popcnt_u64(secret[j]^secret[i])!=32){ ok=0; break; }
#else
        uint64_t x = secret[j]^secret[i];
        x -= (x >> 1) & 0x5555555555555555;
        x = (x & 0x3333333333333333) + ((x >> 2) & 0x3333333333333333);
        x = (x + (x >> 4)) & 0x0f0f0f0f0f0f0f0f;
        x = (x * 0x0101010101010101) >> 56;
        if(x!=32){ ok=0; break; }
#endif
      }
    }while(!ok);
  }
}
class XXHash64
{
public:
  explicit XXHash64(uint64_t seed)
  {
    state[0] = seed + Prime1 + Prime2;
    state[1] = seed + Prime2;
    state[2] = seed;
    state[3] = seed - Prime1;
    bufferSize  = 0;
    totalLength = 0;
  }
  bool add(const void* input, uint64_t length)
  {
    if (!input || length == 0)
      return false;
    totalLength += length;
    const unsigned char* data = (const unsigned char*)input;
    if (bufferSize + length < MaxBufferSize)
    {
      while (length-- > 0)
        buffer[bufferSize++] = *data++;
      return true;
    }
    const unsigned char* stop      = data + length;
    const unsigned char* stopBlock = stop - MaxBufferSize;
    if (bufferSize > 0)
    {
      while (bufferSize < MaxBufferSize)
        buffer[bufferSize++] = *data++;
      process(buffer, state[0], state[1], state[2], state[3]);
    }
    uint64_t s0 = state[0], s1 = state[1], s2 = state[2], s3 = state[3];
    while (data <= stopBlock)
    {
      process(data, s0, s1, s2, s3);
      data += 32;
    }
    state[0] = s0; state[1] = s1; state[2] = s2; state[3] = s3;
    bufferSize = stop - data;
    for (unsigned int i = 0; i < bufferSize; i++)
      buffer[i] = data[i];
    return true;
  }
  uint64_t hash() const
  {
    uint64_t result;
    if (totalLength >= MaxBufferSize)
    {
      result = rotateLeft(state[0],  1) +
               rotateLeft(state[1],  7) +
               rotateLeft(state[2], 12) +
               rotateLeft(state[3], 18);
      result = (result ^ processSingle(0, state[0])) * Prime1 + Prime4;
      result = (result ^ processSingle(0, state[1])) * Prime1 + Prime4;
      result = (result ^ processSingle(0, state[2])) * Prime1 + Prime4;
      result = (result ^ processSingle(0, state[3])) * Prime1 + Prime4;
    }
    else
    {
      result = state[2] + Prime5;
    }
    result += totalLength;
    const unsigned char* data = buffer;
    const unsigned char* stop = data + bufferSize;
    for (; data + 8 <= stop; data += 8)
      result = rotateLeft(result ^ processSingle(0, *(uint64_t*)data), 27) * Prime1 + Prime4;
    if (data + 4 <= stop)
    {
      result = rotateLeft(result ^ (*(uint32_t*)data) * Prime1,   23) * Prime2 + Prime3;
      data  += 4;
    }
    while (data != stop)
      result = rotateLeft(result ^ (*data++) * Prime5,            11) * Prime1;
    result ^= result >> 33;
    result *= Prime2;
    result ^= result >> 29;
    result *= Prime3;
    result ^= result >> 32;
    return result;
  }
private:
  static const uint64_t Prime1 = 11400714785074694791ULL;
  static const uint64_t Prime2 = 14029467366897019727ULL;
  static const uint64_t Prime3 =  1609587929392839161ULL;
  static const uint64_t Prime4 =  9650029242287828579ULL;
  static const uint64_t Prime5 =  2870177450012600261ULL;
  static const uint64_t MaxBufferSize = 31+1;
  uint64_t      state[4];
  unsigned char buffer[MaxBufferSize];
  unsigned int  bufferSize;
  uint64_t      totalLength;
  static inline uint64_t rotateLeft(uint64_t x, unsigned char bits)
  {
    return (x << bits) | (x >> (64 - bits));
  }
  static inline uint64_t processSingle(uint64_t previous, uint64_t input)
  {
    return rotateLeft(previous + input * Prime2, 31) * Prime1;
  }
  static inline void process(const void* data, uint64_t& state0, uint64_t& state1, uint64_t& state2, uint64_t& state3)
  {
    const uint64_t* block = (const uint64_t*) data;
    state0 = processSingle(state0, block[0]);
    state1 = processSingle(state1, block[1]);
    state2 = processSingle(state2, block[2]);
    state3 = processSingle(state3, block[3]);
  }
};
#define XXH_IMPLEMENTATION   
#define XXH_STATIC_LINKING_ONLY   
#if (defined(XXH_INLINE_ALL) || defined(XXH_PRIVATE_API)) \
    && !defined(XXH_INLINE_ALL_31684351384)
#  define XXH_INLINE_ALL_31684351384
#  undef XXH_STATIC_LINKING_ONLY   
#  define XXH_STATIC_LINKING_ONLY
#  undef XXH_PUBLIC_API
#  if defined(__GNUC__)
#    define XXH_PUBLIC_API static __inline __attribute__((unused))
#  elif defined (__cplusplus) || (defined (__STDC_VERSION__) && (__STDC_VERSION__ >= 199901L) )
#    define XXH_PUBLIC_API static inline
#  elif defined(_MSC_VER)
#    define XXH_PUBLIC_API static __inline
#  else
#    define XXH_PUBLIC_API static
#  endif
#  ifdef XXH_NAMESPACE
#    error "XXH_INLINE_ALL with XXH_NAMESPACE is not supported"
#  endif
#  define XXH_NAMESPACE XXH_INLINE_
#  define XXH_IPREF(Id)   XXH_INLINE_ ## Id
#  define XXH_OK XXH_IPREF(XXH_OK)
#  define XXH_ERROR XXH_IPREF(XXH_ERROR)
#  define XXH_errorcode XXH_IPREF(XXH_errorcode)
#  define XXH32_canonical_t  XXH_IPREF(XXH32_canonical_t)
#  define XXH64_canonical_t  XXH_IPREF(XXH64_canonical_t)
#  define XXH128_canonical_t XXH_IPREF(XXH128_canonical_t)
#  define XXH32_state_s XXH_IPREF(XXH32_state_s)
#  define XXH32_state_t XXH_IPREF(XXH32_state_t)
#  define XXH64_state_s XXH_IPREF(XXH64_state_s)
#  define XXH64_state_t XXH_IPREF(XXH64_state_t)
#  define XXH3_state_s  XXH_IPREF(XXH3_state_s)
#  define XXH3_state_t  XXH_IPREF(XXH3_state_t)
#  define XXH128_hash_t XXH_IPREF(XXH128_hash_t)
#  undef XXHASH_H_5627135585666179
#  undef XXHASH_H_STATIC_13879238742
#endif 
#ifndef XXHASH_H_5627135585666179
#define XXHASH_H_5627135585666179 1
#if !defined(XXH_INLINE_ALL) && !defined(XXH_PRIVATE_API)
#  if defined(WIN32) && defined(_MSC_VER) && (defined(XXH_IMPORT) || defined(XXH_EXPORT))
#    ifdef XXH_EXPORT
#      define XXH_PUBLIC_API __declspec(dllexport)
#    elif XXH_IMPORT
#      define XXH_PUBLIC_API __declspec(dllimport)
#    endif
#  else
#    define XXH_PUBLIC_API   
#  endif
#endif
#ifdef XXH_NAMESPACE
#  define XXH_CAT(A,B) A##B
#  define XXH_NAME2(A,B) XXH_CAT(A,B)
#  define XXH_versionNumber XXH_NAME2(XXH_NAMESPACE, XXH_versionNumber)
#  define XXH32 XXH_NAME2(XXH_NAMESPACE, XXH32)
#  define XXH32_createState XXH_NAME2(XXH_NAMESPACE, XXH32_createState)
#  define XXH32_freeState XXH_NAME2(XXH_NAMESPACE, XXH32_freeState)
#  define XXH32_reset XXH_NAME2(XXH_NAMESPACE, XXH32_reset)
#  define XXH32_update XXH_NAME2(XXH_NAMESPACE, XXH32_update)
#  define XXH32_digest XXH_NAME2(XXH_NAMESPACE, XXH32_digest)
#  define XXH32_copyState XXH_NAME2(XXH_NAMESPACE, XXH32_copyState)
#  define XXH32_canonicalFromHash XXH_NAME2(XXH_NAMESPACE, XXH32_canonicalFromHash)
#  define XXH32_hashFromCanonical XXH_NAME2(XXH_NAMESPACE, XXH32_hashFromCanonical)
#  define XXH64 XXH_NAME2(XXH_NAMESPACE, XXH64)
#  define XXH64_createState XXH_NAME2(XXH_NAMESPACE, XXH64_createState)
#  define XXH64_freeState XXH_NAME2(XXH_NAMESPACE, XXH64_freeState)
#  define XXH64_reset XXH_NAME2(XXH_NAMESPACE, XXH64_reset)
#  define XXH64_update XXH_NAME2(XXH_NAMESPACE, XXH64_update)
#  define XXH64_digest XXH_NAME2(XXH_NAMESPACE, XXH64_digest)
#  define XXH64_copyState XXH_NAME2(XXH_NAMESPACE, XXH64_copyState)
#  define XXH64_canonicalFromHash XXH_NAME2(XXH_NAMESPACE, XXH64_canonicalFromHash)
#  define XXH64_hashFromCanonical XXH_NAME2(XXH_NAMESPACE, XXH64_hashFromCanonical)
#  define XXH3_64bits XXH_NAME2(XXH_NAMESPACE, XXH3_64bits)
#  define XXH3_64bits_withSecret XXH_NAME2(XXH_NAMESPACE, XXH3_64bits_withSecret)
#  define XXH3_64bits_withSeed XXH_NAME2(XXH_NAMESPACE, XXH3_64bits_withSeed)
#  define XXH3_createState XXH_NAME2(XXH_NAMESPACE, XXH3_createState)
#  define XXH3_freeState XXH_NAME2(XXH_NAMESPACE, XXH3_freeState)
#  define XXH3_copyState XXH_NAME2(XXH_NAMESPACE, XXH3_copyState)
#  define XXH3_64bits_reset XXH_NAME2(XXH_NAMESPACE, XXH3_64bits_reset)
#  define XXH3_64bits_reset_withSeed XXH_NAME2(XXH_NAMESPACE, XXH3_64bits_reset_withSeed)
#  define XXH3_64bits_reset_withSecret XXH_NAME2(XXH_NAMESPACE, XXH3_64bits_reset_withSecret)
#  define XXH3_64bits_update XXH_NAME2(XXH_NAMESPACE, XXH3_64bits_update)
#  define XXH3_64bits_digest XXH_NAME2(XXH_NAMESPACE, XXH3_64bits_digest)
#  define XXH3_generateSecret XXH_NAME2(XXH_NAMESPACE, XXH3_generateSecret)
#  define XXH128 XXH_NAME2(XXH_NAMESPACE, XXH128)
#  define XXH3_128bits XXH_NAME2(XXH_NAMESPACE, XXH3_128bits)
#  define XXH3_128bits_withSeed XXH_NAME2(XXH_NAMESPACE, XXH3_128bits_withSeed)
#  define XXH3_128bits_withSecret XXH_NAME2(XXH_NAMESPACE, XXH3_128bits_withSecret)
#  define XXH3_128bits_reset XXH_NAME2(XXH_NAMESPACE, XXH3_128bits_reset)
#  define XXH3_128bits_reset_withSeed XXH_NAME2(XXH_NAMESPACE, XXH3_128bits_reset_withSeed)
#  define XXH3_128bits_reset_withSecret XXH_NAME2(XXH_NAMESPACE, XXH3_128bits_reset_withSecret)
#  define XXH3_128bits_update XXH_NAME2(XXH_NAMESPACE, XXH3_128bits_update)
#  define XXH3_128bits_digest XXH_NAME2(XXH_NAMESPACE, XXH3_128bits_digest)
#  define XXH128_isEqual XXH_NAME2(XXH_NAMESPACE, XXH128_isEqual)
#  define XXH128_cmp     XXH_NAME2(XXH_NAMESPACE, XXH128_cmp)
#  define XXH128_canonicalFromHash XXH_NAME2(XXH_NAMESPACE, XXH128_canonicalFromHash)
#  define XXH128_hashFromCanonical XXH_NAME2(XXH_NAMESPACE, XXH128_hashFromCanonical)
#endif
#define XXH_VERSION_MAJOR    0
#define XXH_VERSION_MINOR    8
#define XXH_VERSION_RELEASE  0
#define XXH_VERSION_NUMBER  (XXH_VERSION_MAJOR *100*100 + XXH_VERSION_MINOR *100 + XXH_VERSION_RELEASE)
XXH_PUBLIC_API unsigned XXH_versionNumber (void);
typedef enum { XXH_OK=0, XXH_ERROR } XXH_errorcode;
#if !defined (__VMS) \
  && (defined (__cplusplus) \
  || (defined (__STDC_VERSION__) && (__STDC_VERSION__ >= 199901L) ) )
#   include <stdint.h>
    typedef uint32_t XXH32_hash_t;
#else
#   include <limits.h>
#   if UINT_MAX == 0xFFFFFFFFUL
      typedef unsigned int XXH32_hash_t;
#   else
#     if ULONG_MAX == 0xFFFFFFFFUL
        typedef unsigned long XXH32_hash_t;
#     else
#       error "unsupported platform: need a 32-bit type"
#     endif
#   endif
#endif
XXH_PUBLIC_API XXH32_hash_t XXH32 (const void* input, size_t length, XXH32_hash_t seed);
typedef struct XXH32_state_s XXH32_state_t;   
XXH_PUBLIC_API XXH32_state_t* XXH32_createState(void);
XXH_PUBLIC_API XXH_errorcode  XXH32_freeState(XXH32_state_t* statePtr);
XXH_PUBLIC_API void XXH32_copyState(XXH32_state_t* dst_state, const XXH32_state_t* src_state);
XXH_PUBLIC_API XXH_errorcode XXH32_reset  (XXH32_state_t* statePtr, XXH32_hash_t seed);
XXH_PUBLIC_API XXH_errorcode XXH32_update (XXH32_state_t* statePtr, const void* input, size_t length);
XXH_PUBLIC_API XXH32_hash_t  XXH32_digest (const XXH32_state_t* statePtr);
typedef struct { unsigned char digest[4]; } XXH32_canonical_t;
XXH_PUBLIC_API void XXH32_canonicalFromHash(XXH32_canonical_t* dst, XXH32_hash_t hash);
XXH_PUBLIC_API XXH32_hash_t XXH32_hashFromCanonical(const XXH32_canonical_t* src);
#ifndef XXH_NO_LONG_LONG
#if !defined (__VMS) \
  && (defined (__cplusplus) \
  || (defined (__STDC_VERSION__) && (__STDC_VERSION__ >= 199901L) ) )
#   include <stdint.h>
    typedef uint64_t XXH64_hash_t;
#else
    typedef unsigned long long XXH64_hash_t;
#endif
XXH_PUBLIC_API XXH64_hash_t XXH64 (const void* input, size_t length, XXH64_hash_t seed);
typedef struct XXH64_state_s XXH64_state_t;   
XXH_PUBLIC_API XXH64_state_t* XXH64_createState(void);
XXH_PUBLIC_API XXH_errorcode  XXH64_freeState(XXH64_state_t* statePtr);
XXH_PUBLIC_API void XXH64_copyState(XXH64_state_t* dst_state, const XXH64_state_t* src_state);
XXH_PUBLIC_API XXH_errorcode XXH64_reset  (XXH64_state_t* statePtr, XXH64_hash_t seed);
XXH_PUBLIC_API XXH_errorcode XXH64_update (XXH64_state_t* statePtr, const void* input, size_t length);
XXH_PUBLIC_API XXH64_hash_t  XXH64_digest (const XXH64_state_t* statePtr);
typedef struct { unsigned char digest[sizeof(XXH64_hash_t)]; } XXH64_canonical_t;
XXH_PUBLIC_API void XXH64_canonicalFromHash(XXH64_canonical_t* dst, XXH64_hash_t hash);
XXH_PUBLIC_API XXH64_hash_t XXH64_hashFromCanonical(const XXH64_canonical_t* src);
XXH_PUBLIC_API XXH64_hash_t XXH3_64bits(const void* data, size_t len);
XXH_PUBLIC_API XXH64_hash_t XXH3_64bits_withSeed(const void* data, size_t len, XXH64_hash_t seed);
#define XXH3_SECRET_SIZE_MIN 136
XXH_PUBLIC_API XXH64_hash_t XXH3_64bits_withSecret(const void* data, size_t len, const void* secret, size_t secretSize);
typedef struct XXH3_state_s XXH3_state_t;
XXH_PUBLIC_API XXH3_state_t* XXH3_createState(void);
XXH_PUBLIC_API XXH_errorcode XXH3_freeState(XXH3_state_t* statePtr);
XXH_PUBLIC_API void XXH3_copyState(XXH3_state_t* dst_state, const XXH3_state_t* src_state);
XXH_PUBLIC_API XXH_errorcode XXH3_64bits_reset(XXH3_state_t* statePtr);
XXH_PUBLIC_API XXH_errorcode XXH3_64bits_reset_withSeed(XXH3_state_t* statePtr, XXH64_hash_t seed);
XXH_PUBLIC_API XXH_errorcode XXH3_64bits_reset_withSecret(XXH3_state_t* statePtr, const void* secret, size_t secretSize);
XXH_PUBLIC_API XXH_errorcode XXH3_64bits_update (XXH3_state_t* statePtr, const void* input, size_t length);
XXH_PUBLIC_API XXH64_hash_t  XXH3_64bits_digest (const XXH3_state_t* statePtr);
typedef struct {
 XXH64_hash_t low64;
 XXH64_hash_t high64;
} XXH128_hash_t;
XXH_PUBLIC_API XXH128_hash_t XXH3_128bits(const void* data, size_t len);
XXH_PUBLIC_API XXH128_hash_t XXH3_128bits_withSeed(const void* data, size_t len, XXH64_hash_t seed);
XXH_PUBLIC_API XXH128_hash_t XXH3_128bits_withSecret(const void* data, size_t len, const void* secret, size_t secretSize);
XXH_PUBLIC_API XXH_errorcode XXH3_128bits_reset(XXH3_state_t* statePtr);
XXH_PUBLIC_API XXH_errorcode XXH3_128bits_reset_withSeed(XXH3_state_t* statePtr, XXH64_hash_t seed);
XXH_PUBLIC_API XXH_errorcode XXH3_128bits_reset_withSecret(XXH3_state_t* statePtr, const void* secret, size_t secretSize);
XXH_PUBLIC_API XXH_errorcode XXH3_128bits_update (XXH3_state_t* statePtr, const void* input, size_t length);
XXH_PUBLIC_API XXH128_hash_t XXH3_128bits_digest (const XXH3_state_t* statePtr);
XXH_PUBLIC_API int XXH128_isEqual(XXH128_hash_t h1, XXH128_hash_t h2);
XXH_PUBLIC_API int XXH128_cmp(const void* h128_1, const void* h128_2);
typedef struct { unsigned char digest[sizeof(XXH128_hash_t)]; } XXH128_canonical_t;
XXH_PUBLIC_API void XXH128_canonicalFromHash(XXH128_canonical_t* dst, XXH128_hash_t hash);
XXH_PUBLIC_API XXH128_hash_t XXH128_hashFromCanonical(const XXH128_canonical_t* src);
#endif  
#endif 
#if defined(XXH_STATIC_LINKING_ONLY) && !defined(XXHASH_H_STATIC_13879238742)
#define XXHASH_H_STATIC_13879238742
struct XXH32_state_s {
   XXH32_hash_t total_len_32;
   XXH32_hash_t large_len;
   XXH32_hash_t v1;
   XXH32_hash_t v2;
   XXH32_hash_t v3;
   XXH32_hash_t v4;
   XXH32_hash_t mem32[4];
   XXH32_hash_t memsize;
   XXH32_hash_t reserved;   
};   
#ifndef XXH_NO_LONG_LONG  
struct XXH64_state_s {
   XXH64_hash_t total_len;
   XXH64_hash_t v1;
   XXH64_hash_t v2;
   XXH64_hash_t v3;
   XXH64_hash_t v4;
   XXH64_hash_t mem64[4];
   XXH32_hash_t memsize;
   XXH32_hash_t reserved32;  
   XXH64_hash_t reserved64;  
};   
#if defined (__STDC_VERSION__) && (__STDC_VERSION__ >= 201112L)   
#  include <stdalign.h>
#  define XXH_ALIGN(n)      alignas(n)
#elif defined(__GNUC__)
#  define XXH_ALIGN(n)      __attribute__ ((aligned(n)))
#elif defined(_MSC_VER)
#  define XXH_ALIGN(n)      __declspec(align(n))
#else
#  define XXH_ALIGN(n)   
#endif
#if !(defined(__STDC_VERSION__) && (__STDC_VERSION__ >= 201112L))    \
    && defined(__GNUC__)
#   define XXH_ALIGN_MEMBER(align, type) type XXH_ALIGN(align)
#else
#   define XXH_ALIGN_MEMBER(align, type) XXH_ALIGN(align) type
#endif
#define XXH3_INTERNALBUFFER_SIZE 256
#define XXH3_SECRET_DEFAULT_SIZE 192
struct XXH3_state_s {
   XXH_ALIGN_MEMBER(64, XXH64_hash_t acc[8]);
   XXH_ALIGN_MEMBER(64, unsigned char customSecret[XXH3_SECRET_DEFAULT_SIZE]);
   XXH_ALIGN_MEMBER(64, unsigned char buffer[XXH3_INTERNALBUFFER_SIZE]);
   XXH32_hash_t bufferedSize;
   XXH32_hash_t reserved32;
   size_t nbStripesSoFar;
   XXH64_hash_t totalLen;
   size_t nbStripesPerBlock;
   size_t secretLimit;
   XXH64_hash_t seed;
   XXH64_hash_t reserved64;
   const unsigned char* extSecret;  
}; 
#undef XXH_ALIGN_MEMBER
#define XXH3_INITSTATE(XXH3_state_ptr)   { (XXH3_state_ptr)->seed = 0; }
XXH_PUBLIC_API void XXH3_generateSecret(void* secretBuffer, const void* customSeed, size_t customSeedSize);
XXH_PUBLIC_API XXH128_hash_t XXH128(const void* data, size_t len, XXH64_hash_t seed);
#endif  
#if defined(XXH_INLINE_ALL) || defined(XXH_PRIVATE_API)
#  define XXH_IMPLEMENTATION
#endif
#endif  
#if ( defined(XXH_INLINE_ALL) || defined(XXH_PRIVATE_API) \
   || defined(XXH_IMPLEMENTATION) ) && !defined(XXH_IMPLEM_13a8737387)
#  define XXH_IMPLEM_13a8737387
#ifndef XXH_FORCE_MEMORY_ACCESS   
#  if !defined(__clang__) && defined(__GNUC__) && defined(__ARM_FEATURE_UNALIGNED) && defined(__ARM_ARCH) && (__ARM_ARCH == 6)
#    define XXH_FORCE_MEMORY_ACCESS 2
#  elif !defined(__clang__) && ((defined(__INTEL_COMPILER) && !defined(_WIN32)) || \
  (defined(__GNUC__) && (defined(__ARM_ARCH) && __ARM_ARCH >= 7)))
#    define XXH_FORCE_MEMORY_ACCESS 1
#  endif
#endif
#ifndef XXH_ACCEPT_NULL_INPUT_POINTER   
#  define XXH_ACCEPT_NULL_INPUT_POINTER 0
#endif
#ifndef XXH_FORCE_ALIGN_CHECK  
#  if defined(__i386)  || defined(__x86_64__) || defined(__aarch64__) \
   || defined(_M_IX86) || defined(_M_X64)     || defined(_M_ARM64) 
#    define XXH_FORCE_ALIGN_CHECK 0
#  else
#    define XXH_FORCE_ALIGN_CHECK 1
#  endif
#endif
#ifndef XXH_NO_INLINE_HINTS
#  if defined(__OPTIMIZE_SIZE__)  \
   || defined(__NO_INLINE__)     
#    define XXH_NO_INLINE_HINTS 1
#  else
#    define XXH_NO_INLINE_HINTS 0
#  endif
#endif
#ifndef XXH_REROLL
#  if defined(__OPTIMIZE_SIZE__)
#    define XXH_REROLL 1
#  else
#    define XXH_REROLL 0
#  endif
#endif
static void* XXH_malloc(size_t s) { return malloc(s); }
static void XXH_free(void* p) { free(p); }
static void* XXH_memcpy(void* dest, const void* src, size_t size)
{
    return memcpy(dest,src,size);
}
#ifdef _MSC_VER 
#  pragma warning(disable : 4127) 
#endif
#if XXH_NO_INLINE_HINTS  
#  if defined(__GNUC__)
#    define XXH_FORCE_INLINE static __attribute__((unused))
#  else
#    define XXH_FORCE_INLINE static
#  endif
#  define XXH_NO_INLINE static
#elif defined(_MSC_VER)  
#  define XXH_FORCE_INLINE static __forceinline
#  define XXH_NO_INLINE static __declspec(noinline)
#elif defined(__GNUC__)
#  define XXH_FORCE_INLINE static __inline__ __attribute__((always_inline, unused))
#  define XXH_NO_INLINE static __attribute__((noinline))
#elif defined (__cplusplus) \
  || (defined (__STDC_VERSION__) && (__STDC_VERSION__ >= 199901L))   
#  define XXH_FORCE_INLINE static inline
#  define XXH_NO_INLINE static
#else
#  define XXH_FORCE_INLINE static
#  define XXH_NO_INLINE static
#endif
#ifndef XXH_DEBUGLEVEL
#  ifdef DEBUGLEVEL 
#    define XXH_DEBUGLEVEL DEBUGLEVEL
#  else
#    define XXH_DEBUGLEVEL 0
#  endif
#endif
#if (XXH_DEBUGLEVEL>=1)
#  include <assert.h>   
#  define XXH_ASSERT(c)   assert(c)
#else
#  define XXH_ASSERT(c)   ((void)0)
#endif
#define XXH_STATIC_ASSERT(c)  do { enum { XXH_sa = 1/(int)(!!(c)) }; } while (0)
#if !defined (__VMS) \
 && (defined (__cplusplus) \
 || (defined (__STDC_VERSION__) && (__STDC_VERSION__ >= 199901L) ) )
# include <stdint.h>
  typedef uint8_t xxh_u8;
#else
  typedef unsigned char xxh_u8;
#endif
typedef XXH32_hash_t xxh_u32;
#ifdef XXH_OLD_NAMES
#  define BYTE xxh_u8
#  define U8   xxh_u8
#  define U32  xxh_u32
#endif
#if (defined(XXH_FORCE_MEMORY_ACCESS) && (XXH_FORCE_MEMORY_ACCESS==3))
#elif (defined(XXH_FORCE_MEMORY_ACCESS) && (XXH_FORCE_MEMORY_ACCESS==2))
static xxh_u32 XXH_read32(const void* memPtr) { return *(const xxh_u32*) memPtr; }
#elif (defined(XXH_FORCE_MEMORY_ACCESS) && (XXH_FORCE_MEMORY_ACCESS==1))
#ifdef XXH_OLD_NAMES
typedef union { xxh_u32 u32; } __attribute__((packed)) unalign;
#endif
static xxh_u32 XXH_read32(const void* ptr)
{
    typedef union { xxh_u32 u32; } __attribute__((packed)) xxh_unalign;
    return ((const xxh_unalign*)ptr)->u32;
}
#else
static xxh_u32 XXH_read32(const void* memPtr)
{
    xxh_u32 val;
    memcpy(&val, memPtr, sizeof(val));
    return val;
}
#endif   
typedef enum { XXH_bigEndian=0, XXH_littleEndian=1 } XXH_endianess;
#ifndef XXH_CPU_LITTLE_ENDIAN
#  if defined(_WIN32)  \
     || defined(__LITTLE_ENDIAN__) \
     || (defined(__BYTE_ORDER__) && __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__)
#    define XXH_CPU_LITTLE_ENDIAN 1
#  elif defined(__BIG_ENDIAN__) \
     || (defined(__BYTE_ORDER__) && __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__)
#    define XXH_CPU_LITTLE_ENDIAN 0
#  else
static int XXH_isLittleEndian(void)
{
    const union { xxh_u32 u; xxh_u8 c[4]; } one = { 1 };
    return one.c[0];
}
#   define XXH_CPU_LITTLE_ENDIAN   XXH_isLittleEndian()
#  endif
#endif
#define XXH_GCC_VERSION (__GNUC__ * 100 + __GNUC_MINOR__)
#ifdef __has_builtin
#  define XXH_HAS_BUILTIN(x) __has_builtin(x)
#else
#  define XXH_HAS_BUILTIN(x) 0
#endif
#if !defined(NO_CLANG_BUILTIN) && XXH_HAS_BUILTIN(__builtin_rotateleft32) \
                               && XXH_HAS_BUILTIN(__builtin_rotateleft64)
#  define XXH_rotl32 __builtin_rotateleft32
#  define XXH_rotl64 __builtin_rotateleft64
#elif defined(_MSC_VER)
#  define XXH_rotl32(x,r) _rotl(x,r)
#  define XXH_rotl64(x,r) _rotl64(x,r)
#else
#  define XXH_rotl32(x,r) (((x) << (r)) | ((x) >> (32 - (r))))
#  define XXH_rotl64(x,r) (((x) << (r)) | ((x) >> (64 - (r))))
#endif
#if defined(_MSC_VER)     
#  define XXH_swap32 _byteswap_ulong
#elif XXH_GCC_VERSION >= 403
#  define XXH_swap32 __builtin_bswap32
#else
static xxh_u32 XXH_swap32 (xxh_u32 x)
{
    return  ((x << 24) & 0xff000000 ) |
            ((x <<  8) & 0x00ff0000 ) |
            ((x >>  8) & 0x0000ff00 ) |
            ((x >> 24) & 0x000000ff );
}
#endif
typedef enum { XXH_aligned, XXH_unaligned } XXH_alignment;
#if (defined(XXH_FORCE_MEMORY_ACCESS) && (XXH_FORCE_MEMORY_ACCESS==3))
XXH_FORCE_INLINE xxh_u32 XXH_readLE32(const void* memPtr)
{
    const xxh_u8* bytePtr = (const xxh_u8 *)memPtr;
    return bytePtr[0]
         | ((xxh_u32)bytePtr[1] << 8)
         | ((xxh_u32)bytePtr[2] << 16)
         | ((xxh_u32)bytePtr[3] << 24);
}
XXH_FORCE_INLINE xxh_u32 XXH_readBE32(const void* memPtr)
{
    const xxh_u8* bytePtr = (const xxh_u8 *)memPtr;
    return bytePtr[3]
         | ((xxh_u32)bytePtr[2] << 8)
         | ((xxh_u32)bytePtr[1] << 16)
         | ((xxh_u32)bytePtr[0] << 24);
}
#else
XXH_FORCE_INLINE xxh_u32 XXH_readLE32(const void* ptr)
{
    return XXH_CPU_LITTLE_ENDIAN ? XXH_read32(ptr) : XXH_swap32(XXH_read32(ptr));
}
static xxh_u32 XXH_readBE32(const void* ptr)
{
    return XXH_CPU_LITTLE_ENDIAN ? XXH_swap32(XXH_read32(ptr)) : XXH_read32(ptr);
}
#endif
XXH_FORCE_INLINE xxh_u32
XXH_readLE32_align(const void* ptr, XXH_alignment align)
{
    if (align==XXH_unaligned) {
        return XXH_readLE32(ptr);
    } else {
        return XXH_CPU_LITTLE_ENDIAN ? *(const xxh_u32*)ptr : XXH_swap32(*(const xxh_u32*)ptr);
    }
}
XXH_PUBLIC_API unsigned XXH_versionNumber (void) { return XXH_VERSION_NUMBER; }
static const xxh_u32 XXH_PRIME32_1 = 0x9E3779B1U;   
static const xxh_u32 XXH_PRIME32_2 = 0x85EBCA77U;   
static const xxh_u32 XXH_PRIME32_3 = 0xC2B2AE3DU;   
static const xxh_u32 XXH_PRIME32_4 = 0x27D4EB2FU;   
static const xxh_u32 XXH_PRIME32_5 = 0x165667B1U;   
#ifdef XXH_OLD_NAMES
#  define PRIME32_1 XXH_PRIME32_1
#  define PRIME32_2 XXH_PRIME32_2
#  define PRIME32_3 XXH_PRIME32_3
#  define PRIME32_4 XXH_PRIME32_4
#  define PRIME32_5 XXH_PRIME32_5
#endif
static xxh_u32 XXH32_round(xxh_u32 acc, xxh_u32 input)
{
    acc += input * XXH_PRIME32_2;
    acc  = XXH_rotl32(acc, 13);
    acc *= XXH_PRIME32_1;
#if defined(__GNUC__) && defined(__SSE4_1__) && !defined(XXH_ENABLE_AUTOVECTORIZE)
    __asm__("" : "+r" (acc));
#endif
    return acc;
}
static xxh_u32 XXH32_avalanche(xxh_u32 h32)
{
    h32 ^= h32 >> 15;
    h32 *= XXH_PRIME32_2;
    h32 ^= h32 >> 13;
    h32 *= XXH_PRIME32_3;
    h32 ^= h32 >> 16;
    return(h32);
}
#define XXH_get32bits(p) XXH_readLE32_align(p, align)
static xxh_u32
XXH32_finalize(xxh_u32 h32, const xxh_u8* ptr, size_t len, XXH_alignment align)
{
#define XXH_PROCESS1 do {                           \
    h32 += (*ptr++) * XXH_PRIME32_5;                \
    h32 = XXH_rotl32(h32, 11) * XXH_PRIME32_1;      \
} while (0)
#define XXH_PROCESS4 do {                           \
    h32 += XXH_get32bits(ptr) * XXH_PRIME32_3;      \
    ptr += 4;                                   \
    h32  = XXH_rotl32(h32, 17) * XXH_PRIME32_4;     \
} while (0)
    if (XXH_REROLL) {
        len &= 15;
        while (len >= 4) {
            XXH_PROCESS4;
            len -= 4;
        }
        while (len > 0) {
            XXH_PROCESS1;
            --len;
        }
        return XXH32_avalanche(h32);
    } else {
         switch(len&15)  {
           case 12:      XXH_PROCESS4;
           case 8:       XXH_PROCESS4;
           case 4:       XXH_PROCESS4;
                         return XXH32_avalanche(h32);
           case 13:      XXH_PROCESS4;
           case 9:       XXH_PROCESS4;
           case 5:       XXH_PROCESS4;
                         XXH_PROCESS1;
                         return XXH32_avalanche(h32);
           case 14:      XXH_PROCESS4;
           case 10:      XXH_PROCESS4;
           case 6:       XXH_PROCESS4;
                         XXH_PROCESS1;
                         XXH_PROCESS1;
                         return XXH32_avalanche(h32);
           case 15:      XXH_PROCESS4;
           case 11:      XXH_PROCESS4;
           case 7:       XXH_PROCESS4;
           case 3:       XXH_PROCESS1;
           case 2:       XXH_PROCESS1;
           case 1:       XXH_PROCESS1;
           case 0:       return XXH32_avalanche(h32);
        }
        XXH_ASSERT(0);
        return h32;   
    }
}
#ifdef XXH_OLD_NAMES
#  define PROCESS1 XXH_PROCESS1
#  define PROCESS4 XXH_PROCESS4
#else
#  undef XXH_PROCESS1
#  undef XXH_PROCESS4
#endif
XXH_FORCE_INLINE xxh_u32
XXH32_endian_align(const xxh_u8* input, size_t len, xxh_u32 seed, XXH_alignment align)
{
    const xxh_u8* bEnd = input + len;
    xxh_u32 h32;
#if defined(XXH_ACCEPT_NULL_INPUT_POINTER) && (XXH_ACCEPT_NULL_INPUT_POINTER>=1)
    if (input==NULL) {
        len=0;
        bEnd=input=(const xxh_u8*)(size_t)16;
    }
#endif
    if (len>=16) {
        const xxh_u8* const limit = bEnd - 15;
        xxh_u32 v1 = seed + XXH_PRIME32_1 + XXH_PRIME32_2;
        xxh_u32 v2 = seed + XXH_PRIME32_2;
        xxh_u32 v3 = seed + 0;
        xxh_u32 v4 = seed - XXH_PRIME32_1;
        do {
            v1 = XXH32_round(v1, XXH_get32bits(input)); input += 4;
            v2 = XXH32_round(v2, XXH_get32bits(input)); input += 4;
            v3 = XXH32_round(v3, XXH_get32bits(input)); input += 4;
            v4 = XXH32_round(v4, XXH_get32bits(input)); input += 4;
        } while (input < limit);
        h32 = XXH_rotl32(v1, 1)  + XXH_rotl32(v2, 7)
            + XXH_rotl32(v3, 12) + XXH_rotl32(v4, 18);
    } else {
        h32  = seed + XXH_PRIME32_5;
    }
    h32 += (xxh_u32)len;
    return XXH32_finalize(h32, input, len&15, align);
}
XXH_PUBLIC_API XXH32_hash_t XXH32 (const void* input, size_t len, XXH32_hash_t seed)
{
#if 0
    XXH32_state_t state;
    XXH32_reset(&state, seed);
    XXH32_update(&state, (const xxh_u8*)input, len);
    return XXH32_digest(&state);
#else
    if (XXH_FORCE_ALIGN_CHECK) {
        if ((((size_t)input) & 3) == 0) {   
            return XXH32_endian_align((const xxh_u8*)input, len, seed, XXH_aligned);
    }   }
    return XXH32_endian_align((const xxh_u8*)input, len, seed, XXH_unaligned);
#endif
}
XXH_PUBLIC_API XXH32_state_t* XXH32_createState(void)
{
    return (XXH32_state_t*)XXH_malloc(sizeof(XXH32_state_t));
}
XXH_PUBLIC_API XXH_errorcode XXH32_freeState(XXH32_state_t* statePtr)
{
    XXH_free(statePtr);
    return XXH_OK;
}
XXH_PUBLIC_API void XXH32_copyState(XXH32_state_t* dstState, const XXH32_state_t* srcState)
{
    memcpy(dstState, srcState, sizeof(*dstState));
}
XXH_PUBLIC_API XXH_errorcode XXH32_reset(XXH32_state_t* statePtr, XXH32_hash_t seed)
{
    XXH32_state_t state;   
    memset(&state, 0, sizeof(state));
    state.v1 = seed + XXH_PRIME32_1 + XXH_PRIME32_2;
    state.v2 = seed + XXH_PRIME32_2;
    state.v3 = seed + 0;
    state.v4 = seed - XXH_PRIME32_1;
    memcpy(statePtr, &state, sizeof(state) - sizeof(state.reserved));
    return XXH_OK;
}
XXH_PUBLIC_API XXH_errorcode
XXH32_update(XXH32_state_t* state, const void* input, size_t len)
{
    if (input==NULL)
#if defined(XXH_ACCEPT_NULL_INPUT_POINTER) && (XXH_ACCEPT_NULL_INPUT_POINTER>=1)
        return XXH_OK;
#else
        return XXH_ERROR;
#endif
    {   const xxh_u8* p = (const xxh_u8*)input;
        const xxh_u8* const bEnd = p + len;
        state->total_len_32 += (XXH32_hash_t)len;
        state->large_len |= (XXH32_hash_t)((len>=16) | (state->total_len_32>=16));
        if (state->memsize + len < 16)  {   
            XXH_memcpy((xxh_u8*)(state->mem32) + state->memsize, input, len);
            state->memsize += (XXH32_hash_t)len;
            return XXH_OK;
        }
        if (state->memsize) {   
            XXH_memcpy((xxh_u8*)(state->mem32) + state->memsize, input, 16-state->memsize);
            {   const xxh_u32* p32 = state->mem32;
                state->v1 = XXH32_round(state->v1, XXH_readLE32(p32)); p32++;
                state->v2 = XXH32_round(state->v2, XXH_readLE32(p32)); p32++;
                state->v3 = XXH32_round(state->v3, XXH_readLE32(p32)); p32++;
                state->v4 = XXH32_round(state->v4, XXH_readLE32(p32));
            }
            p += 16-state->memsize;
            state->memsize = 0;
        }
        if (p <= bEnd-16) {
            const xxh_u8* const limit = bEnd - 16;
            xxh_u32 v1 = state->v1;
            xxh_u32 v2 = state->v2;
            xxh_u32 v3 = state->v3;
            xxh_u32 v4 = state->v4;
            do {
                v1 = XXH32_round(v1, XXH_readLE32(p)); p+=4;
                v2 = XXH32_round(v2, XXH_readLE32(p)); p+=4;
                v3 = XXH32_round(v3, XXH_readLE32(p)); p+=4;
                v4 = XXH32_round(v4, XXH_readLE32(p)); p+=4;
            } while (p<=limit);
            state->v1 = v1;
            state->v2 = v2;
            state->v3 = v3;
            state->v4 = v4;
        }
        if (p < bEnd) {
            XXH_memcpy(state->mem32, p, (size_t)(bEnd-p));
            state->memsize = (unsigned)(bEnd-p);
        }
    }
    return XXH_OK;
}
XXH_PUBLIC_API XXH32_hash_t XXH32_digest (const XXH32_state_t* state)
{
    xxh_u32 h32;
    if (state->large_len) {
        h32 = XXH_rotl32(state->v1, 1)
            + XXH_rotl32(state->v2, 7)
            + XXH_rotl32(state->v3, 12)
            + XXH_rotl32(state->v4, 18);
    } else {
        h32 = state->v3  + XXH_PRIME32_5;
    }
    h32 += state->total_len_32;
    return XXH32_finalize(h32, (const xxh_u8*)state->mem32, state->memsize, XXH_aligned);
}
XXH_PUBLIC_API void XXH32_canonicalFromHash(XXH32_canonical_t* dst, XXH32_hash_t hash)
{
    XXH_STATIC_ASSERT(sizeof(XXH32_canonical_t) == sizeof(XXH32_hash_t));
    if (XXH_CPU_LITTLE_ENDIAN) hash = XXH_swap32(hash);
    memcpy(dst, &hash, sizeof(*dst));
}
XXH_PUBLIC_API XXH32_hash_t XXH32_hashFromCanonical(const XXH32_canonical_t* src)
{
    return XXH_readBE32(src);
}
#ifndef XXH_NO_LONG_LONG
typedef XXH64_hash_t xxh_u64;
#ifdef XXH_OLD_NAMES
#  define U64 xxh_u64
#endif
#ifndef XXH_REROLL_XXH64
#  if (defined(__ILP32__) || defined(_ILP32))  \
   || !(defined(__x86_64__) || defined(_M_X64) || defined(_M_AMD64)  \
     || defined(_M_ARM64) || defined(__aarch64__) || defined(__arm64__)  \
     || defined(__PPC64__) || defined(__PPC64LE__) || defined(__ppc64__) || defined(__powerpc64__)  \
     || defined(__mips64__) || defined(__mips64))  \
   || (!defined(SIZE_MAX) || SIZE_MAX < ULLONG_MAX) 
#    define XXH_REROLL_XXH64 1
#  else
#    define XXH_REROLL_XXH64 0
#  endif
#endif 
#if (defined(XXH_FORCE_MEMORY_ACCESS) && (XXH_FORCE_MEMORY_ACCESS==3))
#elif (defined(XXH_FORCE_MEMORY_ACCESS) && (XXH_FORCE_MEMORY_ACCESS==2))
static xxh_u64 XXH_read64(const void* memPtr) { return *(const xxh_u64*) memPtr; }
#elif (defined(XXH_FORCE_MEMORY_ACCESS) && (XXH_FORCE_MEMORY_ACCESS==1))
#ifdef XXH_OLD_NAMES
typedef union { xxh_u32 u32; xxh_u64 u64; } __attribute__((packed)) unalign64;
#endif
static xxh_u64 XXH_read64(const void* ptr)
{
    typedef union { xxh_u32 u32; xxh_u64 u64; } __attribute__((packed)) xxh_unalign64;
    return ((const xxh_unalign64*)ptr)->u64;
}
#else
static xxh_u64 XXH_read64(const void* memPtr)
{
    xxh_u64 val;
    memcpy(&val, memPtr, sizeof(val));
    return val;
}
#endif   
#if defined(_MSC_VER)     
#  define XXH_swap64 _byteswap_uint64
#elif XXH_GCC_VERSION >= 403
#  define XXH_swap64 __builtin_bswap64
#else
static xxh_u64 XXH_swap64 (xxh_u64 x)
{
    return  ((x << 56) & 0xff00000000000000ULL) |
            ((x << 40) & 0x00ff000000000000ULL) |
            ((x << 24) & 0x0000ff0000000000ULL) |
            ((x << 8)  & 0x000000ff00000000ULL) |
            ((x >> 8)  & 0x00000000ff000000ULL) |
            ((x >> 24) & 0x0000000000ff0000ULL) |
            ((x >> 40) & 0x000000000000ff00ULL) |
            ((x >> 56) & 0x00000000000000ffULL);
}
#endif
#if (defined(XXH_FORCE_MEMORY_ACCESS) && (XXH_FORCE_MEMORY_ACCESS==3))
XXH_FORCE_INLINE xxh_u64 XXH_readLE64(const void* memPtr)
{
    const xxh_u8* bytePtr = (const xxh_u8 *)memPtr;
    return bytePtr[0]
         | ((xxh_u64)bytePtr[1] << 8)
         | ((xxh_u64)bytePtr[2] << 16)
         | ((xxh_u64)bytePtr[3] << 24)
         | ((xxh_u64)bytePtr[4] << 32)
         | ((xxh_u64)bytePtr[5] << 40)
         | ((xxh_u64)bytePtr[6] << 48)
         | ((xxh_u64)bytePtr[7] << 56);
}
XXH_FORCE_INLINE xxh_u64 XXH_readBE64(const void* memPtr)
{
    const xxh_u8* bytePtr = (const xxh_u8 *)memPtr;
    return bytePtr[7]
         | ((xxh_u64)bytePtr[6] << 8)
         | ((xxh_u64)bytePtr[5] << 16)
         | ((xxh_u64)bytePtr[4] << 24)
         | ((xxh_u64)bytePtr[3] << 32)
         | ((xxh_u64)bytePtr[2] << 40)
         | ((xxh_u64)bytePtr[1] << 48)
         | ((xxh_u64)bytePtr[0] << 56);
}
#else
XXH_FORCE_INLINE xxh_u64 XXH_readLE64(const void* ptr)
{
    return XXH_CPU_LITTLE_ENDIAN ? XXH_read64(ptr) : XXH_swap64(XXH_read64(ptr));
}
static xxh_u64 XXH_readBE64(const void* ptr)
{
    return XXH_CPU_LITTLE_ENDIAN ? XXH_swap64(XXH_read64(ptr)) : XXH_read64(ptr);
}
#endif
XXH_FORCE_INLINE xxh_u64
XXH_readLE64_align(const void* ptr, XXH_alignment align)
{
    if (align==XXH_unaligned)
        return XXH_readLE64(ptr);
    else
        return XXH_CPU_LITTLE_ENDIAN ? *(const xxh_u64*)ptr : XXH_swap64(*(const xxh_u64*)ptr);
}
static const xxh_u64 XXH_PRIME64_1 = 0x9E3779B185EBCA87ULL;   
static const xxh_u64 XXH_PRIME64_2 = 0xC2B2AE3D27D4EB4FULL;   
static const xxh_u64 XXH_PRIME64_3 = 0x165667B19E3779F9ULL;   
static const xxh_u64 XXH_PRIME64_4 = 0x85EBCA77C2B2AE63ULL;   
static const xxh_u64 XXH_PRIME64_5 = 0x27D4EB2F165667C5ULL;   
#ifdef XXH_OLD_NAMES
#  define PRIME64_1 XXH_PRIME64_1
#  define PRIME64_2 XXH_PRIME64_2
#  define PRIME64_3 XXH_PRIME64_3
#  define PRIME64_4 XXH_PRIME64_4
#  define PRIME64_5 XXH_PRIME64_5
#endif
static xxh_u64 XXH64_round(xxh_u64 acc, xxh_u64 input)
{
    acc += input * XXH_PRIME64_2;
    acc  = XXH_rotl64(acc, 31);
    acc *= XXH_PRIME64_1;
    return acc;
}
static xxh_u64 XXH64_mergeRound(xxh_u64 acc, xxh_u64 val)
{
    val  = XXH64_round(0, val);
    acc ^= val;
    acc  = acc * XXH_PRIME64_1 + XXH_PRIME64_4;
    return acc;
}
static xxh_u64 XXH64_avalanche(xxh_u64 h64)
{
    h64 ^= h64 >> 33;
    h64 *= XXH_PRIME64_2;
    h64 ^= h64 >> 29;
    h64 *= XXH_PRIME64_3;
    h64 ^= h64 >> 32;
    return h64;
}
#define XXH_get64bits(p) XXH_readLE64_align(p, align)
static xxh_u64
XXH64_finalize(xxh_u64 h64, const xxh_u8* ptr, size_t len, XXH_alignment align)
{
#define XXH_PROCESS1_64 do {                                   \
    h64 ^= (*ptr++) * XXH_PRIME64_5;                           \
    h64 = XXH_rotl64(h64, 11) * XXH_PRIME64_1;                 \
} while (0)
#define XXH_PROCESS4_64 do {                                   \
    h64 ^= (xxh_u64)(XXH_get32bits(ptr)) * XXH_PRIME64_1;      \
    ptr += 4;                                              \
    h64 = XXH_rotl64(h64, 23) * XXH_PRIME64_2 + XXH_PRIME64_3;     \
} while (0)
#define XXH_PROCESS8_64 do {                                   \
    xxh_u64 const k1 = XXH64_round(0, XXH_get64bits(ptr)); \
    ptr += 8;                                              \
    h64 ^= k1;                                             \
    h64  = XXH_rotl64(h64,27) * XXH_PRIME64_1 + XXH_PRIME64_4;     \
} while (0)
    if (XXH_REROLL || XXH_REROLL_XXH64) {
        len &= 31;
        while (len >= 8) {
            XXH_PROCESS8_64;
            len -= 8;
        }
        if (len >= 4) {
            XXH_PROCESS4_64;
            len -= 4;
        }
        while (len > 0) {
            XXH_PROCESS1_64;
            --len;
        }
         return  XXH64_avalanche(h64);
    } else {
        switch(len & 31) {
           case 24: XXH_PROCESS8_64;
           case 16: XXH_PROCESS8_64;
           case  8: XXH_PROCESS8_64;
                    return XXH64_avalanche(h64);
           case 28: XXH_PROCESS8_64;
           case 20: XXH_PROCESS8_64;
           case 12: XXH_PROCESS8_64;
           case  4: XXH_PROCESS4_64;
                    return XXH64_avalanche(h64);
           case 25: XXH_PROCESS8_64;
           case 17: XXH_PROCESS8_64;
           case  9: XXH_PROCESS8_64;
                    XXH_PROCESS1_64;
                    return XXH64_avalanche(h64);
           case 29: XXH_PROCESS8_64;
           case 21: XXH_PROCESS8_64;
           case 13: XXH_PROCESS8_64;
           case  5: XXH_PROCESS4_64;
                    XXH_PROCESS1_64;
                    return XXH64_avalanche(h64);
           case 26: XXH_PROCESS8_64;
           case 18: XXH_PROCESS8_64;
           case 10: XXH_PROCESS8_64;
                    XXH_PROCESS1_64;
                    XXH_PROCESS1_64;
                    return XXH64_avalanche(h64);
           case 30: XXH_PROCESS8_64;
           case 22: XXH_PROCESS8_64;
           case 14: XXH_PROCESS8_64;
           case  6: XXH_PROCESS4_64;
                    XXH_PROCESS1_64;
                    XXH_PROCESS1_64;
                    return XXH64_avalanche(h64);
           case 27: XXH_PROCESS8_64;
           case 19: XXH_PROCESS8_64;
           case 11: XXH_PROCESS8_64;
                    XXH_PROCESS1_64;
                    XXH_PROCESS1_64;
                    XXH_PROCESS1_64;
                    return XXH64_avalanche(h64);
           case 31: XXH_PROCESS8_64;
           case 23: XXH_PROCESS8_64;
           case 15: XXH_PROCESS8_64;
           case  7: XXH_PROCESS4_64;
           case  3: XXH_PROCESS1_64;
           case  2: XXH_PROCESS1_64;
           case  1: XXH_PROCESS1_64;
           case  0: return XXH64_avalanche(h64);
        }
    }
    XXH_ASSERT(0);
    return 0;  
}
#ifdef XXH_OLD_NAMES
#  define PROCESS1_64 XXH_PROCESS1_64
#  define PROCESS4_64 XXH_PROCESS4_64
#  define PROCESS8_64 XXH_PROCESS8_64
#else
#  undef XXH_PROCESS1_64
#  undef XXH_PROCESS4_64
#  undef XXH_PROCESS8_64
#endif
XXH_FORCE_INLINE xxh_u64
XXH64_endian_align(const xxh_u8* input, size_t len, xxh_u64 seed, XXH_alignment align)
{
    const xxh_u8* bEnd = input + len;
    xxh_u64 h64;
#if defined(XXH_ACCEPT_NULL_INPUT_POINTER) && (XXH_ACCEPT_NULL_INPUT_POINTER>=1)
    if (input==NULL) {
        len=0;
        bEnd=input=(const xxh_u8*)(size_t)32;
    }
#endif
    if (len>=32) {
        const xxh_u8* const limit = bEnd - 32;
        xxh_u64 v1 = seed + XXH_PRIME64_1 + XXH_PRIME64_2;
        xxh_u64 v2 = seed + XXH_PRIME64_2;
        xxh_u64 v3 = seed + 0;
        xxh_u64 v4 = seed - XXH_PRIME64_1;
        do {
            v1 = XXH64_round(v1, XXH_get64bits(input)); input+=8;
            v2 = XXH64_round(v2, XXH_get64bits(input)); input+=8;
            v3 = XXH64_round(v3, XXH_get64bits(input)); input+=8;
            v4 = XXH64_round(v4, XXH_get64bits(input)); input+=8;
        } while (input<=limit);
        h64 = XXH_rotl64(v1, 1) + XXH_rotl64(v2, 7) + XXH_rotl64(v3, 12) + XXH_rotl64(v4, 18);
        h64 = XXH64_mergeRound(h64, v1);
        h64 = XXH64_mergeRound(h64, v2);
        h64 = XXH64_mergeRound(h64, v3);
        h64 = XXH64_mergeRound(h64, v4);
    } else {
        h64  = seed + XXH_PRIME64_5;
    }
    h64 += (xxh_u64) len;
    return XXH64_finalize(h64, input, len, align);
}
XXH_PUBLIC_API XXH64_hash_t XXH64 (const void* input, size_t len, XXH64_hash_t seed)
{
#if 0
    XXH64_state_t state;
    XXH64_reset(&state, seed);
    XXH64_update(&state, (const xxh_u8*)input, len);
    return XXH64_digest(&state);
#else
    if (XXH_FORCE_ALIGN_CHECK) {
        if ((((size_t)input) & 7)==0) {  
            return XXH64_endian_align((const xxh_u8*)input, len, seed, XXH_aligned);
    }   }
    return XXH64_endian_align((const xxh_u8*)input, len, seed, XXH_unaligned);
#endif
}
XXH_PUBLIC_API XXH64_state_t* XXH64_createState(void)
{
    return (XXH64_state_t*)XXH_malloc(sizeof(XXH64_state_t));
}
XXH_PUBLIC_API XXH_errorcode XXH64_freeState(XXH64_state_t* statePtr)
{
    XXH_free(statePtr);
    return XXH_OK;
}
XXH_PUBLIC_API void XXH64_copyState(XXH64_state_t* dstState, const XXH64_state_t* srcState)
{
    memcpy(dstState, srcState, sizeof(*dstState));
}
XXH_PUBLIC_API XXH_errorcode XXH64_reset(XXH64_state_t* statePtr, XXH64_hash_t seed)
{
    XXH64_state_t state;   
    memset(&state, 0, sizeof(state));
    state.v1 = seed + XXH_PRIME64_1 + XXH_PRIME64_2;
    state.v2 = seed + XXH_PRIME64_2;
    state.v3 = seed + 0;
    state.v4 = seed - XXH_PRIME64_1;
    memcpy(statePtr, &state, sizeof(state) - sizeof(state.reserved64));
    return XXH_OK;
}
XXH_PUBLIC_API XXH_errorcode
XXH64_update (XXH64_state_t* state, const void* input, size_t len)
{
    if (input==NULL)
#if defined(XXH_ACCEPT_NULL_INPUT_POINTER) && (XXH_ACCEPT_NULL_INPUT_POINTER>=1)
        return XXH_OK;
#else
        return XXH_ERROR;
#endif
    {   const xxh_u8* p = (const xxh_u8*)input;
        const xxh_u8* const bEnd = p + len;
        state->total_len += len;
        if (state->memsize + len < 32) {  
            XXH_memcpy(((xxh_u8*)state->mem64) + state->memsize, input, len);
            state->memsize += (xxh_u32)len;
            return XXH_OK;
        }
        if (state->memsize) {   
            XXH_memcpy(((xxh_u8*)state->mem64) + state->memsize, input, 32-state->memsize);
            state->v1 = XXH64_round(state->v1, XXH_readLE64(state->mem64+0));
            state->v2 = XXH64_round(state->v2, XXH_readLE64(state->mem64+1));
            state->v3 = XXH64_round(state->v3, XXH_readLE64(state->mem64+2));
            state->v4 = XXH64_round(state->v4, XXH_readLE64(state->mem64+3));
            p += 32-state->memsize;
            state->memsize = 0;
        }
        if (p+32 <= bEnd) {
            const xxh_u8* const limit = bEnd - 32;
            xxh_u64 v1 = state->v1;
            xxh_u64 v2 = state->v2;
            xxh_u64 v3 = state->v3;
            xxh_u64 v4 = state->v4;
            do {
                v1 = XXH64_round(v1, XXH_readLE64(p)); p+=8;
                v2 = XXH64_round(v2, XXH_readLE64(p)); p+=8;
                v3 = XXH64_round(v3, XXH_readLE64(p)); p+=8;
                v4 = XXH64_round(v4, XXH_readLE64(p)); p+=8;
            } while (p<=limit);
            state->v1 = v1;
            state->v2 = v2;
            state->v3 = v3;
            state->v4 = v4;
        }
        if (p < bEnd) {
            XXH_memcpy(state->mem64, p, (size_t)(bEnd-p));
            state->memsize = (unsigned)(bEnd-p);
        }
    }
    return XXH_OK;
}
XXH_PUBLIC_API XXH64_hash_t XXH64_digest (const XXH64_state_t* state)
{
    xxh_u64 h64;
    if (state->total_len >= 32) {
        xxh_u64 const v1 = state->v1;
        xxh_u64 const v2 = state->v2;
        xxh_u64 const v3 = state->v3;
        xxh_u64 const v4 = state->v4;
        h64 = XXH_rotl64(v1, 1) + XXH_rotl64(v2, 7) + XXH_rotl64(v3, 12) + XXH_rotl64(v4, 18);
        h64 = XXH64_mergeRound(h64, v1);
        h64 = XXH64_mergeRound(h64, v2);
        h64 = XXH64_mergeRound(h64, v3);
        h64 = XXH64_mergeRound(h64, v4);
    } else {
        h64  = state->v3  + XXH_PRIME64_5;
    }
    h64 += (xxh_u64) state->total_len;
    return XXH64_finalize(h64, (const xxh_u8*)state->mem64, (size_t)state->total_len, XXH_aligned);
}
XXH_PUBLIC_API void XXH64_canonicalFromHash(XXH64_canonical_t* dst, XXH64_hash_t hash)
{
    XXH_STATIC_ASSERT(sizeof(XXH64_canonical_t) == sizeof(XXH64_hash_t));
    if (XXH_CPU_LITTLE_ENDIAN) hash = XXH_swap64(hash);
    memcpy(dst, &hash, sizeof(*dst));
}
XXH_PUBLIC_API XXH64_hash_t XXH64_hashFromCanonical(const XXH64_canonical_t* src)
{
    return XXH_readBE64(src);
}
#if defined (__STDC_VERSION__) && __STDC_VERSION__ >= 199901L  && (!defined(SOLARIS))  
#  define XXH_RESTRICT   restrict
#else
#  define XXH_RESTRICT   
#endif
#if (defined(__GNUC__) && (__GNUC__ >= 3))  \
  || (defined(__INTEL_COMPILER) && (__INTEL_COMPILER >= 800)) \
  || defined(__clang__)
#    define XXH_likely(x) __builtin_expect(x, 1)
#    define XXH_unlikely(x) __builtin_expect(x, 0)
#else
#    define XXH_likely(x) (x)
#    define XXH_unlikely(x) (x)
#endif
#if defined(__GNUC__)
#  if defined(__AVX2__)
#    include <immintrin.h>
#  elif defined(__SSE2__)
#    include <emmintrin.h>
#  elif defined(__ARM_NEON__) || defined(__ARM_NEON)
#    define inline __inline__  
#    include <arm_neon.h>
#    undef inline
#  endif
#elif defined(_MSC_VER)
#  include <intrin.h>
#endif
#if defined(__thumb__) && !defined(__thumb2__) && defined(__ARM_ARCH_ISA_ARM)
#   warning "XXH3 is highly inefficient without ARM or Thumb-2."
#endif
#define XXH_SCALAR 0  
#define XXH_SSE2   1  
#define XXH_AVX2   2  
#define XXH_AVX512 3  
#define XXH_NEON   4  
#define XXH_VSX    5  
#ifndef XXH_VECTOR    
#  if defined(__AVX512F__)
#    define XXH_VECTOR XXH_AVX512
#  elif defined(__AVX2__)
#    define XXH_VECTOR XXH_AVX2
#  elif defined(__SSE2__) || defined(_M_AMD64) || defined(_M_X64) || (defined(_M_IX86_FP) && (_M_IX86_FP == 2))
#    define XXH_VECTOR XXH_SSE2
#  elif defined(__GNUC__)  \
  && (defined(__ARM_NEON__) || defined(__ARM_NEON)) \
  && (defined(__LITTLE_ENDIAN__)  \
    || (defined(__BYTE_ORDER__) && __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__))
#    define XXH_VECTOR XXH_NEON
#  elif (defined(__PPC64__) && defined(__POWER8_VECTOR__)) \
     || (defined(__s390x__) && defined(__VEC__)) \
     && defined(__GNUC__) 
#    define XXH_VECTOR XXH_VSX
#  else
#    define XXH_VECTOR XXH_SCALAR
#  endif
#endif
#ifndef XXH_ACC_ALIGN
#  if defined(XXH_X86DISPATCH)
#     define XXH_ACC_ALIGN 64  
#  elif XXH_VECTOR == XXH_SCALAR  
#     define XXH_ACC_ALIGN 8
#  elif XXH_VECTOR == XXH_SSE2  
#     define XXH_ACC_ALIGN 16
#  elif XXH_VECTOR == XXH_AVX2  
#     define XXH_ACC_ALIGN 32
#  elif XXH_VECTOR == XXH_NEON  
#     define XXH_ACC_ALIGN 16
#  elif XXH_VECTOR == XXH_VSX   
#     define XXH_ACC_ALIGN 16
#  elif XXH_VECTOR == XXH_AVX512  
#     define XXH_ACC_ALIGN 64
#  endif
#endif
#if defined(XXH_X86DISPATCH) || XXH_VECTOR == XXH_SSE2 \
    || XXH_VECTOR == XXH_AVX2 || XXH_VECTOR == XXH_AVX512
#  define XXH_SEC_ALIGN XXH_ACC_ALIGN
#else
#  define XXH_SEC_ALIGN 8
#endif
#if XXH_VECTOR == XXH_AVX2  \
  && defined(__GNUC__) && !defined(__clang__)  \
  && defined(__OPTIMIZE__) && !defined(__OPTIMIZE_SIZE__) 
#  pragma GCC push_options
#  pragma GCC optimize("-O2")
#endif
#if XXH_VECTOR == XXH_NEON
# if !defined(XXH_NO_VZIP_HACK)  \
   && defined(__GNUC__) \
   && !defined(__aarch64__) && !defined(__arm64__)
#  define XXH_SPLIT_IN_PLACE(in, outLo, outHi)                                              \
    do {                                                                                    \
       \
           \
       \
      __asm__("vzip.32  %e0, %f0" : "+w" (in));                                             \
      (outLo) = vget_low_u32 (vreinterpretq_u32_u64(in));                                   \
      (outHi) = vget_high_u32(vreinterpretq_u32_u64(in));                                   \
   } while (0)
# else
#  define XXH_SPLIT_IN_PLACE(in, outLo, outHi)                                            \
    do {                                                                                  \
      (outLo) = vmovn_u64    (in);                                                        \
      (outHi) = vshrn_n_u64  ((in), 32);                                                  \
    } while (0)
# endif
#endif  
#if XXH_VECTOR == XXH_VSX
#  if defined(__s390x__)
#    include <s390intrin.h>
#  else
#    if defined(__GNUC__) && !defined(__APPLE_ALTIVEC__)
#      define __APPLE_ALTIVEC__
#    endif
#    include <altivec.h>
#  endif
typedef __vector unsigned long long xxh_u64x2;
typedef __vector unsigned char xxh_u8x16;
typedef __vector unsigned xxh_u32x4;
# ifndef XXH_VSX_BE
#  if defined(__BIG_ENDIAN__) \
  || (defined(__BYTE_ORDER__) && __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__)
#    define XXH_VSX_BE 1
#  elif defined(__VEC_ELEMENT_REG_ORDER__) && __VEC_ELEMENT_REG_ORDER__ == __ORDER_BIG_ENDIAN__
#    warning "-maltivec=be is not recommended. Please use native endianness."
#    define XXH_VSX_BE 1
#  else
#    define XXH_VSX_BE 0
#  endif
# endif 
# if XXH_VSX_BE
#  if defined(__POWER9_VECTOR__) || (defined(__clang__) && defined(__s390x__))
#    define XXH_vec_revb vec_revb
#  else
XXH_FORCE_INLINE xxh_u64x2 XXH_vec_revb(xxh_u64x2 val)
{
    xxh_u8x16 const vByteSwap = { 0x07, 0x06, 0x05, 0x04, 0x03, 0x02, 0x01, 0x00,
                                  0x0F, 0x0E, 0x0D, 0x0C, 0x0B, 0x0A, 0x09, 0x08 };
    return vec_perm(val, val, vByteSwap);
}
#  endif
# endif 
XXH_FORCE_INLINE xxh_u64x2 XXH_vec_loadu(const void *ptr)
{
    xxh_u64x2 ret;
    memcpy(&ret, ptr, sizeof(xxh_u64x2));
# if XXH_VSX_BE
    ret = XXH_vec_revb(ret);
# endif
    return ret;
}
# if defined(__s390x__)
#  define XXH_vec_mulo vec_mulo
#  define XXH_vec_mule vec_mule
# elif defined(__clang__) && XXH_HAS_BUILTIN(__builtin_altivec_vmuleuw)
#  define XXH_vec_mulo __builtin_altivec_vmulouw
#  define XXH_vec_mule __builtin_altivec_vmuleuw
# else
XXH_FORCE_INLINE xxh_u64x2 XXH_vec_mulo(xxh_u32x4 a, xxh_u32x4 b)
{
    xxh_u64x2 result;
    __asm__("vmulouw %0, %1, %2" : "=v" (result) : "v" (a), "v" (b));
    return result;
}
XXH_FORCE_INLINE xxh_u64x2 XXH_vec_mule(xxh_u32x4 a, xxh_u32x4 b)
{
    xxh_u64x2 result;
    __asm__("vmuleuw %0, %1, %2" : "=v" (result) : "v" (a), "v" (b));
    return result;
}
# endif 
#endif 
#if defined(XXH_NO_PREFETCH)
#  define XXH_PREFETCH(ptr)  (void)(ptr)  
#else
#  if defined(_MSC_VER) && (defined(_M_X64) || defined(_M_I86))  
#    include <mmintrin.h>   
#    define XXH_PREFETCH(ptr)  _mm_prefetch((const char*)(ptr), _MM_HINT_T0)
#  elif defined(__GNUC__) && ( (__GNUC__ >= 4) || ( (__GNUC__ == 3) && (__GNUC_MINOR__ >= 1) ) )
#    define XXH_PREFETCH(ptr)  __builtin_prefetch((ptr), 0 , 3 )
#  else
#    define XXH_PREFETCH(ptr) (void)(ptr)  
#  endif
#endif  
#define XXH_SECRET_DEFAULT_SIZE 192   
#if (XXH_SECRET_DEFAULT_SIZE < XXH3_SECRET_SIZE_MIN)
#  error "default keyset is not large enough"
#endif
XXH_ALIGN(64) static const xxh_u8 XXH3_kSecret[XXH_SECRET_DEFAULT_SIZE] = {
    0xb8, 0xfe, 0x6c, 0x39, 0x23, 0xa4, 0x4b, 0xbe, 0x7c, 0x01, 0x81, 0x2c, 0xf7, 0x21, 0xad, 0x1c,
    0xde, 0xd4, 0x6d, 0xe9, 0x83, 0x90, 0x97, 0xdb, 0x72, 0x40, 0xa4, 0xa4, 0xb7, 0xb3, 0x67, 0x1f,
    0xcb, 0x79, 0xe6, 0x4e, 0xcc, 0xc0, 0xe5, 0x78, 0x82, 0x5a, 0xd0, 0x7d, 0xcc, 0xff, 0x72, 0x21,
    0xb8, 0x08, 0x46, 0x74, 0xf7, 0x43, 0x24, 0x8e, 0xe0, 0x35, 0x90, 0xe6, 0x81, 0x3a, 0x26, 0x4c,
    0x3c, 0x28, 0x52, 0xbb, 0x91, 0xc3, 0x00, 0xcb, 0x88, 0xd0, 0x65, 0x8b, 0x1b, 0x53, 0x2e, 0xa3,
    0x71, 0x64, 0x48, 0x97, 0xa2, 0x0d, 0xf9, 0x4e, 0x38, 0x19, 0xef, 0x46, 0xa9, 0xde, 0xac, 0xd8,
    0xa8, 0xfa, 0x76, 0x3f, 0xe3, 0x9c, 0x34, 0x3f, 0xf9, 0xdc, 0xbb, 0xc7, 0xc7, 0x0b, 0x4f, 0x1d,
    0x8a, 0x51, 0xe0, 0x4b, 0xcd, 0xb4, 0x59, 0x31, 0xc8, 0x9f, 0x7e, 0xc9, 0xd9, 0x78, 0x73, 0x64,
    0xea, 0xc5, 0xac, 0x83, 0x34, 0xd3, 0xeb, 0xc3, 0xc5, 0x81, 0xa0, 0xff, 0xfa, 0x13, 0x63, 0xeb,
    0x17, 0x0d, 0xdd, 0x51, 0xb7, 0xf0, 0xda, 0x49, 0xd3, 0x16, 0x55, 0x26, 0x29, 0xd4, 0x68, 0x9e,
    0x2b, 0x16, 0xbe, 0x58, 0x7d, 0x47, 0xa1, 0xfc, 0x8f, 0xf8, 0xb8, 0xd1, 0x7a, 0xd0, 0x31, 0xce,
    0x45, 0xcb, 0x3a, 0x8f, 0x95, 0x16, 0x04, 0x28, 0xaf, 0xd7, 0xfb, 0xca, 0xbb, 0x4b, 0x40, 0x7e,
};
#ifdef XXH_OLD_NAMES
#  define kSecret XXH3_kSecret
#endif
#if defined(_MSC_VER) && defined(_M_IX86)
#    include <intrin.h>
#    define XXH_mult32to64(x, y) __emulu((unsigned)(x), (unsigned)(y))
#else
#    define XXH_mult32to64(x, y) ((xxh_u64)(xxh_u32)(x) * (xxh_u64)(xxh_u32)(y))
#endif
static XXH128_hash_t
XXH_mult64to128(xxh_u64 lhs, xxh_u64 rhs)
{
#if defined(__GNUC__) && !defined(__wasm__) \
    && defined(__SIZEOF_INT128__) \
    || (defined(_INTEGRAL_MAX_BITS) && _INTEGRAL_MAX_BITS >= 128)
    __uint128_t const product = (__uint128_t)lhs * (__uint128_t)rhs;
    XXH128_hash_t r128;
    r128.low64  = (xxh_u64)(product);
    r128.high64 = (xxh_u64)(product >> 64);
    return r128;
#elif defined(_M_X64) || defined(_M_IA64)
#ifndef _MSC_VER
#   pragma intrinsic(_umul128)
#endif
    xxh_u64 product_high;
    xxh_u64 const product_low = _umul128(lhs, rhs, &product_high);
    XXH128_hash_t r128;
    r128.low64  = product_low;
    r128.high64 = product_high;
    return r128;
#else
    xxh_u64 const lo_lo = XXH_mult32to64(lhs & 0xFFFFFFFF, rhs & 0xFFFFFFFF);
    xxh_u64 const hi_lo = XXH_mult32to64(lhs >> 32,        rhs & 0xFFFFFFFF);
    xxh_u64 const lo_hi = XXH_mult32to64(lhs & 0xFFFFFFFF, rhs >> 32);
    xxh_u64 const hi_hi = XXH_mult32to64(lhs >> 32,        rhs >> 32);
    xxh_u64 const cross = (lo_lo >> 32) + (hi_lo & 0xFFFFFFFF) + lo_hi;
    xxh_u64 const upper = (hi_lo >> 32) + (cross >> 32)        + hi_hi;
    xxh_u64 const lower = (cross << 32) | (lo_lo & 0xFFFFFFFF);
    XXH128_hash_t r128;
    r128.low64  = lower;
    r128.high64 = upper;
    return r128;
#endif
}
static xxh_u64
XXH3_mul128_fold64(xxh_u64 lhs, xxh_u64 rhs)
{
    XXH128_hash_t product = XXH_mult64to128(lhs, rhs);
    return product.low64 ^ product.high64;
}
XXH_FORCE_INLINE xxh_u64 XXH_xorshift64(xxh_u64 v64, int shift)
{
    XXH_ASSERT(0 <= shift && shift < 64);
    return v64 ^ (v64 >> shift);
}
static XXH64_hash_t XXH3_avalanche(xxh_u64 h64)
{
    h64 = XXH_xorshift64(h64, 37);
    h64 *= 0x165667919E3779F9ULL;
    h64 = XXH_xorshift64(h64, 32);
    return h64;
}
static XXH64_hash_t XXH3_rrmxmx(xxh_u64 h64, xxh_u64 len)
{
    h64 ^= XXH_rotl64(h64, 49) ^ XXH_rotl64(h64, 24);
    h64 *= 0x9FB21C651E98DF25ULL;
    h64 ^= (h64 >> 35) + len ;
    h64 *= 0x9FB21C651E98DF25ULL;
    return XXH_xorshift64(h64, 28);
}
XXH_FORCE_INLINE XXH64_hash_t
XXH3_len_1to3_64b(const xxh_u8* input, size_t len, const xxh_u8* secret, XXH64_hash_t seed)
{
    XXH_ASSERT(input != NULL);
    XXH_ASSERT(1 <= len && len <= 3);
    XXH_ASSERT(secret != NULL);
    {   xxh_u8  const c1 = input[0];
        xxh_u8  const c2 = input[len >> 1];
        xxh_u8  const c3 = input[len - 1];
        xxh_u32 const combined = ((xxh_u32)c1 << 16) | ((xxh_u32)c2  << 24)
                               | ((xxh_u32)c3 <<  0) | ((xxh_u32)len << 8);
        xxh_u64 const bitflip = (XXH_readLE32(secret) ^ XXH_readLE32(secret+4)) + seed;
        xxh_u64 const keyed = (xxh_u64)combined ^ bitflip;
        return XXH64_avalanche(keyed);
    }
}
XXH_FORCE_INLINE XXH64_hash_t
XXH3_len_4to8_64b(const xxh_u8* input, size_t len, const xxh_u8* secret, XXH64_hash_t seed)
{
    XXH_ASSERT(input != NULL);
    XXH_ASSERT(secret != NULL);
    XXH_ASSERT(4 <= len && len < 8);
    seed ^= (xxh_u64)XXH_swap32((xxh_u32)seed) << 32;
    {   xxh_u32 const input1 = XXH_readLE32(input);
        xxh_u32 const input2 = XXH_readLE32(input + len - 4);
        xxh_u64 const bitflip = (XXH_readLE64(secret+8) ^ XXH_readLE64(secret+16)) - seed;
        xxh_u64 const input64 = input2 + (((xxh_u64)input1) << 32);
        xxh_u64 const keyed = input64 ^ bitflip;
        return XXH3_rrmxmx(keyed, len);
    }
}
XXH_FORCE_INLINE XXH64_hash_t
XXH3_len_9to16_64b(const xxh_u8* input, size_t len, const xxh_u8* secret, XXH64_hash_t seed)
{
    XXH_ASSERT(input != NULL);
    XXH_ASSERT(secret != NULL);
    XXH_ASSERT(8 <= len && len <= 16);
    {   xxh_u64 const bitflip1 = (XXH_readLE64(secret+24) ^ XXH_readLE64(secret+32)) + seed;
        xxh_u64 const bitflip2 = (XXH_readLE64(secret+40) ^ XXH_readLE64(secret+48)) - seed;
        xxh_u64 const input_lo = XXH_readLE64(input)           ^ bitflip1;
        xxh_u64 const input_hi = XXH_readLE64(input + len - 8) ^ bitflip2;
        xxh_u64 const acc = len
                          + XXH_swap64(input_lo) + input_hi
                          + XXH3_mul128_fold64(input_lo, input_hi);
        return XXH3_avalanche(acc);
    }
}
XXH_FORCE_INLINE XXH64_hash_t
XXH3_len_0to16_64b(const xxh_u8* input, size_t len, const xxh_u8* secret, XXH64_hash_t seed)
{
    XXH_ASSERT(len <= 16);
    {   if (XXH_likely(len >  8)) return XXH3_len_9to16_64b(input, len, secret, seed);
        if (XXH_likely(len >= 4)) return XXH3_len_4to8_64b(input, len, secret, seed);
        if (len) return XXH3_len_1to3_64b(input, len, secret, seed);
        return XXH64_avalanche(seed ^ (XXH_readLE64(secret+56) ^ XXH_readLE64(secret+64)));
    }
}
XXH_FORCE_INLINE xxh_u64 XXH3_mix16B(const xxh_u8* XXH_RESTRICT input,
                                     const xxh_u8* XXH_RESTRICT secret, xxh_u64 seed64)
{
#if defined(__GNUC__) && !defined(__clang__)  \
  && defined(__i386__) && defined(__SSE2__)   \
  && !defined(XXH_ENABLE_AUTOVECTORIZE)      
    __asm__ ("" : "+r" (seed64));
#endif
    {   xxh_u64 const input_lo = XXH_readLE64(input);
        xxh_u64 const input_hi = XXH_readLE64(input+8);
        return XXH3_mul128_fold64(
            input_lo ^ (XXH_readLE64(secret)   + seed64),
            input_hi ^ (XXH_readLE64(secret+8) - seed64)
        );
    }
}
XXH_FORCE_INLINE XXH64_hash_t
XXH3_len_17to128_64b(const xxh_u8* XXH_RESTRICT input, size_t len,
                     const xxh_u8* XXH_RESTRICT secret, size_t secretSize,
                     XXH64_hash_t seed)
{
    XXH_ASSERT(secretSize >= XXH3_SECRET_SIZE_MIN); (void)secretSize;
    XXH_ASSERT(16 < len && len <= 128);
    {   xxh_u64 acc = len * XXH_PRIME64_1;
        if (len > 32) {
            if (len > 64) {
                if (len > 96) {
                    acc += XXH3_mix16B(input+48, secret+96, seed);
                    acc += XXH3_mix16B(input+len-64, secret+112, seed);
                }
                acc += XXH3_mix16B(input+32, secret+64, seed);
                acc += XXH3_mix16B(input+len-48, secret+80, seed);
            }
            acc += XXH3_mix16B(input+16, secret+32, seed);
            acc += XXH3_mix16B(input+len-32, secret+48, seed);
        }
        acc += XXH3_mix16B(input+0, secret+0, seed);
        acc += XXH3_mix16B(input+len-16, secret+16, seed);
        return XXH3_avalanche(acc);
    }
}
#define XXH3_MIDSIZE_MAX 240
XXH_NO_INLINE XXH64_hash_t
XXH3_len_129to240_64b(const xxh_u8* XXH_RESTRICT input, size_t len,
                      const xxh_u8* XXH_RESTRICT secret, size_t secretSize,
                      XXH64_hash_t seed)
{
    XXH_ASSERT(secretSize >= XXH3_SECRET_SIZE_MIN); (void)secretSize;
    XXH_ASSERT(128 < len && len <= XXH3_MIDSIZE_MAX);
    #define XXH3_MIDSIZE_STARTOFFSET 3
    #define XXH3_MIDSIZE_LASTOFFSET  17
    {   xxh_u64 acc = len * XXH_PRIME64_1;
        int const nbRounds = (int)len / 16;
        int i;
        for (i=0; i<8; i++) {
            acc += XXH3_mix16B(input+(16*i), secret+(16*i), seed);
        }
        acc = XXH3_avalanche(acc);
        XXH_ASSERT(nbRounds >= 8);
#if defined(__clang__)                                 \
    && (defined(__ARM_NEON) || defined(__ARM_NEON__))  \
    && !defined(XXH_ENABLE_AUTOVECTORIZE)             
        #pragma clang loop vectorize(disable)
#endif
        for (i=8 ; i < nbRounds; i++) {
            acc += XXH3_mix16B(input+(16*i), secret+(16*(i-8)) + XXH3_MIDSIZE_STARTOFFSET, seed);
        }
        acc += XXH3_mix16B(input + len - 16, secret + XXH3_SECRET_SIZE_MIN - XXH3_MIDSIZE_LASTOFFSET, seed);
        return XXH3_avalanche(acc);
    }
}
#define XXH_STRIPE_LEN 64
#define XXH_SECRET_CONSUME_RATE 8   
#define XXH_ACC_NB (XXH_STRIPE_LEN / sizeof(xxh_u64))
#ifdef XXH_OLD_NAMES
#  define STRIPE_LEN XXH_STRIPE_LEN
#  define ACC_NB XXH_ACC_NB
#endif
XXH_FORCE_INLINE void XXH_writeLE64(void* dst, xxh_u64 v64)
{
    if (!XXH_CPU_LITTLE_ENDIAN) v64 = XXH_swap64(v64);
    memcpy(dst, &v64, sizeof(v64));
}
#if !defined (__VMS) \
  && (defined (__cplusplus) \
  || (defined (__STDC_VERSION__) && (__STDC_VERSION__ >= 199901L) ) )
    typedef int64_t xxh_i64;
#else
    typedef long long xxh_i64;
#endif
#if (XXH_VECTOR == XXH_AVX512) || defined(XXH_X86DISPATCH)
#ifndef XXH_TARGET_AVX512
# define XXH_TARGET_AVX512  
#endif
XXH_FORCE_INLINE XXH_TARGET_AVX512 void
XXH3_accumulate_512_avx512(void* XXH_RESTRICT acc,
                     const void* XXH_RESTRICT input,
                     const void* XXH_RESTRICT secret)
{
    XXH_ALIGN(64) __m512i* const xacc = (__m512i *) acc;
    XXH_ASSERT((((size_t)acc) & 63) == 0);
    XXH_STATIC_ASSERT(XXH_STRIPE_LEN == sizeof(__m512i));
    {
        __m512i const data_vec    = _mm512_loadu_si512   (input);
        __m512i const key_vec     = _mm512_loadu_si512   (secret);
        __m512i const data_key    = _mm512_xor_si512     (data_vec, key_vec);
        __m512i const data_key_lo = _mm512_shuffle_epi32 (data_key, (_MM_PERM_ENUM)_MM_SHUFFLE(0, 3, 0, 1));
        __m512i const product     = _mm512_mul_epu32     (data_key, data_key_lo);
        __m512i const data_swap = _mm512_shuffle_epi32(data_vec, (_MM_PERM_ENUM)_MM_SHUFFLE(1, 0, 3, 2));
        __m512i const sum       = _mm512_add_epi64(*xacc, data_swap);
        *xacc = _mm512_add_epi64(product, sum);
    }
}
XXH_FORCE_INLINE XXH_TARGET_AVX512 void
XXH3_scrambleAcc_avx512(void* XXH_RESTRICT acc, const void* XXH_RESTRICT secret)
{
    XXH_ASSERT((((size_t)acc) & 63) == 0);
    XXH_STATIC_ASSERT(XXH_STRIPE_LEN == sizeof(__m512i));
    {   XXH_ALIGN(64) __m512i* const xacc = (__m512i*) acc;
        const __m512i prime32 = _mm512_set1_epi32((int)XXH_PRIME32_1);
        __m512i const acc_vec     = *xacc;
        __m512i const shifted     = _mm512_srli_epi64    (acc_vec, 47);
        __m512i const data_vec    = _mm512_xor_si512     (acc_vec, shifted);
        __m512i const key_vec     = _mm512_loadu_si512   (secret);
        __m512i const data_key    = _mm512_xor_si512     (data_vec, key_vec);
        __m512i const data_key_hi = _mm512_shuffle_epi32 (data_key, (_MM_PERM_ENUM)_MM_SHUFFLE(0, 3, 0, 1));
        __m512i const prod_lo     = _mm512_mul_epu32     (data_key, prime32);
        __m512i const prod_hi     = _mm512_mul_epu32     (data_key_hi, prime32);
        *xacc = _mm512_add_epi64(prod_lo, _mm512_slli_epi64(prod_hi, 32));
    }
}
XXH_FORCE_INLINE XXH_TARGET_AVX512 void
XXH3_initCustomSecret_avx512(void* XXH_RESTRICT customSecret, xxh_u64 seed64)
{
    XXH_STATIC_ASSERT((XXH_SECRET_DEFAULT_SIZE & 63) == 0);
    XXH_STATIC_ASSERT(XXH_SEC_ALIGN == 64);
    XXH_ASSERT(((size_t)customSecret & 63) == 0);
    (void)(&XXH_writeLE64);
    {   int const nbRounds = XXH_SECRET_DEFAULT_SIZE / sizeof(__m512i);
        __m512i const seed = _mm512_mask_set1_epi64(_mm512_set1_epi64((xxh_i64)seed64), 0xAA, -(xxh_i64)seed64);
        XXH_ALIGN(64) const __m512i* const src  = (const __m512i*) XXH3_kSecret;
        XXH_ALIGN(64)       __m512i* const dest = (      __m512i*) customSecret;
        int i;
        for (i=0; i < nbRounds; ++i) {
            union {
                XXH_ALIGN(64) const __m512i* cp;
                XXH_ALIGN(64) void* p;
            } remote_const_void;
            remote_const_void.cp = src + i;
            dest[i] = _mm512_add_epi64(_mm512_stream_load_si512(remote_const_void.p), seed);
    }   }
}
#endif
#if (XXH_VECTOR == XXH_AVX2) || defined(XXH_X86DISPATCH)
#ifndef XXH_TARGET_AVX2
# define XXH_TARGET_AVX2  
#endif
XXH_FORCE_INLINE XXH_TARGET_AVX2 void
XXH3_accumulate_512_avx2( void* XXH_RESTRICT acc,
                    const void* XXH_RESTRICT input,
                    const void* XXH_RESTRICT secret)
{
    XXH_ASSERT((((size_t)acc) & 31) == 0);
    {   XXH_ALIGN(32) __m256i* const xacc    =       (__m256i *) acc;
        const         __m256i* const xinput  = (const __m256i *) input;
        const         __m256i* const xsecret = (const __m256i *) secret;
        size_t i;
        for (i=0; i < XXH_STRIPE_LEN/sizeof(__m256i); i++) {
            __m256i const data_vec    = _mm256_loadu_si256    (xinput+i);
            __m256i const key_vec     = _mm256_loadu_si256   (xsecret+i);
            __m256i const data_key    = _mm256_xor_si256     (data_vec, key_vec);
            __m256i const data_key_lo = _mm256_shuffle_epi32 (data_key, _MM_SHUFFLE(0, 3, 0, 1));
            __m256i const product     = _mm256_mul_epu32     (data_key, data_key_lo);
            __m256i const data_swap = _mm256_shuffle_epi32(data_vec, _MM_SHUFFLE(1, 0, 3, 2));
            __m256i const sum       = _mm256_add_epi64(xacc[i], data_swap);
            xacc[i] = _mm256_add_epi64(product, sum);
    }   }
}
XXH_FORCE_INLINE XXH_TARGET_AVX2 void
XXH3_scrambleAcc_avx2(void* XXH_RESTRICT acc, const void* XXH_RESTRICT secret)
{
    XXH_ASSERT((((size_t)acc) & 31) == 0);
    {   XXH_ALIGN(32) __m256i* const xacc = (__m256i*) acc;
        const         __m256i* const xsecret = (const __m256i *) secret;
        const __m256i prime32 = _mm256_set1_epi32((int)XXH_PRIME32_1);
        size_t i;
        for (i=0; i < XXH_STRIPE_LEN/sizeof(__m256i); i++) {
            __m256i const acc_vec     = xacc[i];
            __m256i const shifted     = _mm256_srli_epi64    (acc_vec, 47);
            __m256i const data_vec    = _mm256_xor_si256     (acc_vec, shifted);
            __m256i const key_vec     = _mm256_loadu_si256   (xsecret+i);
            __m256i const data_key    = _mm256_xor_si256     (data_vec, key_vec);
            __m256i const data_key_hi = _mm256_shuffle_epi32 (data_key, _MM_SHUFFLE(0, 3, 0, 1));
            __m256i const prod_lo     = _mm256_mul_epu32     (data_key, prime32);
            __m256i const prod_hi     = _mm256_mul_epu32     (data_key_hi, prime32);
            xacc[i] = _mm256_add_epi64(prod_lo, _mm256_slli_epi64(prod_hi, 32));
        }
    }
}
XXH_FORCE_INLINE XXH_TARGET_AVX2 void XXH3_initCustomSecret_avx2(void* XXH_RESTRICT customSecret, xxh_u64 seed64)
{
    XXH_STATIC_ASSERT((XXH_SECRET_DEFAULT_SIZE & 31) == 0);
    XXH_STATIC_ASSERT((XXH_SECRET_DEFAULT_SIZE / sizeof(__m256i)) == 6);
    XXH_STATIC_ASSERT(XXH_SEC_ALIGN <= 64);
    (void)(&XXH_writeLE64);
    XXH_PREFETCH(customSecret);
    {   __m256i const seed = _mm256_set_epi64x(-(xxh_i64)seed64, (xxh_i64)seed64, -(xxh_i64)seed64, (xxh_i64)seed64);
        XXH_ALIGN(64) const __m256i* const src  = (const __m256i*) XXH3_kSecret;
        XXH_ALIGN(64)       __m256i*       dest = (      __m256i*) customSecret;
#       if defined(__GNUC__) || defined(__clang__)
        __asm__("" : "+r" (dest));
#       endif
        dest[0] = _mm256_add_epi64(_mm256_stream_load_si256(src+0), seed);
        dest[1] = _mm256_add_epi64(_mm256_stream_load_si256(src+1), seed);
        dest[2] = _mm256_add_epi64(_mm256_stream_load_si256(src+2), seed);
        dest[3] = _mm256_add_epi64(_mm256_stream_load_si256(src+3), seed);
        dest[4] = _mm256_add_epi64(_mm256_stream_load_si256(src+4), seed);
        dest[5] = _mm256_add_epi64(_mm256_stream_load_si256(src+5), seed);
    }
}
#endif
#if (XXH_VECTOR == XXH_SSE2) || defined(XXH_X86DISPATCH)
#ifndef XXH_TARGET_SSE2
# define XXH_TARGET_SSE2  
#endif
XXH_FORCE_INLINE XXH_TARGET_SSE2 void
XXH3_accumulate_512_sse2( void* XXH_RESTRICT acc,
                    const void* XXH_RESTRICT input,
                    const void* XXH_RESTRICT secret)
{
    XXH_ASSERT((((size_t)acc) & 15) == 0);
    {   XXH_ALIGN(16) __m128i* const xacc    =       (__m128i *) acc;
        const         __m128i* const xinput  = (const __m128i *) input;
        const         __m128i* const xsecret = (const __m128i *) secret;
        size_t i;
        for (i=0; i < XXH_STRIPE_LEN/sizeof(__m128i); i++) {
            __m128i const data_vec    = _mm_loadu_si128   (xinput+i);
            __m128i const key_vec     = _mm_loadu_si128   (xsecret+i);
            __m128i const data_key    = _mm_xor_si128     (data_vec, key_vec);
            __m128i const data_key_lo = _mm_shuffle_epi32 (data_key, _MM_SHUFFLE(0, 3, 0, 1));
            __m128i const product     = _mm_mul_epu32     (data_key, data_key_lo);
            __m128i const data_swap = _mm_shuffle_epi32(data_vec, _MM_SHUFFLE(1,0,3,2));
            __m128i const sum       = _mm_add_epi64(xacc[i], data_swap);
            xacc[i] = _mm_add_epi64(product, sum);
    }   }
}
XXH_FORCE_INLINE XXH_TARGET_SSE2 void
XXH3_scrambleAcc_sse2(void* XXH_RESTRICT acc, const void* XXH_RESTRICT secret)
{
    XXH_ASSERT((((size_t)acc) & 15) == 0);
    {   XXH_ALIGN(16) __m128i* const xacc = (__m128i*) acc;
        const         __m128i* const xsecret = (const __m128i *) secret;
        const __m128i prime32 = _mm_set1_epi32((int)XXH_PRIME32_1);
        size_t i;
        for (i=0; i < XXH_STRIPE_LEN/sizeof(__m128i); i++) {
            __m128i const acc_vec     = xacc[i];
            __m128i const shifted     = _mm_srli_epi64    (acc_vec, 47);
            __m128i const data_vec    = _mm_xor_si128     (acc_vec, shifted);
            __m128i const key_vec     = _mm_loadu_si128   (xsecret+i);
            __m128i const data_key    = _mm_xor_si128     (data_vec, key_vec);
            __m128i const data_key_hi = _mm_shuffle_epi32 (data_key, _MM_SHUFFLE(0, 3, 0, 1));
            __m128i const prod_lo     = _mm_mul_epu32     (data_key, prime32);
            __m128i const prod_hi     = _mm_mul_epu32     (data_key_hi, prime32);
            xacc[i] = _mm_add_epi64(prod_lo, _mm_slli_epi64(prod_hi, 32));
        }
    }
}
XXH_FORCE_INLINE XXH_TARGET_SSE2 void XXH3_initCustomSecret_sse2(void* XXH_RESTRICT customSecret, xxh_u64 seed64)
{
    XXH_STATIC_ASSERT((XXH_SECRET_DEFAULT_SIZE & 15) == 0);
    (void)(&XXH_writeLE64);
    {   int const nbRounds = XXH_SECRET_DEFAULT_SIZE / sizeof(__m128i);
#       if defined(_MSC_VER) && defined(_M_IX86) && _MSC_VER < 1900
        XXH_ALIGN(16) const xxh_i64 seed64x2[2] = { (xxh_i64)seed64, -(xxh_i64)seed64 };
        __m128i const seed = _mm_load_si128((__m128i const*)seed64x2);
#       else
        __m128i const seed = _mm_set_epi64x(-(xxh_i64)seed64, (xxh_i64)seed64);
#       endif
        int i;
        XXH_ALIGN(64)        const float* const src  = (float const*) XXH3_kSecret;
        XXH_ALIGN(XXH_SEC_ALIGN) __m128i*       dest = (__m128i*) customSecret;
#       if defined(__GNUC__) || defined(__clang__)
        __asm__("" : "+r" (dest));
#       endif
        for (i=0; i < nbRounds; ++i) {
            dest[i] = _mm_add_epi64(_mm_castps_si128(_mm_load_ps(src+i*4)), seed);
    }   }
}
#endif
#if (XXH_VECTOR == XXH_NEON)
XXH_FORCE_INLINE void
XXH3_accumulate_512_neon( void* XXH_RESTRICT acc,
                    const void* XXH_RESTRICT input,
                    const void* XXH_RESTRICT secret)
{
    XXH_ASSERT((((size_t)acc) & 15) == 0);
    {
        XXH_ALIGN(16) uint64x2_t* const xacc = (uint64x2_t *) acc;
        uint8_t const* const xinput = (const uint8_t *) input;
        uint8_t const* const xsecret  = (const uint8_t *) secret;
        size_t i;
        for (i=0; i < XXH_STRIPE_LEN / sizeof(uint64x2_t); i++) {
            uint8x16_t data_vec    = vld1q_u8(xinput  + (i * 16));
            uint8x16_t key_vec     = vld1q_u8(xsecret + (i * 16));
            uint64x2_t data_key;
            uint32x2_t data_key_lo, data_key_hi;
            uint64x2_t const data64  = vreinterpretq_u64_u8(data_vec);
            uint64x2_t const swapped = vextq_u64(data64, data64, 1);
            xacc[i] = vaddq_u64 (xacc[i], swapped);
            data_key = vreinterpretq_u64_u8(veorq_u8(data_vec, key_vec));
            XXH_SPLIT_IN_PLACE(data_key, data_key_lo, data_key_hi);
            xacc[i] = vmlal_u32 (xacc[i], data_key_lo, data_key_hi);
        }
    }
}
XXH_FORCE_INLINE void
XXH3_scrambleAcc_neon(void* XXH_RESTRICT acc, const void* XXH_RESTRICT secret)
{
    XXH_ASSERT((((size_t)acc) & 15) == 0);
    {   uint64x2_t* xacc       = (uint64x2_t*) acc;
        uint8_t const* xsecret = (uint8_t const*) secret;
        uint32x2_t prime       = vdup_n_u32 (XXH_PRIME32_1);
        size_t i;
        for (i=0; i < XXH_STRIPE_LEN/sizeof(uint64x2_t); i++) {
            uint64x2_t acc_vec  = xacc[i];
            uint64x2_t shifted  = vshrq_n_u64 (acc_vec, 47);
            uint64x2_t data_vec = veorq_u64   (acc_vec, shifted);
            uint8x16_t key_vec  = vld1q_u8(xsecret + (i * 16));
            uint64x2_t data_key = veorq_u64(data_vec, vreinterpretq_u64_u8(key_vec));
            uint32x2_t data_key_lo, data_key_hi;
            XXH_SPLIT_IN_PLACE(data_key, data_key_lo, data_key_hi);
            {   
                uint64x2_t prod_hi = vmull_u32 (data_key_hi, prime);
                xacc[i] = vshlq_n_u64(prod_hi, 32);
                xacc[i] = vmlal_u32(xacc[i], data_key_lo, prime);
            }
    }   }
}
#endif
#if (XXH_VECTOR == XXH_VSX)
XXH_FORCE_INLINE void
XXH3_accumulate_512_vsx(  void* XXH_RESTRICT acc,
                    const void* XXH_RESTRICT input,
                    const void* XXH_RESTRICT secret)
{
          xxh_u64x2* const xacc     =       (xxh_u64x2*) acc;    
    xxh_u64x2 const* const xinput   = (xxh_u64x2 const*) input;   
    xxh_u64x2 const* const xsecret  = (xxh_u64x2 const*) secret;    
    xxh_u64x2 const v32 = { 32, 32 };
    size_t i;
    for (i = 0; i < XXH_STRIPE_LEN / sizeof(xxh_u64x2); i++) {
        xxh_u64x2 const data_vec = XXH_vec_loadu(xinput + i);
        xxh_u64x2 const key_vec  = XXH_vec_loadu(xsecret + i);
        xxh_u64x2 const data_key = data_vec ^ key_vec;
        xxh_u32x4 const shuffled = (xxh_u32x4)vec_rl(data_key, v32);
        xxh_u64x2 const product  = XXH_vec_mulo((xxh_u32x4)data_key, shuffled);
        xacc[i] += product;
#ifdef __s390x__
        xacc[i] += vec_permi(data_vec, data_vec, 2);
#else
        xacc[i] += vec_xxpermdi(data_vec, data_vec, 2);
#endif
    }
}
XXH_FORCE_INLINE void
XXH3_scrambleAcc_vsx(void* XXH_RESTRICT acc, const void* XXH_RESTRICT secret)
{
    XXH_ASSERT((((size_t)acc) & 15) == 0);
    {         xxh_u64x2* const xacc    =       (xxh_u64x2*) acc;
        const xxh_u64x2* const xsecret = (const xxh_u64x2*) secret;
        xxh_u64x2 const v32  = { 32, 32 };
        xxh_u64x2 const v47 = { 47, 47 };
        xxh_u32x4 const prime = { XXH_PRIME32_1, XXH_PRIME32_1, XXH_PRIME32_1, XXH_PRIME32_1 };
        size_t i;
        for (i = 0; i < XXH_STRIPE_LEN / sizeof(xxh_u64x2); i++) {
            xxh_u64x2 const acc_vec  = xacc[i];
            xxh_u64x2 const data_vec = acc_vec ^ (acc_vec >> v47);
            xxh_u64x2 const key_vec  = XXH_vec_loadu(xsecret + i);
            xxh_u64x2 const data_key = data_vec ^ key_vec;
            xxh_u64x2 const prod_even  = XXH_vec_mule((xxh_u32x4)data_key, prime);
            xxh_u64x2 const prod_odd  = XXH_vec_mulo((xxh_u32x4)data_key, prime);
            xacc[i] = prod_odd + (prod_even << v32);
    }   }
}
#endif
XXH_FORCE_INLINE void
XXH3_accumulate_512_scalar(void* XXH_RESTRICT acc,
                     const void* XXH_RESTRICT input,
                     const void* XXH_RESTRICT secret)
{
    XXH_ALIGN(XXH_ACC_ALIGN) xxh_u64* const xacc = (xxh_u64*) acc; 
    const xxh_u8* const xinput  = (const xxh_u8*) input;  
    const xxh_u8* const xsecret = (const xxh_u8*) secret;   
    size_t i;
    XXH_ASSERT(((size_t)acc & (XXH_ACC_ALIGN-1)) == 0);
    for (i=0; i < XXH_ACC_NB; i++) {
        xxh_u64 const data_val = XXH_readLE64(xinput + 8*i);
        xxh_u64 const data_key = data_val ^ XXH_readLE64(xsecret + i*8);
        xacc[i ^ 1] += data_val; 
        xacc[i] += XXH_mult32to64(data_key & 0xFFFFFFFF, data_key >> 32);
    }
}
XXH_FORCE_INLINE void
XXH3_scrambleAcc_scalar(void* XXH_RESTRICT acc, const void* XXH_RESTRICT secret)
{
    XXH_ALIGN(XXH_ACC_ALIGN) xxh_u64* const xacc = (xxh_u64*) acc;   
    const xxh_u8* const xsecret = (const xxh_u8*) secret;   
    size_t i;
    XXH_ASSERT((((size_t)acc) & (XXH_ACC_ALIGN-1)) == 0);
    for (i=0; i < XXH_ACC_NB; i++) {
        xxh_u64 const key64 = XXH_readLE64(xsecret + 8*i);
        xxh_u64 acc64 = xacc[i];
        acc64 = XXH_xorshift64(acc64, 47);
        acc64 ^= key64;
        acc64 *= XXH_PRIME32_1;
        xacc[i] = acc64;
    }
}
XXH_FORCE_INLINE void
XXH3_initCustomSecret_scalar(void* XXH_RESTRICT customSecret, xxh_u64 seed64)
{
    const xxh_u8* kSecretPtr = XXH3_kSecret;
    XXH_STATIC_ASSERT((XXH_SECRET_DEFAULT_SIZE & 15) == 0);
#if defined(__clang__) && defined(__aarch64__)
    __asm__("" : "+r" (kSecretPtr));
#endif
    XXH_ASSERT(kSecretPtr == XXH3_kSecret);
    {   int const nbRounds = XXH_SECRET_DEFAULT_SIZE / 16;
        int i;
        for (i=0; i < nbRounds; i++) {
            xxh_u64 lo = XXH_readLE64(kSecretPtr + 16*i)     + seed64;
            xxh_u64 hi = XXH_readLE64(kSecretPtr + 16*i + 8) - seed64;
            XXH_writeLE64((xxh_u8*)customSecret + 16*i,     lo);
            XXH_writeLE64((xxh_u8*)customSecret + 16*i + 8, hi);
    }   }
}
typedef void (*XXH3_f_accumulate_512)(void* XXH_RESTRICT, const void*, const void*);
typedef void (*XXH3_f_scrambleAcc)(void* XXH_RESTRICT, const void*);
typedef void (*XXH3_f_initCustomSecret)(void* XXH_RESTRICT, xxh_u64);
#if (XXH_VECTOR == XXH_AVX512)
#define XXH3_accumulate_512 XXH3_accumulate_512_avx512
#define XXH3_scrambleAcc    XXH3_scrambleAcc_avx512
#define XXH3_initCustomSecret XXH3_initCustomSecret_avx512
#elif (XXH_VECTOR == XXH_AVX2)
#define XXH3_accumulate_512 XXH3_accumulate_512_avx2
#define XXH3_scrambleAcc    XXH3_scrambleAcc_avx2
#define XXH3_initCustomSecret XXH3_initCustomSecret_avx2
#elif (XXH_VECTOR == XXH_SSE2)
#define XXH3_accumulate_512 XXH3_accumulate_512_sse2
#define XXH3_scrambleAcc    XXH3_scrambleAcc_sse2
#define XXH3_initCustomSecret XXH3_initCustomSecret_sse2
#elif (XXH_VECTOR == XXH_NEON)
#define XXH3_accumulate_512 XXH3_accumulate_512_neon
#define XXH3_scrambleAcc    XXH3_scrambleAcc_neon
#define XXH3_initCustomSecret XXH3_initCustomSecret_scalar
#elif (XXH_VECTOR == XXH_VSX)
#define XXH3_accumulate_512 XXH3_accumulate_512_vsx
#define XXH3_scrambleAcc    XXH3_scrambleAcc_vsx
#define XXH3_initCustomSecret XXH3_initCustomSecret_scalar
#else 
#define XXH3_accumulate_512 XXH3_accumulate_512_scalar
#define XXH3_scrambleAcc    XXH3_scrambleAcc_scalar
#define XXH3_initCustomSecret XXH3_initCustomSecret_scalar
#endif
#ifndef XXH_PREFETCH_DIST
#  ifdef __clang__
#    define XXH_PREFETCH_DIST 320
#  else
#    if (XXH_VECTOR == XXH_AVX512)
#      define XXH_PREFETCH_DIST 512
#    else
#      define XXH_PREFETCH_DIST 384
#    endif
#  endif  
#endif  
XXH_FORCE_INLINE void
XXH3_accumulate(     xxh_u64* XXH_RESTRICT acc,
                const xxh_u8* XXH_RESTRICT input,
                const xxh_u8* XXH_RESTRICT secret,
                      size_t nbStripes,
                      XXH3_f_accumulate_512 f_acc512)
{
    size_t n;
    for (n = 0; n < nbStripes; n++ ) {
        const xxh_u8* const in = input + n*XXH_STRIPE_LEN;
        XXH_PREFETCH(in + XXH_PREFETCH_DIST);
        f_acc512(acc,
                 in,
                 secret + n*XXH_SECRET_CONSUME_RATE);
    }
}
XXH_FORCE_INLINE void
XXH3_hashLong_internal_loop(xxh_u64* XXH_RESTRICT acc,
                      const xxh_u8* XXH_RESTRICT input, size_t len,
                      const xxh_u8* XXH_RESTRICT secret, size_t secretSize,
                            XXH3_f_accumulate_512 f_acc512,
                            XXH3_f_scrambleAcc f_scramble)
{
    size_t const nbStripesPerBlock = (secretSize - XXH_STRIPE_LEN) / XXH_SECRET_CONSUME_RATE;
    size_t const block_len = XXH_STRIPE_LEN * nbStripesPerBlock;
    size_t const nb_blocks = (len - 1) / block_len;
    size_t n;
    XXH_ASSERT(secretSize >= XXH3_SECRET_SIZE_MIN);
    for (n = 0; n < nb_blocks; n++) {
        XXH3_accumulate(acc, input + n*block_len, secret, nbStripesPerBlock, f_acc512);
        f_scramble(acc, secret + secretSize - XXH_STRIPE_LEN);
    }
    XXH_ASSERT(len > XXH_STRIPE_LEN);
    {   size_t const nbStripes = ((len - 1) - (block_len * nb_blocks)) / XXH_STRIPE_LEN;
        XXH_ASSERT(nbStripes <= (secretSize / XXH_SECRET_CONSUME_RATE));
        XXH3_accumulate(acc, input + nb_blocks*block_len, secret, nbStripes, f_acc512);
        {   const xxh_u8* const p = input + len - XXH_STRIPE_LEN;
#define XXH_SECRET_LASTACC_START 7  
            f_acc512(acc, p, secret + secretSize - XXH_STRIPE_LEN - XXH_SECRET_LASTACC_START);
    }   }
}
XXH_FORCE_INLINE xxh_u64
XXH3_mix2Accs(const xxh_u64* XXH_RESTRICT acc, const xxh_u8* XXH_RESTRICT secret)
{
    return XXH3_mul128_fold64(
               acc[0] ^ XXH_readLE64(secret),
               acc[1] ^ XXH_readLE64(secret+8) );
}
static XXH64_hash_t
XXH3_mergeAccs(const xxh_u64* XXH_RESTRICT acc, const xxh_u8* XXH_RESTRICT secret, xxh_u64 start)
{
    xxh_u64 result64 = start;
    size_t i = 0;
    for (i = 0; i < 4; i++) {
        result64 += XXH3_mix2Accs(acc+2*i, secret + 16*i);
#if defined(__clang__)                                 \
    && (defined(__arm__) || defined(__thumb__))        \
    && (defined(__ARM_NEON) || defined(__ARM_NEON__))   \
    && !defined(XXH_ENABLE_AUTOVECTORIZE)             
        __asm__("" : "+r" (result64));
#endif
    }
    return XXH3_avalanche(result64);
}
#define XXH3_INIT_ACC { XXH_PRIME32_3, XXH_PRIME64_1, XXH_PRIME64_2, XXH_PRIME64_3, \
                        XXH_PRIME64_4, XXH_PRIME32_2, XXH_PRIME64_5, XXH_PRIME32_1 }
XXH_FORCE_INLINE XXH64_hash_t
XXH3_hashLong_64b_internal(const void* XXH_RESTRICT input, size_t len,
                           const void* XXH_RESTRICT secret, size_t secretSize,
                           XXH3_f_accumulate_512 f_acc512,
                           XXH3_f_scrambleAcc f_scramble)
{
    XXH_ALIGN(XXH_ACC_ALIGN) xxh_u64 acc[XXH_ACC_NB] = XXH3_INIT_ACC;
    XXH3_hashLong_internal_loop(acc, (const xxh_u8*)input, len, (const xxh_u8*)secret, secretSize, f_acc512, f_scramble);
    XXH_STATIC_ASSERT(sizeof(acc) == 64);
#define XXH_SECRET_MERGEACCS_START 11
    XXH_ASSERT(secretSize >= sizeof(acc) + XXH_SECRET_MERGEACCS_START);
    return XXH3_mergeAccs(acc, (const xxh_u8*)secret + XXH_SECRET_MERGEACCS_START, (xxh_u64)len * XXH_PRIME64_1);
}
XXH_NO_INLINE XXH64_hash_t
XXH3_hashLong_64b_withSecret(const void* XXH_RESTRICT input, size_t len,
                             XXH64_hash_t seed64, const xxh_u8* XXH_RESTRICT secret, size_t secretLen)
{
    (void)seed64;
    return XXH3_hashLong_64b_internal(input, len, secret, secretLen, XXH3_accumulate_512, XXH3_scrambleAcc);
}
XXH_NO_INLINE XXH64_hash_t
XXH3_hashLong_64b_default(const void* XXH_RESTRICT input, size_t len,
                          XXH64_hash_t seed64, const xxh_u8* XXH_RESTRICT secret, size_t secretLen)
{
    (void)seed64; (void)secret; (void)secretLen;
    return XXH3_hashLong_64b_internal(input, len, XXH3_kSecret, sizeof(XXH3_kSecret), XXH3_accumulate_512, XXH3_scrambleAcc);
}
XXH_FORCE_INLINE XXH64_hash_t
XXH3_hashLong_64b_withSeed_internal(const void* input, size_t len,
                                    XXH64_hash_t seed,
                                    XXH3_f_accumulate_512 f_acc512,
                                    XXH3_f_scrambleAcc f_scramble,
                                    XXH3_f_initCustomSecret f_initSec)
{
    if (seed == 0)
        return XXH3_hashLong_64b_internal(input, len,
                                          XXH3_kSecret, sizeof(XXH3_kSecret),
                                          f_acc512, f_scramble);
    {   XXH_ALIGN(XXH_SEC_ALIGN) xxh_u8 secret[XXH_SECRET_DEFAULT_SIZE];
        f_initSec(secret, seed);
        return XXH3_hashLong_64b_internal(input, len, secret, sizeof(secret),
                                          f_acc512, f_scramble);
    }
}
XXH_NO_INLINE XXH64_hash_t
XXH3_hashLong_64b_withSeed(const void* input, size_t len,
                           XXH64_hash_t seed, const xxh_u8* secret, size_t secretLen)
{
    (void)secret; (void)secretLen;
    return XXH3_hashLong_64b_withSeed_internal(input, len, seed,
                XXH3_accumulate_512, XXH3_scrambleAcc, XXH3_initCustomSecret);
}
typedef XXH64_hash_t (*XXH3_hashLong64_f)(const void* XXH_RESTRICT, size_t,
                                          XXH64_hash_t, const xxh_u8* XXH_RESTRICT, size_t);
XXH_FORCE_INLINE XXH64_hash_t
XXH3_64bits_internal(const void* XXH_RESTRICT input, size_t len,
                     XXH64_hash_t seed64, const void* XXH_RESTRICT secret, size_t secretLen,
                     XXH3_hashLong64_f f_hashLong)
{
    XXH_ASSERT(secretLen >= XXH3_SECRET_SIZE_MIN);
    if (len <= 16)
        return XXH3_len_0to16_64b((const xxh_u8*)input, len, (const xxh_u8*)secret, seed64);
    if (len <= 128)
        return XXH3_len_17to128_64b((const xxh_u8*)input, len, (const xxh_u8*)secret, secretLen, seed64);
    if (len <= XXH3_MIDSIZE_MAX)
        return XXH3_len_129to240_64b((const xxh_u8*)input, len, (const xxh_u8*)secret, secretLen, seed64);
    return f_hashLong(input, len, seed64, (const xxh_u8*)secret, secretLen);
}
XXH_PUBLIC_API XXH64_hash_t XXH3_64bits(const void* input, size_t len)
{
    return XXH3_64bits_internal(input, len, 0, XXH3_kSecret, sizeof(XXH3_kSecret), XXH3_hashLong_64b_default);
}
XXH_PUBLIC_API XXH64_hash_t
XXH3_64bits_withSecret(const void* input, size_t len, const void* secret, size_t secretSize)
{
    return XXH3_64bits_internal(input, len, 0, secret, secretSize, XXH3_hashLong_64b_withSecret);
}
XXH_PUBLIC_API XXH64_hash_t
XXH3_64bits_withSeed(const void* input, size_t len, XXH64_hash_t seed)
{
    return XXH3_64bits_internal(input, len, seed, XXH3_kSecret, sizeof(XXH3_kSecret), XXH3_hashLong_64b_withSeed);
}
static void* XXH_alignedMalloc(size_t s, size_t align)
{
    XXH_ASSERT(align <= 128 && align >= 8); 
    XXH_ASSERT((align & (align-1)) == 0);   
    XXH_ASSERT(s != 0 && s < (s + align));  
    {   
        xxh_u8* base = (xxh_u8*)XXH_malloc(s + align);
        if (base != NULL) {
            size_t offset = align - ((size_t)base & (align - 1)); 
            xxh_u8* ptr = base + offset;
            XXH_ASSERT((size_t)ptr % align == 0);
            ptr[-1] = (xxh_u8)offset;
            return ptr;
        }
        return NULL;
    }
}
static void XXH_alignedFree(void* p)
{
    if (p != NULL) {
        xxh_u8* ptr = (xxh_u8*)p;
        xxh_u8 offset = ptr[-1];
        xxh_u8* base = ptr - offset;
        XXH_free(base);
    }
}
XXH_PUBLIC_API XXH3_state_t* XXH3_createState(void)
{
    XXH3_state_t* const state = (XXH3_state_t*)XXH_alignedMalloc(sizeof(XXH3_state_t), 64);
    if (state==NULL) return NULL;
    XXH3_INITSTATE(state);
    return state;
}
XXH_PUBLIC_API XXH_errorcode XXH3_freeState(XXH3_state_t* statePtr)
{
    XXH_alignedFree(statePtr);
    return XXH_OK;
}
XXH_PUBLIC_API void
XXH3_copyState(XXH3_state_t* dst_state, const XXH3_state_t* src_state)
{
    memcpy(dst_state, src_state, sizeof(*dst_state));
}
static void
XXH3_64bits_reset_internal(XXH3_state_t* statePtr,
                           XXH64_hash_t seed,
                           const void* secret, size_t secretSize)
{
    size_t const initStart = offsetof(XXH3_state_t, bufferedSize);
    size_t const initLength = offsetof(XXH3_state_t, nbStripesPerBlock) - initStart;
    XXH_ASSERT(offsetof(XXH3_state_t, nbStripesPerBlock) > initStart);
    XXH_ASSERT(statePtr != NULL);
    memset((char*)statePtr + initStart, 0, initLength);
    statePtr->acc[0] = XXH_PRIME32_3;
    statePtr->acc[1] = XXH_PRIME64_1;
    statePtr->acc[2] = XXH_PRIME64_2;
    statePtr->acc[3] = XXH_PRIME64_3;
    statePtr->acc[4] = XXH_PRIME64_4;
    statePtr->acc[5] = XXH_PRIME32_2;
    statePtr->acc[6] = XXH_PRIME64_5;
    statePtr->acc[7] = XXH_PRIME32_1;
    statePtr->seed = seed;
    statePtr->extSecret = (const unsigned char*)secret;
    XXH_ASSERT(secretSize >= XXH3_SECRET_SIZE_MIN);
    statePtr->secretLimit = secretSize - XXH_STRIPE_LEN;
    statePtr->nbStripesPerBlock = statePtr->secretLimit / XXH_SECRET_CONSUME_RATE;
}
XXH_PUBLIC_API XXH_errorcode
XXH3_64bits_reset(XXH3_state_t* statePtr)
{
    if (statePtr == NULL) return XXH_ERROR;
    XXH3_64bits_reset_internal(statePtr, 0, XXH3_kSecret, XXH_SECRET_DEFAULT_SIZE);
    return XXH_OK;
}
XXH_PUBLIC_API XXH_errorcode
XXH3_64bits_reset_withSecret(XXH3_state_t* statePtr, const void* secret, size_t secretSize)
{
    if (statePtr == NULL) return XXH_ERROR;
    XXH3_64bits_reset_internal(statePtr, 0, secret, secretSize);
    if (secret == NULL) return XXH_ERROR;
    if (secretSize < XXH3_SECRET_SIZE_MIN) return XXH_ERROR;
    return XXH_OK;
}
XXH_PUBLIC_API XXH_errorcode
XXH3_64bits_reset_withSeed(XXH3_state_t* statePtr, XXH64_hash_t seed)
{
    if (statePtr == NULL) return XXH_ERROR;
    if (seed==0) return XXH3_64bits_reset(statePtr);
    if (seed != statePtr->seed) XXH3_initCustomSecret(statePtr->customSecret, seed);
    XXH3_64bits_reset_internal(statePtr, seed, NULL, XXH_SECRET_DEFAULT_SIZE);
    return XXH_OK;
}
XXH_FORCE_INLINE void
XXH3_consumeStripes(xxh_u64* XXH_RESTRICT acc,
                    size_t* XXH_RESTRICT nbStripesSoFarPtr, size_t nbStripesPerBlock,
                    const xxh_u8* XXH_RESTRICT input, size_t nbStripes,
                    const xxh_u8* XXH_RESTRICT secret, size_t secretLimit,
                    XXH3_f_accumulate_512 f_acc512,
                    XXH3_f_scrambleAcc f_scramble)
{
    XXH_ASSERT(nbStripes <= nbStripesPerBlock);  
    XXH_ASSERT(*nbStripesSoFarPtr < nbStripesPerBlock);
    if (nbStripesPerBlock - *nbStripesSoFarPtr <= nbStripes) {
        size_t const nbStripesToEndofBlock = nbStripesPerBlock - *nbStripesSoFarPtr;
        size_t const nbStripesAfterBlock = nbStripes - nbStripesToEndofBlock;
        XXH3_accumulate(acc, input, secret + nbStripesSoFarPtr[0] * XXH_SECRET_CONSUME_RATE, nbStripesToEndofBlock, f_acc512);
        f_scramble(acc, secret + secretLimit);
        XXH3_accumulate(acc, input + nbStripesToEndofBlock * XXH_STRIPE_LEN, secret, nbStripesAfterBlock, f_acc512);
        *nbStripesSoFarPtr = nbStripesAfterBlock;
    } else {
        XXH3_accumulate(acc, input, secret + nbStripesSoFarPtr[0] * XXH_SECRET_CONSUME_RATE, nbStripes, f_acc512);
        *nbStripesSoFarPtr += nbStripes;
    }
}
XXH_FORCE_INLINE XXH_errorcode
XXH3_update(XXH3_state_t* state,
            const xxh_u8* input, size_t len,
            XXH3_f_accumulate_512 f_acc512,
            XXH3_f_scrambleAcc f_scramble)
{
    if (input==NULL)
#if defined(XXH_ACCEPT_NULL_INPUT_POINTER) && (XXH_ACCEPT_NULL_INPUT_POINTER>=1)
        return XXH_OK;
#else
        return XXH_ERROR;
#endif
    {   const xxh_u8* const bEnd = input + len;
        const unsigned char* const secret = (state->extSecret == NULL) ? state->customSecret : state->extSecret;
        state->totalLen += len;
        if (state->bufferedSize + len <= XXH3_INTERNALBUFFER_SIZE) {  
            XXH_memcpy(state->buffer + state->bufferedSize, input, len);
            state->bufferedSize += (XXH32_hash_t)len;
            return XXH_OK;
        }
        #define XXH3_INTERNALBUFFER_STRIPES (XXH3_INTERNALBUFFER_SIZE / XXH_STRIPE_LEN)
        XXH_STATIC_ASSERT(XXH3_INTERNALBUFFER_SIZE % XXH_STRIPE_LEN == 0);   
        if (state->bufferedSize) {
            size_t const loadSize = XXH3_INTERNALBUFFER_SIZE - state->bufferedSize;
            XXH_memcpy(state->buffer + state->bufferedSize, input, loadSize);
            input += loadSize;
            XXH3_consumeStripes(state->acc,
                               &state->nbStripesSoFar, state->nbStripesPerBlock,
                                state->buffer, XXH3_INTERNALBUFFER_STRIPES,
                                secret, state->secretLimit,
                                f_acc512, f_scramble);
            state->bufferedSize = 0;
        }
        XXH_ASSERT(input < bEnd);
        if (input+XXH3_INTERNALBUFFER_SIZE < bEnd) {
            const xxh_u8* const limit = bEnd - XXH3_INTERNALBUFFER_SIZE;
            do {
                XXH3_consumeStripes(state->acc,
                                   &state->nbStripesSoFar, state->nbStripesPerBlock,
                                    input, XXH3_INTERNALBUFFER_STRIPES,
                                    secret, state->secretLimit,
                                    f_acc512, f_scramble);
                input += XXH3_INTERNALBUFFER_SIZE;
            } while (input<limit);
            memcpy(state->buffer + sizeof(state->buffer) - XXH_STRIPE_LEN, input - XXH_STRIPE_LEN, XXH_STRIPE_LEN);
        }
        XXH_ASSERT(input < bEnd);
        XXH_memcpy(state->buffer, input, (size_t)(bEnd-input));
        state->bufferedSize = (XXH32_hash_t)(bEnd-input);
    }
    return XXH_OK;
}
XXH_PUBLIC_API XXH_errorcode
XXH3_64bits_update(XXH3_state_t* state, const void* input, size_t len)
{
    return XXH3_update(state, (const xxh_u8*)input, len,
                       XXH3_accumulate_512, XXH3_scrambleAcc);
}
XXH_FORCE_INLINE void
XXH3_digest_long (XXH64_hash_t* acc,
                  const XXH3_state_t* state,
                  const unsigned char* secret)
{
    memcpy(acc, state->acc, sizeof(state->acc));
    if (state->bufferedSize >= XXH_STRIPE_LEN) {
        size_t const nbStripes = (state->bufferedSize - 1) / XXH_STRIPE_LEN;
        size_t nbStripesSoFar = state->nbStripesSoFar;
        XXH3_consumeStripes(acc,
                           &nbStripesSoFar, state->nbStripesPerBlock,
                            state->buffer, nbStripes,
                            secret, state->secretLimit,
                            XXH3_accumulate_512, XXH3_scrambleAcc);
        XXH3_accumulate_512(acc,
                            state->buffer + state->bufferedSize - XXH_STRIPE_LEN,
                            secret + state->secretLimit - XXH_SECRET_LASTACC_START);
    } else {  
        xxh_u8 lastStripe[XXH_STRIPE_LEN];
        size_t const catchupSize = XXH_STRIPE_LEN - state->bufferedSize;
        XXH_ASSERT(state->bufferedSize > 0);  
        memcpy(lastStripe, state->buffer + sizeof(state->buffer) - catchupSize, catchupSize);
        memcpy(lastStripe + catchupSize, state->buffer, state->bufferedSize);
        XXH3_accumulate_512(acc,
                            lastStripe,
                            secret + state->secretLimit - XXH_SECRET_LASTACC_START);
    }
}
XXH_PUBLIC_API XXH64_hash_t XXH3_64bits_digest (const XXH3_state_t* state)
{
    const unsigned char* const secret = (state->extSecret == NULL) ? state->customSecret : state->extSecret;
    if (state->totalLen > XXH3_MIDSIZE_MAX) {
        XXH_ALIGN(XXH_ACC_ALIGN) XXH64_hash_t acc[XXH_ACC_NB];
        XXH3_digest_long(acc, state, secret);
        return XXH3_mergeAccs(acc,
                              secret + XXH_SECRET_MERGEACCS_START,
                              (xxh_u64)state->totalLen * XXH_PRIME64_1);
    }
    if (state->seed)
        return XXH3_64bits_withSeed(state->buffer, (size_t)state->totalLen, state->seed);
    return XXH3_64bits_withSecret(state->buffer, (size_t)(state->totalLen),
                                  secret, state->secretLimit + XXH_STRIPE_LEN);
}
#define XXH_MIN(x, y) (((x) > (y)) ? (y) : (x))
XXH_PUBLIC_API void
XXH3_generateSecret(void* secretBuffer, const void* customSeed, size_t customSeedSize)
{
    XXH_ASSERT(secretBuffer != NULL);
    if (customSeedSize == 0) {
        memcpy(secretBuffer, XXH3_kSecret, XXH_SECRET_DEFAULT_SIZE);
        return;
    }
    XXH_ASSERT(customSeed != NULL);
    {   size_t const segmentSize = sizeof(XXH128_hash_t);
        size_t const nbSegments = XXH_SECRET_DEFAULT_SIZE / segmentSize;
        XXH128_canonical_t scrambler;
        XXH64_hash_t seeds[12];
        size_t segnb;
        XXH_ASSERT(nbSegments == 12);
        XXH_ASSERT(segmentSize * nbSegments == XXH_SECRET_DEFAULT_SIZE); 
        XXH128_canonicalFromHash(&scrambler, XXH128(customSeed, customSeedSize, 0));
        {   size_t toFill = XXH_MIN(customSeedSize, sizeof(seeds));
            size_t filled = toFill;
            memcpy(seeds, customSeed, toFill);
            while (filled < sizeof(seeds)) {
                toFill = XXH_MIN(filled, sizeof(seeds) - filled);
                memcpy((char*)seeds + filled, seeds, toFill);
                filled += toFill;
        }   }
        memcpy(secretBuffer, &scrambler, sizeof(scrambler));
        for (segnb=1; segnb < nbSegments; segnb++) {
            size_t const segmentStart = segnb * segmentSize;
            XXH128_canonical_t segment;
            XXH128_canonicalFromHash(&segment,
                XXH128(&scrambler, sizeof(scrambler), XXH_readLE64(seeds + segnb) + segnb) );
            memcpy((char*)secretBuffer + segmentStart, &segment, sizeof(segment));
    }   }
}
XXH_FORCE_INLINE XXH128_hash_t
XXH3_len_1to3_128b(const xxh_u8* input, size_t len, const xxh_u8* secret, XXH64_hash_t seed)
{
    XXH_ASSERT(input != NULL);
    XXH_ASSERT(1 <= len && len <= 3);
    XXH_ASSERT(secret != NULL);
    {   xxh_u8 const c1 = input[0];
        xxh_u8 const c2 = input[len >> 1];
        xxh_u8 const c3 = input[len - 1];
        xxh_u32 const combinedl = ((xxh_u32)c1 <<16) | ((xxh_u32)c2 << 24)
                                | ((xxh_u32)c3 << 0) | ((xxh_u32)len << 8);
        xxh_u32 const combinedh = XXH_rotl32(XXH_swap32(combinedl), 13);
        xxh_u64 const bitflipl = (XXH_readLE32(secret) ^ XXH_readLE32(secret+4)) + seed;
        xxh_u64 const bitfliph = (XXH_readLE32(secret+8) ^ XXH_readLE32(secret+12)) - seed;
        xxh_u64 const keyed_lo = (xxh_u64)combinedl ^ bitflipl;
        xxh_u64 const keyed_hi = (xxh_u64)combinedh ^ bitfliph;
        XXH128_hash_t h128;
        h128.low64  = XXH64_avalanche(keyed_lo);
        h128.high64 = XXH64_avalanche(keyed_hi);
        return h128;
    }
}
XXH_FORCE_INLINE XXH128_hash_t
XXH3_len_4to8_128b(const xxh_u8* input, size_t len, const xxh_u8* secret, XXH64_hash_t seed)
{
    XXH_ASSERT(input != NULL);
    XXH_ASSERT(secret != NULL);
    XXH_ASSERT(4 <= len && len <= 8);
    seed ^= (xxh_u64)XXH_swap32((xxh_u32)seed) << 32;
    {   xxh_u32 const input_lo = XXH_readLE32(input);
        xxh_u32 const input_hi = XXH_readLE32(input + len - 4);
        xxh_u64 const input_64 = input_lo + ((xxh_u64)input_hi << 32);
        xxh_u64 const bitflip = (XXH_readLE64(secret+16) ^ XXH_readLE64(secret+24)) + seed;
        xxh_u64 const keyed = input_64 ^ bitflip;
        XXH128_hash_t m128 = XXH_mult64to128(keyed, XXH_PRIME64_1 + (len << 2));
        m128.high64 += (m128.low64 << 1);
        m128.low64  ^= (m128.high64 >> 3);
        m128.low64   = XXH_xorshift64(m128.low64, 35);
        m128.low64  *= 0x9FB21C651E98DF25ULL;
        m128.low64   = XXH_xorshift64(m128.low64, 28);
        m128.high64  = XXH3_avalanche(m128.high64);
        return m128;
    }
}
XXH_FORCE_INLINE XXH128_hash_t
XXH3_len_9to16_128b(const xxh_u8* input, size_t len, const xxh_u8* secret, XXH64_hash_t seed)
{
    XXH_ASSERT(input != NULL);
    XXH_ASSERT(secret != NULL);
    XXH_ASSERT(9 <= len && len <= 16);
    {   xxh_u64 const bitflipl = (XXH_readLE64(secret+32) ^ XXH_readLE64(secret+40)) - seed;
        xxh_u64 const bitfliph = (XXH_readLE64(secret+48) ^ XXH_readLE64(secret+56)) + seed;
        xxh_u64 const input_lo = XXH_readLE64(input);
        xxh_u64       input_hi = XXH_readLE64(input + len - 8);
        XXH128_hash_t m128 = XXH_mult64to128(input_lo ^ input_hi ^ bitflipl, XXH_PRIME64_1);
        m128.low64 += (xxh_u64)(len - 1) << 54;
        input_hi   ^= bitfliph;
        if (sizeof(void *) < sizeof(xxh_u64)) { 
            m128.high64 += (input_hi & 0xFFFFFFFF00000000ULL) + XXH_mult32to64((xxh_u32)input_hi, XXH_PRIME32_2);
        } else {
            m128.high64 += input_hi + XXH_mult32to64((xxh_u32)input_hi, XXH_PRIME32_2 - 1);
        }
        m128.low64  ^= XXH_swap64(m128.high64);
        {   
            XXH128_hash_t h128 = XXH_mult64to128(m128.low64, XXH_PRIME64_2);
            h128.high64 += m128.high64 * XXH_PRIME64_2;
            h128.low64   = XXH3_avalanche(h128.low64);
            h128.high64  = XXH3_avalanche(h128.high64);
            return h128;
    }   }
}
XXH_FORCE_INLINE XXH128_hash_t
XXH3_len_0to16_128b(const xxh_u8* input, size_t len, const xxh_u8* secret, XXH64_hash_t seed)
{
    XXH_ASSERT(len <= 16);
    {   if (len > 8) return XXH3_len_9to16_128b(input, len, secret, seed);
        if (len >= 4) return XXH3_len_4to8_128b(input, len, secret, seed);
        if (len) return XXH3_len_1to3_128b(input, len, secret, seed);
        {   XXH128_hash_t h128;
            xxh_u64 const bitflipl = XXH_readLE64(secret+64) ^ XXH_readLE64(secret+72);
            xxh_u64 const bitfliph = XXH_readLE64(secret+80) ^ XXH_readLE64(secret+88);
            h128.low64 = XXH64_avalanche(seed ^ bitflipl);
            h128.high64 = XXH64_avalanche( seed ^ bitfliph);
            return h128;
    }   }
}
XXH_FORCE_INLINE XXH128_hash_t
XXH128_mix32B(XXH128_hash_t acc, const xxh_u8* input_1, const xxh_u8* input_2,
              const xxh_u8* secret, XXH64_hash_t seed)
{
    acc.low64  += XXH3_mix16B (input_1, secret+0, seed);
    acc.low64  ^= XXH_readLE64(input_2) + XXH_readLE64(input_2 + 8);
    acc.high64 += XXH3_mix16B (input_2, secret+16, seed);
    acc.high64 ^= XXH_readLE64(input_1) + XXH_readLE64(input_1 + 8);
    return acc;
}
XXH_FORCE_INLINE XXH128_hash_t
XXH3_len_17to128_128b(const xxh_u8* XXH_RESTRICT input, size_t len,
                      const xxh_u8* XXH_RESTRICT secret, size_t secretSize,
                      XXH64_hash_t seed)
{
    XXH_ASSERT(secretSize >= XXH3_SECRET_SIZE_MIN); (void)secretSize;
    XXH_ASSERT(16 < len && len <= 128);
    {   XXH128_hash_t acc;
        acc.low64 = len * XXH_PRIME64_1;
        acc.high64 = 0;
        if (len > 32) {
            if (len > 64) {
                if (len > 96) {
                    acc = XXH128_mix32B(acc, input+48, input+len-64, secret+96, seed);
                }
                acc = XXH128_mix32B(acc, input+32, input+len-48, secret+64, seed);
            }
            acc = XXH128_mix32B(acc, input+16, input+len-32, secret+32, seed);
        }
        acc = XXH128_mix32B(acc, input, input+len-16, secret, seed);
        {   XXH128_hash_t h128;
            h128.low64  = acc.low64 + acc.high64;
            h128.high64 = (acc.low64    * XXH_PRIME64_1)
                        + (acc.high64   * XXH_PRIME64_4)
                        + ((len - seed) * XXH_PRIME64_2);
            h128.low64  = XXH3_avalanche(h128.low64);
            h128.high64 = (XXH64_hash_t)0 - XXH3_avalanche(h128.high64);
            return h128;
        }
    }
}
XXH_NO_INLINE XXH128_hash_t
XXH3_len_129to240_128b(const xxh_u8* XXH_RESTRICT input, size_t len,
                       const xxh_u8* XXH_RESTRICT secret, size_t secretSize,
                       XXH64_hash_t seed)
{
    XXH_ASSERT(secretSize >= XXH3_SECRET_SIZE_MIN); (void)secretSize;
    XXH_ASSERT(128 < len && len <= XXH3_MIDSIZE_MAX);
    {   XXH128_hash_t acc;
        int const nbRounds = (int)len / 32;
        int i;
        acc.low64 = len * XXH_PRIME64_1;
        acc.high64 = 0;
        for (i=0; i<4; i++) {
            acc = XXH128_mix32B(acc,
                                input  + (32 * i),
                                input  + (32 * i) + 16,
                                secret + (32 * i),
                                seed);
        }
        acc.low64 = XXH3_avalanche(acc.low64);
        acc.high64 = XXH3_avalanche(acc.high64);
        XXH_ASSERT(nbRounds >= 4);
        for (i=4 ; i < nbRounds; i++) {
            acc = XXH128_mix32B(acc,
                                input + (32 * i),
                                input + (32 * i) + 16,
                                secret + XXH3_MIDSIZE_STARTOFFSET + (32 * (i - 4)),
                                seed);
        }
        acc = XXH128_mix32B(acc,
                            input + len - 16,
                            input + len - 32,
                            secret + XXH3_SECRET_SIZE_MIN - XXH3_MIDSIZE_LASTOFFSET - 16,
                            0ULL - seed);
        {   XXH128_hash_t h128;
            h128.low64  = acc.low64 + acc.high64;
            h128.high64 = (acc.low64    * XXH_PRIME64_1)
                        + (acc.high64   * XXH_PRIME64_4)
                        + ((len - seed) * XXH_PRIME64_2);
            h128.low64  = XXH3_avalanche(h128.low64);
            h128.high64 = (XXH64_hash_t)0 - XXH3_avalanche(h128.high64);
            return h128;
        }
    }
}
XXH_FORCE_INLINE XXH128_hash_t
XXH3_hashLong_128b_internal(const void* XXH_RESTRICT input, size_t len,
                            const xxh_u8* XXH_RESTRICT secret, size_t secretSize,
                            XXH3_f_accumulate_512 f_acc512,
                            XXH3_f_scrambleAcc f_scramble)
{
    XXH_ALIGN(XXH_ACC_ALIGN) xxh_u64 acc[XXH_ACC_NB] = XXH3_INIT_ACC;
    XXH3_hashLong_internal_loop(acc, (const xxh_u8*)input, len, secret, secretSize, f_acc512, f_scramble);
    XXH_STATIC_ASSERT(sizeof(acc) == 64);
    XXH_ASSERT(secretSize >= sizeof(acc) + XXH_SECRET_MERGEACCS_START);
    {   XXH128_hash_t h128;
        h128.low64  = XXH3_mergeAccs(acc,
                                     secret + XXH_SECRET_MERGEACCS_START,
                                     (xxh_u64)len * XXH_PRIME64_1);
        h128.high64 = XXH3_mergeAccs(acc,
                                     secret + secretSize
                                            - sizeof(acc) - XXH_SECRET_MERGEACCS_START,
                                     ~((xxh_u64)len * XXH_PRIME64_2));
        return h128;
    }
}
XXH_NO_INLINE XXH128_hash_t
XXH3_hashLong_128b_default(const void* XXH_RESTRICT input, size_t len,
                           XXH64_hash_t seed64,
                           const void* XXH_RESTRICT secret, size_t secretLen)
{
    (void)seed64; (void)secret; (void)secretLen;
    return XXH3_hashLong_128b_internal(input, len, XXH3_kSecret, sizeof(XXH3_kSecret),
                                       XXH3_accumulate_512, XXH3_scrambleAcc);
}
XXH_NO_INLINE XXH128_hash_t
XXH3_hashLong_128b_withSecret(const void* XXH_RESTRICT input, size_t len,
                              XXH64_hash_t seed64,
                              const void* XXH_RESTRICT secret, size_t secretLen)
{
    (void)seed64;
    return XXH3_hashLong_128b_internal(input, len, (const xxh_u8*)secret, secretLen,
                                       XXH3_accumulate_512, XXH3_scrambleAcc);
}
XXH_FORCE_INLINE XXH128_hash_t
XXH3_hashLong_128b_withSeed_internal(const void* XXH_RESTRICT input, size_t len,
                                XXH64_hash_t seed64,
                                XXH3_f_accumulate_512 f_acc512,
                                XXH3_f_scrambleAcc f_scramble,
                                XXH3_f_initCustomSecret f_initSec)
{
    if (seed64 == 0)
        return XXH3_hashLong_128b_internal(input, len,
                                           XXH3_kSecret, sizeof(XXH3_kSecret),
                                           f_acc512, f_scramble);
    {   XXH_ALIGN(XXH_SEC_ALIGN) xxh_u8 secret[XXH_SECRET_DEFAULT_SIZE];
        f_initSec(secret, seed64);
        return XXH3_hashLong_128b_internal(input, len, (const xxh_u8*)secret, sizeof(secret),
                                           f_acc512, f_scramble);
    }
}
XXH_NO_INLINE XXH128_hash_t
XXH3_hashLong_128b_withSeed(const void* input, size_t len,
                            XXH64_hash_t seed64, const void* XXH_RESTRICT secret, size_t secretLen)
{
    (void)secret; (void)secretLen;
    return XXH3_hashLong_128b_withSeed_internal(input, len, seed64,
                XXH3_accumulate_512, XXH3_scrambleAcc, XXH3_initCustomSecret);
}
typedef XXH128_hash_t (*XXH3_hashLong128_f)(const void* XXH_RESTRICT, size_t,
                                            XXH64_hash_t, const void* XXH_RESTRICT, size_t);
XXH_FORCE_INLINE XXH128_hash_t
XXH3_128bits_internal(const void* input, size_t len,
                      XXH64_hash_t seed64, const void* XXH_RESTRICT secret, size_t secretLen,
                      XXH3_hashLong128_f f_hl128)
{
    XXH_ASSERT(secretLen >= XXH3_SECRET_SIZE_MIN);
    if (len <= 16)
        return XXH3_len_0to16_128b((const xxh_u8*)input, len, (const xxh_u8*)secret, seed64);
    if (len <= 128)
        return XXH3_len_17to128_128b((const xxh_u8*)input, len, (const xxh_u8*)secret, secretLen, seed64);
    if (len <= XXH3_MIDSIZE_MAX)
        return XXH3_len_129to240_128b((const xxh_u8*)input, len, (const xxh_u8*)secret, secretLen, seed64);
    return f_hl128(input, len, seed64, secret, secretLen);
}
XXH_PUBLIC_API XXH128_hash_t XXH3_128bits(const void* input, size_t len)
{
    return XXH3_128bits_internal(input, len, 0,
                                 XXH3_kSecret, sizeof(XXH3_kSecret),
                                 XXH3_hashLong_128b_default);
}
XXH_PUBLIC_API XXH128_hash_t
XXH3_128bits_withSecret(const void* input, size_t len, const void* secret, size_t secretSize)
{
    return XXH3_128bits_internal(input, len, 0,
                                 (const xxh_u8*)secret, secretSize,
                                 XXH3_hashLong_128b_withSecret);
}
XXH_PUBLIC_API XXH128_hash_t
XXH3_128bits_withSeed(const void* input, size_t len, XXH64_hash_t seed)
{
    return XXH3_128bits_internal(input, len, seed,
                                 XXH3_kSecret, sizeof(XXH3_kSecret),
                                 XXH3_hashLong_128b_withSeed);
}
XXH_PUBLIC_API XXH128_hash_t
XXH128(const void* input, size_t len, XXH64_hash_t seed)
{
    return XXH3_128bits_withSeed(input, len, seed);
}
static void
XXH3_128bits_reset_internal(XXH3_state_t* statePtr,
                            XXH64_hash_t seed,
                            const void* secret, size_t secretSize)
{
    XXH3_64bits_reset_internal(statePtr, seed, secret, secretSize);
}
XXH_PUBLIC_API XXH_errorcode
XXH3_128bits_reset(XXH3_state_t* statePtr)
{
    if (statePtr == NULL) return XXH_ERROR;
    XXH3_128bits_reset_internal(statePtr, 0, XXH3_kSecret, XXH_SECRET_DEFAULT_SIZE);
    return XXH_OK;
}
XXH_PUBLIC_API XXH_errorcode
XXH3_128bits_reset_withSecret(XXH3_state_t* statePtr, const void* secret, size_t secretSize)
{
    if (statePtr == NULL) return XXH_ERROR;
    XXH3_128bits_reset_internal(statePtr, 0, secret, secretSize);
    if (secret == NULL) return XXH_ERROR;
    if (secretSize < XXH3_SECRET_SIZE_MIN) return XXH_ERROR;
    return XXH_OK;
}
XXH_PUBLIC_API XXH_errorcode
XXH3_128bits_reset_withSeed(XXH3_state_t* statePtr, XXH64_hash_t seed)
{
    if (statePtr == NULL) return XXH_ERROR;
    if (seed==0) return XXH3_128bits_reset(statePtr);
    if (seed != statePtr->seed) XXH3_initCustomSecret(statePtr->customSecret, seed);
    XXH3_128bits_reset_internal(statePtr, seed, NULL, XXH_SECRET_DEFAULT_SIZE);
    return XXH_OK;
}
XXH_PUBLIC_API XXH_errorcode
XXH3_128bits_update(XXH3_state_t* state, const void* input, size_t len)
{
    return XXH3_update(state, (const xxh_u8*)input, len,
                       XXH3_accumulate_512, XXH3_scrambleAcc);
}
XXH_PUBLIC_API XXH128_hash_t XXH3_128bits_digest (const XXH3_state_t* state)
{
    const unsigned char* const secret = (state->extSecret == NULL) ? state->customSecret : state->extSecret;
    if (state->totalLen > XXH3_MIDSIZE_MAX) {
        XXH_ALIGN(XXH_ACC_ALIGN) XXH64_hash_t acc[XXH_ACC_NB];
        XXH3_digest_long(acc, state, secret);
        XXH_ASSERT(state->secretLimit + XXH_STRIPE_LEN >= sizeof(acc) + XXH_SECRET_MERGEACCS_START);
        {   XXH128_hash_t h128;
            h128.low64  = XXH3_mergeAccs(acc,
                                         secret + XXH_SECRET_MERGEACCS_START,
                                         (xxh_u64)state->totalLen * XXH_PRIME64_1);
            h128.high64 = XXH3_mergeAccs(acc,
                                         secret + state->secretLimit + XXH_STRIPE_LEN
                                                - sizeof(acc) - XXH_SECRET_MERGEACCS_START,
                                         ~((xxh_u64)state->totalLen * XXH_PRIME64_2));
            return h128;
        }
    }
    if (state->seed)
        return XXH3_128bits_withSeed(state->buffer, (size_t)state->totalLen, state->seed);
    return XXH3_128bits_withSecret(state->buffer, (size_t)(state->totalLen),
                                   secret, state->secretLimit + XXH_STRIPE_LEN);
}
XXH_PUBLIC_API int XXH128_isEqual(XXH128_hash_t h1, XXH128_hash_t h2)
{
    return !(memcmp(&h1, &h2, sizeof(h1)));
}
XXH_PUBLIC_API int XXH128_cmp(const void* h128_1, const void* h128_2)
{
    XXH128_hash_t const h1 = *(const XXH128_hash_t*)h128_1;
    XXH128_hash_t const h2 = *(const XXH128_hash_t*)h128_2;
    int const hcmp = (h1.high64 > h2.high64) - (h2.high64 > h1.high64);
    if (hcmp) return hcmp;
    return (h1.low64 > h2.low64) - (h2.low64 > h1.low64);
}
XXH_PUBLIC_API void
XXH128_canonicalFromHash(XXH128_canonical_t* dst, XXH128_hash_t hash)
{
    XXH_STATIC_ASSERT(sizeof(XXH128_canonical_t) == sizeof(XXH128_hash_t));
    if (XXH_CPU_LITTLE_ENDIAN) {
        hash.high64 = XXH_swap64(hash.high64);
        hash.low64  = XXH_swap64(hash.low64);
    }
    memcpy(dst, &hash.high64, sizeof(hash.high64));
    memcpy((char*)dst + sizeof(hash.high64), &hash.low64, sizeof(hash.low64));
}
XXH_PUBLIC_API XXH128_hash_t
XXH128_hashFromCanonical(const XXH128_canonical_t* src)
{
    XXH128_hash_t h;
    h.high64 = XXH_readBE64(src);
    h.low64  = XXH_readBE64(src->digest + 8);
    return h;
}
#if XXH_VECTOR == XXH_AVX2  \
  && defined(__GNUC__) && !defined(__clang__)  \
  && defined(__OPTIMIZE__) && !defined(__OPTIMIZE_SIZE__) 
#  pragma GCC pop_options
#endif
#endif  
#endif  
void libzpaq::error(const char* msg) {
	g_exec_text=msg;
  if (strstr(msg, "ut of memory")) throw std::bad_alloc();
  throw std::runtime_error(msg);
}
using libzpaq::error;
typedef void* ThreadReturn;                                
typedef pthread_t ThreadID;                                
void run(ThreadID& tid, ThreadReturn(*f)(void*), void* arg)
  {pthread_create(&tid, NULL, f, arg);}
void join(ThreadID tid) {pthread_join(tid, NULL);}         
typedef pthread_mutex_t Mutex;                             
void init_mutex(Mutex& m) {pthread_mutex_init(&m, 0);}     
void lock(Mutex& m) {pthread_mutex_lock(&m);}              
void release(Mutex& m) {pthread_mutex_unlock(&m);}         
void destroy_mutex(Mutex& m) {pthread_mutex_destroy(&m);}  
class Semaphore {
public:
  Semaphore() {sem=-1;}
  void init(int n) {
    assert(n>=0);
    assert(sem==-1);
    pthread_cond_init(&cv, 0);
    pthread_mutex_init(&mutex, 0);
    sem=n;
  }
  void destroy() {
    assert(sem>=0);
    pthread_mutex_destroy(&mutex);
    pthread_cond_destroy(&cv);
  }
  int wait() {
    assert(sem>=0);
    pthread_mutex_lock(&mutex);
    int r=0;
    if (sem==0) r=pthread_cond_wait(&cv, &mutex);
    assert(sem>0);
    --sem;
    pthread_mutex_unlock(&mutex);
    return r;
  }
  void signal() {
    assert(sem>=0);
    pthread_mutex_lock(&mutex);
    ++sem;
    pthread_cond_signal(&cv);
    pthread_mutex_unlock(&mutex);
  }
private:
  pthread_cond_t cv;  
  pthread_mutex_t mutex; 
  int sem;  
};
void setupConsole(void) 
{
}
void restoreConsole(void) 
{
	if (flagsilent)
		return;
	printf("\x1b[0m");
}
int terminalwidth() 
{
    struct winsize w;
    ioctl(fileno(stdout), TIOCGWINSZ, &w);
    return (int)(w.ws_col);
}
int terminalheight()
{
    struct winsize w;
    ioctl(fileno(stdout), TIOCGWINSZ, &w);
    return (int)(w.ws_row);
}
int mygetch(bool i_flagmore)
{
	int mychar=0;
	struct termios oldt, newt;
	tcgetattr ( STDIN_FILENO, &oldt );
	newt = oldt;
	newt.c_lflag &= ~( ICANON | ECHO );
	tcsetattr ( STDIN_FILENO, TCSANOW, &newt );
	mychar = getchar();
	tcsetattr ( STDIN_FILENO, TCSANOW, &oldt );
	if (!i_flagmore)
		return mychar;
	if ((mychar==113) || (mychar==81) || (mychar==3))  
	{
		myprintf("\n\n");
		seppuku();
	}
	return mychar;
}
void printbar(char i_carattere,bool i_printbarraenne=true)
{
	int twidth=terminalwidth();
	if (twidth<10)
		twidth=100;
	for (int i=0;i<twidth-4;i++)
		myprintf("%c",i_carattere);
	if (i_printbarraenne)
		myprintf("\n");
}
void moreprint(const char* i_stringa)
{
	if (g_output_handle)
		fprintf(g_output_handle,"%s\n",i_stringa);
	if (flagsilent)
		return;
	int larghezzaconsole=terminalwidth()-2;
	int altezzaconsole=terminalheight();
	static int righestampate=0;
	if (!i_stringa)
		return;
	if ((larghezzaconsole<0) || (altezzaconsole<0))
	{
		printf("%s\n",i_stringa);
		return;
	}
	if (!strcmp(i_stringa,"\n"))
	{
		printf("\n");
		righestampate++;
		if (righestampate>(altezzaconsole-2))
		{
			printf("-- More (q, Q or control C to exit) --\r");
			mygetch(true);
			for (int i=0;i<altezzaconsole;i++)
				printf("\n");
			righestampate=0;
		}
		return;
	}
	int lunghezzastringa=strlen(i_stringa);
	if (!larghezzaconsole)
		return;
	int righe	=(lunghezzastringa/larghezzaconsole)+1;
	int massimo	=lunghezzastringa-(larghezzaconsole*(righe-1));
	for (int riga=1; riga<=righe;riga++)
	{
		int currentmax=larghezzaconsole;
		if (riga==righe)
			currentmax=massimo;
		int startcarattere=(riga-1)*larghezzaconsole;
		for (int i=startcarattere;i<startcarattere+currentmax;i++)
			printf("%c",i_stringa[i]);
		printf("\n");
		righestampate++;
		if (righestampate>(altezzaconsole-2))
		{
			printf("-- More (q, Q or control C to exit) --\r");
			mygetch(true);
			for (int i=0;i<altezzaconsole;i++)
				printf("\n");
			righestampate=0;
		}
	}
}
void morebar(const char i_carattere)
{
	int twidth=terminalwidth();
	if (twidth<10)
		twidth=100; 
	if (twidth>100)
		twidth=100;
	char barbuffer[100+10];
	for (int i=0;i<twidth-4;i++)
		sprintf(barbuffer+i,"%c",i_carattere);
	moreprint(barbuffer);
}
bool getcaptcha(const string i_captcha,const string i_reason)
{
	if (i_captcha=="")
		return false;
	if (i_reason=="")
		return false;
	printf("\nTo confirm a dangerous command\n");
	printf(">>> %s\n",i_reason.c_str());
	printf("enter EXACTLY the capcha, then press CR (return)\n");
	printf("Entering anything else will quit.\n");
	printf("\nCaptcha to continue:     %s\n",i_captcha.c_str());
	char myline[81];
    int dummy=scanf("%80s", myline);
	if (dummy==888888)	
		printf("no-warning-please\n");
	if (myline!=i_captcha)
	{
		printf("Wrong captcha\n");
		return false;
	}
	printf("Captcha OK\n");
	return true;
}
char* stristr(const char* str1,const char* str2)
{
    const char* p1 = str1;
    const char* p2 = str2;
    const char* r = *p2 == 0 ? str1 : 0 ;
    while((*p1!=0) && (*p2!=0))
    {
        if( tolower((unsigned char)*p1)==tolower((unsigned char)*p2))
        {
            if(r==0)
                r=p1;
            p2++;
        }
        else
        {
            p2=str2;
            if(r!=0)
                p1=r+1;
            if(tolower((unsigned char)*p1)==tolower((unsigned char)*p2))
            {
                r=p1;
                p2++;
            }
            else
                r=0;
        }
        p1++;
    }
    return *p2 == 0 ? (char*)r : 0 ;
}
bool isdirectory(string i_filename)
{
	if (i_filename.length()==0)
		return false;
	else
	return
		i_filename[i_filename.size()-1]=='/';
}
bool havedoublequote(string i_filename)
{
	if (i_filename.length()==0)
		return false;
	else
	return
		i_filename[i_filename.size()-1]=='"';
}
string cutdoublequote(const string& i_string)
{
#ifdef ESX
	return "";
#else
	string temp=i_string;
	if (havedoublequote(i_string))
		temp.pop_back();
	return temp;
#endif
}
bool isextension(const char* i_filename,const char* i_ext)
{
	if (!i_filename)
		return false;
	if (!i_ext)
		return false;
	if (isdirectory(i_filename))
		return false;
	char * posizione=stristr(i_filename, i_ext);
	if (!posizione)
		return false;
	return (posizione-i_filename)+strlen(i_ext)==strlen(i_filename);
}
bool iszpaq(string i_filename)
{
	return isextension(i_filename.c_str(), ".zpaq");
}
bool isxls(string i_filename)
{
	return (isextension(i_filename.c_str(), ".xls") || isextension(i_filename.c_str(), ".ppt") || isextension(i_filename.c_str(), ".pps"));
}
bool isads(string i_filename)
{
	if (i_filename.length()==0)
		return false;
	else
		return strstr(i_filename.c_str(), ":$DATA")!=0;  
}
bool iszfs(string i_filename)
{
	if (i_filename.length()==0)
		return false;
	else
		return strstr(i_filename.c_str(), ".zfs")!=0;  
}
bool replace(std::string& str, const std::string& from, const std::string& to) {
    size_t start_pos = str.find(from);
    if(start_pos == std::string::npos)
        return false;
    str.replace(start_pos, from.length(), to);
    return true;
}
void myreplaceall(std::string& str, const std::string& from, const std::string& to) {
    if(from.empty())
        return;
    size_t start_pos = 0;
    while((start_pos = str.find(from, start_pos)) != std::string::npos) {
        str.replace(start_pos, from.length(), to);
        start_pos += to.length(); 
    }
}
string format_datetime(string i_formato,tm* t=NULL)
{
	char	temp[10];
	if (t==NULL)
	{
		time_t now=time(NULL);
		t=localtime(&now);
	}
	sprintf(temp,"%02d",t->tm_hour);
	string hour=temp;
	sprintf(temp,"%02d",t->tm_min);
	string min=temp;
	sprintf(temp,"%02d",t->tm_sec);
	string sec=temp;
	sprintf(temp,"%d",t->tm_wday);
	string weekday=temp;
	sprintf(temp,"%04d",t->tm_year+1900);
	string	year=temp;
	sprintf(temp,"%02d",t->tm_mon+1);
	string month=temp;
	sprintf(temp,"%02d",t->tm_mday);
	string day=temp;
	sprintf(temp,"%02d",(t->tm_yday-t->tm_wday+7)/7);
	string	week=temp;
	string date=year+'-'+month+'-'+day;
	string time=hour+'-'+min+'-'+sec;
	string datetime=date+'_'+time;
	myreplaceall(i_formato,"$hour",hour);
	myreplaceall(i_formato,"$min",min);
	myreplaceall(i_formato,"$sec",sec);
	myreplaceall(i_formato,"$weekday",weekday);
	myreplaceall(i_formato,"$year",year);
	myreplaceall(i_formato,"$month",month);
	myreplaceall(i_formato,"$day",day);
	myreplaceall(i_formato,"$week",week);
	myreplaceall(i_formato,"$date",date);
	myreplaceall(i_formato,"$time",time);
	myreplaceall(i_formato,"$datetime",datetime);
	return i_formato;
}
bool myreplace(string& i_str, const string& i_from, const string& i_to) 
{
    size_t start_pos = i_str.find(i_from);
    if(start_pos == std::string::npos)
        return false;
    i_str.replace(start_pos, i_from.length(), i_to);
    return true;
}
int mypos(const string& i_substring,const string& i_string) 
{
    size_t start_pos = i_string.find(i_substring);
    if	(start_pos==std::string::npos)
        return -1;
	else
		return start_pos;
}
std::string myright(std::string const& source, size_t const length) 
{
  if (length >= source.size()) 
 	return source;
  return source.substr(source.size() - length);
} 
std::string myleft(std::string const& source, size_t const length) 
{
  if (length >= source.size()) 
 	return source;
  return source.substr(0,length);
} 
string mytrim(const string& i_str)
{
	size_t first = i_str.find_first_not_of(' ');
	if (string::npos == first)
		return i_str;
	size_t last = i_str.find_last_not_of(' ');
	return i_str.substr(first, (last - first + 1));
}
void explode(string i_string,char i_delimiter,vector<string>& array)
{
	unsigned int i=0;
	while(i<i_string.size())
	{
		string temp="";
		while ((i_string[i]!=i_delimiter) && (i<i_string.size()))
        {
			temp+=i_string[i];
			i++;
		}
		array.push_back(temp);
		i++;
		if (i>=i_string.size())
			break;
    }
}
struct s_fileandsize
{
	string	filename;
	uint64_t size;
	int64_t attr;
	int64_t date;
	int64_t data;
	bool 	isdir;
	string 	hashhex;
	string 	hashtype;
	bool 	flaghashstored;
	string	writtenfilename;
	bool	hashok;
	bool	filenotfound;
	s_fileandsize(): size(0),attr(0),date(0),data(-1),isdir(false),flaghashstored(false),hashok(false),filenotfound(false) {filename="";hashhex="";hashtype="";writtenfilename="";}
};
string mymaxfile(string i_filename,const unsigned int i_lunghezza)
{
	if (i_filename=="")
		return "";
	if (i_lunghezza==0)
		return "";
	if (i_filename.length()<=i_lunghezza)
		return i_filename;
	if (i_lunghezza>10)
	{
		if (i_filename.length()>10)
		{
			unsigned int intestazione=i_lunghezza-10;
			return i_filename.substr(0,intestazione)+"(...)"+i_filename.substr(i_filename.length()-5,5);
		}
		else
		return i_filename.substr(0,i_lunghezza);
	}
	else
		return i_filename.substr(0,i_lunghezza);
}
#ifndef align_up
#define align_up(num, align) \
	(((num) + ((align) - 1)) & ~((align) - 1))
#endif
#define memalign(align, size) aligned_malloc(align, size)
typedef uint16_t myoffset_t;
#define PTR_OFFSET_SZ sizeof(myoffset_t)
void * aligned_malloc(size_t align, size_t size)
{
	void * ptr = NULL;
	assert((align & (align - 1)) == 0);
	if(align && size)
	{
		uint32_t hdr_size = PTR_OFFSET_SZ + (align - 1);
		void * p = malloc(size + hdr_size);
		if(p)
		{
			ptr = (void *) align_up(((uintptr_t)p + PTR_OFFSET_SZ), align);
			*((myoffset_t *)ptr - 1) = (myoffset_t)((uintptr_t)ptr - (uintptr_t)p);
		} 
	} 
	return ptr;
}
void aligned_free(void * ptr)
{
	assert(ptr);
	myoffset_t offset = *((myoffset_t *)ptr - 1);
	void * p = (void *)((uint8_t *)ptr - offset);
	free(p);
}
	std::string utf8toansi(const std::string & utf8)
	{
		return utf8;
	}
const std::string WHITESPACE = " \n\r\t\f\v";
std::string myltrim(const std::string &s)
{
    size_t start = s.find_first_not_of(WHITESPACE);
    return (start == std::string::npos) ? "" : s.substr(start);
}
std::string myrtrim(const std::string &s)
{
    size_t end = s.find_last_not_of(WHITESPACE);
    return (end == std::string::npos) ? "" : s.substr(0, end + 1);
}
std::string mytrim2(const std::string &s) 
{
    return myrtrim(myltrim(s));
}
string extractfilename(const string& i_string) 
{
	size_t i = i_string.rfind('/', i_string.length());
	if (i != string::npos) 
		return(i_string.substr(i+1, i_string.length() - i));
	return(i_string);
}
string prendiestensione(const string& s) 
{
	if (isdirectory(s))
		return ("");
	string nomefile=extractfilename(s);
	size_t i = nomefile.rfind('.', nomefile.length());
	if (i != string::npos) 
	{
		int lunghezzaestensione=nomefile.length() - i;
		if (lunghezzaestensione>20)
			return("");
		return(nomefile.substr(i+1, lunghezzaestensione));
	}
   return("");
}
string extractfilepath(const string& i_string) 
{
	size_t i = i_string.rfind('/', i_string.length());
	if (i != string::npos) 
		return(i_string.substr(0, i+1));
	return("");
}
string prendinomefileebasta(const string& s) 
{
	string nomefile=extractfilename(s);
	size_t i = nomefile.rfind('.', nomefile.length());
	if (i != string::npos) 
		return(nomefile.substr(0,i));
	return(nomefile);
}
string path(const string& fn) 
{
	int n=0;
	for (int i=0; fn[i]; ++i)
	if (fn[i]=='/' || fn[i]=='\\') 
		n=i+1;
	return fn.substr(0, n);
}
string padleft(std::string str, const size_t num, const char paddingChar = ' ')
{
    if(num > str.size())
	{
        string tmpstring=str;
		tmpstring.insert(0, num - tmpstring.size(), paddingChar);
		return tmpstring;
	}
	else
		return("");
}
string purgeansi(string i_string,bool i_keeppath=false)
{
	if (i_string=="")
		return ("");
	string purged;
	for (unsigned int i=0;i<i_string.length();i++)
	{
		if (i_keeppath)
		{
			if ((i_string[i]==':') || (i_string[i]=='/') || (i_string[i]=='\\'))
			{
				purged+=i_string[i];
				continue;
			}
		}
		if (isalnum(i_string[i]))
			purged+=i_string[i];
		else
		{
			switch (i_string[i]) 
			{
				case ' ':
				case '-':
				case '#':
				case '~':
				case '%':
				case '^':
				case '_':
				case '.':
				case '+':
				case '=':
				purged+=i_string[i];
				break;
				case '&':
				purged+="_and_";
				break;
				case ',':
				case '`':
				case '@':
				case '$':
				case '*':
				case '|':
				case ':':
				case ';':
				case '"':
				case '\'':
				case '<':
				case '>':
				case '\n':
				case '\r':
				case '\t':
				purged+='_';
				break;
				case '(':
				case '{':
				purged+='(';
				break;
				case ')':
				case '}':
				purged+=')';
				break;
			}
		}
	}
	return purged;
}
string forcelatinansi(string i_string)
{
	if (i_string=="")
		return ("");
	for (unsigned int j=0;j<i_string.length();j++)
	{
		if (i_string[j]<0)
		{
			if (i_string[j]==-1) 
			i_string[j]='u';
				else
				if (i_string[j]==-2) 
					i_string[j]='u';
				else
				if (i_string[j]==-3)  
					i_string[j]='u';
				else
				if (i_string[j]==-4) 
					i_string[j]='u';
				else
				if (i_string[j]==-5) 
					i_string[j]='u';
				else
				if (i_string[j]==-6) 
					i_string[j]='u';
				else
				if (i_string[j]==-7) 
					i_string[j]='u';
				else
				if (i_string[j]==-8) 
					i_string[j]='o';
				else
				if (i_string[j]==-9) 
					i_string[j]='o';
				else
				if (i_string[j]==-10) 
					i_string[j]='o';
				else
				if (i_string[j]==-11) 
					i_string[j]='o';
				else
				if (i_string[j]==-12) 
					i_string[j]='o';
				else
				if (i_string[j]==-13) 
					i_string[j]='o';
				else
				if (i_string[j]==-14) 
					i_string[j]='o';
				else
				if (i_string[j]==-15) 
					i_string[j]='o';
				else
				if (i_string[j]==-17) 
					i_string[j]='i';
				else
				if (i_string[j]==-18) 
					i_string[j]='i';
				else
				if (i_string[j]==-19) 
					i_string[j]='i';
				else
				if (i_string[j]==-20) 
					i_string[j]='i';
				else
				if (i_string[j]==-21) 
					i_string[j]='e';
				else
				if (i_string[j]==-22) 
					i_string[j]='e';
				else
				if (i_string[j]==-23) 
					i_string[j]='e';
				else
				if (i_string[j]==-24) 
					i_string[j]='e';
				else
				if (i_string[j]==-25) 
					i_string[j]='a';
				else
				if (i_string[j]==-26) 
					i_string[j]='a';
				else
				if (i_string[j]==-27) 
					i_string[j]='a';
				else
				if (i_string[j]==-28) 
					i_string[j]='a';
				else
				if (i_string[j]==-29) 
					i_string[j]='a';
				else
				if (i_string[j]==-30) 
					i_string[j]='e';
				else
				if (i_string[j]==-31) 
					i_string[j]='a';
				else
				if (i_string[j]==-32) 
					i_string[j]='a';
				else
				if (i_string[j]==-33) 
					i_string[j]='u';
				else
				if (i_string[j]==-34) 
					i_string[j]='u';
				else
				if (i_string[j]==-35) 
					i_string[j]='u';
				else
				if (i_string[j]==-36) 
					i_string[j]='u';
				else
				if (i_string[j]==-37) 
					i_string[j]='u';
				else
				if (i_string[j]==-38) 
					i_string[j]='u';
				else
				if (i_string[j]==-39) 
					i_string[j]='U';
				else
				if (i_string[j]==-40) 
					i_string[j]='O';
				else
				if (i_string[j]==-41) 
					i_string[j]='x';
				else
				if (i_string[j]==-42) 
					i_string[j]='O';
				else
				if (i_string[j]==-45) 
					i_string[j]='O';
				else
				if (i_string[j]==-46) 
					i_string[j]='O';
				else
				if (i_string[j]==-47) 
					i_string[j]='N';
				else
				if (i_string[j]==-49) 
					i_string[j]='I';
				else
				if (i_string[j]==-50) 
					i_string[j]='I';
				else
				if (i_string[j]==-51) 
					i_string[j]='I';
				else
				if (i_string[j]==-52) 
					i_string[j]='I';
				else
				if (i_string[j]==-53) 
					i_string[j]='E';
				else
				if (i_string[j]==-54) 
					i_string[j]='E';
				else
				if (i_string[j]==-55) 
					i_string[j]='E';
				else
				if (i_string[j]==-56) 
					i_string[j]='E';
				else
				if (i_string[j]==-57) 
					i_string[j]='E';
				else		
				if (i_string[j]==-60) 
					i_string[j]='A';
				else
				if (i_string[j]==-61) 
					i_string[j]='A';
				else
				if (i_string[j]==-62) 
					i_string[j]='A';
				else
				if (i_string[j]==-63) 
					i_string[j]='A';
				else
				if (i_string[j]==-64) 
					i_string[j]='A';
				else
				if (i_string[j]==-66) 
					i_string[j]='3';
				else
				if (i_string[j]==-68) 
					i_string[j]='3';
				else
				if (i_string[j]==-69) 
					i_string[j]='>';
				else
				if (i_string[j]==-70) 
					i_string[j]='o';
				else
				if (i_string[j]==-72) 
					i_string[j]='.';
				else
				if (i_string[j]==-74) 
					i_string[j]=' ';
				else
				if (i_string[j]==-75) 
					i_string[j]=' ';
				else
				if (i_string[j]==-76) 
					i_string[j]=' ';
				else
				if (i_string[j]==-78) 
					i_string[j]='2';
				else
				if (i_string[j]==-80) 
					i_string[j]='o';
				else
				if (i_string[j]==-81) 
					i_string[j]='-';
				else
				if (i_string[j]==-82) 
					i_string[j]='-';
				else
				if (i_string[j]==-83) 
					i_string[j]='-';
				else
				if (i_string[j]==-84) 
					i_string[j]='-';
				else
				if (i_string[j]==-85) 
					i_string[j]='<';
				else
				if (i_string[j]==-89) 
					i_string[j]='S';
				else
				if (i_string[j]==-90) 
					i_string[j]=' ';
				else
				if (i_string[j]==-93) 
					i_string[j]=' ';
				else
				if (i_string[j]==-94) 
					i_string[j]=' ';
				else
				if (i_string[j]==-95) 
					i_string[j]=' ';
				else
				if (i_string[j]==-96) 
					i_string[j]=' ';
				else
				if (i_string[j]==-98) 
					i_string[j]=' ';
				else
				if (i_string[j]==-102)
					i_string[j]='s';
				else
				if (i_string[j]==-103)
					i_string[j]='a';
				else
				if (i_string[j]==-106)
					i_string[j]='-';
				else
				if (i_string[j]==-107)
					i_string[j]='.';
				else
				if (i_string[j]==-108) 
					i_string[j]='"';
				else
				if (i_string[j]==-109) 
					i_string[j]='"';
				else
				if (i_string[j]==-110) 
					i_string[j]=' ';
				else
				if (i_string[j]==-111) 
					i_string[j]=' ';
				else
				if (i_string[j]==-112) 
					i_string[j]=' ';
				else
				if (i_string[j]==-112) 
					i_string[j]=' ';
				else
				if (i_string[j]==-113) 
					i_string[j]=' ';
				else
				if (i_string[j]==-114) 
					i_string[j]=' ';
				else
				if (i_string[j]==-115)
					i_string[j]=' ';
				else
				if (i_string[j]==-116) 
					i_string[j]=' ';
				else
				if (i_string[j]==-118) 
					i_string[j]='S';
				else
				if (i_string[j]==-123) 
					i_string[j]='d';
				else
				if (i_string[j]==-128) 
					i_string[j]='E';
				else
					i_string[j]=' ';
		}
	}
	return i_string;
}
string purgedouble(const string& i_string,const string& i_from,const string& i_to)
{
	if (i_string=="")
		return("");
	if (i_from=="")
		return("");
	if (i_to=="")
		return("");
	string purged=i_string;
	myreplaceall(purged,i_from,i_to);
	return purged;
}
string compressemlfilename(const string& i_string)
{
	if (i_string=="")
		return("");
	string uniqfilename=extractfilename(i_string);
	string percorso=extractfilepath(i_string);
	for (int k=0;k<10;k++)
		uniqfilename=purgedouble(uniqfilename,"  "," ");
	for (int k=0;k<10;k++)
		uniqfilename=purgedouble(uniqfilename,"..",".");
	for (int k=0;k<10;k++)
		uniqfilename=purgedouble(uniqfilename,"Fw ","Fwd ");
	for (int k=0;k<10;k++)
		uniqfilename=purgedouble(uniqfilename,"Fwd Fwd ","Fwd ");
	for (int k=0;k<10;k++)
		uniqfilename=purgedouble(uniqfilename," R "," Re ");
	for (int k=0;k<10;k++)
		uniqfilename=purgedouble(uniqfilename,"R Fwd ","Re Fwd");
	for (int k=0;k<10;k++)
		uniqfilename=purgedouble(uniqfilename," RE "," Re ");
	for (int k=0;k<10;k++)
		uniqfilename=purgedouble(uniqfilename,"Re Re ","Re ");
	for (int k=0;k<10;k++)
		uniqfilename=purgedouble(uniqfilename,"Fwd Re Fwd Re ","Fwd Re ");
	for (int k=0;k<10;k++)
		uniqfilename=purgedouble(uniqfilename,"Re Fwd Re Fwd ","Re Fwd ");
	for (int k=0;k<10;k++)
		uniqfilename=purgedouble(uniqfilename," SV SV "," SV ");
	for (int k=0;k<10;k++)
		uniqfilename=purgedouble(uniqfilename,"Fwd FW ","Fwd ");
	for (int k=0;k<10;k++)
		uniqfilename=purgedouble(uniqfilename,"Fwd I ","Fwd ");
	for (int k=0;k<10;k++)
		uniqfilename=purgedouble(uniqfilename,"I Fwd ","Fwd ");
	for (int k=0;k<10;k++)
			uniqfilename=purgedouble(uniqfilename,"R Re ","Re ");
	for (int k=0;k<10;k++)
		uniqfilename=purgedouble(uniqfilename,"__","_");
	for (int k=0;k<10;k++)
	uniqfilename=purgedouble(uniqfilename," _ ","_");
	for (int k=0;k<10;k++)
		uniqfilename=purgedouble(uniqfilename,"  "," ");
#ifndef ESX
	for (int k=uniqfilename.length()-1;k>0;k--)
	{
		if ((uniqfilename[k]=='-') || (uniqfilename[k]=='.') || (uniqfilename[k]==' '))
		{
			uniqfilename.pop_back();
		}
		else
		{
			break;
		}
	}
#endif
	uniqfilename=mytrim2(uniqfilename);
	uniqfilename=percorso+uniqfilename;
	return uniqfilename;
}
void print_datetime(void)
{
	int hours, minutes, seconds, day, month, year;
	time_t now;
	time(&now);
	struct tm *local = localtime(&now);
	hours = local->tm_hour;			
	minutes = local->tm_min;		
	seconds = local->tm_sec;		
	day = local->tm_mday;			
	month = local->tm_mon + 1;		
	year = local->tm_year + 1900;	
	myprintf("%02d/%02d/%d %02d:%02d:%02d ", day, month, year, hours,minutes,seconds);
}
void printUTF8(const char* s, FILE* f=stdout) 
{
	assert(f);
	assert(s);
	if (g_output_handle!=0)
		fprintf(g_output_handle,"%s",s);
	if (flagsilent)
		return;
  fprintf(f, "%s", s);
}
FILE* freadopen(const char* i_filename)
{
	FILE* myfp=fopen(i_filename, "rb" );
	if (myfp==NULL)
	{
		if (flagdebug)
		{
			myprintf( "\nfreadopen cannot open:");
			printUTF8(i_filename);
			myprintf("\n");
		}
		return 0;
	}
	return myfp;
}
int64_t prendidimensionehandle(FILE* i_handle)
{
	if (i_handle==0)
		return 0;
	fseeko(i_handle, 0, SEEK_END);
	int64_t dimensione=ftello(i_handle);
	fseeko(i_handle, 0, SEEK_SET);
	return dimensione;	
}
int64_t prendidimensionefile(const char* i_filename)
{
	if (!i_filename)
		return 0;
	FILE* myfile = freadopen(i_filename);
	if (myfile)
    {
		fseeko(myfile, 0, SEEK_END);
		int64_t dimensione=ftello(myfile);
		fclose(myfile);
		return dimensione;
	}
	else
	return 0;
}
bool islonguncpath(string i_filename)
{
	if (i_filename.size()<8)
		return false;
	if (i_filename[0]=='/')
	if (i_filename[1]=='/')
	if (i_filename[2]=='?')
	if (i_filename[3]=='/')
	if (toupper(i_filename[4])=='U')
	if (toupper(i_filename[5])=='N')
	if (toupper(i_filename[6])=='C')
	if (i_filename[7]=='/')
		return true;
	return false;
}
bool islongpath(string i_filename)
{
	if (i_filename.size()<8)
		return false;
	if (i_filename[0]=='/')
	if (i_filename[1]=='/')
	if (i_filename[2]=='?')
	if (i_filename[3]=='/')
	if (isalpha(i_filename[4]))
	if (i_filename[5]==':')
	if (i_filename[6]=='/')
		return true;
	return false;
}
bool comparechar(char c1, char c2)
{
    if (c1 == c2)
        return true;
    else if (std::toupper(c1) == std::toupper(c2))
        return true;
    return false;
}
string stringtolower(string i_stringa)
{
#ifndef ESX
	std::for_each(i_stringa.begin(), i_stringa.end(), [](char & c)
	{
		c = ::tolower(c);	
	});
#endif
	return i_stringa;
}			
string stringtoupper(string i_stringa)
{
#ifndef ESX	
std::for_each(i_stringa.begin(), i_stringa.end(), [](char & c)
	{
		c = ::toupper(c);	
	});
#endif
	return i_stringa;
}			
int myposi(string i_substring,string i_string) 
{
	i_substring=stringtolower(i_substring);
	i_string=stringtolower(i_string);
    size_t start_pos = i_string.find(i_substring);
    if	(start_pos==std::string::npos)
        return -1;
	else
		return start_pos;
}
bool stringcomparei(std::string str1, std::string str2)
{
    return ( (str1.size() == str2.size() ) &&
             std::equal(str1.begin(), str1.end(), str2.begin(), &comparechar) );
}
inline char *  migliaia(uint64_t n)
{
	static char retbuf[30];
	char *p = &retbuf[sizeof(retbuf)-1];
	unsigned int i = 0;
	*p = '\0';
	do 
	{
		if(i%3 == 0 && i != 0)
			*--p = '.';
		*--p = '0' + n % 10;
		n /= 10;
		i++;
		} while(n != 0);
	return p;
}
inline char *  migliaia2(uint64_t n)
{
	static char retbuf[30];
	char *p = &retbuf[sizeof(retbuf)-1];
	unsigned int i = 0;
	*p = '\0';
	do 
	{
		if(i%3 == 0 && i != 0)
			*--p = '.';
		*--p = '0' + n % 10;
		n /= 10;
		i++;
		} while(n != 0);
	return p;
}
inline char *  migliaia3(uint64_t n)
{
	static char retbuf[30];
	char *p = &retbuf[sizeof(retbuf)-1];
	unsigned int i = 0;
	*p = '\0';
	do 
	{
		if(i%3 == 0 && i != 0)
			*--p = '.';
		*--p = '0' + n % 10;
		n /= 10;
		i++;
		} while(n != 0);
	return p;
}
inline char *  migliaia4(uint64_t n)
{
	static char retbuf[30];
	char *p = &retbuf[sizeof(retbuf)-1];
	unsigned int i = 0;
	*p = '\0';
	do 
	{
		if(i%3 == 0 && i != 0)
			*--p = '.';
		*--p = '0' + n % 10;
		n /= 10;
		i++;
		} while(n != 0);
	return p;
}
inline char *  migliaia5(uint64_t n)
{
	static char retbuf[30];
	char *p = &retbuf[sizeof(retbuf)-1];
	unsigned int i = 0;
	*p = '\0';
	do 
	{
		if(i%3 == 0 && i != 0)
			*--p = '.';
		*--p = '0' + n % 10;
		n /= 10;
		i++;
		} while(n != 0);
	return p;
}
string timetohuman(int32_t i_seconds)
{
	if (i_seconds<=0)
		return "00:00:00";
	int h=(i_seconds/3600); 
	int m=(i_seconds -(3600*h))/60;
	int s=(i_seconds -(3600*h)-(m*60));
	char	temporaneo[20];
	sprintf(temporaneo,"%03d:%02d:%02d",h,m,s);
	return temporaneo;
}
inline char* tohuman(uint64_t i_bytes)
{
	static char io_buf[30];
	char const *myappend[] = {"B","KB","MB","GB","TB","PB"};
	char length = sizeof(myappend)/sizeof(myappend[0]);
	double mybytes=i_bytes;
	int i=0;
	if (i_bytes > 1024) 
		for (i=0;(i_bytes / 1024) > 0 && i<length-1; i++, i_bytes /= 1024)
			mybytes = i_bytes / 1024.0;
	sprintf(io_buf, "%.02lf %s",mybytes,myappend[i]);
	return io_buf;
}
inline char* tohuman2(uint64_t i_bytes)
{
	static char io_buf[30];
	char const *myappend[] = {"B","KB","MB","GB","TB","PB"};
	char length = sizeof(myappend)/sizeof(myappend[0]);
	double mybytes=i_bytes;
	int i=0;
	if (i_bytes > 1024) 
		for (i=0;(i_bytes / 1024) > 0 && i<length-1; i++, i_bytes /= 1024)
			mybytes = i_bytes / 1024.0;
	sprintf(io_buf, "%.02lf %s",mybytes,myappend[i]);
	return io_buf;
}
inline char* tohuman3(uint64_t i_bytes)
{
	static char io_buf[30];
	char const *myappend[] = {"B","KB","MB","GB","TB","PB"};
	char length = sizeof(myappend)/sizeof(myappend[0]);
	double mybytes=i_bytes;
	int i=0;
	if (i_bytes > 1024) 
		for (i=0;(i_bytes / 1024) > 0 && i<length-1; i++, i_bytes /= 1024)
			mybytes = i_bytes / 1024.0;
	sprintf(io_buf, "%.02lf %s",mybytes,myappend[i]);
	return io_buf;
}
inline char* tohuman4(uint64_t i_bytes)
{
	static char io_buf[30];
	char const *myappend[] = {"B","KB","MB","GB","TB","PB"};
	char length = sizeof(myappend)/sizeof(myappend[0]);
	double mybytes=i_bytes;
	int i=0;
	if (i_bytes > 1024) 
		for (i=0;(i_bytes / 1024) > 0 && i<length-1; i++, i_bytes /= 1024)
			mybytes = i_bytes / 1024.0;
	sprintf(io_buf, "%.02lf %s",mybytes,myappend[i]);
	return io_buf;
}
int64_t encodestringdate(string i_date)
{
	string purged;
	for (unsigned int i=0;i<i_date.length();i++)
		if (isdigit(i_date[i]))
			purged+=i_date[i];
	if (purged.length()!=14)
	{
		myprintf("106: datelength !=14\n");
		return -1;
	}
	for (int i=0;i<=13;i++)
		if (!isdigit(purged[i]))
		{
			myprintf("107: date[%d] not idigit\n",i);
			return -1;
		}
	int year=std::stoi(purged.substr(0,4));
	int month=std::stoi(purged.substr(4,2));
	int day=std::stoi(purged.substr(6,2));
	int hour=std::stoi(purged.substr(8,2));
	int minute=std::stoi(purged.substr(10,2));
	int second=std::stoi(purged.substr(12,2));
	if (flagdebug)
		myprintf("14669: date   %04d-%02d-%02d %02d:%02d:%02d\n",year,month,day,hour,minute,second);
	if ((year<1970) || (year>2070))
	{
		myprintf("108: year not from 1970 to 2070\n");
		return -1;
	}
	if ((month<1) || (month>12))
	{
		myprintf("136: month not in 1 to 12\n");
		return -1;
	}
	if ((day<1) || (day>31))
	{
		myprintf("141: day not in 1 to 31\n");
		return -1;
	}
	if (hour>24)
	{
		myprintf("147: hour >24\n");
		return -1;
	}
	if (minute>60)
	{
		myprintf("152: minute >60\n");
		return -1;
	}	
	if (second>60)
	{
		myprintf("157: second >60\n");
		return -1;
	}	
	bool isleap= (((year % 4 == 0) &&
         (year % 100 != 0)) ||
         (year % 400 == 0));
    if (month == 2)
    {
        if (isleap)
		{
			if (!(day <=29))
			{
				myprintf("180: leap year, feb must be <=29\n");
				return -1;
			}
		}
        else
			if (!(day <=28))
			{
				myprintf("187: NO leap year, feb must be <=28\n");
				return -1;
			}
    }
    if ((month==4) || (month==6) || (month==9) || (month==11))
		if (!(day <= 30))
		{
			myprintf("195: month cannot have more than 30 days\n");
			return -1;
		}
	return year*10000000000LL
		+month*100000000LL 
		+day*1000000		
		+hour*10000 
		+minute*100	
		+second;	
}
string itos(int64_t x, int n=1) {
  assert(x>=0);
  assert(n>=0);
  string r;
  for (; x || n>0; x/=10, --n) r=string(1, '0'+x%10)+r;
  return r;
}
string subpart(string fn, int part) {
  for (int j=fn.size()-1; j>=0; --j) {
    if (fn[j]=='?')
      fn[j]='0'+part%10, part/=10;
    else if (fn[j]=='*')
      fn=fn.substr(0, j)+itos(part)+fn.substr(j+1), part=0;
  }
  return fn;
}
int64_t mtime() 
{
  timeval tv;
  gettimeofday(&tv, 0);
  return tv.tv_sec*1000LL+tv.tv_usec/1000;
}
string ConvertUtcToLocalTime(const string i_date)
{
	if (flagdebug)
		myprintf("\n20006: converting to localtime %s\n",i_date.c_str());
	return i_date;
}
string dateToString(int64_t date,bool i_mylocal=false) 
{
  if (date<=0) return "                   ";
  string s="0000-00-00 00:00:00";
  static const int t[]={18,17,15,14,12,11,9,8,6,5,3,2,1,0};
  for (int i=0; i<14; ++i) s[t[i]]+=int(date%10), date/=10;
  
  if (!flagutc)
		s=ConvertUtcToLocalTime(s);

  if (i_mylocal)
  {
	char mylocal[30];
	mylocal[ 0]=s.at(8);
	mylocal[ 1]=s.at( 9);
	mylocal[ 2]='/';
	mylocal[ 3]=s.at( 5);
	mylocal[ 4]=s.at( 6);
	mylocal[ 5]='/';
	mylocal[ 6]=s.at( 0);
	mylocal[ 7]=s.at( 1);
	mylocal[ 8]=s.at( 2);
	mylocal[ 9]=s.at( 3);
	mylocal[10]=' ';
	mylocal[11]=' ';
	mylocal[12]=s.at(11);
	mylocal[13]=s.at(12);
	mylocal[14]=s.at(13);
	mylocal[15]=s.at(14);
	mylocal[16]=s.at(15);
	mylocal[17]=0;
	s=mylocal;
	
  }
  return s;
}
string attrToString(int64_t attrib) {
  string r="     ";
  if ((attrib&255)=='u') {
    r[0]="0pc3d5b7 9lBsDEF"[(attrib>>20)&15];
    for (int i=0; i<4; ++i)
      r[4-i]=(attrib>>(8+3*i))%8+'0';
  }
  else if ((attrib&255)=='w') {
    for (int i=0, j=0; i<32; ++i) {
      if ((attrib>>(i+8))&1) {
        char c="RHS DAdFTprCoIEivs89012345678901"[i];
        if (j<5) r[j]=c;
        else r+=c;
        ++j;
      }
    }
  }
  return r;
}
int64_t decimal_time(time_t tt) {
  if (tt==-1) tt=0;
  int64_t t=(sizeof(tt)==4) ? unsigned(tt) : tt;
  const int second=t%60;
  const int minute=t/60%60;
  const int hour=t/3600%24;
  t/=86400;  
  const int term=t/1461;  
  t%=1461;
  t+=(t>=59);  
  t+=(t>=425);
  t+=(t>=1157);
  const int year=term*4+t/366+1970;  
  t%=366;
  t+=(t>=60)*2;  
  t+=(t>=123);   
  t+=(t>=185);   
  t+=(t>=278);   
  t+=(t>=340);   
  const int month=t/31+1;
  const int day=t%31+1;
  return year*10000000000LL+month*100000000+day*1000000
         +hour*10000+minute*100+second;
}
time_t unix_time(int64_t date) {
  if (date<=0) return -1;
  static const int days[12]={0,31,59,90,120,151,181,212,243,273,304,334};
  const int year=date/10000000000LL%10000;
  const int month=(date/100000000%100-1)%12;
  const int day=date/1000000%100;
  const int hour=date/10000%100;
  const int min=date/100%100;
  const int sec=date%100;
  return (day-1+days[month]+(year%4==0 && month>1)+((year-1970)*1461+1)/4)
    *86400+hour*3600+min*60+sec;
}
long long fsbtoblk(int64_t num, uint64_t fsbs, u_long bs)
{
	return (num * (intmax_t) fsbs / (int64_t) bs);
}
bool iswindowspath(const string& i_filename)
{
	if (i_filename.size()>3)
	{
		if (isalpha(i_filename[0]))
			if (i_filename[1]==':')
				if ((i_filename[2]=='\\') || (i_filename[2]=='/')) 
					return true;
	}
	return false;
}
bool iswindowsunc(const string& i_filename)
{
	if (i_filename=="")
			return false;
	if (i_filename[0]!='/')
			return false;
	if (i_filename[1]!='/')
			return false;
	bool	foundslash=false;
	for (unsigned int i=3;i<i_filename.size();i++)
	{
		if (i_filename[i]=='/')
		{
			foundslash=true;
			break;
		}
	}
	return foundslash;
}
string getfirstwindowsuncdir(const string& i_filename)
{
	if (i_filename=="")
			return "";
	if (i_filename[0]!='/')
			return "";
	if (i_filename[1]!='/')
			return "";
	string	theserver="";
	string 	theshare="";
	string 	firstshare="";
	for (unsigned int i=3;i<i_filename.size();i++)
		if (i_filename[i]=='/')
		{
			theserver=i_filename.substr(0,i+1);
			theshare=i_filename.substr(i+1,i_filename.size());
			break;
		}
	for (unsigned int i=0;i<theshare.size();i++)
		if (theshare[i]=='/')
		{
			firstshare=theshare.substr(0,i);
			break;
		}
	return theserver+firstshare;
}
bool direxists(string i_directory) 
{
	struct stat sb;
    return ((stat(i_directory.c_str(), &sb) == 0) && S_ISDIR(sb.st_mode)); 	
}
string	trimbarra(string i_path)
{
	if (isdirectory(i_path))
		return i_path.substr(0, i_path.size()-1);
	return i_path;
}
string	makeshortpath(string i_path)
{
	if (islongpath(i_path))
		return myright(i_path,i_path.size()-4);
	return i_path;
}	
string makelongpath(string i_path)
{
	return i_path;
}
int64_t getfreespace(string i_path)
{
	struct statfs stat;
	if (statfs(i_path.c_str(), &stat) != 0) 
	{
		return 0;
	}
	static long blocksize = 0;
	int dummy;
	if (blocksize == 0)
		getbsize(&dummy, &blocksize);
	return  fsbtoblk(stat.f_bavail,
	stat.f_bsize, blocksize)*1024;
}
void printerr(const char* i_where,const char* filename,int32_t i_fileattr) 
{
	string lasterror=i_where;
	string lasterror2=filename;
	string risultato=lasterror+":"+lasterror2;
	perror(risultato.c_str());
}
void ioerr(const char* msg) 
{
  printerr("11896",msg,0);
  throw std::runtime_error(msg);
}
typedef FILE* FP;
const FP FPNULL=NULL;
const char* const RB="rb";
const char* const WB="wb";
const char* const RBPLUS="rb+";
bool fileexists(const string& i_filename) 
{
  struct stat buffer;   
  return (stat(i_filename.c_str(),&buffer)==0); 
}
bool realfileexists(const string& i_filename) 
{
  struct stat buffer;   
  if (stat(i_filename.c_str(),&buffer)==0)
	if (!S_ISDIR(buffer.st_mode))
		return true;
	return false;
}
bool getfileinfo(string i_filename,int64_t& o_size,int64_t& o_date,int64_t& o_attr)
{
	o_size=0;
	o_date=0;
	o_attr=0;
	while (i_filename.size()>1 && i_filename[i_filename.size()-1]=='/')
		i_filename=i_filename.substr(0, i_filename.size()-1);  
	struct stat sb;
	if (!lstat(i_filename.c_str(), &sb)) 
	{
		if (S_ISREG(sb.st_mode))
		{
			o_date=decimal_time(sb.st_mtime);
			o_size=sb.st_size;
			o_attr='u'+(sb.st_mode<<8);
			return true;
		}
	}
	return false;
}
bool delete_file(const char* filename) {
	return remove(filename)==0;
}
bool delete_dir(const char* i_directory) {
  return remove(i_directory)==0;
}
int erredbarras(const std::string &i_path)
{
		bool 	risultato=false;
		DIR *d=opendir(i_path.c_str());
		if (d) 
		{
			struct dirent *p;
			risultato=true;
			while (risultato && (p=readdir(d))) 
			{
				if (!strcmp(p->d_name, ".") || !strcmp(p->d_name, ".."))
					continue;
				bool risultato2=false;
				struct stat statbuf;
				std::string temp;
				if (isdirectory(i_path))
					temp=i_path+p->d_name;
				else
					temp=i_path+"/"+p->d_name;
				if (!stat(temp.c_str(), &statbuf)) 
				{
					if (S_ISDIR(statbuf.st_mode))
						risultato2=erredbarras(temp);
					else
					{
						if (flagdebug)
							myprintf("20733: delete file %s\n",temp.c_str());
						risultato2=delete_file(temp.c_str());
					}
				}
				risultato=risultato2;
			}
			closedir(d);
		}
		if (risultato)
		{
			if (flagdebug)
				myprintf("20745: delete dir  %s\n\n",i_path.c_str());
			delete_dir(i_path.c_str());
		}
	   return risultato;
}
bool stermina(string i_path,int32_t i_expectedfile=0)
{
	if (i_path=="")
		return false;
	if (flagdebug)
		myprintf("20870 : PRE  ------------------ %s ----------\n",i_path.c_str());
	if (isdirectory(i_path))
		i_path=i_path.substr(0, i_path.size()-1);
	if (flagdebug)
		myprintf("20880 : POST ------------------ %s ----------\n",i_path.c_str());
	g_rd=0; 
	g_rd_expected=i_expectedfile;
	g_startrd=mtime();
	g_rd_ultimotempo=0;
	erredbarras(i_path);
	return (!direxists(i_path));
}
string nomefileseesistegia(string i_nomefile)
{
	if (!fileexists(i_nomefile))
		return i_nomefile;
	string percorso=extractfilepath(i_nomefile);
	string estensione=prendiestensione(i_nomefile);
	string nomefile=prendinomefileebasta(i_nomefile);
	char	numero[10];
	for (int i=1;i<99999;i++)
	{
		sprintf(numero,"%05d",i);
		string snumero=numero;
		string candidato=percorso+nomefile+"_"+snumero+"."+estensione;
		if (!fileexists(candidato))
			return candidato;
	}
	return ("");
}
string forbiddenstring[] = {"CON","PRN","AUX","NUL","COM1","COM2","COM3","COM4","COM5","COM6","COM7","COM8","COM9","LPT1","LPT2","LPT3","LPT4","LPT5","LPT6","LPT7","LPT8","LPT9"};
size_t forbiddenstringsize = sizeof(forbiddenstring)/sizeof(forbiddenstring[0]);
char forbiddenchar[] = {'<','>','"','|','?','*'};
size_t forbiddencharsize = sizeof(forbiddenchar)/sizeof(forbiddenchar[0]);
bool isreserved(const string& i_filename,string& o_fixed)
{
	return false;
}
string linuxtowinpath(const string& i_path)
{
	string risultato=i_path;
	myreplaceall(risultato,"/","\\");
	return risultato;
}
void xcommand(string i_command,string i_parameter)
{
	if (flagdebug)
	{
		myprintf("Entering xcommand()\n");
		myprintf("i_command   |%s|\n",i_command.c_str());
		myprintf("i_parameter |%s|\n",i_parameter.c_str());
	}
	if (i_command=="")
	{
		if (flagdebug)
				myprintf("Exit because empty i_command\n");
		return;
	}
	if (!fileexists(i_command))
	{
		if (flagdebug)
				myprintf("Exit because not fileexists  |%s|\n",i_command.c_str());
		return;
	}
	int dummy;
	string mycommand="";
	if (i_parameter=="")
	{
		if (flagdebug)
				myprintf("20273: i_parameter is empty\n");
		if (flagdebug)
			myprintf("20278: On *unix insert single double quote\n");
		mycommand="\""+i_command+"\"";
	}
	else
	{
		if (flagdebug)
				myprintf("20291: i_parameter is NOT empty\n");
		if (flagdebug)
			myprintf("20284: On *unix insert single double quote for cmd /c\n");
		mycommand="\""+i_command+"\""+" \""+i_parameter+"\"";
	}
	if (flagdebug)
		myprintf("20265: Do system on mycommand |%s|\n",mycommand.c_str());
	dummy=system(mycommand.c_str());
	if (dummy==888888)
		myprintf("no-warning-please\n");
}
string g_gettempdirectory()
{
	return "/tmp/";
}
bool exists(string filename) {
  int len=filename.size();
  if (len<1) return false;
  if (filename[len-1]=='/') filename=filename.substr(0, len-1);
  struct stat sb;
  return !lstat(filename.c_str(), &sb);
}
bool close(const char* filename, int64_t date, int64_t attr, FP fp=FPNULL) {
  assert(filename);
  if (fp!=FPNULL) fclose(fp);
  if (date>0) {
    struct utimbuf ub;
    ub.actime=time(NULL);
    ub.modtime=unix_time(date);
    utime(filename, &ub);
  }
  if ((attr&255)=='u')
    chmod(filename, attr>>8);
	return true;
}
void makepath(string path, int64_t date=0, int64_t attr=0) {
  for (unsigned i=0; i<path.size(); ++i) {
    if (path[i]=='\\' || path[i]=='/') {
      path[i]=0;
      mkdir(path.c_str(), 0777);
      path[i]='/';
    }
  }
  string filename=path;
  if (filename!="" && filename[filename.size()-1]=='/')
    filename=filename.substr(0, filename.size()-1);  
  close(filename.c_str(), date, attr);
}
bool saggiascrivibilitacartella(string i_cartella)
{
	if (i_cartella=="")
	{
		if (flagdebug)
				myprintf("20574: empty folder to be checked\n");
		return false;
	}
	if (flagdebug)		
		myprintf("20857: i_cartella %s\n",i_cartella.c_str());
	i_cartella=extractfilepath(i_cartella);
	if (flagdebug)		
		myprintf("20859: i_cartella %s\n",i_cartella.c_str());
	if (!isdirectory(i_cartella))
			i_cartella+="/";
	if (flagdebug)		
		myprintf("20580: Folder %s\n",i_cartella.c_str());
	string	percorso=extractfilepath(i_cartella);
	if (flagdebug)
		myprintf("20583: Percorso %s\n",percorso.c_str());
	if  (percorso=="")
	{
		if (flagdebug)
				myprintf("20587: percorso empty\n");
		return false;
	}
	makepath(percorso);
	string	testfile;
	testfile=percorso+"test$$$.txt.me";
	if (flagdebug)
		myprintf("20593: TEST FILE PRE  <<%s>>\n",testfile.c_str());
	testfile=nomefileseesistegia(testfile);
	if (flagdebug)
	myprintf("20595: TEST FILE POST <<%s>>\n",testfile.c_str());
	if (flagdebug)
		myprintf("20599: A1\n");
	FILE* testbyte=fopen(testfile.c_str(), "wb");
	if (testbyte!=NULL)
	{
		if (flagdebug)
			myprintf("20605\n");
		fprintf(testbyte,"this-file-can-be-deleted");
		if (flagdebug)
			myprintf("20608\n");
		fclose(testbyte);
	}
	if (flagdebug)
			myprintf("20611\n");
	bool risultato=fileexists(testfile.c_str());
	if (flagdebug)
			myprintf("20617\n");
	delete_file(testfile.c_str());
	if (flagdebug)
			myprintf("20620\n");
	return risultato;
}
int numberOfProcessors() {
  int rc=0;  
  size_t rclen=sizeof(rc);
  int mib[2]={CTL_HW, HW_NCPU};
  if (sysctl(mib, 2, &rc, &rclen, 0, 0)!=0)
    perror("sysctl");
  if (rc<1) rc=1; 
  if (sizeof(char*)==4 && rc>2) rc=2;
  return rc;
}
inline int tolowerW(int c) {
  return c;
}
bool ispath(const char* a, const char* b) {
  for (; *a; ++a, ++b) {
    const int ca=tolowerW(*a);
    const int cb=tolowerW(*b);
    if (ca=='*') {
      while (true) {
        if (ispath(a+1, b)) return true;
        if (!*b) return false;
        ++b;
      }
    }
    else if (ca=='?') {
      if (*b==0) return false;
    }
    else if (ca==cb && ca=='/' && a[1]==0)
      return true;
    else if (ca!=cb)
      return false;
  }
  return *b==0 || *b=='/';
}
unsigned btoi(const char* &s) {
  s+=4;
  return (s[-4]&255)|((s[-3]&255)<<8)|((s[-2]&255)<<16)|((s[-1]&255)<<24);
}
int64_t btol(const char* &s) {
  uint64_t r=btoi(s);
  return r+(uint64_t(btoi(s))<<32);
}
string append_path(string a, string b) {
  int na=a.size();
  int nb=b.size();
  if (nb>0 && b[0]=='/') b=b.substr(1);
  if (na>0 && a[na-1]=='/') a=a.substr(0, na-1);
  return a+"/"+b;
}
bool	iswildcards(const string& i_string)
{
	bool 	stars=strstr(i_string.c_str(), "*")!=0;			
	bool 	questionmark=strstr(i_string.c_str(), "?")!=0;
	return 	stars+questionmark;
}						
bool check_if_password(string i_filename)
{
	if (flagdebug)
		myprintf("21026: check_if_password of %s\n",i_filename.c_str());
	if (iswildcards(i_filename))
	{
		if (flagdebug)
			myprintf("21075: wildcard detected, no password check\n");
		return	false;
	}	
	if (!fileexists(i_filename))
		return false;
	FILE* inFile = freadopen(i_filename.c_str());
	if (inFile==NULL) 
	{
		int err=1;
		myprintf("\n19802: ERR <%s> kind %d\n",i_filename.c_str(),err); 
		seppuku();
	}
    char s[4]={0};
    const int nr=fread(s,1,4,inFile);
	fclose(inFile);
    if (nr>0 && memcmp(s, "7kSt", 4) && (memcmp(s, "zPQ", 3) || s[3]<1))
		return true;
	return false;
}
bool comparecrc32block(s_crc32block a, s_crc32block b)
{
	char a_start[40];
	char b_start[40];
	sprintf(a_start,"%014lld",(long long)a.crc32start);
	sprintf(b_start,"%014lld",(long long)b.crc32start);
	return a.filename+a_start<b.filename+b_start;
}
bool comparecrc32(s_fileandsize a, s_fileandsize b)
{
	return a.hashhex>b.hashhex;
}
bool comparesizehash(s_fileandsize a, s_fileandsize b)
{
	return (a.size < b.size) ||
           ((a.size == b.size) && (a.hashhex > b.hashhex)) || 
           ((a.size == b.size) && (a.hashhex == b.hashhex) &&
              (a.filename<b.filename));
}
bool comparefilenamesize(s_fileandsize a, s_fileandsize b)
{
	char a_size[40];
	char b_size[40];
	sprintf(a_size,"%014lld",(long long)a.size);
	sprintf(b_size,"%014lld",(long long)b.size);
	return a_size+a.filename<b_size+b.filename;
}
bool comparefilenamedate(s_fileandsize a, s_fileandsize b)
{
	char a_size[40];
	char b_size[40];
	sprintf(a_size,"%014lld",(long long)a.date);
	sprintf(b_size,"%014lld",(long long)b.date);
	return a_size+a.filename<b_size+b.filename;
}
bool sortbyval(const std::pair<string, string> &a, 
               const std::pair<string, string> &b) 
{ 
	if (a.second==b.second)
		return (a.first < b.first);
	return (a.second < b.second); 
} 
bool sortbysize(const std::pair<uint64_t, string> &a, 
               const std::pair<uint64_t, string> &b) 
{ 
    return (a.first < b.first); 
} 
int64_t myabs(int64_t i_first,int64_t i_second)
{
	if (i_first>i_second)
		return i_first-i_second;
	else
		return i_second-i_first;
}
struct xorshift128plus_key_s 
{
    uint64_t part1;
    uint64_t part2;
};
typedef struct xorshift128plus_key_s xorshift128plus_key_t;
static inline void xorshift128plus_init(uint64_t key1, uint64_t key2, xorshift128plus_key_t *key) 
{
  key->part1 = key1;
  key->part2 = key2;
}
uint64_t xorshift128plus(xorshift128plus_key_t * key) 
{
    uint64_t s1 = key->part1;
    const uint64_t s0 = key->part2;
    key->part1 = s0;
    s1 ^= s1 << 23; 
    key->part2 = s1 ^ s0 ^ (s1 >> 18) ^ (s0 >> 5); 
    return key->part2 + s0;
}
void populateRandom_xorshift128plus(uint32_t *answer, uint32_t size,uint64_t i_key1, uint64_t i_key2) 
{
	xorshift128plus_key_t mykey; 
	mykey.part1 = i_key1;
	mykey.part2 = i_key2;
  xorshift128plus_init(i_key1, i_key2, &mykey);
  uint32_t i = size;
  while (i > 2) {
    *(uint64_t *)(answer + size - i) = xorshift128plus(&mykey);
    i -= 2;
  }
  if (i != 0)
    answer[size - i] = (uint32_t)xorshift128plus(&mykey);
}
#define CRC32_USE_LOOKUP_TABLE_SLICING_BY_16
uint32_t crc32_combine (uint32_t crcA, uint32_t crcB, size_t lengthB);
uint32_t crc32_16bytes (const void* data, size_t length, uint32_t previousCrc32 = 0);
#ifndef __LITTLE_ENDIAN
  #define __LITTLE_ENDIAN 1234
#endif
#ifndef __BIG_ENDIAN
  #define __BIG_ENDIAN    4321
#endif
#if defined(_MSC_VER) || defined(__MINGW32__)
  #define __BYTE_ORDER __LITTLE_ENDIAN
  #include <xmmintrin.h>
  #ifdef __MINGW32__
    #define PREFETCH(location) __builtin_prefetch(location)
  #else
    #define PREFETCH(location) _mm_prefetch(location, _MM_HINT_T0)
  #endif
#else
  #include <sys/param.h>
  #ifdef __GNUC__
    #define PREFETCH(location) __builtin_prefetch(location)
  #else
    #define PREFETCH(location) ;
  #endif
#endif
#define __BYTE_ORDER __LITTLE_ENDIAN
namespace
{
  const uint32_t Polynomial = 0xEDB88320;
  static inline uint32_t swap(uint32_t x)
  {
#ifndef ESX
#if defined(__GNUC__) || defined(__clang__) && !defined(ESX)
    return __builtin_bswap32(x);
  #else
    return (x >> 24) |
          ((x >>  8) & 0x0000FF00) |
          ((x <<  8) & 0x00FF0000) |
           (x << 24);
  #endif
#else 
 return (x >> 24) |
          ((x >>  8) & 0x0000FF00) |
          ((x <<  8) & 0x00FF0000) |
           (x << 24);
#endif
  }
  const size_t MaxSlice = 16;
} 
extern const uint32_t Crc32Lookup[MaxSlice][256]; 
uint32_t crc32_16bytes(const void* data, size_t length, uint32_t previousCrc32)
{
  uint32_t crc = ~previousCrc32; 
  const uint32_t* current = (const uint32_t*) data;
  const size_t Unroll = 4;
  const size_t BytesAtOnce = 16 * Unroll;
  while (length >= BytesAtOnce)
  {
    for (size_t unrolling = 0; unrolling < Unroll; unrolling++)
    {
#if __BYTE_ORDER == __BIG_ENDIAN
    uint32_t one   = *current++ ^ swap(crc);
    uint32_t two   = *current++;
    uint32_t three = *current++;
    uint32_t four  = *current++;
    crc  = Crc32Lookup[ 0][ four         & 0xFF] ^
           Crc32Lookup[ 1][(four  >>  8) & 0xFF] ^
           Crc32Lookup[ 2][(four  >> 16) & 0xFF] ^
           Crc32Lookup[ 3][(four  >> 24) & 0xFF] ^
           Crc32Lookup[ 4][ three        & 0xFF] ^
           Crc32Lookup[ 5][(three >>  8) & 0xFF] ^
           Crc32Lookup[ 6][(three >> 16) & 0xFF] ^
           Crc32Lookup[ 7][(three >> 24) & 0xFF] ^
           Crc32Lookup[ 8][ two          & 0xFF] ^
           Crc32Lookup[ 9][(two   >>  8) & 0xFF] ^
           Crc32Lookup[10][(two   >> 16) & 0xFF] ^
           Crc32Lookup[11][(two   >> 24) & 0xFF] ^
           Crc32Lookup[12][ one          & 0xFF] ^
           Crc32Lookup[13][(one   >>  8) & 0xFF] ^
           Crc32Lookup[14][(one   >> 16) & 0xFF] ^
           Crc32Lookup[15][(one   >> 24) & 0xFF];
#else
    uint32_t one   = *current++ ^ crc;
    uint32_t two   = *current++;
    uint32_t three = *current++;
    uint32_t four  = *current++;
    crc  = Crc32Lookup[ 0][(four  >> 24) & 0xFF] ^
           Crc32Lookup[ 1][(four  >> 16) & 0xFF] ^
           Crc32Lookup[ 2][(four  >>  8) & 0xFF] ^
           Crc32Lookup[ 3][ four         & 0xFF] ^
           Crc32Lookup[ 4][(three >> 24) & 0xFF] ^
           Crc32Lookup[ 5][(three >> 16) & 0xFF] ^
           Crc32Lookup[ 6][(three >>  8) & 0xFF] ^
           Crc32Lookup[ 7][ three        & 0xFF] ^
           Crc32Lookup[ 8][(two   >> 24) & 0xFF] ^
           Crc32Lookup[ 9][(two   >> 16) & 0xFF] ^
           Crc32Lookup[10][(two   >>  8) & 0xFF] ^
           Crc32Lookup[11][ two          & 0xFF] ^
           Crc32Lookup[12][(one   >> 24) & 0xFF] ^
           Crc32Lookup[13][(one   >> 16) & 0xFF] ^
           Crc32Lookup[14][(one   >>  8) & 0xFF] ^
           Crc32Lookup[15][ one          & 0xFF];
#endif
    }
    length -= BytesAtOnce;
  }
  const uint8_t* currentChar = (const uint8_t*) current;
  while (length-- != 0)
    crc = (crc >> 8) ^ Crc32Lookup[0][(crc & 0xFF) ^ *currentChar++];
  return ~crc; 
}
uint32_t crc32_combine(uint32_t crcA, uint32_t crcB, size_t lengthB)
{
  if (lengthB == 0)
    return crcA;
  const uint32_t CrcBits = 32;
  uint32_t odd [CrcBits]; 
  uint32_t even[CrcBits]; 
  odd[0] = Polynomial;    
  for (unsigned int i = 1; i < CrcBits; i++)
    odd[i] = 1 << (i - 1);
  for (unsigned int i = 0; i < CrcBits; i++)
  {
    uint32_t vec = odd[i];
    even[i] = 0;
    for (int j = 0; vec != 0; j++, vec >>= 1)
      if (vec & 1)
        even[i] ^= odd[j];
  }
  for (unsigned int i = 0; i < CrcBits; i++)
  {
    uint32_t vec = even[i];
    odd[i] = 0;
    for (int j = 0; vec != 0; j++, vec >>= 1)
      if (vec & 1)
        odd[i] ^= even[j];
  }
  uint32_t* a = even;
  uint32_t* b = odd;
  for (; lengthB > 0; lengthB >>= 1)
  {
    for (unsigned int i = 0; i < CrcBits; i++)
    {
      uint32_t vec = b[i];
      a[i] = 0;
      for (int j = 0; vec != 0; j++, vec >>= 1)
        if (vec & 1)
          a[i] ^= b[j];
    }
    if (lengthB & 1)
    {
      uint32_t sum = 0;
      for (int i = 0; crcA != 0; i++, crcA >>= 1)
        if (crcA & 1)
          sum ^= a[i];
      crcA = sum;
    }
    uint32_t* t = a; a = b; b = t;
  }
  return crcA ^ crcB;
}
#ifndef NO_LUT
const uint32_t Crc32Lookup[MaxSlice][256] =
{
  {
    0x00000000,0x77073096,0xEE0E612C,0x990951BA,0x076DC419,0x706AF48F,0xE963A535,0x9E6495A3,
    0x0EDB8832,0x79DCB8A4,0xE0D5E91E,0x97D2D988,0x09B64C2B,0x7EB17CBD,0xE7B82D07,0x90BF1D91,
    0x1DB71064,0x6AB020F2,0xF3B97148,0x84BE41DE,0x1ADAD47D,0x6DDDE4EB,0xF4D4B551,0x83D385C7,
    0x136C9856,0x646BA8C0,0xFD62F97A,0x8A65C9EC,0x14015C4F,0x63066CD9,0xFA0F3D63,0x8D080DF5,
    0x3B6E20C8,0x4C69105E,0xD56041E4,0xA2677172,0x3C03E4D1,0x4B04D447,0xD20D85FD,0xA50AB56B,
    0x35B5A8FA,0x42B2986C,0xDBBBC9D6,0xACBCF940,0x32D86CE3,0x45DF5C75,0xDCD60DCF,0xABD13D59,
    0x26D930AC,0x51DE003A,0xC8D75180,0xBFD06116,0x21B4F4B5,0x56B3C423,0xCFBA9599,0xB8BDA50F,
    0x2802B89E,0x5F058808,0xC60CD9B2,0xB10BE924,0x2F6F7C87,0x58684C11,0xC1611DAB,0xB6662D3D,
    0x76DC4190,0x01DB7106,0x98D220BC,0xEFD5102A,0x71B18589,0x06B6B51F,0x9FBFE4A5,0xE8B8D433,
    0x7807C9A2,0x0F00F934,0x9609A88E,0xE10E9818,0x7F6A0DBB,0x086D3D2D,0x91646C97,0xE6635C01,
    0x6B6B51F4,0x1C6C6162,0x856530D8,0xF262004E,0x6C0695ED,0x1B01A57B,0x8208F4C1,0xF50FC457,
    0x65B0D9C6,0x12B7E950,0x8BBEB8EA,0xFCB9887C,0x62DD1DDF,0x15DA2D49,0x8CD37CF3,0xFBD44C65,
    0x4DB26158,0x3AB551CE,0xA3BC0074,0xD4BB30E2,0x4ADFA541,0x3DD895D7,0xA4D1C46D,0xD3D6F4FB,
    0x4369E96A,0x346ED9FC,0xAD678846,0xDA60B8D0,0x44042D73,0x33031DE5,0xAA0A4C5F,0xDD0D7CC9,
    0x5005713C,0x270241AA,0xBE0B1010,0xC90C2086,0x5768B525,0x206F85B3,0xB966D409,0xCE61E49F,
    0x5EDEF90E,0x29D9C998,0xB0D09822,0xC7D7A8B4,0x59B33D17,0x2EB40D81,0xB7BD5C3B,0xC0BA6CAD,
    0xEDB88320,0x9ABFB3B6,0x03B6E20C,0x74B1D29A,0xEAD54739,0x9DD277AF,0x04DB2615,0x73DC1683,
    0xE3630B12,0x94643B84,0x0D6D6A3E,0x7A6A5AA8,0xE40ECF0B,0x9309FF9D,0x0A00AE27,0x7D079EB1,
    0xF00F9344,0x8708A3D2,0x1E01F268,0x6906C2FE,0xF762575D,0x806567CB,0x196C3671,0x6E6B06E7,
    0xFED41B76,0x89D32BE0,0x10DA7A5A,0x67DD4ACC,0xF9B9DF6F,0x8EBEEFF9,0x17B7BE43,0x60B08ED5,
    0xD6D6A3E8,0xA1D1937E,0x38D8C2C4,0x4FDFF252,0xD1BB67F1,0xA6BC5767,0x3FB506DD,0x48B2364B,
    0xD80D2BDA,0xAF0A1B4C,0x36034AF6,0x41047A60,0xDF60EFC3,0xA867DF55,0x316E8EEF,0x4669BE79,
    0xCB61B38C,0xBC66831A,0x256FD2A0,0x5268E236,0xCC0C7795,0xBB0B4703,0x220216B9,0x5505262F,
    0xC5BA3BBE,0xB2BD0B28,0x2BB45A92,0x5CB36A04,0xC2D7FFA7,0xB5D0CF31,0x2CD99E8B,0x5BDEAE1D,
    0x9B64C2B0,0xEC63F226,0x756AA39C,0x026D930A,0x9C0906A9,0xEB0E363F,0x72076785,0x05005713,
    0x95BF4A82,0xE2B87A14,0x7BB12BAE,0x0CB61B38,0x92D28E9B,0xE5D5BE0D,0x7CDCEFB7,0x0BDBDF21,
    0x86D3D2D4,0xF1D4E242,0x68DDB3F8,0x1FDA836E,0x81BE16CD,0xF6B9265B,0x6FB077E1,0x18B74777,
    0x88085AE6,0xFF0F6A70,0x66063BCA,0x11010B5C,0x8F659EFF,0xF862AE69,0x616BFFD3,0x166CCF45,
    0xA00AE278,0xD70DD2EE,0x4E048354,0x3903B3C2,0xA7672661,0xD06016F7,0x4969474D,0x3E6E77DB,
    0xAED16A4A,0xD9D65ADC,0x40DF0B66,0x37D83BF0,0xA9BCAE53,0xDEBB9EC5,0x47B2CF7F,0x30B5FFE9,
    0xBDBDF21C,0xCABAC28A,0x53B39330,0x24B4A3A6,0xBAD03605,0xCDD70693,0x54DE5729,0x23D967BF,
    0xB3667A2E,0xC4614AB8,0x5D681B02,0x2A6F2B94,0xB40BBE37,0xC30C8EA1,0x5A05DF1B,0x2D02EF8D,
  }
#if defined(CRC32_USE_LOOKUP_TABLE_SLICING_BY_4) || defined(CRC32_USE_LOOKUP_TABLE_SLICING_BY_8) || defined(CRC32_USE_LOOKUP_TABLE_SLICING_BY_16)
  ,{
    0x00000000,0x191B3141,0x32366282,0x2B2D53C3,0x646CC504,0x7D77F445,0x565AA786,0x4F4196C7,
    0xC8D98A08,0xD1C2BB49,0xFAEFE88A,0xE3F4D9CB,0xACB54F0C,0xB5AE7E4D,0x9E832D8E,0x87981CCF,
    0x4AC21251,0x53D92310,0x78F470D3,0x61EF4192,0x2EAED755,0x37B5E614,0x1C98B5D7,0x05838496,
    0x821B9859,0x9B00A918,0xB02DFADB,0xA936CB9A,0xE6775D5D,0xFF6C6C1C,0xD4413FDF,0xCD5A0E9E,
    0x958424A2,0x8C9F15E3,0xA7B24620,0xBEA97761,0xF1E8E1A6,0xE8F3D0E7,0xC3DE8324,0xDAC5B265,
    0x5D5DAEAA,0x44469FEB,0x6F6BCC28,0x7670FD69,0x39316BAE,0x202A5AEF,0x0B07092C,0x121C386D,
    0xDF4636F3,0xC65D07B2,0xED705471,0xF46B6530,0xBB2AF3F7,0xA231C2B6,0x891C9175,0x9007A034,
    0x179FBCFB,0x0E848DBA,0x25A9DE79,0x3CB2EF38,0x73F379FF,0x6AE848BE,0x41C51B7D,0x58DE2A3C,
    0xF0794F05,0xE9627E44,0xC24F2D87,0xDB541CC6,0x94158A01,0x8D0EBB40,0xA623E883,0xBF38D9C2,
    0x38A0C50D,0x21BBF44C,0x0A96A78F,0x138D96CE,0x5CCC0009,0x45D73148,0x6EFA628B,0x77E153CA,
    0xBABB5D54,0xA3A06C15,0x888D3FD6,0x91960E97,0xDED79850,0xC7CCA911,0xECE1FAD2,0xF5FACB93,
    0x7262D75C,0x6B79E61D,0x4054B5DE,0x594F849F,0x160E1258,0x0F152319,0x243870DA,0x3D23419B,
    0x65FD6BA7,0x7CE65AE6,0x57CB0925,0x4ED03864,0x0191AEA3,0x188A9FE2,0x33A7CC21,0x2ABCFD60,
    0xAD24E1AF,0xB43FD0EE,0x9F12832D,0x8609B26C,0xC94824AB,0xD05315EA,0xFB7E4629,0xE2657768,
    0x2F3F79F6,0x362448B7,0x1D091B74,0x04122A35,0x4B53BCF2,0x52488DB3,0x7965DE70,0x607EEF31,
    0xE7E6F3FE,0xFEFDC2BF,0xD5D0917C,0xCCCBA03D,0x838A36FA,0x9A9107BB,0xB1BC5478,0xA8A76539,
    0x3B83984B,0x2298A90A,0x09B5FAC9,0x10AECB88,0x5FEF5D4F,0x46F46C0E,0x6DD93FCD,0x74C20E8C,
    0xF35A1243,0xEA412302,0xC16C70C1,0xD8774180,0x9736D747,0x8E2DE606,0xA500B5C5,0xBC1B8484,
    0x71418A1A,0x685ABB5B,0x4377E898,0x5A6CD9D9,0x152D4F1E,0x0C367E5F,0x271B2D9C,0x3E001CDD,
    0xB9980012,0xA0833153,0x8BAE6290,0x92B553D1,0xDDF4C516,0xC4EFF457,0xEFC2A794,0xF6D996D5,
    0xAE07BCE9,0xB71C8DA8,0x9C31DE6B,0x852AEF2A,0xCA6B79ED,0xD37048AC,0xF85D1B6F,0xE1462A2E,
    0x66DE36E1,0x7FC507A0,0x54E85463,0x4DF36522,0x02B2F3E5,0x1BA9C2A4,0x30849167,0x299FA026,
    0xE4C5AEB8,0xFDDE9FF9,0xD6F3CC3A,0xCFE8FD7B,0x80A96BBC,0x99B25AFD,0xB29F093E,0xAB84387F,
    0x2C1C24B0,0x350715F1,0x1E2A4632,0x07317773,0x4870E1B4,0x516BD0F5,0x7A468336,0x635DB277,
    0xCBFAD74E,0xD2E1E60F,0xF9CCB5CC,0xE0D7848D,0xAF96124A,0xB68D230B,0x9DA070C8,0x84BB4189,
    0x03235D46,0x1A386C07,0x31153FC4,0x280E0E85,0x674F9842,0x7E54A903,0x5579FAC0,0x4C62CB81,
    0x8138C51F,0x9823F45E,0xB30EA79D,0xAA1596DC,0xE554001B,0xFC4F315A,0xD7626299,0xCE7953D8,
    0x49E14F17,0x50FA7E56,0x7BD72D95,0x62CC1CD4,0x2D8D8A13,0x3496BB52,0x1FBBE891,0x06A0D9D0,
    0x5E7EF3EC,0x4765C2AD,0x6C48916E,0x7553A02F,0x3A1236E8,0x230907A9,0x0824546A,0x113F652B,
    0x96A779E4,0x8FBC48A5,0xA4911B66,0xBD8A2A27,0xF2CBBCE0,0xEBD08DA1,0xC0FDDE62,0xD9E6EF23,
    0x14BCE1BD,0x0DA7D0FC,0x268A833F,0x3F91B27E,0x70D024B9,0x69CB15F8,0x42E6463B,0x5BFD777A,
    0xDC656BB5,0xC57E5AF4,0xEE530937,0xF7483876,0xB809AEB1,0xA1129FF0,0x8A3FCC33,0x9324FD72,
  },
  {
    0x00000000,0x01C26A37,0x0384D46E,0x0246BE59,0x0709A8DC,0x06CBC2EB,0x048D7CB2,0x054F1685,
    0x0E1351B8,0x0FD13B8F,0x0D9785D6,0x0C55EFE1,0x091AF964,0x08D89353,0x0A9E2D0A,0x0B5C473D,
    0x1C26A370,0x1DE4C947,0x1FA2771E,0x1E601D29,0x1B2F0BAC,0x1AED619B,0x18ABDFC2,0x1969B5F5,
    0x1235F2C8,0x13F798FF,0x11B126A6,0x10734C91,0x153C5A14,0x14FE3023,0x16B88E7A,0x177AE44D,
    0x384D46E0,0x398F2CD7,0x3BC9928E,0x3A0BF8B9,0x3F44EE3C,0x3E86840B,0x3CC03A52,0x3D025065,
    0x365E1758,0x379C7D6F,0x35DAC336,0x3418A901,0x3157BF84,0x3095D5B3,0x32D36BEA,0x331101DD,
    0x246BE590,0x25A98FA7,0x27EF31FE,0x262D5BC9,0x23624D4C,0x22A0277B,0x20E69922,0x2124F315,
    0x2A78B428,0x2BBADE1F,0x29FC6046,0x283E0A71,0x2D711CF4,0x2CB376C3,0x2EF5C89A,0x2F37A2AD,
    0x709A8DC0,0x7158E7F7,0x731E59AE,0x72DC3399,0x7793251C,0x76514F2B,0x7417F172,0x75D59B45,
    0x7E89DC78,0x7F4BB64F,0x7D0D0816,0x7CCF6221,0x798074A4,0x78421E93,0x7A04A0CA,0x7BC6CAFD,
    0x6CBC2EB0,0x6D7E4487,0x6F38FADE,0x6EFA90E9,0x6BB5866C,0x6A77EC5B,0x68315202,0x69F33835,
    0x62AF7F08,0x636D153F,0x612BAB66,0x60E9C151,0x65A6D7D4,0x6464BDE3,0x662203BA,0x67E0698D,
    0x48D7CB20,0x4915A117,0x4B531F4E,0x4A917579,0x4FDE63FC,0x4E1C09CB,0x4C5AB792,0x4D98DDA5,
    0x46C49A98,0x4706F0AF,0x45404EF6,0x448224C1,0x41CD3244,0x400F5873,0x4249E62A,0x438B8C1D,
    0x54F16850,0x55330267,0x5775BC3E,0x56B7D609,0x53F8C08C,0x523AAABB,0x507C14E2,0x51BE7ED5,
    0x5AE239E8,0x5B2053DF,0x5966ED86,0x58A487B1,0x5DEB9134,0x5C29FB03,0x5E6F455A,0x5FAD2F6D,
    0xE1351B80,0xE0F771B7,0xE2B1CFEE,0xE373A5D9,0xE63CB35C,0xE7FED96B,0xE5B86732,0xE47A0D05,
    0xEF264A38,0xEEE4200F,0xECA29E56,0xED60F461,0xE82FE2E4,0xE9ED88D3,0xEBAB368A,0xEA695CBD,
    0xFD13B8F0,0xFCD1D2C7,0xFE976C9E,0xFF5506A9,0xFA1A102C,0xFBD87A1B,0xF99EC442,0xF85CAE75,
    0xF300E948,0xF2C2837F,0xF0843D26,0xF1465711,0xF4094194,0xF5CB2BA3,0xF78D95FA,0xF64FFFCD,
    0xD9785D60,0xD8BA3757,0xDAFC890E,0xDB3EE339,0xDE71F5BC,0xDFB39F8B,0xDDF521D2,0xDC374BE5,
    0xD76B0CD8,0xD6A966EF,0xD4EFD8B6,0xD52DB281,0xD062A404,0xD1A0CE33,0xD3E6706A,0xD2241A5D,
    0xC55EFE10,0xC49C9427,0xC6DA2A7E,0xC7184049,0xC25756CC,0xC3953CFB,0xC1D382A2,0xC011E895,
    0xCB4DAFA8,0xCA8FC59F,0xC8C97BC6,0xC90B11F1,0xCC440774,0xCD866D43,0xCFC0D31A,0xCE02B92D,
    0x91AF9640,0x906DFC77,0x922B422E,0x93E92819,0x96A63E9C,0x976454AB,0x9522EAF2,0x94E080C5,
    0x9FBCC7F8,0x9E7EADCF,0x9C381396,0x9DFA79A1,0x98B56F24,0x99770513,0x9B31BB4A,0x9AF3D17D,
    0x8D893530,0x8C4B5F07,0x8E0DE15E,0x8FCF8B69,0x8A809DEC,0x8B42F7DB,0x89044982,0x88C623B5,
    0x839A6488,0x82580EBF,0x801EB0E6,0x81DCDAD1,0x8493CC54,0x8551A663,0x8717183A,0x86D5720D,
    0xA9E2D0A0,0xA820BA97,0xAA6604CE,0xABA46EF9,0xAEEB787C,0xAF29124B,0xAD6FAC12,0xACADC625,
    0xA7F18118,0xA633EB2F,0xA4755576,0xA5B73F41,0xA0F829C4,0xA13A43F3,0xA37CFDAA,0xA2BE979D,
    0xB5C473D0,0xB40619E7,0xB640A7BE,0xB782CD89,0xB2CDDB0C,0xB30FB13B,0xB1490F62,0xB08B6555,
    0xBBD72268,0xBA15485F,0xB853F606,0xB9919C31,0xBCDE8AB4,0xBD1CE083,0xBF5A5EDA,0xBE9834ED,
  },
  {
    0x00000000,0xB8BC6765,0xAA09C88B,0x12B5AFEE,0x8F629757,0x37DEF032,0x256B5FDC,0x9DD738B9,
    0xC5B428EF,0x7D084F8A,0x6FBDE064,0xD7018701,0x4AD6BFB8,0xF26AD8DD,0xE0DF7733,0x58631056,
    0x5019579F,0xE8A530FA,0xFA109F14,0x42ACF871,0xDF7BC0C8,0x67C7A7AD,0x75720843,0xCDCE6F26,
    0x95AD7F70,0x2D111815,0x3FA4B7FB,0x8718D09E,0x1ACFE827,0xA2738F42,0xB0C620AC,0x087A47C9,
    0xA032AF3E,0x188EC85B,0x0A3B67B5,0xB28700D0,0x2F503869,0x97EC5F0C,0x8559F0E2,0x3DE59787,
    0x658687D1,0xDD3AE0B4,0xCF8F4F5A,0x7733283F,0xEAE41086,0x525877E3,0x40EDD80D,0xF851BF68,
    0xF02BF8A1,0x48979FC4,0x5A22302A,0xE29E574F,0x7F496FF6,0xC7F50893,0xD540A77D,0x6DFCC018,
    0x359FD04E,0x8D23B72B,0x9F9618C5,0x272A7FA0,0xBAFD4719,0x0241207C,0x10F48F92,0xA848E8F7,
    0x9B14583D,0x23A83F58,0x311D90B6,0x89A1F7D3,0x1476CF6A,0xACCAA80F,0xBE7F07E1,0x06C36084,
    0x5EA070D2,0xE61C17B7,0xF4A9B859,0x4C15DF3C,0xD1C2E785,0x697E80E0,0x7BCB2F0E,0xC377486B,
    0xCB0D0FA2,0x73B168C7,0x6104C729,0xD9B8A04C,0x446F98F5,0xFCD3FF90,0xEE66507E,0x56DA371B,
    0x0EB9274D,0xB6054028,0xA4B0EFC6,0x1C0C88A3,0x81DBB01A,0x3967D77F,0x2BD27891,0x936E1FF4,
    0x3B26F703,0x839A9066,0x912F3F88,0x299358ED,0xB4446054,0x0CF80731,0x1E4DA8DF,0xA6F1CFBA,
    0xFE92DFEC,0x462EB889,0x549B1767,0xEC277002,0x71F048BB,0xC94C2FDE,0xDBF98030,0x6345E755,
    0x6B3FA09C,0xD383C7F9,0xC1366817,0x798A0F72,0xE45D37CB,0x5CE150AE,0x4E54FF40,0xF6E89825,
    0xAE8B8873,0x1637EF16,0x048240F8,0xBC3E279D,0x21E91F24,0x99557841,0x8BE0D7AF,0x335CB0CA,
    0xED59B63B,0x55E5D15E,0x47507EB0,0xFFEC19D5,0x623B216C,0xDA874609,0xC832E9E7,0x708E8E82,
    0x28ED9ED4,0x9051F9B1,0x82E4565F,0x3A58313A,0xA78F0983,0x1F336EE6,0x0D86C108,0xB53AA66D,
    0xBD40E1A4,0x05FC86C1,0x1749292F,0xAFF54E4A,0x322276F3,0x8A9E1196,0x982BBE78,0x2097D91D,
    0x78F4C94B,0xC048AE2E,0xD2FD01C0,0x6A4166A5,0xF7965E1C,0x4F2A3979,0x5D9F9697,0xE523F1F2,
    0x4D6B1905,0xF5D77E60,0xE762D18E,0x5FDEB6EB,0xC2098E52,0x7AB5E937,0x680046D9,0xD0BC21BC,
    0x88DF31EA,0x3063568F,0x22D6F961,0x9A6A9E04,0x07BDA6BD,0xBF01C1D8,0xADB46E36,0x15080953,
    0x1D724E9A,0xA5CE29FF,0xB77B8611,0x0FC7E174,0x9210D9CD,0x2AACBEA8,0x38191146,0x80A57623,
    0xD8C66675,0x607A0110,0x72CFAEFE,0xCA73C99B,0x57A4F122,0xEF189647,0xFDAD39A9,0x45115ECC,
    0x764DEE06,0xCEF18963,0xDC44268D,0x64F841E8,0xF92F7951,0x41931E34,0x5326B1DA,0xEB9AD6BF,
    0xB3F9C6E9,0x0B45A18C,0x19F00E62,0xA14C6907,0x3C9B51BE,0x842736DB,0x96929935,0x2E2EFE50,
    0x2654B999,0x9EE8DEFC,0x8C5D7112,0x34E11677,0xA9362ECE,0x118A49AB,0x033FE645,0xBB838120,
    0xE3E09176,0x5B5CF613,0x49E959FD,0xF1553E98,0x6C820621,0xD43E6144,0xC68BCEAA,0x7E37A9CF,
    0xD67F4138,0x6EC3265D,0x7C7689B3,0xC4CAEED6,0x591DD66F,0xE1A1B10A,0xF3141EE4,0x4BA87981,
    0x13CB69D7,0xAB770EB2,0xB9C2A15C,0x017EC639,0x9CA9FE80,0x241599E5,0x36A0360B,0x8E1C516E,
    0x866616A7,0x3EDA71C2,0x2C6FDE2C,0x94D3B949,0x090481F0,0xB1B8E695,0xA30D497B,0x1BB12E1E,
    0x43D23E48,0xFB6E592D,0xE9DBF6C3,0x516791A6,0xCCB0A91F,0x740CCE7A,0x66B96194,0xDE0506F1,
  }
#endif 
#if defined (CRC32_USE_LOOKUP_TABLE_SLICING_BY_8) || defined(CRC32_USE_LOOKUP_TABLE_SLICING_BY_16)
  ,{
    0x00000000,0x3D6029B0,0x7AC05360,0x47A07AD0,0xF580A6C0,0xC8E08F70,0x8F40F5A0,0xB220DC10,
    0x30704BC1,0x0D106271,0x4AB018A1,0x77D03111,0xC5F0ED01,0xF890C4B1,0xBF30BE61,0x825097D1,
    0x60E09782,0x5D80BE32,0x1A20C4E2,0x2740ED52,0x95603142,0xA80018F2,0xEFA06222,0xD2C04B92,
    0x5090DC43,0x6DF0F5F3,0x2A508F23,0x1730A693,0xA5107A83,0x98705333,0xDFD029E3,0xE2B00053,
    0xC1C12F04,0xFCA106B4,0xBB017C64,0x866155D4,0x344189C4,0x0921A074,0x4E81DAA4,0x73E1F314,
    0xF1B164C5,0xCCD14D75,0x8B7137A5,0xB6111E15,0x0431C205,0x3951EBB5,0x7EF19165,0x4391B8D5,
    0xA121B886,0x9C419136,0xDBE1EBE6,0xE681C256,0x54A11E46,0x69C137F6,0x2E614D26,0x13016496,
    0x9151F347,0xAC31DAF7,0xEB91A027,0xD6F18997,0x64D15587,0x59B17C37,0x1E1106E7,0x23712F57,
    0x58F35849,0x659371F9,0x22330B29,0x1F532299,0xAD73FE89,0x9013D739,0xD7B3ADE9,0xEAD38459,
    0x68831388,0x55E33A38,0x124340E8,0x2F236958,0x9D03B548,0xA0639CF8,0xE7C3E628,0xDAA3CF98,
    0x3813CFCB,0x0573E67B,0x42D39CAB,0x7FB3B51B,0xCD93690B,0xF0F340BB,0xB7533A6B,0x8A3313DB,
    0x0863840A,0x3503ADBA,0x72A3D76A,0x4FC3FEDA,0xFDE322CA,0xC0830B7A,0x872371AA,0xBA43581A,
    0x9932774D,0xA4525EFD,0xE3F2242D,0xDE920D9D,0x6CB2D18D,0x51D2F83D,0x167282ED,0x2B12AB5D,
    0xA9423C8C,0x9422153C,0xD3826FEC,0xEEE2465C,0x5CC29A4C,0x61A2B3FC,0x2602C92C,0x1B62E09C,
    0xF9D2E0CF,0xC4B2C97F,0x8312B3AF,0xBE729A1F,0x0C52460F,0x31326FBF,0x7692156F,0x4BF23CDF,
    0xC9A2AB0E,0xF4C282BE,0xB362F86E,0x8E02D1DE,0x3C220DCE,0x0142247E,0x46E25EAE,0x7B82771E,
    0xB1E6B092,0x8C869922,0xCB26E3F2,0xF646CA42,0x44661652,0x79063FE2,0x3EA64532,0x03C66C82,
    0x8196FB53,0xBCF6D2E3,0xFB56A833,0xC6368183,0x74165D93,0x49767423,0x0ED60EF3,0x33B62743,
    0xD1062710,0xEC660EA0,0xABC67470,0x96A65DC0,0x248681D0,0x19E6A860,0x5E46D2B0,0x6326FB00,
    0xE1766CD1,0xDC164561,0x9BB63FB1,0xA6D61601,0x14F6CA11,0x2996E3A1,0x6E369971,0x5356B0C1,
    0x70279F96,0x4D47B626,0x0AE7CCF6,0x3787E546,0x85A73956,0xB8C710E6,0xFF676A36,0xC2074386,
    0x4057D457,0x7D37FDE7,0x3A978737,0x07F7AE87,0xB5D77297,0x88B75B27,0xCF1721F7,0xF2770847,
    0x10C70814,0x2DA721A4,0x6A075B74,0x576772C4,0xE547AED4,0xD8278764,0x9F87FDB4,0xA2E7D404,
    0x20B743D5,0x1DD76A65,0x5A7710B5,0x67173905,0xD537E515,0xE857CCA5,0xAFF7B675,0x92979FC5,
    0xE915E8DB,0xD475C16B,0x93D5BBBB,0xAEB5920B,0x1C954E1B,0x21F567AB,0x66551D7B,0x5B3534CB,
    0xD965A31A,0xE4058AAA,0xA3A5F07A,0x9EC5D9CA,0x2CE505DA,0x11852C6A,0x562556BA,0x6B457F0A,
    0x89F57F59,0xB49556E9,0xF3352C39,0xCE550589,0x7C75D999,0x4115F029,0x06B58AF9,0x3BD5A349,
    0xB9853498,0x84E51D28,0xC34567F8,0xFE254E48,0x4C059258,0x7165BBE8,0x36C5C138,0x0BA5E888,
    0x28D4C7DF,0x15B4EE6F,0x521494BF,0x6F74BD0F,0xDD54611F,0xE03448AF,0xA794327F,0x9AF41BCF,
    0x18A48C1E,0x25C4A5AE,0x6264DF7E,0x5F04F6CE,0xED242ADE,0xD044036E,0x97E479BE,0xAA84500E,
    0x4834505D,0x755479ED,0x32F4033D,0x0F942A8D,0xBDB4F69D,0x80D4DF2D,0xC774A5FD,0xFA148C4D,
    0x78441B9C,0x4524322C,0x028448FC,0x3FE4614C,0x8DC4BD5C,0xB0A494EC,0xF704EE3C,0xCA64C78C,
  },
  {
    0x00000000,0xCB5CD3A5,0x4DC8A10B,0x869472AE,0x9B914216,0x50CD91B3,0xD659E31D,0x1D0530B8,
    0xEC53826D,0x270F51C8,0xA19B2366,0x6AC7F0C3,0x77C2C07B,0xBC9E13DE,0x3A0A6170,0xF156B2D5,
    0x03D6029B,0xC88AD13E,0x4E1EA390,0x85427035,0x9847408D,0x531B9328,0xD58FE186,0x1ED33223,
    0xEF8580F6,0x24D95353,0xA24D21FD,0x6911F258,0x7414C2E0,0xBF481145,0x39DC63EB,0xF280B04E,
    0x07AC0536,0xCCF0D693,0x4A64A43D,0x81387798,0x9C3D4720,0x57619485,0xD1F5E62B,0x1AA9358E,
    0xEBFF875B,0x20A354FE,0xA6372650,0x6D6BF5F5,0x706EC54D,0xBB3216E8,0x3DA66446,0xF6FAB7E3,
    0x047A07AD,0xCF26D408,0x49B2A6A6,0x82EE7503,0x9FEB45BB,0x54B7961E,0xD223E4B0,0x197F3715,
    0xE82985C0,0x23755665,0xA5E124CB,0x6EBDF76E,0x73B8C7D6,0xB8E41473,0x3E7066DD,0xF52CB578,
    0x0F580A6C,0xC404D9C9,0x4290AB67,0x89CC78C2,0x94C9487A,0x5F959BDF,0xD901E971,0x125D3AD4,
    0xE30B8801,0x28575BA4,0xAEC3290A,0x659FFAAF,0x789ACA17,0xB3C619B2,0x35526B1C,0xFE0EB8B9,
    0x0C8E08F7,0xC7D2DB52,0x4146A9FC,0x8A1A7A59,0x971F4AE1,0x5C439944,0xDAD7EBEA,0x118B384F,
    0xE0DD8A9A,0x2B81593F,0xAD152B91,0x6649F834,0x7B4CC88C,0xB0101B29,0x36846987,0xFDD8BA22,
    0x08F40F5A,0xC3A8DCFF,0x453CAE51,0x8E607DF4,0x93654D4C,0x58399EE9,0xDEADEC47,0x15F13FE2,
    0xE4A78D37,0x2FFB5E92,0xA96F2C3C,0x6233FF99,0x7F36CF21,0xB46A1C84,0x32FE6E2A,0xF9A2BD8F,
    0x0B220DC1,0xC07EDE64,0x46EAACCA,0x8DB67F6F,0x90B34FD7,0x5BEF9C72,0xDD7BEEDC,0x16273D79,
    0xE7718FAC,0x2C2D5C09,0xAAB92EA7,0x61E5FD02,0x7CE0CDBA,0xB7BC1E1F,0x31286CB1,0xFA74BF14,
    0x1EB014D8,0xD5ECC77D,0x5378B5D3,0x98246676,0x852156CE,0x4E7D856B,0xC8E9F7C5,0x03B52460,
    0xF2E396B5,0x39BF4510,0xBF2B37BE,0x7477E41B,0x6972D4A3,0xA22E0706,0x24BA75A8,0xEFE6A60D,
    0x1D661643,0xD63AC5E6,0x50AEB748,0x9BF264ED,0x86F75455,0x4DAB87F0,0xCB3FF55E,0x006326FB,
    0xF135942E,0x3A69478B,0xBCFD3525,0x77A1E680,0x6AA4D638,0xA1F8059D,0x276C7733,0xEC30A496,
    0x191C11EE,0xD240C24B,0x54D4B0E5,0x9F886340,0x828D53F8,0x49D1805D,0xCF45F2F3,0x04192156,
    0xF54F9383,0x3E134026,0xB8873288,0x73DBE12D,0x6EDED195,0xA5820230,0x2316709E,0xE84AA33B,
    0x1ACA1375,0xD196C0D0,0x5702B27E,0x9C5E61DB,0x815B5163,0x4A0782C6,0xCC93F068,0x07CF23CD,
    0xF6999118,0x3DC542BD,0xBB513013,0x700DE3B6,0x6D08D30E,0xA65400AB,0x20C07205,0xEB9CA1A0,
    0x11E81EB4,0xDAB4CD11,0x5C20BFBF,0x977C6C1A,0x8A795CA2,0x41258F07,0xC7B1FDA9,0x0CED2E0C,
    0xFDBB9CD9,0x36E74F7C,0xB0733DD2,0x7B2FEE77,0x662ADECF,0xAD760D6A,0x2BE27FC4,0xE0BEAC61,
    0x123E1C2F,0xD962CF8A,0x5FF6BD24,0x94AA6E81,0x89AF5E39,0x42F38D9C,0xC467FF32,0x0F3B2C97,
    0xFE6D9E42,0x35314DE7,0xB3A53F49,0x78F9ECEC,0x65FCDC54,0xAEA00FF1,0x28347D5F,0xE368AEFA,
    0x16441B82,0xDD18C827,0x5B8CBA89,0x90D0692C,0x8DD55994,0x46898A31,0xC01DF89F,0x0B412B3A,
    0xFA1799EF,0x314B4A4A,0xB7DF38E4,0x7C83EB41,0x6186DBF9,0xAADA085C,0x2C4E7AF2,0xE712A957,
    0x15921919,0xDECECABC,0x585AB812,0x93066BB7,0x8E035B0F,0x455F88AA,0xC3CBFA04,0x089729A1,
    0xF9C19B74,0x329D48D1,0xB4093A7F,0x7F55E9DA,0x6250D962,0xA90C0AC7,0x2F987869,0xE4C4ABCC,
  },
  {
    0x00000000,0xA6770BB4,0x979F1129,0x31E81A9D,0xF44F2413,0x52382FA7,0x63D0353A,0xC5A73E8E,
    0x33EF4E67,0x959845D3,0xA4705F4E,0x020754FA,0xC7A06A74,0x61D761C0,0x503F7B5D,0xF64870E9,
    0x67DE9CCE,0xC1A9977A,0xF0418DE7,0x56368653,0x9391B8DD,0x35E6B369,0x040EA9F4,0xA279A240,
    0x5431D2A9,0xF246D91D,0xC3AEC380,0x65D9C834,0xA07EF6BA,0x0609FD0E,0x37E1E793,0x9196EC27,
    0xCFBD399C,0x69CA3228,0x582228B5,0xFE552301,0x3BF21D8F,0x9D85163B,0xAC6D0CA6,0x0A1A0712,
    0xFC5277FB,0x5A257C4F,0x6BCD66D2,0xCDBA6D66,0x081D53E8,0xAE6A585C,0x9F8242C1,0x39F54975,
    0xA863A552,0x0E14AEE6,0x3FFCB47B,0x998BBFCF,0x5C2C8141,0xFA5B8AF5,0xCBB39068,0x6DC49BDC,
    0x9B8CEB35,0x3DFBE081,0x0C13FA1C,0xAA64F1A8,0x6FC3CF26,0xC9B4C492,0xF85CDE0F,0x5E2BD5BB,
    0x440B7579,0xE27C7ECD,0xD3946450,0x75E36FE4,0xB044516A,0x16335ADE,0x27DB4043,0x81AC4BF7,
    0x77E43B1E,0xD19330AA,0xE07B2A37,0x460C2183,0x83AB1F0D,0x25DC14B9,0x14340E24,0xB2430590,
    0x23D5E9B7,0x85A2E203,0xB44AF89E,0x123DF32A,0xD79ACDA4,0x71EDC610,0x4005DC8D,0xE672D739,
    0x103AA7D0,0xB64DAC64,0x87A5B6F9,0x21D2BD4D,0xE47583C3,0x42028877,0x73EA92EA,0xD59D995E,
    0x8BB64CE5,0x2DC14751,0x1C295DCC,0xBA5E5678,0x7FF968F6,0xD98E6342,0xE86679DF,0x4E11726B,
    0xB8590282,0x1E2E0936,0x2FC613AB,0x89B1181F,0x4C162691,0xEA612D25,0xDB8937B8,0x7DFE3C0C,
    0xEC68D02B,0x4A1FDB9F,0x7BF7C102,0xDD80CAB6,0x1827F438,0xBE50FF8C,0x8FB8E511,0x29CFEEA5,
    0xDF879E4C,0x79F095F8,0x48188F65,0xEE6F84D1,0x2BC8BA5F,0x8DBFB1EB,0xBC57AB76,0x1A20A0C2,
    0x8816EAF2,0x2E61E146,0x1F89FBDB,0xB9FEF06F,0x7C59CEE1,0xDA2EC555,0xEBC6DFC8,0x4DB1D47C,
    0xBBF9A495,0x1D8EAF21,0x2C66B5BC,0x8A11BE08,0x4FB68086,0xE9C18B32,0xD82991AF,0x7E5E9A1B,
    0xEFC8763C,0x49BF7D88,0x78576715,0xDE206CA1,0x1B87522F,0xBDF0599B,0x8C184306,0x2A6F48B2,
    0xDC27385B,0x7A5033EF,0x4BB82972,0xEDCF22C6,0x28681C48,0x8E1F17FC,0xBFF70D61,0x198006D5,
    0x47ABD36E,0xE1DCD8DA,0xD034C247,0x7643C9F3,0xB3E4F77D,0x1593FCC9,0x247BE654,0x820CEDE0,
    0x74449D09,0xD23396BD,0xE3DB8C20,0x45AC8794,0x800BB91A,0x267CB2AE,0x1794A833,0xB1E3A387,
    0x20754FA0,0x86024414,0xB7EA5E89,0x119D553D,0xD43A6BB3,0x724D6007,0x43A57A9A,0xE5D2712E,
    0x139A01C7,0xB5ED0A73,0x840510EE,0x22721B5A,0xE7D525D4,0x41A22E60,0x704A34FD,0xD63D3F49,
    0xCC1D9F8B,0x6A6A943F,0x5B828EA2,0xFDF58516,0x3852BB98,0x9E25B02C,0xAFCDAAB1,0x09BAA105,
    0xFFF2D1EC,0x5985DA58,0x686DC0C5,0xCE1ACB71,0x0BBDF5FF,0xADCAFE4B,0x9C22E4D6,0x3A55EF62,
    0xABC30345,0x0DB408F1,0x3C5C126C,0x9A2B19D8,0x5F8C2756,0xF9FB2CE2,0xC813367F,0x6E643DCB,
    0x982C4D22,0x3E5B4696,0x0FB35C0B,0xA9C457BF,0x6C636931,0xCA146285,0xFBFC7818,0x5D8B73AC,
    0x03A0A617,0xA5D7ADA3,0x943FB73E,0x3248BC8A,0xF7EF8204,0x519889B0,0x6070932D,0xC6079899,
    0x304FE870,0x9638E3C4,0xA7D0F959,0x01A7F2ED,0xC400CC63,0x6277C7D7,0x539FDD4A,0xF5E8D6FE,
    0x647E3AD9,0xC209316D,0xF3E12BF0,0x55962044,0x90311ECA,0x3646157E,0x07AE0FE3,0xA1D90457,
    0x579174BE,0xF1E67F0A,0xC00E6597,0x66796E23,0xA3DE50AD,0x05A95B19,0x34414184,0x92364A30,
  },
  {
    0x00000000,0xCCAA009E,0x4225077D,0x8E8F07E3,0x844A0EFA,0x48E00E64,0xC66F0987,0x0AC50919,
    0xD3E51BB5,0x1F4F1B2B,0x91C01CC8,0x5D6A1C56,0x57AF154F,0x9B0515D1,0x158A1232,0xD92012AC,
    0x7CBB312B,0xB01131B5,0x3E9E3656,0xF23436C8,0xF8F13FD1,0x345B3F4F,0xBAD438AC,0x767E3832,
    0xAF5E2A9E,0x63F42A00,0xED7B2DE3,0x21D12D7D,0x2B142464,0xE7BE24FA,0x69312319,0xA59B2387,
    0xF9766256,0x35DC62C8,0xBB53652B,0x77F965B5,0x7D3C6CAC,0xB1966C32,0x3F196BD1,0xF3B36B4F,
    0x2A9379E3,0xE639797D,0x68B67E9E,0xA41C7E00,0xAED97719,0x62737787,0xECFC7064,0x205670FA,
    0x85CD537D,0x496753E3,0xC7E85400,0x0B42549E,0x01875D87,0xCD2D5D19,0x43A25AFA,0x8F085A64,
    0x562848C8,0x9A824856,0x140D4FB5,0xD8A74F2B,0xD2624632,0x1EC846AC,0x9047414F,0x5CED41D1,
    0x299DC2ED,0xE537C273,0x6BB8C590,0xA712C50E,0xADD7CC17,0x617DCC89,0xEFF2CB6A,0x2358CBF4,
    0xFA78D958,0x36D2D9C6,0xB85DDE25,0x74F7DEBB,0x7E32D7A2,0xB298D73C,0x3C17D0DF,0xF0BDD041,
    0x5526F3C6,0x998CF358,0x1703F4BB,0xDBA9F425,0xD16CFD3C,0x1DC6FDA2,0x9349FA41,0x5FE3FADF,
    0x86C3E873,0x4A69E8ED,0xC4E6EF0E,0x084CEF90,0x0289E689,0xCE23E617,0x40ACE1F4,0x8C06E16A,
    0xD0EBA0BB,0x1C41A025,0x92CEA7C6,0x5E64A758,0x54A1AE41,0x980BAEDF,0x1684A93C,0xDA2EA9A2,
    0x030EBB0E,0xCFA4BB90,0x412BBC73,0x8D81BCED,0x8744B5F4,0x4BEEB56A,0xC561B289,0x09CBB217,
    0xAC509190,0x60FA910E,0xEE7596ED,0x22DF9673,0x281A9F6A,0xE4B09FF4,0x6A3F9817,0xA6959889,
    0x7FB58A25,0xB31F8ABB,0x3D908D58,0xF13A8DC6,0xFBFF84DF,0x37558441,0xB9DA83A2,0x7570833C,
    0x533B85DA,0x9F918544,0x111E82A7,0xDDB48239,0xD7718B20,0x1BDB8BBE,0x95548C5D,0x59FE8CC3,
    0x80DE9E6F,0x4C749EF1,0xC2FB9912,0x0E51998C,0x04949095,0xC83E900B,0x46B197E8,0x8A1B9776,
    0x2F80B4F1,0xE32AB46F,0x6DA5B38C,0xA10FB312,0xABCABA0B,0x6760BA95,0xE9EFBD76,0x2545BDE8,
    0xFC65AF44,0x30CFAFDA,0xBE40A839,0x72EAA8A7,0x782FA1BE,0xB485A120,0x3A0AA6C3,0xF6A0A65D,
    0xAA4DE78C,0x66E7E712,0xE868E0F1,0x24C2E06F,0x2E07E976,0xE2ADE9E8,0x6C22EE0B,0xA088EE95,
    0x79A8FC39,0xB502FCA7,0x3B8DFB44,0xF727FBDA,0xFDE2F2C3,0x3148F25D,0xBFC7F5BE,0x736DF520,
    0xD6F6D6A7,0x1A5CD639,0x94D3D1DA,0x5879D144,0x52BCD85D,0x9E16D8C3,0x1099DF20,0xDC33DFBE,
    0x0513CD12,0xC9B9CD8C,0x4736CA6F,0x8B9CCAF1,0x8159C3E8,0x4DF3C376,0xC37CC495,0x0FD6C40B,
    0x7AA64737,0xB60C47A9,0x3883404A,0xF42940D4,0xFEEC49CD,0x32464953,0xBCC94EB0,0x70634E2E,
    0xA9435C82,0x65E95C1C,0xEB665BFF,0x27CC5B61,0x2D095278,0xE1A352E6,0x6F2C5505,0xA386559B,
    0x061D761C,0xCAB77682,0x44387161,0x889271FF,0x825778E6,0x4EFD7878,0xC0727F9B,0x0CD87F05,
    0xD5F86DA9,0x19526D37,0x97DD6AD4,0x5B776A4A,0x51B26353,0x9D1863CD,0x1397642E,0xDF3D64B0,
    0x83D02561,0x4F7A25FF,0xC1F5221C,0x0D5F2282,0x079A2B9B,0xCB302B05,0x45BF2CE6,0x89152C78,
    0x50353ED4,0x9C9F3E4A,0x121039A9,0xDEBA3937,0xD47F302E,0x18D530B0,0x965A3753,0x5AF037CD,
    0xFF6B144A,0x33C114D4,0xBD4E1337,0x71E413A9,0x7B211AB0,0xB78B1A2E,0x39041DCD,0xF5AE1D53,
    0x2C8E0FFF,0xE0240F61,0x6EAB0882,0xA201081C,0xA8C40105,0x646E019B,0xEAE10678,0x264B06E6,
  }
#endif 
#ifdef CRC32_USE_LOOKUP_TABLE_SLICING_BY_16
  ,{
    0x00000000,0x177B1443,0x2EF62886,0x398D3CC5,0x5DEC510C,0x4A97454F,0x731A798A,0x64616DC9,
    0xBBD8A218,0xACA3B65B,0x952E8A9E,0x82559EDD,0xE634F314,0xF14FE757,0xC8C2DB92,0xDFB9CFD1,
    0xACC04271,0xBBBB5632,0x82366AF7,0x954D7EB4,0xF12C137D,0xE657073E,0xDFDA3BFB,0xC8A12FB8,
    0x1718E069,0x0063F42A,0x39EEC8EF,0x2E95DCAC,0x4AF4B165,0x5D8FA526,0x640299E3,0x73798DA0,
    0x82F182A3,0x958A96E0,0xAC07AA25,0xBB7CBE66,0xDF1DD3AF,0xC866C7EC,0xF1EBFB29,0xE690EF6A,
    0x392920BB,0x2E5234F8,0x17DF083D,0x00A41C7E,0x64C571B7,0x73BE65F4,0x4A335931,0x5D484D72,
    0x2E31C0D2,0x394AD491,0x00C7E854,0x17BCFC17,0x73DD91DE,0x64A6859D,0x5D2BB958,0x4A50AD1B,
    0x95E962CA,0x82927689,0xBB1F4A4C,0xAC645E0F,0xC80533C6,0xDF7E2785,0xE6F31B40,0xF1880F03,
    0xDE920307,0xC9E91744,0xF0642B81,0xE71F3FC2,0x837E520B,0x94054648,0xAD887A8D,0xBAF36ECE,
    0x654AA11F,0x7231B55C,0x4BBC8999,0x5CC79DDA,0x38A6F013,0x2FDDE450,0x1650D895,0x012BCCD6,
    0x72524176,0x65295535,0x5CA469F0,0x4BDF7DB3,0x2FBE107A,0x38C50439,0x014838FC,0x16332CBF,
    0xC98AE36E,0xDEF1F72D,0xE77CCBE8,0xF007DFAB,0x9466B262,0x831DA621,0xBA909AE4,0xADEB8EA7,
    0x5C6381A4,0x4B1895E7,0x7295A922,0x65EEBD61,0x018FD0A8,0x16F4C4EB,0x2F79F82E,0x3802EC6D,
    0xE7BB23BC,0xF0C037FF,0xC94D0B3A,0xDE361F79,0xBA5772B0,0xAD2C66F3,0x94A15A36,0x83DA4E75,
    0xF0A3C3D5,0xE7D8D796,0xDE55EB53,0xC92EFF10,0xAD4F92D9,0xBA34869A,0x83B9BA5F,0x94C2AE1C,
    0x4B7B61CD,0x5C00758E,0x658D494B,0x72F65D08,0x169730C1,0x01EC2482,0x38611847,0x2F1A0C04,
    0x6655004F,0x712E140C,0x48A328C9,0x5FD83C8A,0x3BB95143,0x2CC24500,0x154F79C5,0x02346D86,
    0xDD8DA257,0xCAF6B614,0xF37B8AD1,0xE4009E92,0x8061F35B,0x971AE718,0xAE97DBDD,0xB9ECCF9E,
    0xCA95423E,0xDDEE567D,0xE4636AB8,0xF3187EFB,0x97791332,0x80020771,0xB98F3BB4,0xAEF42FF7,
    0x714DE026,0x6636F465,0x5FBBC8A0,0x48C0DCE3,0x2CA1B12A,0x3BDAA569,0x025799AC,0x152C8DEF,
    0xE4A482EC,0xF3DF96AF,0xCA52AA6A,0xDD29BE29,0xB948D3E0,0xAE33C7A3,0x97BEFB66,0x80C5EF25,
    0x5F7C20F4,0x480734B7,0x718A0872,0x66F11C31,0x029071F8,0x15EB65BB,0x2C66597E,0x3B1D4D3D,
    0x4864C09D,0x5F1FD4DE,0x6692E81B,0x71E9FC58,0x15889191,0x02F385D2,0x3B7EB917,0x2C05AD54,
    0xF3BC6285,0xE4C776C6,0xDD4A4A03,0xCA315E40,0xAE503389,0xB92B27CA,0x80A61B0F,0x97DD0F4C,
    0xB8C70348,0xAFBC170B,0x96312BCE,0x814A3F8D,0xE52B5244,0xF2504607,0xCBDD7AC2,0xDCA66E81,
    0x031FA150,0x1464B513,0x2DE989D6,0x3A929D95,0x5EF3F05C,0x4988E41F,0x7005D8DA,0x677ECC99,
    0x14074139,0x037C557A,0x3AF169BF,0x2D8A7DFC,0x49EB1035,0x5E900476,0x671D38B3,0x70662CF0,
    0xAFDFE321,0xB8A4F762,0x8129CBA7,0x9652DFE4,0xF233B22D,0xE548A66E,0xDCC59AAB,0xCBBE8EE8,
    0x3A3681EB,0x2D4D95A8,0x14C0A96D,0x03BBBD2E,0x67DAD0E7,0x70A1C4A4,0x492CF861,0x5E57EC22,
    0x81EE23F3,0x969537B0,0xAF180B75,0xB8631F36,0xDC0272FF,0xCB7966BC,0xF2F45A79,0xE58F4E3A,
    0x96F6C39A,0x818DD7D9,0xB800EB1C,0xAF7BFF5F,0xCB1A9296,0xDC6186D5,0xE5ECBA10,0xF297AE53,
    0x2D2E6182,0x3A5575C1,0x03D84904,0x14A35D47,0x70C2308E,0x67B924CD,0x5E341808,0x494F0C4B,
  },
  {
    0x00000000,0xEFC26B3E,0x04F5D03D,0xEB37BB03,0x09EBA07A,0xE629CB44,0x0D1E7047,0xE2DC1B79,
    0x13D740F4,0xFC152BCA,0x172290C9,0xF8E0FBF7,0x1A3CE08E,0xF5FE8BB0,0x1EC930B3,0xF10B5B8D,
    0x27AE81E8,0xC86CEAD6,0x235B51D5,0xCC993AEB,0x2E452192,0xC1874AAC,0x2AB0F1AF,0xC5729A91,
    0x3479C11C,0xDBBBAA22,0x308C1121,0xDF4E7A1F,0x3D926166,0xD2500A58,0x3967B15B,0xD6A5DA65,
    0x4F5D03D0,0xA09F68EE,0x4BA8D3ED,0xA46AB8D3,0x46B6A3AA,0xA974C894,0x42437397,0xAD8118A9,
    0x5C8A4324,0xB348281A,0x587F9319,0xB7BDF827,0x5561E35E,0xBAA38860,0x51943363,0xBE56585D,
    0x68F38238,0x8731E906,0x6C065205,0x83C4393B,0x61182242,0x8EDA497C,0x65EDF27F,0x8A2F9941,
    0x7B24C2CC,0x94E6A9F2,0x7FD112F1,0x901379CF,0x72CF62B6,0x9D0D0988,0x763AB28B,0x99F8D9B5,
    0x9EBA07A0,0x71786C9E,0x9A4FD79D,0x758DBCA3,0x9751A7DA,0x7893CCE4,0x93A477E7,0x7C661CD9,
    0x8D6D4754,0x62AF2C6A,0x89989769,0x665AFC57,0x8486E72E,0x6B448C10,0x80733713,0x6FB15C2D,
    0xB9148648,0x56D6ED76,0xBDE15675,0x52233D4B,0xB0FF2632,0x5F3D4D0C,0xB40AF60F,0x5BC89D31,
    0xAAC3C6BC,0x4501AD82,0xAE361681,0x41F47DBF,0xA32866C6,0x4CEA0DF8,0xA7DDB6FB,0x481FDDC5,
    0xD1E70470,0x3E256F4E,0xD512D44D,0x3AD0BF73,0xD80CA40A,0x37CECF34,0xDCF97437,0x333B1F09,
    0xC2304484,0x2DF22FBA,0xC6C594B9,0x2907FF87,0xCBDBE4FE,0x24198FC0,0xCF2E34C3,0x20EC5FFD,
    0xF6498598,0x198BEEA6,0xF2BC55A5,0x1D7E3E9B,0xFFA225E2,0x10604EDC,0xFB57F5DF,0x14959EE1,
    0xE59EC56C,0x0A5CAE52,0xE16B1551,0x0EA97E6F,0xEC756516,0x03B70E28,0xE880B52B,0x0742DE15,
    0xE6050901,0x09C7623F,0xE2F0D93C,0x0D32B202,0xEFEEA97B,0x002CC245,0xEB1B7946,0x04D91278,
    0xF5D249F5,0x1A1022CB,0xF12799C8,0x1EE5F2F6,0xFC39E98F,0x13FB82B1,0xF8CC39B2,0x170E528C,
    0xC1AB88E9,0x2E69E3D7,0xC55E58D4,0x2A9C33EA,0xC8402893,0x278243AD,0xCCB5F8AE,0x23779390,
    0xD27CC81D,0x3DBEA323,0xD6891820,0x394B731E,0xDB976867,0x34550359,0xDF62B85A,0x30A0D364,
    0xA9580AD1,0x469A61EF,0xADADDAEC,0x426FB1D2,0xA0B3AAAB,0x4F71C195,0xA4467A96,0x4B8411A8,
    0xBA8F4A25,0x554D211B,0xBE7A9A18,0x51B8F126,0xB364EA5F,0x5CA68161,0xB7913A62,0x5853515C,
    0x8EF68B39,0x6134E007,0x8A035B04,0x65C1303A,0x871D2B43,0x68DF407D,0x83E8FB7E,0x6C2A9040,
    0x9D21CBCD,0x72E3A0F3,0x99D41BF0,0x761670CE,0x94CA6BB7,0x7B080089,0x903FBB8A,0x7FFDD0B4,
    0x78BF0EA1,0x977D659F,0x7C4ADE9C,0x9388B5A2,0x7154AEDB,0x9E96C5E5,0x75A17EE6,0x9A6315D8,
    0x6B684E55,0x84AA256B,0x6F9D9E68,0x805FF556,0x6283EE2F,0x8D418511,0x66763E12,0x89B4552C,
    0x5F118F49,0xB0D3E477,0x5BE45F74,0xB426344A,0x56FA2F33,0xB938440D,0x520FFF0E,0xBDCD9430,
    0x4CC6CFBD,0xA304A483,0x48331F80,0xA7F174BE,0x452D6FC7,0xAAEF04F9,0x41D8BFFA,0xAE1AD4C4,
    0x37E20D71,0xD820664F,0x3317DD4C,0xDCD5B672,0x3E09AD0B,0xD1CBC635,0x3AFC7D36,0xD53E1608,
    0x24354D85,0xCBF726BB,0x20C09DB8,0xCF02F686,0x2DDEEDFF,0xC21C86C1,0x292B3DC2,0xC6E956FC,
    0x104C8C99,0xFF8EE7A7,0x14B95CA4,0xFB7B379A,0x19A72CE3,0xF66547DD,0x1D52FCDE,0xF29097E0,
    0x039BCC6D,0xEC59A753,0x076E1C50,0xE8AC776E,0x0A706C17,0xE5B20729,0x0E85BC2A,0xE147D714,
  },
  {
    0x00000000,0xC18EDFC0,0x586CB9C1,0x99E26601,0xB0D97382,0x7157AC42,0xE8B5CA43,0x293B1583,
    0xBAC3E145,0x7B4D3E85,0xE2AF5884,0x23218744,0x0A1A92C7,0xCB944D07,0x52762B06,0x93F8F4C6,
    0xAEF6C4CB,0x6F781B0B,0xF69A7D0A,0x3714A2CA,0x1E2FB749,0xDFA16889,0x46430E88,0x87CDD148,
    0x1435258E,0xD5BBFA4E,0x4C599C4F,0x8DD7438F,0xA4EC560C,0x656289CC,0xFC80EFCD,0x3D0E300D,
    0x869C8FD7,0x47125017,0xDEF03616,0x1F7EE9D6,0x3645FC55,0xF7CB2395,0x6E294594,0xAFA79A54,
    0x3C5F6E92,0xFDD1B152,0x6433D753,0xA5BD0893,0x8C861D10,0x4D08C2D0,0xD4EAA4D1,0x15647B11,
    0x286A4B1C,0xE9E494DC,0x7006F2DD,0xB1882D1D,0x98B3389E,0x593DE75E,0xC0DF815F,0x01515E9F,
    0x92A9AA59,0x53277599,0xCAC51398,0x0B4BCC58,0x2270D9DB,0xE3FE061B,0x7A1C601A,0xBB92BFDA,
    0xD64819EF,0x17C6C62F,0x8E24A02E,0x4FAA7FEE,0x66916A6D,0xA71FB5AD,0x3EFDD3AC,0xFF730C6C,
    0x6C8BF8AA,0xAD05276A,0x34E7416B,0xF5699EAB,0xDC528B28,0x1DDC54E8,0x843E32E9,0x45B0ED29,
    0x78BEDD24,0xB93002E4,0x20D264E5,0xE15CBB25,0xC867AEA6,0x09E97166,0x900B1767,0x5185C8A7,
    0xC27D3C61,0x03F3E3A1,0x9A1185A0,0x5B9F5A60,0x72A44FE3,0xB32A9023,0x2AC8F622,0xEB4629E2,
    0x50D49638,0x915A49F8,0x08B82FF9,0xC936F039,0xE00DE5BA,0x21833A7A,0xB8615C7B,0x79EF83BB,
    0xEA17777D,0x2B99A8BD,0xB27BCEBC,0x73F5117C,0x5ACE04FF,0x9B40DB3F,0x02A2BD3E,0xC32C62FE,
    0xFE2252F3,0x3FAC8D33,0xA64EEB32,0x67C034F2,0x4EFB2171,0x8F75FEB1,0x169798B0,0xD7194770,
    0x44E1B3B6,0x856F6C76,0x1C8D0A77,0xDD03D5B7,0xF438C034,0x35B61FF4,0xAC5479F5,0x6DDAA635,
    0x77E1359F,0xB66FEA5F,0x2F8D8C5E,0xEE03539E,0xC738461D,0x06B699DD,0x9F54FFDC,0x5EDA201C,
    0xCD22D4DA,0x0CAC0B1A,0x954E6D1B,0x54C0B2DB,0x7DFBA758,0xBC757898,0x25971E99,0xE419C159,
    0xD917F154,0x18992E94,0x817B4895,0x40F59755,0x69CE82D6,0xA8405D16,0x31A23B17,0xF02CE4D7,
    0x63D41011,0xA25ACFD1,0x3BB8A9D0,0xFA367610,0xD30D6393,0x1283BC53,0x8B61DA52,0x4AEF0592,
    0xF17DBA48,0x30F36588,0xA9110389,0x689FDC49,0x41A4C9CA,0x802A160A,0x19C8700B,0xD846AFCB,
    0x4BBE5B0D,0x8A3084CD,0x13D2E2CC,0xD25C3D0C,0xFB67288F,0x3AE9F74F,0xA30B914E,0x62854E8E,
    0x5F8B7E83,0x9E05A143,0x07E7C742,0xC6691882,0xEF520D01,0x2EDCD2C1,0xB73EB4C0,0x76B06B00,
    0xE5489FC6,0x24C64006,0xBD242607,0x7CAAF9C7,0x5591EC44,0x941F3384,0x0DFD5585,0xCC738A45,
    0xA1A92C70,0x6027F3B0,0xF9C595B1,0x384B4A71,0x11705FF2,0xD0FE8032,0x491CE633,0x889239F3,
    0x1B6ACD35,0xDAE412F5,0x430674F4,0x8288AB34,0xABB3BEB7,0x6A3D6177,0xF3DF0776,0x3251D8B6,
    0x0F5FE8BB,0xCED1377B,0x5733517A,0x96BD8EBA,0xBF869B39,0x7E0844F9,0xE7EA22F8,0x2664FD38,
    0xB59C09FE,0x7412D63E,0xEDF0B03F,0x2C7E6FFF,0x05457A7C,0xC4CBA5BC,0x5D29C3BD,0x9CA71C7D,
    0x2735A3A7,0xE6BB7C67,0x7F591A66,0xBED7C5A6,0x97ECD025,0x56620FE5,0xCF8069E4,0x0E0EB624,
    0x9DF642E2,0x5C789D22,0xC59AFB23,0x041424E3,0x2D2F3160,0xECA1EEA0,0x754388A1,0xB4CD5761,
    0x89C3676C,0x484DB8AC,0xD1AFDEAD,0x1021016D,0x391A14EE,0xF894CB2E,0x6176AD2F,0xA0F872EF,
    0x33008629,0xF28E59E9,0x6B6C3FE8,0xAAE2E028,0x83D9F5AB,0x42572A6B,0xDBB54C6A,0x1A3B93AA,
  },
  {
    0x00000000,0x9BA54C6F,0xEC3B9E9F,0x779ED2F0,0x03063B7F,0x98A37710,0xEF3DA5E0,0x7498E98F,
    0x060C76FE,0x9DA93A91,0xEA37E861,0x7192A40E,0x050A4D81,0x9EAF01EE,0xE931D31E,0x72949F71,
    0x0C18EDFC,0x97BDA193,0xE0237363,0x7B863F0C,0x0F1ED683,0x94BB9AEC,0xE325481C,0x78800473,
    0x0A149B02,0x91B1D76D,0xE62F059D,0x7D8A49F2,0x0912A07D,0x92B7EC12,0xE5293EE2,0x7E8C728D,
    0x1831DBF8,0x83949797,0xF40A4567,0x6FAF0908,0x1B37E087,0x8092ACE8,0xF70C7E18,0x6CA93277,
    0x1E3DAD06,0x8598E169,0xF2063399,0x69A37FF6,0x1D3B9679,0x869EDA16,0xF10008E6,0x6AA54489,
    0x14293604,0x8F8C7A6B,0xF812A89B,0x63B7E4F4,0x172F0D7B,0x8C8A4114,0xFB1493E4,0x60B1DF8B,
    0x122540FA,0x89800C95,0xFE1EDE65,0x65BB920A,0x11237B85,0x8A8637EA,0xFD18E51A,0x66BDA975,
    0x3063B7F0,0xABC6FB9F,0xDC58296F,0x47FD6500,0x33658C8F,0xA8C0C0E0,0xDF5E1210,0x44FB5E7F,
    0x366FC10E,0xADCA8D61,0xDA545F91,0x41F113FE,0x3569FA71,0xAECCB61E,0xD95264EE,0x42F72881,
    0x3C7B5A0C,0xA7DE1663,0xD040C493,0x4BE588FC,0x3F7D6173,0xA4D82D1C,0xD346FFEC,0x48E3B383,
    0x3A772CF2,0xA1D2609D,0xD64CB26D,0x4DE9FE02,0x3971178D,0xA2D45BE2,0xD54A8912,0x4EEFC57D,
    0x28526C08,0xB3F72067,0xC469F297,0x5FCCBEF8,0x2B545777,0xB0F11B18,0xC76FC9E8,0x5CCA8587,
    0x2E5E1AF6,0xB5FB5699,0xC2658469,0x59C0C806,0x2D582189,0xB6FD6DE6,0xC163BF16,0x5AC6F379,
    0x244A81F4,0xBFEFCD9B,0xC8711F6B,0x53D45304,0x274CBA8B,0xBCE9F6E4,0xCB772414,0x50D2687B,
    0x2246F70A,0xB9E3BB65,0xCE7D6995,0x55D825FA,0x2140CC75,0xBAE5801A,0xCD7B52EA,0x56DE1E85,
    0x60C76FE0,0xFB62238F,0x8CFCF17F,0x1759BD10,0x63C1549F,0xF86418F0,0x8FFACA00,0x145F866F,
    0x66CB191E,0xFD6E5571,0x8AF08781,0x1155CBEE,0x65CD2261,0xFE686E0E,0x89F6BCFE,0x1253F091,
    0x6CDF821C,0xF77ACE73,0x80E41C83,0x1B4150EC,0x6FD9B963,0xF47CF50C,0x83E227FC,0x18476B93,
    0x6AD3F4E2,0xF176B88D,0x86E86A7D,0x1D4D2612,0x69D5CF9D,0xF27083F2,0x85EE5102,0x1E4B1D6D,
    0x78F6B418,0xE353F877,0x94CD2A87,0x0F6866E8,0x7BF08F67,0xE055C308,0x97CB11F8,0x0C6E5D97,
    0x7EFAC2E6,0xE55F8E89,0x92C15C79,0x09641016,0x7DFCF999,0xE659B5F6,0x91C76706,0x0A622B69,
    0x74EE59E4,0xEF4B158B,0x98D5C77B,0x03708B14,0x77E8629B,0xEC4D2EF4,0x9BD3FC04,0x0076B06B,
    0x72E22F1A,0xE9476375,0x9ED9B185,0x057CFDEA,0x71E41465,0xEA41580A,0x9DDF8AFA,0x067AC695,
    0x50A4D810,0xCB01947F,0xBC9F468F,0x273A0AE0,0x53A2E36F,0xC807AF00,0xBF997DF0,0x243C319F,
    0x56A8AEEE,0xCD0DE281,0xBA933071,0x21367C1E,0x55AE9591,0xCE0BD9FE,0xB9950B0E,0x22304761,
    0x5CBC35EC,0xC7197983,0xB087AB73,0x2B22E71C,0x5FBA0E93,0xC41F42FC,0xB381900C,0x2824DC63,
    0x5AB04312,0xC1150F7D,0xB68BDD8D,0x2D2E91E2,0x59B6786D,0xC2133402,0xB58DE6F2,0x2E28AA9D,
    0x489503E8,0xD3304F87,0xA4AE9D77,0x3F0BD118,0x4B933897,0xD03674F8,0xA7A8A608,0x3C0DEA67,
    0x4E997516,0xD53C3979,0xA2A2EB89,0x3907A7E6,0x4D9F4E69,0xD63A0206,0xA1A4D0F6,0x3A019C99,
    0x448DEE14,0xDF28A27B,0xA8B6708B,0x33133CE4,0x478BD56B,0xDC2E9904,0xABB04BF4,0x3015079B,
    0x428198EA,0xD924D485,0xAEBA0675,0x351F4A1A,0x4187A395,0xDA22EFFA,0xADBC3D0A,0x36197165,
  },
  {
    0x00000000,0xDD96D985,0x605CB54B,0xBDCA6CCE,0xC0B96A96,0x1D2FB313,0xA0E5DFDD,0x7D730658,
    0x5A03D36D,0x87950AE8,0x3A5F6626,0xE7C9BFA3,0x9ABAB9FB,0x472C607E,0xFAE60CB0,0x2770D535,
    0xB407A6DA,0x69917F5F,0xD45B1391,0x09CDCA14,0x74BECC4C,0xA92815C9,0x14E27907,0xC974A082,
    0xEE0475B7,0x3392AC32,0x8E58C0FC,0x53CE1979,0x2EBD1F21,0xF32BC6A4,0x4EE1AA6A,0x937773EF,
    0xB37E4BF5,0x6EE89270,0xD322FEBE,0x0EB4273B,0x73C72163,0xAE51F8E6,0x139B9428,0xCE0D4DAD,
    0xE97D9898,0x34EB411D,0x89212DD3,0x54B7F456,0x29C4F20E,0xF4522B8B,0x49984745,0x940E9EC0,
    0x0779ED2F,0xDAEF34AA,0x67255864,0xBAB381E1,0xC7C087B9,0x1A565E3C,0xA79C32F2,0x7A0AEB77,
    0x5D7A3E42,0x80ECE7C7,0x3D268B09,0xE0B0528C,0x9DC354D4,0x40558D51,0xFD9FE19F,0x2009381A,
    0xBD8D91AB,0x601B482E,0xDDD124E0,0x0047FD65,0x7D34FB3D,0xA0A222B8,0x1D684E76,0xC0FE97F3,
    0xE78E42C6,0x3A189B43,0x87D2F78D,0x5A442E08,0x27372850,0xFAA1F1D5,0x476B9D1B,0x9AFD449E,
    0x098A3771,0xD41CEEF4,0x69D6823A,0xB4405BBF,0xC9335DE7,0x14A58462,0xA96FE8AC,0x74F93129,
    0x5389E41C,0x8E1F3D99,0x33D55157,0xEE4388D2,0x93308E8A,0x4EA6570F,0xF36C3BC1,0x2EFAE244,
    0x0EF3DA5E,0xD36503DB,0x6EAF6F15,0xB339B690,0xCE4AB0C8,0x13DC694D,0xAE160583,0x7380DC06,
    0x54F00933,0x8966D0B6,0x34ACBC78,0xE93A65FD,0x944963A5,0x49DFBA20,0xF415D6EE,0x29830F6B,
    0xBAF47C84,0x6762A501,0xDAA8C9CF,0x073E104A,0x7A4D1612,0xA7DBCF97,0x1A11A359,0xC7877ADC,
    0xE0F7AFE9,0x3D61766C,0x80AB1AA2,0x5D3DC327,0x204EC57F,0xFDD81CFA,0x40127034,0x9D84A9B1,
    0xA06A2517,0x7DFCFC92,0xC036905C,0x1DA049D9,0x60D34F81,0xBD459604,0x008FFACA,0xDD19234F,
    0xFA69F67A,0x27FF2FFF,0x9A354331,0x47A39AB4,0x3AD09CEC,0xE7464569,0x5A8C29A7,0x871AF022,
    0x146D83CD,0xC9FB5A48,0x74313686,0xA9A7EF03,0xD4D4E95B,0x094230DE,0xB4885C10,0x691E8595,
    0x4E6E50A0,0x93F88925,0x2E32E5EB,0xF3A43C6E,0x8ED73A36,0x5341E3B3,0xEE8B8F7D,0x331D56F8,
    0x13146EE2,0xCE82B767,0x7348DBA9,0xAEDE022C,0xD3AD0474,0x0E3BDDF1,0xB3F1B13F,0x6E6768BA,
    0x4917BD8F,0x9481640A,0x294B08C4,0xF4DDD141,0x89AED719,0x54380E9C,0xE9F26252,0x3464BBD7,
    0xA713C838,0x7A8511BD,0xC74F7D73,0x1AD9A4F6,0x67AAA2AE,0xBA3C7B2B,0x07F617E5,0xDA60CE60,
    0xFD101B55,0x2086C2D0,0x9D4CAE1E,0x40DA779B,0x3DA971C3,0xE03FA846,0x5DF5C488,0x80631D0D,
    0x1DE7B4BC,0xC0716D39,0x7DBB01F7,0xA02DD872,0xDD5EDE2A,0x00C807AF,0xBD026B61,0x6094B2E4,
    0x47E467D1,0x9A72BE54,0x27B8D29A,0xFA2E0B1F,0x875D0D47,0x5ACBD4C2,0xE701B80C,0x3A976189,
    0xA9E01266,0x7476CBE3,0xC9BCA72D,0x142A7EA8,0x695978F0,0xB4CFA175,0x0905CDBB,0xD493143E,
    0xF3E3C10B,0x2E75188E,0x93BF7440,0x4E29ADC5,0x335AAB9D,0xEECC7218,0x53061ED6,0x8E90C753,
    0xAE99FF49,0x730F26CC,0xCEC54A02,0x13539387,0x6E2095DF,0xB3B64C5A,0x0E7C2094,0xD3EAF911,
    0xF49A2C24,0x290CF5A1,0x94C6996F,0x495040EA,0x342346B2,0xE9B59F37,0x547FF3F9,0x89E92A7C,
    0x1A9E5993,0xC7088016,0x7AC2ECD8,0xA754355D,0xDA273305,0x07B1EA80,0xBA7B864E,0x67ED5FCB,
    0x409D8AFE,0x9D0B537B,0x20C13FB5,0xFD57E630,0x8024E068,0x5DB239ED,0xE0785523,0x3DEE8CA6,
  },
  {
    0x00000000,0x9D0FE176,0xE16EC4AD,0x7C6125DB,0x19AC8F1B,0x84A36E6D,0xF8C24BB6,0x65CDAAC0,
    0x33591E36,0xAE56FF40,0xD237DA9B,0x4F383BED,0x2AF5912D,0xB7FA705B,0xCB9B5580,0x5694B4F6,
    0x66B23C6C,0xFBBDDD1A,0x87DCF8C1,0x1AD319B7,0x7F1EB377,0xE2115201,0x9E7077DA,0x037F96AC,
    0x55EB225A,0xC8E4C32C,0xB485E6F7,0x298A0781,0x4C47AD41,0xD1484C37,0xAD2969EC,0x3026889A,
    0xCD6478D8,0x506B99AE,0x2C0ABC75,0xB1055D03,0xD4C8F7C3,0x49C716B5,0x35A6336E,0xA8A9D218,
    0xFE3D66EE,0x63328798,0x1F53A243,0x825C4335,0xE791E9F5,0x7A9E0883,0x06FF2D58,0x9BF0CC2E,
    0xABD644B4,0x36D9A5C2,0x4AB88019,0xD7B7616F,0xB27ACBAF,0x2F752AD9,0x53140F02,0xCE1BEE74,
    0x988F5A82,0x0580BBF4,0x79E19E2F,0xE4EE7F59,0x8123D599,0x1C2C34EF,0x604D1134,0xFD42F042,
    0x41B9F7F1,0xDCB61687,0xA0D7335C,0x3DD8D22A,0x581578EA,0xC51A999C,0xB97BBC47,0x24745D31,
    0x72E0E9C7,0xEFEF08B1,0x938E2D6A,0x0E81CC1C,0x6B4C66DC,0xF64387AA,0x8A22A271,0x172D4307,
    0x270BCB9D,0xBA042AEB,0xC6650F30,0x5B6AEE46,0x3EA74486,0xA3A8A5F0,0xDFC9802B,0x42C6615D,
    0x1452D5AB,0x895D34DD,0xF53C1106,0x6833F070,0x0DFE5AB0,0x90F1BBC6,0xEC909E1D,0x719F7F6B,
    0x8CDD8F29,0x11D26E5F,0x6DB34B84,0xF0BCAAF2,0x95710032,0x087EE144,0x741FC49F,0xE91025E9,
    0xBF84911F,0x228B7069,0x5EEA55B2,0xC3E5B4C4,0xA6281E04,0x3B27FF72,0x4746DAA9,0xDA493BDF,
    0xEA6FB345,0x77605233,0x0B0177E8,0x960E969E,0xF3C33C5E,0x6ECCDD28,0x12ADF8F3,0x8FA21985,
    0xD936AD73,0x44394C05,0x385869DE,0xA55788A8,0xC09A2268,0x5D95C31E,0x21F4E6C5,0xBCFB07B3,
    0x8373EFE2,0x1E7C0E94,0x621D2B4F,0xFF12CA39,0x9ADF60F9,0x07D0818F,0x7BB1A454,0xE6BE4522,
    0xB02AF1D4,0x2D2510A2,0x51443579,0xCC4BD40F,0xA9867ECF,0x34899FB9,0x48E8BA62,0xD5E75B14,
    0xE5C1D38E,0x78CE32F8,0x04AF1723,0x99A0F655,0xFC6D5C95,0x6162BDE3,0x1D039838,0x800C794E,
    0xD698CDB8,0x4B972CCE,0x37F60915,0xAAF9E863,0xCF3442A3,0x523BA3D5,0x2E5A860E,0xB3556778,
    0x4E17973A,0xD318764C,0xAF795397,0x3276B2E1,0x57BB1821,0xCAB4F957,0xB6D5DC8C,0x2BDA3DFA,
    0x7D4E890C,0xE041687A,0x9C204DA1,0x012FACD7,0x64E20617,0xF9EDE761,0x858CC2BA,0x188323CC,
    0x28A5AB56,0xB5AA4A20,0xC9CB6FFB,0x54C48E8D,0x3109244D,0xAC06C53B,0xD067E0E0,0x4D680196,
    0x1BFCB560,0x86F35416,0xFA9271CD,0x679D90BB,0x02503A7B,0x9F5FDB0D,0xE33EFED6,0x7E311FA0,
    0xC2CA1813,0x5FC5F965,0x23A4DCBE,0xBEAB3DC8,0xDB669708,0x4669767E,0x3A0853A5,0xA707B2D3,
    0xF1930625,0x6C9CE753,0x10FDC288,0x8DF223FE,0xE83F893E,0x75306848,0x09514D93,0x945EACE5,
    0xA478247F,0x3977C509,0x4516E0D2,0xD81901A4,0xBDD4AB64,0x20DB4A12,0x5CBA6FC9,0xC1B58EBF,
    0x97213A49,0x0A2EDB3F,0x764FFEE4,0xEB401F92,0x8E8DB552,0x13825424,0x6FE371FF,0xF2EC9089,
    0x0FAE60CB,0x92A181BD,0xEEC0A466,0x73CF4510,0x1602EFD0,0x8B0D0EA6,0xF76C2B7D,0x6A63CA0B,
    0x3CF77EFD,0xA1F89F8B,0xDD99BA50,0x40965B26,0x255BF1E6,0xB8541090,0xC435354B,0x593AD43D,
    0x691C5CA7,0xF413BDD1,0x8872980A,0x157D797C,0x70B0D3BC,0xEDBF32CA,0x91DE1711,0x0CD1F667,
    0x5A454291,0xC74AA3E7,0xBB2B863C,0x2624674A,0x43E9CD8A,0xDEE62CFC,0xA2870927,0x3F88E851,
  },
  {
    0x00000000,0xB9FBDBE8,0xA886B191,0x117D6A79,0x8A7C6563,0x3387BE8B,0x22FAD4F2,0x9B010F1A,
    0xCF89CC87,0x7672176F,0x670F7D16,0xDEF4A6FE,0x45F5A9E4,0xFC0E720C,0xED731875,0x5488C39D,
    0x44629F4F,0xFD9944A7,0xECE42EDE,0x551FF536,0xCE1EFA2C,0x77E521C4,0x66984BBD,0xDF639055,
    0x8BEB53C8,0x32108820,0x236DE259,0x9A9639B1,0x019736AB,0xB86CED43,0xA911873A,0x10EA5CD2,
    0x88C53E9E,0x313EE576,0x20438F0F,0x99B854E7,0x02B95BFD,0xBB428015,0xAA3FEA6C,0x13C43184,
    0x474CF219,0xFEB729F1,0xEFCA4388,0x56319860,0xCD30977A,0x74CB4C92,0x65B626EB,0xDC4DFD03,
    0xCCA7A1D1,0x755C7A39,0x64211040,0xDDDACBA8,0x46DBC4B2,0xFF201F5A,0xEE5D7523,0x57A6AECB,
    0x032E6D56,0xBAD5B6BE,0xABA8DCC7,0x1253072F,0x89520835,0x30A9D3DD,0x21D4B9A4,0x982F624C,
    0xCAFB7B7D,0x7300A095,0x627DCAEC,0xDB861104,0x40871E1E,0xF97CC5F6,0xE801AF8F,0x51FA7467,
    0x0572B7FA,0xBC896C12,0xADF4066B,0x140FDD83,0x8F0ED299,0x36F50971,0x27886308,0x9E73B8E0,
    0x8E99E432,0x37623FDA,0x261F55A3,0x9FE48E4B,0x04E58151,0xBD1E5AB9,0xAC6330C0,0x1598EB28,
    0x411028B5,0xF8EBF35D,0xE9969924,0x506D42CC,0xCB6C4DD6,0x7297963E,0x63EAFC47,0xDA1127AF,
    0x423E45E3,0xFBC59E0B,0xEAB8F472,0x53432F9A,0xC8422080,0x71B9FB68,0x60C49111,0xD93F4AF9,
    0x8DB78964,0x344C528C,0x253138F5,0x9CCAE31D,0x07CBEC07,0xBE3037EF,0xAF4D5D96,0x16B6867E,
    0x065CDAAC,0xBFA70144,0xAEDA6B3D,0x1721B0D5,0x8C20BFCF,0x35DB6427,0x24A60E5E,0x9D5DD5B6,
    0xC9D5162B,0x702ECDC3,0x6153A7BA,0xD8A87C52,0x43A97348,0xFA52A8A0,0xEB2FC2D9,0x52D41931,
    0x4E87F0BB,0xF77C2B53,0xE601412A,0x5FFA9AC2,0xC4FB95D8,0x7D004E30,0x6C7D2449,0xD586FFA1,
    0x810E3C3C,0x38F5E7D4,0x29888DAD,0x90735645,0x0B72595F,0xB28982B7,0xA3F4E8CE,0x1A0F3326,
    0x0AE56FF4,0xB31EB41C,0xA263DE65,0x1B98058D,0x80990A97,0x3962D17F,0x281FBB06,0x91E460EE,
    0xC56CA373,0x7C97789B,0x6DEA12E2,0xD411C90A,0x4F10C610,0xF6EB1DF8,0xE7967781,0x5E6DAC69,
    0xC642CE25,0x7FB915CD,0x6EC47FB4,0xD73FA45C,0x4C3EAB46,0xF5C570AE,0xE4B81AD7,0x5D43C13F,
    0x09CB02A2,0xB030D94A,0xA14DB333,0x18B668DB,0x83B767C1,0x3A4CBC29,0x2B31D650,0x92CA0DB8,
    0x8220516A,0x3BDB8A82,0x2AA6E0FB,0x935D3B13,0x085C3409,0xB1A7EFE1,0xA0DA8598,0x19215E70,
    0x4DA99DED,0xF4524605,0xE52F2C7C,0x5CD4F794,0xC7D5F88E,0x7E2E2366,0x6F53491F,0xD6A892F7,
    0x847C8BC6,0x3D87502E,0x2CFA3A57,0x9501E1BF,0x0E00EEA5,0xB7FB354D,0xA6865F34,0x1F7D84DC,
    0x4BF54741,0xF20E9CA9,0xE373F6D0,0x5A882D38,0xC1892222,0x7872F9CA,0x690F93B3,0xD0F4485B,
    0xC01E1489,0x79E5CF61,0x6898A518,0xD1637EF0,0x4A6271EA,0xF399AA02,0xE2E4C07B,0x5B1F1B93,
    0x0F97D80E,0xB66C03E6,0xA711699F,0x1EEAB277,0x85EBBD6D,0x3C106685,0x2D6D0CFC,0x9496D714,
    0x0CB9B558,0xB5426EB0,0xA43F04C9,0x1DC4DF21,0x86C5D03B,0x3F3E0BD3,0x2E4361AA,0x97B8BA42,
    0xC33079DF,0x7ACBA237,0x6BB6C84E,0xD24D13A6,0x494C1CBC,0xF0B7C754,0xE1CAAD2D,0x583176C5,
    0x48DB2A17,0xF120F1FF,0xE05D9B86,0x59A6406E,0xC2A74F74,0x7B5C949C,0x6A21FEE5,0xD3DA250D,
    0x8752E690,0x3EA93D78,0x2FD45701,0x962F8CE9,0x0D2E83F3,0xB4D5581B,0xA5A83262,0x1C53E98A,
  },
  {
    0x00000000,0xAE689191,0x87A02563,0x29C8B4F2,0xD4314C87,0x7A59DD16,0x539169E4,0xFDF9F875,
    0x73139F4F,0xDD7B0EDE,0xF4B3BA2C,0x5ADB2BBD,0xA722D3C8,0x094A4259,0x2082F6AB,0x8EEA673A,
    0xE6273E9E,0x484FAF0F,0x61871BFD,0xCFEF8A6C,0x32167219,0x9C7EE388,0xB5B6577A,0x1BDEC6EB,
    0x9534A1D1,0x3B5C3040,0x129484B2,0xBCFC1523,0x4105ED56,0xEF6D7CC7,0xC6A5C835,0x68CD59A4,
    0x173F7B7D,0xB957EAEC,0x909F5E1E,0x3EF7CF8F,0xC30E37FA,0x6D66A66B,0x44AE1299,0xEAC68308,
    0x642CE432,0xCA4475A3,0xE38CC151,0x4DE450C0,0xB01DA8B5,0x1E753924,0x37BD8DD6,0x99D51C47,
    0xF11845E3,0x5F70D472,0x76B86080,0xD8D0F111,0x25290964,0x8B4198F5,0xA2892C07,0x0CE1BD96,
    0x820BDAAC,0x2C634B3D,0x05ABFFCF,0xABC36E5E,0x563A962B,0xF85207BA,0xD19AB348,0x7FF222D9,
    0x2E7EF6FA,0x8016676B,0xA9DED399,0x07B64208,0xFA4FBA7D,0x54272BEC,0x7DEF9F1E,0xD3870E8F,
    0x5D6D69B5,0xF305F824,0xDACD4CD6,0x74A5DD47,0x895C2532,0x2734B4A3,0x0EFC0051,0xA09491C0,
    0xC859C864,0x663159F5,0x4FF9ED07,0xE1917C96,0x1C6884E3,0xB2001572,0x9BC8A180,0x35A03011,
    0xBB4A572B,0x1522C6BA,0x3CEA7248,0x9282E3D9,0x6F7B1BAC,0xC1138A3D,0xE8DB3ECF,0x46B3AF5E,
    0x39418D87,0x97291C16,0xBEE1A8E4,0x10893975,0xED70C100,0x43185091,0x6AD0E463,0xC4B875F2,
    0x4A5212C8,0xE43A8359,0xCDF237AB,0x639AA63A,0x9E635E4F,0x300BCFDE,0x19C37B2C,0xB7ABEABD,
    0xDF66B319,0x710E2288,0x58C6967A,0xF6AE07EB,0x0B57FF9E,0xA53F6E0F,0x8CF7DAFD,0x229F4B6C,
    0xAC752C56,0x021DBDC7,0x2BD50935,0x85BD98A4,0x784460D1,0xD62CF140,0xFFE445B2,0x518CD423,
    0x5CFDEDF4,0xF2957C65,0xDB5DC897,0x75355906,0x88CCA173,0x26A430E2,0x0F6C8410,0xA1041581,
    0x2FEE72BB,0x8186E32A,0xA84E57D8,0x0626C649,0xFBDF3E3C,0x55B7AFAD,0x7C7F1B5F,0xD2178ACE,
    0xBADAD36A,0x14B242FB,0x3D7AF609,0x93126798,0x6EEB9FED,0xC0830E7C,0xE94BBA8E,0x47232B1F,
    0xC9C94C25,0x67A1DDB4,0x4E696946,0xE001F8D7,0x1DF800A2,0xB3909133,0x9A5825C1,0x3430B450,
    0x4BC29689,0xE5AA0718,0xCC62B3EA,0x620A227B,0x9FF3DA0E,0x319B4B9F,0x1853FF6D,0xB63B6EFC,
    0x38D109C6,0x96B99857,0xBF712CA5,0x1119BD34,0xECE04541,0x4288D4D0,0x6B406022,0xC528F1B3,
    0xADE5A817,0x038D3986,0x2A458D74,0x842D1CE5,0x79D4E490,0xD7BC7501,0xFE74C1F3,0x501C5062,
    0xDEF63758,0x709EA6C9,0x5956123B,0xF73E83AA,0x0AC77BDF,0xA4AFEA4E,0x8D675EBC,0x230FCF2D,
    0x72831B0E,0xDCEB8A9F,0xF5233E6D,0x5B4BAFFC,0xA6B25789,0x08DAC618,0x211272EA,0x8F7AE37B,
    0x01908441,0xAFF815D0,0x8630A122,0x285830B3,0xD5A1C8C6,0x7BC95957,0x5201EDA5,0xFC697C34,
    0x94A42590,0x3ACCB401,0x130400F3,0xBD6C9162,0x40956917,0xEEFDF886,0xC7354C74,0x695DDDE5,
    0xE7B7BADF,0x49DF2B4E,0x60179FBC,0xCE7F0E2D,0x3386F658,0x9DEE67C9,0xB426D33B,0x1A4E42AA,
    0x65BC6073,0xCBD4F1E2,0xE21C4510,0x4C74D481,0xB18D2CF4,0x1FE5BD65,0x362D0997,0x98459806,
    0x16AFFF3C,0xB8C76EAD,0x910FDA5F,0x3F674BCE,0xC29EB3BB,0x6CF6222A,0x453E96D8,0xEB560749,
    0x839B5EED,0x2DF3CF7C,0x043B7B8E,0xAA53EA1F,0x57AA126A,0xF9C283FB,0xD00A3709,0x7E62A698,
    0xF088C1A2,0x5EE05033,0x7728E4C1,0xD9407550,0x24B98D25,0x8AD11CB4,0xA319A846,0x0D7139D7,
  }
#endif 
};
#endif 
static pthread_once_t crc32c_once_sw = PTHREAD_ONCE_INIT;
static uint32_t crc32c_table[8][256];
#define POLY 0x82f63b78
static void crc32c_init_sw(void)
{
    uint32_t n, crc, k;
    for (n = 0; n < 256; n++) {
        crc = n;
        crc = crc & 1 ? (crc >> 1) ^ POLY : crc >> 1;
        crc = crc & 1 ? (crc >> 1) ^ POLY : crc >> 1;
        crc = crc & 1 ? (crc >> 1) ^ POLY : crc >> 1;
        crc = crc & 1 ? (crc >> 1) ^ POLY : crc >> 1;
        crc = crc & 1 ? (crc >> 1) ^ POLY : crc >> 1;
        crc = crc & 1 ? (crc >> 1) ^ POLY : crc >> 1;
        crc = crc & 1 ? (crc >> 1) ^ POLY : crc >> 1;
        crc = crc & 1 ? (crc >> 1) ^ POLY : crc >> 1;
        crc32c_table[0][n] = crc;
    }
    for (n = 0; n < 256; n++) {
        crc = crc32c_table[0][n];
        for (k = 1; k < 8; k++) {
            crc = crc32c_table[0][crc & 0xff] ^ (crc >> 8);
            crc32c_table[k][n] = crc;
        }
    }
}
static uint32_t crc32c_sw(uint32_t crci, const unsigned char *buf, size_t len)
{
    const unsigned char *next = buf;
    uint64_t crc;
    pthread_once(&crc32c_once_sw, crc32c_init_sw);
    crc = crci ^ 0xffffffff;
    while (len && ((uintptr_t)next & 7) != 0) {
        crc = crc32c_table[0][(crc ^ *next++) & 0xff] ^ (crc >> 8);
        len--;
    }
    while (len >= 8) {
        crc ^= *(uint64_t *)next;
        crc = crc32c_table[7][crc & 0xff] ^
              crc32c_table[6][(crc >> 8) & 0xff] ^
              crc32c_table[5][(crc >> 16) & 0xff] ^
              crc32c_table[4][(crc >> 24) & 0xff] ^
              crc32c_table[3][(crc >> 32) & 0xff] ^
              crc32c_table[2][(crc >> 40) & 0xff] ^
              crc32c_table[1][(crc >> 48) & 0xff] ^
              crc32c_table[0][crc >> 56];
        next += 8;
        len -= 8;
    }
    while (len) {
        crc = crc32c_table[0][(crc ^ *next++) & 0xff] ^ (crc >> 8);
        len--;
    }
    return (uint32_t)crc ^ 0xffffffff;
}
static inline uint32_t gf2_matrix_times(uint32_t *mat, uint32_t vec)
{
    uint32_t sum;
    sum = 0;
    while (vec) {
        if (vec & 1)
            sum ^= *mat;
        vec >>= 1;
        mat++;
    }
    return sum;
}
static inline void gf2_matrix_square(uint32_t *square, uint32_t *mat)
{
    int n;
    for (n = 0; n < 32; n++)
        square[n] = gf2_matrix_times(mat, mat[n]);
}
static void crc32c_zeros_op(uint32_t *even, size_t len)
{
    int n;
    uint32_t row;
    uint32_t odd[32];       
    odd[0] = POLY;              
    row = 1;
    for (n = 1; n < 32; n++) {
        odd[n] = row;
        row <<= 1;
    }
    gf2_matrix_square(even, odd);
    gf2_matrix_square(odd, even);
    do {
        gf2_matrix_square(even, odd);
        len >>= 1;
        if (len == 0)
            return;
        gf2_matrix_square(odd, even);
        len >>= 1;
    } while (len);
    for (n = 0; n < 32; n++)
        even[n] = odd[n];
}
static void crc32c_zeros(uint32_t zeros[][256], size_t len)
{
    uint32_t n;
    uint32_t op[32];
    crc32c_zeros_op(op, len);
    for (n = 0; n < 256; n++) {
        zeros[0][n] = gf2_matrix_times(op, n);
        zeros[1][n] = gf2_matrix_times(op, n << 8);
        zeros[2][n] = gf2_matrix_times(op, n << 16);
        zeros[3][n] = gf2_matrix_times(op, n << 24);
    }
}
static inline uint32_t crc32c_shift(uint32_t zeros[][256], uint32_t crc)
{
    return zeros[0][crc & 0xff] ^ zeros[1][(crc >> 8) & 0xff] ^
           zeros[2][(crc >> 16) & 0xff] ^ zeros[3][crc >> 24];
}
#define LONG 8192
#define LONGx1 "8192"
#define LONGx2 "16384"
#define SHORT 256
#define SHORTx1 "256"
#define SHORTx2 "512"
static pthread_once_t crc32c_once_hw = PTHREAD_ONCE_INIT;
static uint32_t crc32c_long[4][256];
static uint32_t crc32c_short[4][256];
static void crc32c_init_hw(void)
{
    crc32c_zeros(crc32c_long, LONG);
    crc32c_zeros(crc32c_short, SHORT);
}
#if defined(_WIN64)
static uint32_t crc32c_hw(uint32_t crc, const unsigned char *buf, size_t len)
{
    const unsigned char *next = buf;
    const unsigned char *end;
    uint64_t crc0, crc1, crc2;      
    pthread_once(&crc32c_once_hw, crc32c_init_hw);
    crc0 = crc ^ 0xffffffff;
    while (len && ((uintptr_t)next & 7) != 0) {
        __asm__("crc32b\t" "(%1), %0"
                : "=r"(crc0)
                : "r"(next), "0"(crc0));
        next++;
        len--;
    }
    while (len >= LONG*3) {
        crc1 = 0;
        crc2 = 0;
        end = next + LONG;
        do {
            __asm__("crc32q\t" "(%3), %0\n\t"
                    "crc32q\t" LONGx1 "(%3), %1\n\t"
                    "crc32q\t" LONGx2 "(%3), %2"
                    : "=r"(crc0), "=r"(crc1), "=r"(crc2)
                    : "r"(next), "0"(crc0), "1"(crc1), "2"(crc2));
            next += 8;
        } while (next < end);
        crc0 = crc32c_shift(crc32c_long, crc0) ^ crc1;
        crc0 = crc32c_shift(crc32c_long, crc0) ^ crc2;
        next += LONG*2;
        len -= LONG*3;
    }
    while (len >= SHORT*3) {
        crc1 = 0;
        crc2 = 0;
        end = next + SHORT;
        do {
            __asm__("crc32q\t" "(%3), %0\n\t"
                    "crc32q\t" SHORTx1 "(%3), %1\n\t"
                    "crc32q\t" SHORTx2 "(%3), %2"
                    : "=r"(crc0), "=r"(crc1), "=r"(crc2)
                    : "r"(next), "0"(crc0), "1"(crc1), "2"(crc2));
            next += 8;
        } while (next < end);
        crc0 = crc32c_shift(crc32c_short, crc0) ^ crc1;
        crc0 = crc32c_shift(crc32c_short, crc0) ^ crc2;
        next += SHORT*2;
        len -= SHORT*3;
    }
    end = next + (len - (len & 7));
    while (next < end) {
        __asm__("crc32q\t" "(%1), %0"
                : "=r"(crc0)
                : "r"(next), "0"(crc0));
        next += 8;
    }
    len &= 7;
    while (len) {
        __asm__("crc32b\t" "(%1), %0"
                : "=r"(crc0)
                : "r"(next), "0"(crc0));
        next++;
        len--;
    }
    return (uint32_t)crc0 ^ 0xffffffff;
}
#define SSE42(have) \
    do { \
        uint32_t eax, ecx; \
        eax = 1; \
        __asm__("cpuid" \
                : "=c"(ecx) \
                : "a"(eax) \
                : "%ebx", "%edx"); \
        (have) = (ecx >> 20) & 1; \
    } while (0)
#endif
uint32_t crc32c(uint32_t crc, const unsigned char *buf, size_t len)
{
#if  defined(_WIN64)
    int sse42;
    SSE42(sse42);
    return sse42 ? crc32c_hw(crc, buf, len) : crc32c_sw(crc, buf, len);
#else
    return crc32c_sw(crc, buf, len);
#endif
}
class ArchiveBase {
protected:
  libzpaq::AES_CTR* aes;  
  FP fp;          
public:
  ArchiveBase(): aes(0), fp(FPNULL) {}
  ~ArchiveBase() {
    if (aes) delete aes;
    if (fp!=FPNULL) fclose(fp);
  }  
  bool isopen() {return fp!=FPNULL;}
};
class InputArchive: public ArchiveBase, public libzpaq::Reader {
  vector<int64_t> sz;  
  int64_t off;  
  string fn;  
public:
  InputArchive(const char* filename, const char* password=0);
  int get() {
    error("get() not implemented");
    return -1;
  }
  int read(char* obuf, int len) {
    int nr=fread(obuf, 1, len, fp);
    if (nr==0) {
      seek(0, SEEK_CUR);
      nr=fread(obuf, 1, len, fp);
    }
    if (nr==0) return 0;
    if (aes) aes->encrypt(obuf, nr, off);
    off+=nr;
    return nr;
  }
  void seek(int64_t p, int whence);
  int64_t tell() {
    return off;
  }
	int64_t totalsize()
	{
		int64_t temp=0;
		for (unsigned i=0; i<sz.size(); ++i) 
			temp+=sz[i];
		return temp;
	}
};
void InputArchive::seek(int64_t p, int whence) {
  if (!isopen()) return;
  if (whence==SEEK_SET) off=p;
  else if (whence==SEEK_CUR) off+=p;
  else if (whence==SEEK_END) {
    off=p;
    for (unsigned i=0; i<sz.size(); ++i) off+=sz[i];
  }
  if (sz.size()==1) {
    fseeko(fp, off, SEEK_SET);
    return;
  }
  assert(sz.size()>1);
  int64_t sum=0;
  unsigned i;
  for (i=0;; ++i) {
    sum+=sz[i];
    if (sum>off || i+1>=sz.size()) break;
  }
  const string next=subpart(fn, i+1);
  fclose(fp);
  fp=fopen(next.c_str(), RB);
  if (fp==FPNULL) ioerr(next.c_str());
  fseeko(fp, off-sum, SEEK_END);
}
InputArchive::InputArchive(const char* filename, const char* password):
     fn(filename) {
  assert(filename);
  off=0;
  const string part0=subpart(filename, 0);
  for (unsigned i=1; ; ++i) {
    const string parti=subpart(filename, i);
    if (i>1 && parti==part0) break;
    fp=fopen(parti.c_str(), RB);
    if (fp==FPNULL) break;
    fseeko(fp, 0, SEEK_END);
    sz.push_back(ftello(fp));
    fclose(fp);
  }
  const string part1=subpart(filename, 1);
  fp=fopen(part1.c_str(), RB);
  if (!isopen()) ioerr(part1.c_str());
  assert(fp!=FPNULL);
  if (password) {
    char salt[32], key[32];
    if (fread(salt, 1, 32, fp)!=32) error("cannot read salt");
    libzpaq::stretchKey(key, password, salt);
    aes=new libzpaq::AES_CTR(key, 32, salt);
    off=32;
  }
}
class OutputArchive: public ArchiveBase, public libzpaq::Writer {
  int64_t off;    
  unsigned ptr;   
  enum {BUFSIZE=1<<16};
  char buf[BUFSIZE];  
public:
  OutputArchive(const char* filename, const char* password=0,
                const char* salt_=0, int64_t off_=0);
  void flush() {
    assert(fp!=FPNULL);
    if (aes) aes->encrypt(buf, ptr, ftello(fp)+off);
    fwrite(buf, 1, ptr, fp);
    ptr=0;
  }
  void seek(int64_t p, int whence) {
    if (fp!=FPNULL) {
      flush();
      fseeko(fp, p, whence);
    }
    else if (whence==SEEK_SET) off=p;
    else off+=p;  
  }
  int64_t tell() const {
    if (fp!=FPNULL) return ftello(fp)+ptr;
    else return off;
  }
  void put(int c) {
    if (fp==FPNULL) ++off;
    else {
      if (ptr>=BUFSIZE) flush();
      buf[ptr++]=c;
    }
  }
  void write(const char* ibuf, int len) {
    if (fp==FPNULL) off+=len;
    else while (len-->0) put(*ibuf++);
  }
  void close() {
    if (fp!=FPNULL) {
      flush();
      fclose(fp);
    }
    fp=FPNULL;
  }
};
OutputArchive::OutputArchive(const char* filename, const char* password,
    const char* salt_, int64_t off_): ptr(0) {
  assert(filename);
  off=off_;
  if (!*filename) return;
  char salt[32]={0};
  fp=fopen(filename, RBPLUS);
  if (isopen()) {
    if (off!=0) error("file exists and off > 0");
    if (password) {
      if (fread(salt, 1, 32, fp)!=32) error("cannot read salt");
      if (salt_ && memcmp(salt, salt_, 32)) error("salt mismatch");
    }
    seek(0, SEEK_END);
  }
  else {
    fp=fopen(filename, WB);
    if (!isopen()) ioerr(filename);
    if (password) {
      if (!salt_) error("salt not specified");
      memcpy(salt, salt_, 32);
      if (off==0 && fwrite(salt, 1, 32, fp)!=32) ioerr(filename);
    }
  }
  if (password) {
    char key[32];
    libzpaq::stretchKey(key, password, salt);
    aes=new libzpaq::AES_CTR(key, 32, salt);
  }
}
struct StringWriter: public libzpaq::Writer {
  string s;
  void put(int c) {
    if (s.size()>=65535) error("string too long");
    s+=char(c);
  }
};
static const int64_t HT_BAD=   -0x7FFFFFFFFFFFFFFALL;  
static const int64_t DEFAULT_VERSION=99999999999999LL; 
struct HT 
{
	uint32_t crc32;			
	uint32_t crc32size;
	unsigned char sha1[20]; 
	int usize;      		
	int64_t csize;  		
	HT(const char* s=0, int u=-2) 
	{
		crc32=0;
		crc32size=0;
		csize=0;
		if (s) 
			memcpy(sha1, s, 20);
		else 
			memset(sha1, 0, 20);
		usize=u;
	}
};
struct DTV 
{
  int64_t date;          
  int64_t size;          
  int64_t attr;          
  double csize;          
  vector<unsigned> ptr;  
  int version;           
  DTV(): date(0), size(0), attr(0), csize(0), version(0) {}
};
class franzfs
{
	private:
	public:
	char*		data;
	uint64_t	filesize;
	uint64_t 	position;
	size_t ramread(size_t i_size,char* o_ptr)
	{
		if (o_ptr==NULL)
			return 0;
		if (i_size==0)
			return 0;
		if (!data)
		{
			myprintf("22938: Guru data is null\n");
			return 0; 
		}
		if ((position+i_size)>filesize)
			i_size=filesize-position;
		memcpy(o_ptr,data+position,i_size);
		position+=i_size;
		return i_size;
	}
	size_t ramwrite(uint64_t i_offset,char* i_ptr, size_t i_size)
	{
		if (i_offset>filesize)
		{
			myprintf("22953: i_offset greater then filesize %s %s\n",migliaia(i_offset),migliaia2(filesize));
			return 0;
		}
		if (i_ptr==NULL)
			return 0;
		if (i_size==0)
			return 0;
		if (!data)
		{
			myprintf("35254: Guru data is null\n");
			return 0; 
		}
		position=i_offset;
		if (position+i_size>filesize)
		{
			myprintf("35248: cannot write beyond size %s %s %s\n",migliaia(position),migliaia2(i_size),migliaia3(filesize));
			return 0;
		}
		memcpy(data+position,i_ptr,i_size);
		position+=i_size;
		return i_size;
	}
	franzfs(){data=NULL;position=0;}
	bool init(int64_t i_size) 
	{
		data=(char*)malloc(i_size);
		if (data==NULL)
		{
			myprintf("35250: GURU on malloc\n");
			return false;
		}
		memset(data,0,i_size); 
		g_ramdisksize+=i_size;
		filesize=i_size;
		if (flagdebug)
			myprintf("23000: allocated %21s\n",migliaia(i_size));
		return true;
	}
	bool reset() 
	{
		if (data==NULL)
		{
			myprintf("23001: GURU on reset\n");
			return false;
		}
		if (filesize==0)
		{
			myprintf("23006: GURU on filesize\n");
			return false;
		}
		free(data);
		g_ramdisksize-=filesize;
		filesize=0;
		if (flagdebug)
			myprintf("Deallocati  %s\n",migliaia(filesize));
		return true;
	}
};
#define	FIX_TOOLONG 	1;
#define	FIX_ADS 		2;
#define	FIX_UTF8		4;
#define FIX_RESERVED 	8;
#define FIX_WINDOWSPATH	16;
#define	FIX_WINDOWSUNC	32;
struct DT   
{
	int64_t date;          	
	int64_t size;          	
	int64_t attr;          	
	int64_t data;          	
	vector<unsigned> ptr;  	
	vector<DTV> dtv;       	
	int written;           	
	string outputname;		
	string hexhash;			
	string hashtype;		
	char 			franz_block[FRANZOFFSETSHA256];
	int				franz_block_size;
	uint32_t 		file_crc32;
	int64_t			hashedsize;
	int		chunk;
	uint32_t		filefix;	
	int64_t			expectedsize;
	bool	forceadd;
	XXH3_state_t	*pfile_xxh3;  
    XXHash64 		*pfile_xxhash64;
	libzpaq::SHA256 *pfile_sha256;
	libzpaq::SHA1 	*pfile_sha1;
	SHA3			*pfile_sha3;
	MD5				*pfile_md5;
	blake3_hasher 	*pfile_blake3;
	franzfs			*pramfile;
	DT(): date(0), size(0), attr(0), data(0),written(-1),franz_block_size(FRANZOFFSETSHA256),file_crc32(0),hashedsize(0),chunk(-1),filefix(0),expectedsize(0),forceadd(false)
	{
		memset(franz_block,0,sizeof(franz_block));
		hexhash	="";
		hashtype="";
		outputname="";
		pfile_xxhash64=NULL;
		if (g_franzotype==FRANZO_XXHASH64)
			pfile_xxhash64=new XXHash64(0);
		pfile_md5=NULL;
		if (g_franzotype==FRANZO_MD5)
			pfile_md5=new MD5;
		pfile_sha1=NULL;
		if (g_franzotype==FRANZO_SHA_1)
			pfile_sha1=new libzpaq::SHA1;
		pfile_sha256=NULL;
		if (g_franzotype==FRANZO_SHA_256)
			pfile_sha256=new libzpaq::SHA256;
		pfile_sha3=NULL;
		if (g_franzotype==FRANZO_SHA3)
			pfile_sha3=new SHA3;
		pfile_xxh3=NULL;
		if (g_franzotype==FRANZO_XXH3)
		{
			pfile_xxh3=(XXH3_state_t*)aligned_malloc(64, sizeof(XXH3_state_t));
			(void)XXH3_128bits_reset(pfile_xxh3);
		}
		pfile_blake3=NULL;
		if (g_franzotype==FRANZO_BLAKE3)
		{
			pfile_blake3=(blake3_hasher*)malloc(sizeof(blake3_hasher));
			blake3_hasher_init(pfile_blake3);
		}
		pramfile=NULL;
	}
};
typedef map<string, DT> DTMap;
struct Block 
{
  int64_t offset;       
  int64_t usize;        
  int64_t bsize;        
  vector<DTMap::iterator> files;  
  unsigned start;       
  unsigned size;        
  unsigned frags;       
  unsigned extracted;   
  enum {READY, WORKING, GOOD, BAD} state;
  Block(unsigned s, int64_t o): offset(o), usize(-1), bsize(0), start(s),
      size(0), frags(0), extracted(0), state(READY) {}
};
struct VER 
{
  int64_t date;          
  int64_t lastdate;      
  int64_t offset;        
  int64_t data_offset;   
  int64_t csize;         
  int updates;           
  int deletes;           
  unsigned firstFragment;
  int64_t usize;         
  VER() {memset(this, 0, sizeof(*this));}
};
class CompressJob;
class Jidac 
{
public:
	int 	doCommand(int argc, const char** argv);
	friend 	ThreadReturn decompressThread(void* arg);
	friend 	ThreadReturn decompressthreadramdisk(void* arg);
	friend 	struct ExtractJob;
	void usageall		(string i_command); 
private:
	string				fullcommandline;
	vector<string> 		results;     	
	string	zpaqfranzexename;
	MAPPAHELP help_map;					
	MAPPAHELP switches_map;	
	string archive;           			
	vector<string> 		files;     		
	vector<int64_t> 	files_size;		
	vector<uint64_t> 	files_count;	
	vector<uint64_t> 	files_time;
	vector<DTMap> 		files_edt;
	int all;                  			
	int fragment;             			
	int summary;              			
	int howmanythreads;              	
	unsigned int menoenne;
	int64_t date;             			
	int64_t version;          			
	string method;            			
	const char* index;        			
	string	plainpassword;
	const char* password;     			
	char password_string[32]; 			
	char new_password_string[32]; 		
	const char* new_password; 			
	string nottype;           			
	string sfxnottype;           		
	vector<string> notfiles;  			
	vector<string> sfxnotfiles;  		
	vector<string> tofiles;   			
	vector<string> onlyfiles; 			
	vector<string> chunkfiles; 			
	vector<string> sfxonlyfiles; 		
	vector<string> alwaysfiles; 		
	string repack;       				
	map<int, string> mappacommenti;
	string versioncomment;
	bool flagnoattributes;        		
	bool flagforce;               		
	bool flagcomment;
	bool flagtest;
	bool flagskipzfs;
	bool flagnoqnap;					
	bool flagforcewindows;        		
	bool flagnopath;					
	bool flagnosort;              		
	bool flagnochecksum;				
	uint32_t filelength;
	uint32_t dirlength;
	string searchfrom;					
	string replaceto;					
	string searchhash;
	int64_t dhsize;           			
	int64_t dcsize;           			
	vector<HT> ht;            			
	DTMap dt;                 			
	DTMap edt;                			
	vector<Block> block;      			
	vector<VER> ver;          			
	int add();                			
	int extract();            			
	int setpassword();					
	int extractw();            			
	int info();							
	int list();               			
	int zpaqdirsize();               	
	int testverify();					
	int kill();							
	int utf();							
	int test();           				
	int verify(bool i_readfile);        
	int consolidate(string i_archive);	
	int summa();						
	int decimation();					
	int deduplicate();					
	int paranoid();						
	int fillami();						
	int dir();							
	int robocopy();						
	int mycopy();						
	int zero();							
	int trim();							
	int rd();							
	int purgersync();					
	int sfx();							
	int dircompare(bool i_flagonlysize,bool i_flagrobocopy);
	int benchmark();
	int	zfs(string command);
	int windowsc();						
	int adminrun();						
	void load_help_map	();					
	void helphelp		();        			
	void usage			();        			
	void examples		(string i_command);	
	void join_split();
	void	reset();
	void 	printsanitizeflags();
	string 	rename(string name);           
	int64_t read_archive(const char* arc, int *errors=0, int i_myappend=0,bool i_quiet=false);  
	bool 	isselected(const char* filename, bool rn,int64_t i_size);
	void 	scandir(bool i_checkifselected,DTMap& i_edt,string filename, bool i_recursive=true);        
	void 	addfile(bool i_checkifselected,DTMap& i_edt,string filename, int64_t edate, int64_t esize,int64_t eattr);          
	int64_t franzparallelscandir(bool i_flaghash,bool i_recursive,bool i_forcedir);
	bool 	equal(DTMap::const_iterator p, const char* filename, uint32_t &o_crc32,string i_myhashtype,string i_myhash,string& o_hash);
	void 	write715attr(libzpaq::StringBuffer& i_sb, uint64_t i_data, unsigned int i_quanti);
	void 	writefranzattr(libzpaq::StringBuffer& i_sb, uint64_t i_data, unsigned int i_quanti,string i_filename,uint32_t i_crc32fromfragments,uint32_t i_crc32,string i_thehash);
	int 	enumeratecomments();
	int 	searchcomments(string i_testo,vector<DTMap::iterator> &filelist);
	string 	zfs_get_snaplist(string i_header,string i_footer,vector<string>& o_array_primachiocciola,vector<string>& o_array_dopochiocciola);
	string 	sanitizzanomefile(string i_filename,int i_filelength,int& io_collisioni,MAPPAFILEHASH& io_mappacollisioni);
	void 	getpasswordifempty();
	string 	getpasswordblind();
	string 	getpassword();
	int		writesfxmodule(string i_filename);
	int 	decompress_sfx_to_file(FILE* i_outfile);
	int 	extractqueue2(int i_chunk,int i_chunksize);
	int 	multiverify(vector <s_fileandsize>& i_arrayfilename);
	bool 	removetempdirifempty(string i_folder,bool i_deleteifsizezero);
	void 	handleflaglongpath();
	bool 	getfoldersize(string i_folder,uint64_t& o_totalsize,uint32_t & o_totalfile,uint32_t& o_totalfolder,uint32_t& o_longfiles);
	uint64_t hashastringa(string& i_string);
	uint32_t casekollision(DTMap& i_dtmap,vector<string>& o_collisions,bool i_fix);
	void 	changedtmapkey(string i_oldkey,string i_newkey);
	int 	removeemptydirs(string i_folder,bool i_kill);
	int 	writeresource(string i_filename,bool i_force,const char* i_mime64);
	int 	decompress_mime64_to_file(FILE* i_outfile,const char* i_mime64);
	int 	hashselect();
};
uint64_t Jidac::hashastringa(string& i_string)
{
	uint64_t myseed = 0;
	XXHash64 myhash(myseed);
	myhash.add(i_string.c_str(),i_string.size());
	return myhash.hash();
}
void Jidac::changedtmapkey(string i_oldkey,string i_newkey)
{
	DTMap::iterator myp=dt.find(i_oldkey);
	if (myp==dt.end())
		return;
	DT olddt=myp->second;
	dt[i_newkey]=olddt;
	myp->second.date=0;		
}
uint32_t Jidac::casekollision(DTMap& i_dtmap,vector<string>& o_collisions,bool i_fix=false)
{
	int64_t	startkoll=mtime();
	if (flagverbose)
		myprintf("Case-collision checks on %s files ",migliaia(i_dtmap.size()));
	uint32_t fixed=0;
	o_collisions.clear();
	vector<uint64_t>	hashedstrings;
	for (DTMap::iterator p=i_dtmap.begin(); p!=i_dtmap.end(); p++) 
		if (all || p->second.date)
		{
			string		fn			=rename(p->first);
			string 		filename	=stringtolower(fn);
			uint64_t hashato=hashastringa(filename);
			if (binary_search(hashedstrings.begin(),hashedstrings.end(),hashato)==true)
			{
				if (i_fix)
				{
					char	buf[10];
					string 	percorso	=extractfilepath(fn);
					string	nomefile	=prendinomefileebasta(fn);
					string	estensione	=prendiestensione(fn);
					int		iterazione	=1;
					string	rifatto		="";
					do
					{
						sprintf(buf,"_%08d",iterazione++);
						if (percorso!="")
							rifatto=percorso;
						string pezzetto=buf;
						if (nomefile!="")
							rifatto+=nomefile+buf;
						if (estensione!="")
							rifatto+="."+estensione;
						hashato=hashastringa(rifatto);
						if (binary_search(hashedstrings.begin(),hashedstrings.end(),hashato)==false)
							break;
					}
					while (iterazione<1000);
					if (iterazione<1000)
					{
						changedtmapkey(p->first,rifatto);
						fixed++;
					}
					else
					{
						myprintf("23507: ERROR IMPOSSIBLE TO 'DECASE' ");
						printUTF8(filename.c_str());
						myprintf("\n");
					}
				}
				else
					o_collisions.push_back(fn);
			}
			else
			{
				auto it = std::upper_bound(hashedstrings.cbegin(),hashedstrings.cend(),hashato); 
				hashedstrings.insert(it,hashato);
			}
		}
	int64_t	endkoll=mtime();
	if (flagverbose)
		myprintf("done in %.2fs\n",(endkoll-startkoll)*0.001);
	return (fixed);
}
void Jidac::join_split() 
{
}
string Jidac::getpasswordblind()
{
	string myresult="";
	myprintf("\nEnter password :");
	char carattere;
	while (1)
	{
		carattere=getchar();
		if (carattere==10)
			break;
		myresult+=carattere;
	}
	myprintf("\n");
	return myresult;
}
void Jidac::getpasswordifempty()
{
	if (password==NULL)
		if (check_if_password(archive))
		{
			myprintf("Archive seems encrypted (or corrupted)");
			string spassword=getpasswordblind();
			if (spassword!="")
			{
				libzpaq::SHA256 sha256;
				for (unsigned int i=0;i<spassword.size();i++)
					sha256.put(spassword[i]);
				memcpy(password_string, sha256.result(), 32);
				password=password_string;
			}
		}
}	
void Jidac::reset()
{
	g_freeze="";
	files_size.clear();
	files_count.clear();
	files_time.clear();
	files_edt.clear();
	ver.clear();
	block.clear();
	dt.clear();
	ht.clear();
	edt.clear();
	ht.resize(1);  
	ver.resize(1); 
	dhsize=dcsize=0;
	tofiles.clear();
	files.clear();
}
int Jidac::paranoid() 
{
	unz(archive.c_str(), password);
	return 0;
}
extern void unzerror(const char* msg);
class unzReader {
public:
  virtual int get() = 0;  
  virtual ~unzReader() {}
};
class unzWriter {
public:
  virtual void put(int c) = 0;  
  virtual ~unzWriter() {}
};
template <typename T>
class Array {
  T *data;     
  size_t n;    
  int offset;  
  void operator=(const Array&);  
  Array(const Array&);  
public:
  Array(size_t sz=0, int ex=0): data(0), n(0), offset(0) {
    resize(sz, ex);} 
  void resize(size_t sz, int ex=0); 
  ~Array() {resize(0);}  
  size_t size() const {return n;}  
  int isize() const {return int(n);}  
  T& operator[](size_t i) {assert(n>0 && i<n); return data[i];}
  T& operator()(size_t i) {assert(n>0 && (n&(n-1))==0); return data[i&(n-1)];}
};
template<typename T>
void Array<T>::resize(size_t sz, int ex) {
  assert(size_t(-1)>0);  
  while (ex>0) {
    if (sz>sz*2) unzerror("Array too big");
    sz*=2, --ex;
  }
  if (n>0) {
    assert(offset>=0 && offset<=64);
    assert((char*)data-offset);
    free((char*)data-offset);
  }
  n=0;
  if (sz==0) return;
  n=sz;
  const size_t nb=128+n*sizeof(T);  
  if (nb<=128 || (nb-128)/sizeof(T)!=n) unzerror("Array too big");
  data=(T*)calloc(nb, 1);
  if (!data) unzerror("out of memory");
  offset=64-(((char*)data-(char*)0)&63);
  assert(offset>0 && offset<=64);
  data=(T*)((char*)data+offset);
}
class unzSHA1 {
public:
  void put(int c) {  
    uint32_t& r=w[len0>>5&15];
    r=(r<<8)|(c&255);
    if (!(len0+=8)) ++len1;
    if ((len0&511)==0) process();
  }
  double size() const {return len0/8+len1*536870912.0;} 
  const char* result();  
  unzSHA1() {init();}
private:
  void init();      
  uint32_t len0, len1;   
  uint32_t h[5];         
  uint32_t w[80];        
  char hbuf[20];    
  void process();   
};
void unzSHA1::init() {
  len0=len1=0;
  h[0]=0x67452301;
  h[1]=0xEFCDAB89;
  h[2]=0x98BADCFE;
  h[3]=0x10325476;
  h[4]=0xC3D2E1F0;
}
const char* unzSHA1::result() {
  const uint32_t s1=len1, s0=len0;
  put(0x80);
  while ((len0&511)!=448)
    put(0);
  put(s1>>24);
  put(s1>>16);
  put(s1>>8);
  put(s1);
  put(s0>>24);
  put(s0>>16);
  put(s0>>8);
  put(s0);
  for (int i=0; i<5; ++i) {
    hbuf[4*i]=h[i]>>24;
    hbuf[4*i+1]=h[i]>>16;
    hbuf[4*i+2]=h[i]>>8;
    hbuf[4*i+3]=h[i];
  }
  init();
  return hbuf;
}
void unzSHA1::process() {
  for (int i=16; i<80; ++i) {
    w[i]=w[i-3]^w[i-8]^w[i-14]^w[i-16];
    w[i]=w[i]<<1|w[i]>>31;
  }
  uint32_t a=h[0];
  uint32_t b=h[1];
  uint32_t c=h[2];
  uint32_t d=h[3];
  uint32_t e=h[4];
  const uint32_t k1=0x5A827999, k2=0x6ED9EBA1, k3=0x8F1BBCDC, k4=0xCA62C1D6;
#define f1(a,b,c,d,e,i) e+=(a<<5|a>>27)+((b&c)|(~b&d))+k1+w[i]; b=b<<30|b>>2;
#define f5(i) f1(a,b,c,d,e,i) f1(e,a,b,c,d,i+1) f1(d,e,a,b,c,i+2) \
              f1(c,d,e,a,b,i+3) f1(b,c,d,e,a,i+4)
  f5(0) f5(5) f5(10) f5(15)
#undef f1
#define f1(a,b,c,d,e,i) e+=(a<<5|a>>27)+(b^c^d)+k2+w[i]; b=b<<30|b>>2;
  f5(20) f5(25) f5(30) f5(35)
#undef f1
#define f1(a,b,c,d,e,i) e+=(a<<5|a>>27)+((b&c)|(b&d)|(c&d))+k3+w[i]; \
        b=b<<30|b>>2;
  f5(40) f5(45) f5(50) f5(55)
#undef f1
#define f1(a,b,c,d,e,i) e+=(a<<5|a>>27)+(b^c^d)+k4+w[i]; b=b<<30|b>>2;
  f5(60) f5(65) f5(70) f5(75)
#undef f1
#undef f5
  h[0]+=a;
  h[1]+=b;
  h[2]+=c;
  h[3]+=d;
  h[4]+=e;
}
class unzSHA256 {
public:
  void put(int c) {  
    unsigned& r=w[len0>>5&15];
    r=(r<<8)|(c&255);
    if (!(len0+=8)) ++len1;
    if ((len0&511)==0) process();
  }
  double size() const {return len0/8+len1*536870912.0;} 
  uint64_t usize() const {return len0/8+(uint64_t(len1)<<29);} 
  const char* result();  
  unzSHA256() {init();}
private:
  void init();           
  unsigned len0, len1;   
  unsigned s[8];         
  unsigned w[16];        
  char hbuf[32];         
  void process();        
};
void unzSHA256::init() {
  len0=len1=0;
  s[0]=0x6a09e667;
  s[1]=0xbb67ae85;
  s[2]=0x3c6ef372;
  s[3]=0xa54ff53a;
  s[4]=0x510e527f;
  s[5]=0x9b05688c;
  s[6]=0x1f83d9ab;
  s[7]=0x5be0cd19;
  memset(w, 0, sizeof(w));
}
void unzSHA256::process() {
  #define ror(a,b) ((a)>>(b)|(a<<(32-(b))))
  #define m(i) \
     w[(i)&15]+=w[(i-7)&15] \
       +(ror(w[(i-15)&15],7)^ror(w[(i-15)&15],18)^(w[(i-15)&15]>>3)) \
       +(ror(w[(i-2)&15],17)^ror(w[(i-2)&15],19)^(w[(i-2)&15]>>10))
  #define r(a,b,c,d,e,f,g,h,i) { \
    unsigned t1=ror(e,14)^e; \
    t1=ror(t1,5)^e; \
    h+=ror(t1,6)+((e&f)^(~e&g))+k[i]+w[(i)&15]; } \
    d+=h; \
    {unsigned t1=ror(a,9)^a; \
    t1=ror(t1,11)^a; \
    h+=ror(t1,2)+((a&b)^(c&(a^b))); }
  #define mr(a,b,c,d,e,f,g,h,i) m(i); r(a,b,c,d,e,f,g,h,i);
  #define r8(i) \
    r(a,b,c,d,e,f,g,h,i);   \
    r(h,a,b,c,d,e,f,g,i+1); \
    r(g,h,a,b,c,d,e,f,i+2); \
    r(f,g,h,a,b,c,d,e,i+3); \
    r(e,f,g,h,a,b,c,d,i+4); \
    r(d,e,f,g,h,a,b,c,i+5); \
    r(c,d,e,f,g,h,a,b,i+6); \
    r(b,c,d,e,f,g,h,a,i+7);
  #define mr8(i) \
    mr(a,b,c,d,e,f,g,h,i);   \
    mr(h,a,b,c,d,e,f,g,i+1); \
    mr(g,h,a,b,c,d,e,f,i+2); \
    mr(f,g,h,a,b,c,d,e,i+3); \
    mr(e,f,g,h,a,b,c,d,i+4); \
    mr(d,e,f,g,h,a,b,c,i+5); \
    mr(c,d,e,f,g,h,a,b,i+6); \
    mr(b,c,d,e,f,g,h,a,i+7);
  static const unsigned k[64]={
    0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5,
    0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
    0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3,
    0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
    0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc,
    0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
    0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7,
    0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
    0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13,
    0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
    0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3,
    0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
    0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5,
    0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
    0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208,
    0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2};
  unsigned a=s[0];
  unsigned b=s[1];
  unsigned c=s[2];
  unsigned d=s[3];
  unsigned e=s[4];
  unsigned f=s[5];
  unsigned g=s[6];
  unsigned h=s[7];
  r8(0);
  r8(8);
  mr8(16);
  mr8(24);
  mr8(32);
  mr8(40);
  mr8(48);
  mr8(56);
  s[0]+=a;
  s[1]+=b;
  s[2]+=c;
  s[3]+=d;
  s[4]+=e;
  s[5]+=f;
  s[6]+=g;
  s[7]+=h;
  #undef mr8
  #undef r8
  #undef mr
  #undef r
  #undef m
  #undef ror
}
const char* unzSHA256::result() {
  const unsigned s1=len1, s0=len0;
  put(0x80);
  while ((len0&511)!=448) put(0);
  put(s1>>24);
  put(s1>>16);
  put(s1>>8);
  put(s1);
  put(s0>>24);
  put(s0>>16);
  put(s0>>8);
  put(s0);
  for (int i=0; i<8; ++i) {
    hbuf[4*i]=s[i]>>24;
    hbuf[4*i+1]=s[i]>>16;
    hbuf[4*i+2]=s[i]>>8;
    hbuf[4*i+3]=s[i];
  }
  init();
  return hbuf;
}
class unzAES_CTR {
  uint32_t Te0[256], Te1[256], Te2[256], Te3[256], Te4[256]; 
  uint32_t ek[60];  
  int Nr;  
  uint32_t iv0, iv1;  
public:
  unzAES_CTR(const char* key, int keylen, const char* iv=0);
  void encrypt(uint32_t s0, uint32_t s1, uint32_t s2, uint32_t s3, unsigned char* ct);
  void encrypt(char* unzBuf, int n, uint64_t offset);  
};
#define Te4_0 0x000000FF & Te4
#define Te4_1 0x0000FF00 & Te4
#define Te4_2 0x00FF0000 & Te4
#define Te4_3 0xFF000000 & Te4
static inline unsigned unzbyte(unsigned x, unsigned n) {return (x>>(8*n))&255;}
static inline void LOAD32H(uint32_t& x, const char* y) {
  const unsigned char* u=(const unsigned char*)y;
  x=u[0]<<24|u[1]<<16|u[2]<<8|u[3];
}
static inline void STORE32H(uint32_t& x, unsigned char* y) {
  y[0]=x>>24;
  y[1]=x>>16;
  y[2]=x>>8;
  y[3]=x;
}
#define setup_mix(temp) \
  ((Te4_3[unzbyte(temp, 2)]) ^ (Te4_2[unzbyte(temp, 1)]) ^ \
   (Te4_1[unzbyte(temp, 0)]) ^ (Te4_0[unzbyte(temp, 3)]))
unzAES_CTR::unzAES_CTR(const char* key, int keylen, const char* iv) {
  assert(key  != NULL);
  assert(keylen==16 || keylen==24 || keylen==32);
  iv0=iv1=0;
  if (iv) {
    LOAD32H(iv0, iv);
    LOAD32H(iv1, iv+4);
  }
  for (int i=0; i<256; ++i) {
    unsigned s1=
    "\x63\x7c\x77\x7b\xf2\x6b\x6f\xc5\x30\x01\x67\x2b\xfe\xd7\xab\x76"
    "\xca\x82\xc9\x7d\xfa\x59\x47\xf0\xad\xd4\xa2\xaf\x9c\xa4\x72\xc0"
    "\xb7\xfd\x93\x26\x36\x3f\xf7\xcc\x34\xa5\xe5\xf1\x71\xd8\x31\x15"
    "\x04\xc7\x23\xc3\x18\x96\x05\x9a\x07\x12\x80\xe2\xeb\x27\xb2\x75"
    "\x09\x83\x2c\x1a\x1b\x6e\x5a\xa0\x52\x3b\xd6\xb3\x29\xe3\x2f\x84"
    "\x53\xd1\x00\xed\x20\xfc\xb1\x5b\x6a\xcb\xbe\x39\x4a\x4c\x58\xcf"
    "\xd0\xef\xaa\xfb\x43\x4d\x33\x85\x45\xf9\x02\x7f\x50\x3c\x9f\xa8"
    "\x51\xa3\x40\x8f\x92\x9d\x38\xf5\xbc\xb6\xda\x21\x10\xff\xf3\xd2"
    "\xcd\x0c\x13\xec\x5f\x97\x44\x17\xc4\xa7\x7e\x3d\x64\x5d\x19\x73"
    "\x60\x81\x4f\xdc\x22\x2a\x90\x88\x46\xee\xb8\x14\xde\x5e\x0b\xdb"
    "\xe0\x32\x3a\x0a\x49\x06\x24\x5c\xc2\xd3\xac\x62\x91\x95\xe4\x79"
    "\xe7\xc8\x37\x6d\x8d\xd5\x4e\xa9\x6c\x56\xf4\xea\x65\x7a\xae\x08"
    "\xba\x78\x25\x2e\x1c\xa6\xb4\xc6\xe8\xdd\x74\x1f\x4b\xbd\x8b\x8a"
    "\x70\x3e\xb5\x66\x48\x03\xf6\x0e\x61\x35\x57\xb9\x86\xc1\x1d\x9e"
    "\xe1\xf8\x98\x11\x69\xd9\x8e\x94\x9b\x1e\x87\xe9\xce\x55\x28\xdf"
    "\x8c\xa1\x89\x0d\xbf\xe6\x42\x68\x41\x99\x2d\x0f\xb0\x54\xbb\x16"
    [i]&255;
    unsigned s2=s1<<1;
    if (s2>=0x100) s2^=0x11b;
    unsigned s3=s1^s2;
    Te0[i]=s2<<24|s1<<16|s1<<8|s3;
    Te1[i]=s3<<24|s2<<16|s1<<8|s1;
    Te2[i]=s1<<24|s3<<16|s2<<8|s1;
    Te3[i]=s1<<24|s1<<16|s3<<8|s2;
    Te4[i]=s1<<24|s1<<16|s1<<8|s1;
  }
  Nr = 10 + ((keylen/8)-2)*2;  
  int i = 0;
  uint32_t* rk = &ek[0];
  uint32_t temp;
  static const uint32_t rcon[10] = {
    0x01000000UL, 0x02000000UL, 0x04000000UL, 0x08000000UL,
    0x10000000UL, 0x20000000UL, 0x40000000UL, 0x80000000UL,
    0x1B000000UL, 0x36000000UL};  
  LOAD32H(rk[0], key   );
  LOAD32H(rk[1], key +  4);
  LOAD32H(rk[2], key +  8);
  LOAD32H(rk[3], key + 12);
  if (keylen == 16) {
    for (;;) {
      temp  = rk[3];
      rk[4] = rk[0] ^ setup_mix(temp) ^ rcon[i];
      rk[5] = rk[1] ^ rk[4];
      rk[6] = rk[2] ^ rk[5];
      rk[7] = rk[3] ^ rk[6];
      if (++i == 10) {
         break;
      }
      rk += 4;
    }
  }
  else if (keylen == 24) {
    LOAD32H(rk[4], key + 16);
    LOAD32H(rk[5], key + 20);
    for (;;) {
      temp = rk[5];
      rk[ 6] = rk[ 0] ^ setup_mix(temp) ^ rcon[i];
      rk[ 7] = rk[ 1] ^ rk[ 6];
      rk[ 8] = rk[ 2] ^ rk[ 7];
      rk[ 9] = rk[ 3] ^ rk[ 8];
      if (++i == 8) {
        break;
      }
      rk[10] = rk[ 4] ^ rk[ 9];
      rk[11] = rk[ 5] ^ rk[10];
      rk += 6;
    }
  }
  else if (keylen == 32) {
    LOAD32H(rk[4], key + 16);
    LOAD32H(rk[5], key + 20);
    LOAD32H(rk[6], key + 24);
    LOAD32H(rk[7], key + 28);
    for (;;) {
      temp = rk[7];
      rk[ 8] = rk[ 0] ^ setup_mix(temp) ^ rcon[i];
      rk[ 9] = rk[ 1] ^ rk[ 8];
      rk[10] = rk[ 2] ^ rk[ 9];
      rk[11] = rk[ 3] ^ rk[10];
      if (++i == 7) {
        break;
      }
      temp = rk[11];
      rk[12] = rk[ 4] ^ setup_mix(temp<<24|temp>>8);
      rk[13] = rk[ 5] ^ rk[12];
      rk[14] = rk[ 6] ^ rk[13];
      rk[15] = rk[ 7] ^ rk[14];
      rk += 8;
    }
  }
}
void unzAES_CTR::encrypt(uint32_t s0, uint32_t s1, uint32_t s2, uint32_t s3, unsigned char* ct) {
  int r = Nr >> 1;
  uint32_t *rk = &ek[0];
  uint32_t t0=0, t1=0, t2=0, t3=0;
  s0 ^= rk[0];
  s1 ^= rk[1];
  s2 ^= rk[2];
  s3 ^= rk[3];
  for (;;) {
    t0 =
      Te0[unzbyte(s0, 3)] ^
      Te1[unzbyte(s1, 2)] ^
      Te2[unzbyte(s2, 1)] ^
      Te3[unzbyte(s3, 0)] ^
      rk[4];
    t1 =
      Te0[unzbyte(s1, 3)] ^
      Te1[unzbyte(s2, 2)] ^
      Te2[unzbyte(s3, 1)] ^
      Te3[unzbyte(s0, 0)] ^
      rk[5];
    t2 =
      Te0[unzbyte(s2, 3)] ^
      Te1[unzbyte(s3, 2)] ^
      Te2[unzbyte(s0, 1)] ^
      Te3[unzbyte(s1, 0)] ^
      rk[6];
    t3 =
      Te0[unzbyte(s3, 3)] ^
      Te1[unzbyte(s0, 2)] ^
      Te2[unzbyte(s1, 1)] ^
      Te3[unzbyte(s2, 0)] ^
      rk[7];
    rk += 8;
    if (--r == 0) {
      break;
    }
    s0 =
      Te0[unzbyte(t0, 3)] ^
      Te1[unzbyte(t1, 2)] ^
      Te2[unzbyte(t2, 1)] ^
      Te3[unzbyte(t3, 0)] ^
      rk[0];
    s1 =
      Te0[unzbyte(t1, 3)] ^
      Te1[unzbyte(t2, 2)] ^
      Te2[unzbyte(t3, 1)] ^
      Te3[unzbyte(t0, 0)] ^
      rk[1];
    s2 =
      Te0[unzbyte(t2, 3)] ^
      Te1[unzbyte(t3, 2)] ^
      Te2[unzbyte(t0, 1)] ^
      Te3[unzbyte(t1, 0)] ^
      rk[2];
    s3 =
      Te0[unzbyte(t3, 3)] ^
      Te1[unzbyte(t0, 2)] ^
      Te2[unzbyte(t1, 1)] ^
      Te3[unzbyte(t2, 0)] ^
      rk[3];
  }
  s0 =
    (Te4_3[unzbyte(t0, 3)]) ^
    (Te4_2[unzbyte(t1, 2)]) ^
    (Te4_1[unzbyte(t2, 1)]) ^
    (Te4_0[unzbyte(t3, 0)]) ^
    rk[0];
  STORE32H(s0, ct);
  s1 =
    (Te4_3[unzbyte(t1, 3)]) ^
    (Te4_2[unzbyte(t2, 2)]) ^
    (Te4_1[unzbyte(t3, 1)]) ^
    (Te4_0[unzbyte(t0, 0)]) ^
    rk[1];
  STORE32H(s1, ct+4);
  s2 =
    (Te4_3[unzbyte(t2, 3)]) ^
    (Te4_2[unzbyte(t3, 2)]) ^
    (Te4_1[unzbyte(t0, 1)]) ^
    (Te4_0[unzbyte(t1, 0)]) ^
    rk[2];
  STORE32H(s2, ct+8);
  s3 =
    (Te4_3[unzbyte(t3, 3)]) ^
    (Te4_2[unzbyte(t0, 2)]) ^
    (Te4_1[unzbyte(t1, 1)]) ^
    (Te4_0[unzbyte(t2, 0)]) ^ 
    rk[3];
  STORE32H(s3, ct+12);
}
void unzAES_CTR::encrypt(char* unzBuf, int n, uint64_t offset) {
  for (uint64_t i=offset/16; i<=(offset+n)/16; ++i) {
    unsigned char ct[16];
    encrypt(iv0, iv1, i>>32, i, ct);
    for (int j=0; j<16; ++j) {
      const int k=i*16-offset+j;
      if (k>=0 && k<n)
        unzBuf[k]^=ct[j];
    }
  }
}
#undef setup_mix
#undef Te4_3
#undef Te4_2
#undef Te4_1
#undef Te4_0
static void unzpbkdf2(const char* pw, int pwLen, const char* salt, int saltLen,
                    char* unzBuf, int dkLen) {
  assert(dkLen%32==0);
  assert(pwLen<=64);
  unzSHA256 sha256;
  char b[32];
  for (int i=1; i*32<=dkLen; ++i) {
    for (int j=0; j<pwLen; ++j) sha256.put(pw[j]^0x36);
    for (int j=pwLen; j<64; ++j) sha256.put(0x36);
    for (int j=0; j<saltLen; ++j) sha256.put(salt[j]);
    for (int j=24; j>=0; j-=8) sha256.put(i>>j);
    memcpy(b, sha256.result(), 32);
    for (int j=0; j<pwLen; ++j) sha256.put(pw[j]^0x5c);
    for (int j=pwLen; j<64; ++j) sha256.put(0x5c);
    for (int j=0; j<32; ++j) sha256.put(b[j]);
    memcpy(unzBuf+i*32-32, sha256.result(), 32);
  }
}
static void salsa8(uint32_t* b) {
  unsigned x[16]={0};
  memcpy(x, b, 64);
  for (int i=0; i<4; ++i) {
    #define R(a,b) (((a)<<(b))+((a)>>(32-b)))
    x[ 4] ^= R(x[ 0]+x[12], 7);  x[ 8] ^= R(x[ 4]+x[ 0], 9);
    x[12] ^= R(x[ 8]+x[ 4],13);  x[ 0] ^= R(x[12]+x[ 8],18);
    x[ 9] ^= R(x[ 5]+x[ 1], 7);  x[13] ^= R(x[ 9]+x[ 5], 9);
    x[ 1] ^= R(x[13]+x[ 9],13);  x[ 5] ^= R(x[ 1]+x[13],18);
    x[14] ^= R(x[10]+x[ 6], 7);  x[ 2] ^= R(x[14]+x[10], 9);
    x[ 6] ^= R(x[ 2]+x[14],13);  x[10] ^= R(x[ 6]+x[ 2],18);
    x[ 3] ^= R(x[15]+x[11], 7);  x[ 7] ^= R(x[ 3]+x[15], 9);
    x[11] ^= R(x[ 7]+x[ 3],13);  x[15] ^= R(x[11]+x[ 7],18);
    x[ 1] ^= R(x[ 0]+x[ 3], 7);  x[ 2] ^= R(x[ 1]+x[ 0], 9);
    x[ 3] ^= R(x[ 2]+x[ 1],13);  x[ 0] ^= R(x[ 3]+x[ 2],18);
    x[ 6] ^= R(x[ 5]+x[ 4], 7);  x[ 7] ^= R(x[ 6]+x[ 5], 9);
    x[ 4] ^= R(x[ 7]+x[ 6],13);  x[ 5] ^= R(x[ 4]+x[ 7],18);
    x[11] ^= R(x[10]+x[ 9], 7);  x[ 8] ^= R(x[11]+x[10], 9);
    x[ 9] ^= R(x[ 8]+x[11],13);  x[10] ^= R(x[ 9]+x[ 8],18);
    x[12] ^= R(x[15]+x[14], 7);  x[13] ^= R(x[12]+x[15], 9);
    x[14] ^= R(x[13]+x[12],13);  x[15] ^= R(x[14]+x[13],18);
    #undef R
  }
  for (int i=0; i<16; ++i) b[i]+=x[i];
}
static void blockmix(uint32_t* b, int r) {
  assert(r<=8);
  uint32_t x[16];
  uint32_t y[256];
  memcpy(x, b+32*r-16, 64);
  for (int i=0; i<2*r; ++i) {
    for (int j=0; j<16; ++j) x[j]^=b[i*16+j];
    salsa8(x);
    memcpy(&y[i*16], x, 64);
  }
  for (int i=0; i<r; ++i) memcpy(b+i*16, &y[i*32], 64);
  for (int i=0; i<r; ++i) memcpy(b+(i+r)*16, &y[i*32+16], 64);
}
static void smix(char* b, int r, int n) {
  Array<uint32_t> x(32*r), v(32*r*n);
  for (int i=0; i<r*128; ++i) x[i/4]+=(b[i]&255)<<i%4*8;
  for (int i=0; i<n; ++i) {
    memcpy(&v[i*r*32], &x[0], r*128);
    blockmix(&x[0], r);
  }
  for (int i=0; i<n; ++i) {
    uint32_t j=x[(2*r-1)*16]&(n-1);
    for (int k=0; k<r*32; ++k) x[k]^=v[j*r*32+k];
    blockmix(&x[0], r);
  }
  for (int i=0; i<r*128; ++i) b[i]=x[i/4]>>(i%4*8);
}
void unzscrypt(const char* pw, int pwlen,
            const char* salt, int saltlen,
            int n, int r, int p, char* unzBuf, int buflen) {
  assert(r<=8);
  assert(n>0 && (n&(n-1))==0);  
  Array<char> b(p*r*128);
  unzpbkdf2(pw, pwlen, salt, saltlen,  &b[0], p*r*128);
  for (int i=0; i<p; ++i) smix(&b[i*r*128], r, n);
  unzpbkdf2(pw, pwlen, &b[0], p*r*128,  unzBuf, buflen);
}
void stretchKey(char* out, const char* in, const char* salt) {
  unzscrypt(in, 32, salt, 32, 1<<14, 8, 1, out, 32);
}
typedef enum {NONE,CONS,CM,ICM,MATCH,AVG,MIX2,MIX,ISSE,SSE} CompType;
const int compsize[256]={0,2,3,2,3,4,6,6,3,5};
class unzZPAQL {
public:
  unzZPAQL();
  void clear();           
  void inith();           
  void initp();           
  void run(uint32_t input);    
  int read(unzReader* in2);  
  void outc(int c);       
  unzWriter* output;         
  unzSHA1* sha1;             
  uint32_t H(int i) {return h(i);}  
  Array<uint8_t> header;   
  int cend;           
  int hbegin, hend;   
private:
  Array<uint8_t> m;        
  Array<uint32_t> h;       
  Array<uint32_t> r;       
  uint32_t a, b, c, d;     
  int f;              
  int pc;             
  void init(int hbits, int mbits);  
  int execute();  
  void div(uint32_t x) {if (x) a/=x; else a=0;}
  void mod(uint32_t x) {if (x) a%=x; else a=0;}
  void swap(uint32_t& x) {a^=x; x^=a; a^=x;}
  void swap(uint8_t& x)  {a^=x; x^=a; a^=x;}
  void err();  
};
int unzZPAQL::read(unzReader* in2) {
  int hsize=in2->get();
  if (hsize<0) unzerror("end of header");
  hsize+=in2->get()*256;
  if (hsize<0) unzerror("end of header");
  header.resize(hsize+300);
  cend=hbegin=hend=0;
  header[cend++]=hsize&255;
  header[cend++]=hsize>>8;
  while (cend<7) header[cend++]=in2->get(); 
  int n=header[cend-1];
  for (int i=0; i<n; ++i) {
    int type=in2->get();  
    if (type==-1) unzerror("unexpected end of file");
    header[cend++]=type;  
    int size=compsize[type];
    if (size<1) unzerror("Invalid component type");
    if (cend+size>hsize) unzerror("COMP overflows header");
    for (int j=1; j<size; ++j)
      header[cend++]=in2->get();
  }
  if ((header[cend++]=in2->get())!=0) unzerror("missing COMP END");
  hbegin=hend=cend+128;
  if (hend>hsize+129) unzerror("missing HCOMP");
  while (hend<hsize+129) {
    assert(hend<header.isize()-8);
    int op=in2->get();
    if (op<0) unzerror("unexpected end of file");
    header[hend++]=op;
  }
  if ((header[hend++]=in2->get())!=0) unzerror("missing HCOMP END");
  assert(cend>=7 && cend<header.isize());
  assert(hbegin==cend+128 && hbegin<header.isize());
  assert(hend>hbegin && hend<header.isize());
  assert(hsize==header[0]+256*header[1]);
  assert(hsize==cend-2+hend-hbegin);
  return cend+hend-hbegin;
}
void unzZPAQL::clear() {
  cend=hbegin=hend=0;  
  a=b=c=d=f=pc=0;      
  header.resize(0);
  h.resize(0);
  m.resize(0);
  r.resize(0);
}
unzZPAQL::unzZPAQL() {
  output=0;
  sha1=0;
  clear();
}
void unzZPAQL::inith() {
  assert(header.isize()>6);
  assert(output==0);
  assert(sha1==0);
  init(header[2], header[3]); 
}
void unzZPAQL::initp() {
  assert(header.isize()>6);
  init(header[4], header[5]); 
}
void unzZPAQL::init(int hbits, int mbits) {
  assert(header.isize()>0);
  assert(cend>=7);
  assert(hbegin>=cend+128);
  assert(hend>=hbegin);
  assert(hend<header.isize()-130);
  assert(header[0]+256*header[1]==cend-2+hend-hbegin);
  h.resize(1, hbits);
  m.resize(1, mbits);
  r.resize(256);
  a=b=c=d=pc=f=0;
}
void unzZPAQL::run(uint32_t input) {
  assert(cend>6);
  assert(hbegin>=cend+128);
  assert(hend>=hbegin);
  assert(hend<header.isize()-130);
  assert(m.size()>0);
  assert(h.size()>0);
  assert(header[0]+256*header[1]==cend+hend-hbegin-2);
  pc=hbegin;
  a=input;
  while (execute()) ;
}
void unzZPAQL::outc(int c) {
  if (output) output->put(c);
  if (sha1) sha1->put(c);
}
int unzZPAQL::execute() {
  switch(header[pc++]) {
    case 0: err(); break; 
    case 1: ++a; break; 
    case 2: --a; break; 
    case 3: a = ~a; break; 
    case 4: a = 0; break; 
    case 7: a = r[header[pc++]]; break; 
    case 8: swap(b); break; 
    case 9: ++b; break; 
    case 10: --b; break; 
    case 11: b = ~b; break; 
    case 12: b = 0; break; 
    case 15: b = r[header[pc++]]; break; 
    case 16: swap(c); break; 
    case 17: ++c; break; 
    case 18: --c; break; 
    case 19: c = ~c; break; 
    case 20: c = 0; break; 
    case 23: c = r[header[pc++]]; break; 
    case 24: swap(d); break; 
    case 25: ++d; break; 
    case 26: --d; break; 
    case 27: d = ~d; break; 
    case 28: d = 0; break; 
    case 31: d = r[header[pc++]]; break; 
    case 32: swap(m(b)); break; 
    case 33: ++m(b); break; 
    case 34: --m(b); break; 
    case 35: m(b) = ~m(b); break; 
    case 36: m(b) = 0; break; 
    case 39: if (f) pc+=((header[pc]+128)&255)-127; else ++pc; break; 
    case 40: swap(m(c)); break; 
    case 41: ++m(c); break; 
    case 42: --m(c); break; 
    case 43: m(c) = ~m(c); break; 
    case 44: m(c) = 0; break; 
    case 47: if (!f) pc+=((header[pc]+128)&255)-127; else ++pc; break; 
    case 48: swap(h(d)); break; 
    case 49: ++h(d); break; 
    case 50: --h(d); break; 
    case 51: h(d) = ~h(d); break; 
    case 52: h(d) = 0; break; 
    case 55: r[header[pc++]] = a; break; 
    case 56: return 0  ; 
    case 57: outc(a&255); break; 
    case 59: a = (a+m(b)+512)*773; break; 
    case 60: h(d) = (h(d)+a+512)*773; break; 
    case 63: pc+=((header[pc]+128)&255)-127; break; 
    case 64: break; 
    case 65: a = b; break; 
    case 66: a = c; break; 
    case 67: a = d; break; 
    case 68: a = m(b); break; 
    case 69: a = m(c); break; 
    case 70: a = h(d); break; 
    case 71: a = header[pc++]; break; 
    case 72: b = a; break; 
    case 73: break; 
    case 74: b = c; break; 
    case 75: b = d; break; 
    case 76: b = m(b); break; 
    case 77: b = m(c); break; 
    case 78: b = h(d); break; 
    case 79: b = header[pc++]; break; 
    case 80: c = a; break; 
    case 81: c = b; break; 
    case 82: break; 
    case 83: c = d; break; 
    case 84: c = m(b); break; 
    case 85: c = m(c); break; 
    case 86: c = h(d); break; 
    case 87: c = header[pc++]; break; 
    case 88: d = a; break; 
    case 89: d = b; break; 
    case 90: d = c; break; 
    case 91: break; 
    case 92: d = m(b); break; 
    case 93: d = m(c); break; 
    case 94: d = h(d); break; 
    case 95: d = header[pc++]; break; 
    case 96: m(b) = a; break; 
    case 97: m(b) = b; break; 
    case 98: m(b) = c; break; 
    case 99: m(b) = d; break; 
    case 100: break; 
    case 101: m(b) = m(c); break; 
    case 102: m(b) = h(d); break; 
    case 103: m(b) = header[pc++]; break; 
    case 104: m(c) = a; break; 
    case 105: m(c) = b; break; 
    case 106: m(c) = c; break; 
    case 107: m(c) = d; break; 
    case 108: m(c) = m(b); break; 
    case 109: break; 
    case 110: m(c) = h(d); break; 
    case 111: m(c) = header[pc++]; break; 
    case 112: h(d) = a; break; 
    case 113: h(d) = b; break; 
    case 114: h(d) = c; break; 
    case 115: h(d) = d; break; 
    case 116: h(d) = m(b); break; 
    case 117: h(d) = m(c); break; 
    case 118: break; 
    case 119: h(d) = header[pc++]; break; 
    case 128: a += a; break; 
    case 129: a += b; break; 
    case 130: a += c; break; 
    case 131: a += d; break; 
    case 132: a += m(b); break; 
    case 133: a += m(c); break; 
    case 134: a += h(d); break; 
    case 135: a += header[pc++]; break; 
    case 136: a -= a; break; 
    case 137: a -= b; break; 
    case 138: a -= c; break; 
    case 139: a -= d; break; 
    case 140: a -= m(b); break; 
    case 141: a -= m(c); break; 
    case 142: a -= h(d); break; 
    case 143: a -= header[pc++]; break; 
    case 144: a *= a; break; 
    case 145: a *= b; break; 
    case 146: a *= c; break; 
    case 147: a *= d; break; 
    case 148: a *= m(b); break; 
    case 149: a *= m(c); break; 
    case 150: a *= h(d); break; 
    case 151: a *= header[pc++]; break; 
    case 152: div(a); break; 
    case 153: div(b); break; 
    case 154: div(c); break; 
    case 155: div(d); break; 
    case 156: div(m(b)); break; 
    case 157: div(m(c)); break; 
    case 158: div(h(d)); break; 
    case 159: div(header[pc++]); break; 
    case 160: mod(a); break; 
    case 161: mod(b); break; 
    case 162: mod(c); break; 
    case 163: mod(d); break; 
    case 164: mod(m(b)); break; 
    case 165: mod(m(c)); break; 
    case 166: mod(h(d)); break; 
    case 167: mod(header[pc++]); break; 
    case 168: a &= a; break; 
    case 169: a &= b; break; 
    case 170: a &= c; break; 
    case 171: a &= d; break; 
    case 172: a &= m(b); break; 
    case 173: a &= m(c); break; 
    case 174: a &= h(d); break; 
    case 175: a &= header[pc++]; break; 
    case 176: a &= ~ a; break; 
    case 177: a &= ~ b; break; 
    case 178: a &= ~ c; break; 
    case 179: a &= ~ d; break; 
    case 180: a &= ~ m(b); break; 
    case 181: a &= ~ m(c); break; 
    case 182: a &= ~ h(d); break; 
    case 183: a &= ~ header[pc++]; break; 
    case 184: a |= a; break; 
    case 185: a |= b; break; 
    case 186: a |= c; break; 
    case 187: a |= d; break; 
    case 188: a |= m(b); break; 
    case 189: a |= m(c); break; 
    case 190: a |= h(d); break; 
    case 191: a |= header[pc++]; break; 
    case 192: a ^= a; break; 
    case 193: a ^= b; break; 
    case 194: a ^= c; break; 
    case 195: a ^= d; break; 
    case 196: a ^= m(b); break; 
    case 197: a ^= m(c); break; 
    case 198: a ^= h(d); break; 
    case 199: a ^= header[pc++]; break; 
    case 200: a <<= (a&31); break; 
    case 201: a <<= (b&31); break; 
    case 202: a <<= (c&31); break; 
    case 203: a <<= (d&31); break; 
    case 204: a <<= (m(b)&31); break; 
    case 205: a <<= (m(c)&31); break; 
    case 206: a <<= (h(d)&31); break; 
    case 207: a <<= (header[pc++]&31); break; 
    case 208: a >>= (a&31); break; 
    case 209: a >>= (b&31); break; 
    case 210: a >>= (c&31); break; 
    case 211: a >>= (d&31); break; 
    case 212: a >>= (m(b)&31); break; 
    case 213: a >>= (m(c)&31); break; 
    case 214: a >>= (h(d)&31); break; 
    case 215: a >>= (header[pc++]&31); break; 
    case 216: f = (true); break; 
    case 217: f = (a == b); break; 
    case 218: f = (a == c); break; 
    case 219: f = (a == d); break; 
    case 220: f = (a == uint32_t(m(b))); break; 
    case 221: f = (a == uint32_t(m(c))); break; 
    case 222: f = (a == h(d)); break; 
    case 223: f = (a == uint32_t(header[pc++])); break; 
    case 224: f = (false); break; 
    case 225: f = (a < b); break; 
    case 226: f = (a < c); break; 
    case 227: f = (a < d); break; 
    case 228: f = (a < uint32_t(m(b))); break; 
    case 229: f = (a < uint32_t(m(c))); break; 
    case 230: f = (a < h(d)); break; 
    case 231: f = (a < uint32_t(header[pc++])); break; 
    case 232: f = (false); break; 
    case 233: f = (a > b); break; 
    case 234: f = (a > c); break; 
    case 235: f = (a > d); break; 
    case 236: f = (a > uint32_t(m(b))); break; 
    case 237: f = (a > uint32_t(m(c))); break; 
    case 238: f = (a > h(d)); break; 
    case 239: f = (a > uint32_t(header[pc++])); break; 
    case 255: if((pc=hbegin+header[pc]+256*header[pc+1])>=hend)err();break;
    default: err();
  }
  return 1;
}
void unzZPAQL::err() {
  unzerror("unzZPAQL execution error");
}
struct unzComponent {
  uint32_t limit;      
  uint32_t cxt;        
  uint32_t a, b, c;    
  Array<uint32_t> cm;  
  Array<uint8_t> ht;   
  Array<uint16_t> a16; 
  void init();    
  unzComponent() {init();}
};
void unzComponent::init() {
  limit=cxt=a=b=c=0;
  cm.resize(0);
  ht.resize(0);
  a16.resize(0);
}
class StateTable {
  enum {N=64}; 
  int num_states(int n0, int n1);  
  void discount(int& n0);  
  void next_state(int& n0, int& n1, int y);  
public:
  uint8_t ns[1024]; 
  int next(int state, int y) {  
    assert(state>=0 && state<256);
    assert(y>=0 && y<4);
    return ns[state*4+y];
  }
  int cminit(int state) {  
    assert(state>=0 && state<256);
    return ((ns[state*4+3]*2+1)<<22)/(ns[state*4+2]+ns[state*4+3]+1);
  }
  StateTable();
};
int StateTable::num_states(int n0, int n1) {
  const int B=6;
  const int bound[B]={20,48,15,8,6,5}; 
  if (n0<n1) return num_states(n1, n0);
  if (n0<0 || n1<0 || n1>=B || n0>bound[n1]) return 0;
  return 1+(n1>0 && n0+n1<=17);
}
void StateTable::discount(int& n0) {
  n0=(n0>=1)+(n0>=2)+(n0>=3)+(n0>=4)+(n0>=5)+(n0>=7)+(n0>=8);
}
void StateTable::next_state(int& n0, int& n1, int y) {
  if (n0<n1)
    next_state(n1, n0, 1-y);
  else {
    if (y) {
      ++n1;
      discount(n0);
    }
    else {
      ++n0;
      discount(n1);
    }
    while (!num_states(n0, n1)) {
      if (n1<2) --n0;
      else {
        n0=(n0*(n1-1)+(n1/2))/n1;
        --n1;
      }
    }
  }
}
StateTable::StateTable() {
  const int N=50;
  uint8_t t[N][N][2]={{{0}}}; 
  int state=0;
  for (int i=0; i<N; ++i) {
    for (int n1=0; n1<=i; ++n1) {
      int n0=i-n1;
      int n=num_states(n0, n1);
      assert(n>=0 && n<=2);
      if (n) {
        t[n0][n1][0]=state;
        t[n0][n1][1]=state+n-1;
        state+=n;
      }
    }
  }
  memset(ns, 0, sizeof(ns));
  for (int n0=0; n0<N; ++n0) {
    for (int n1=0; n1<N; ++n1) {
      for (int y=0; y<num_states(n0, n1); ++y) {
        int s=t[n0][n1][y];
        assert(s>=0 && s<256);
        int s0=n0, s1=n1;
        next_state(s0, s1, 0);
        assert(s0>=0 && s0<N && s1>=0 && s1<N);
        ns[s*4+0]=t[s0][s1][0];
        s0=n0, s1=n1;
        next_state(s0, s1, 1);
        assert(s0>=0 && s0<N && s1>=0 && s1<N);
        ns[s*4+1]=t[s0][s1][1];
        ns[s*4+2]=n0;
        ns[s*4+3]=n1;
      }
    }
  }
}
class unzPredictor {
public:
  unzPredictor(unzZPAQL&);
  void init();          
  int predict();        
  void update(int y);   
  bool isModeled() {    
    assert(z.header.isize()>6);
    return z.header[6]!=0;
  }
private:
  int c8;               
  int hmap4;            
  int p[256];           
  uint32_t h[256];           
  unzZPAQL& z;             
  unzComponent comp[256];  
  int dt2k[256];        
  int dt[1024];         
  uint16_t squasht[4096];    
  short stretcht[32768];
  StateTable st;        
  void train(unzComponent& cr, int y) {
    assert(y==0 || y==1);
    uint32_t& pn=cr.cm(cr.cxt);
    uint32_t count=pn&0x3ff;
    int error=y*32767-(cr.cm(cr.cxt)>>17);
    pn+=(error*dt[count]&-1024)+(count<cr.limit);
  }
  int squash(int x) {
    assert(x>=-2048 && x<=2047);
    return squasht[x+2048];
  }
  int stretch(int x) {
    assert(x>=0 && x<=32767);
    return stretcht[x];
  }
  int clamp2k(int x) {
    if (x<-2048) return -2048;
    else if (x>2047) return 2047;
    else return x;
  }
  int clamp512k(int x) {
    if (x<-(1<<19)) return -(1<<19);
    else if (x>=(1<<19)) return (1<<19)-1;
    else return x;
  }
  size_t find(Array<uint8_t>& ht, int sizebits, uint32_t cxt);
};
unzPredictor::unzPredictor(unzZPAQL& zr):
    c8(1), hmap4(1), z(zr) {
  assert(sizeof(uint8_t)==1);
  assert(sizeof(uint16_t)==2);
  assert(sizeof(uint32_t)==4);
  assert(sizeof(uint64_t)==8);
  assert(sizeof(short)==2);
  assert(sizeof(int)==4);
  dt2k[0]=0;
  for (int i=1; i<256; ++i)
    dt2k[i]=2048/i;
  for (int i=0; i<1024; ++i)
    dt[i]=(1<<17)/(i*2+3)*2;
  for (int i=0; i<32768; ++i)
    stretcht[i]=int(log((i+0.5)/(32767.5-i))*64+0.5+100000)-100000;
  for (int i=0; i<4096; ++i)
    squasht[i]=int(32768.0/(1+exp((i-2048)*(-1.0/64))));
  uint32_t sqsum=0, stsum=0;
  for (int i=32767; i>=0; --i)
    stsum=stsum*3+stretch(i);
  for (int i=4095; i>=0; --i)
    sqsum=sqsum*3+squash(i-2048);
  assert(stsum==3887533746u);
  assert(sqsum==2278286169u);
}
void unzPredictor::init() {
  z.inith();
  for (int i=0; i<256; ++i) h[i]=p[i]=0;
  for (int i=0; i<256; ++i)  
    comp[i].init();
  int n=z.header[6]; 
  const uint8_t* cp=&z.header[7];  
  for (int i=0; i<n; ++i) {
    assert(cp<&z.header[z.cend]);
    assert(cp>&z.header[0] && cp<&z.header[z.header.isize()-8]);
    unzComponent& cr=comp[i];
    switch(cp[0]) {
      case CONS:  
        p[i]=(cp[1]-128)*4;
        break;
      case CM: 
        if (cp[1]>32) unzerror("max size for CM is 32");
        cr.cm.resize(1, cp[1]);  
        cr.limit=cp[2]*4;
        for (size_t j=0; j<cr.cm.size(); ++j)
          cr.cm[j]=0x80000000;
        break;
      case ICM: 
        if (cp[1]>26) unzerror("max size for ICM is 26");
        cr.limit=1023;
        cr.cm.resize(256);
        cr.ht.resize(64, cp[1]);
        for (size_t j=0; j<cr.cm.size(); ++j)
          cr.cm[j]=st.cminit(j);
        break;
      case MATCH:  
        if (cp[1]>32 || cp[2]>32) unzerror("max size for MATCH is 32 32");
        cr.cm.resize(1, cp[1]);  
        cr.ht.resize(1, cp[2]);  
        cr.ht(0)=1;
        break;
      case AVG: 
        if (cp[1]>=i) unzerror("AVG j >= i");
        if (cp[2]>=i) unzerror("AVG k >= i");
        break;
      case MIX2:  
        if (cp[1]>32) unzerror("max size for MIX2 is 32");
        if (cp[3]>=i) unzerror("MIX2 k >= i");
        if (cp[2]>=i) unzerror("MIX2 j >= i");
        cr.c=(size_t(1)<<cp[1]); 
        cr.a16.resize(1, cp[1]);  
        for (size_t j=0; j<cr.a16.size(); ++j)
          cr.a16[j]=32768;
        break;
      case MIX: {  
        if (cp[1]>32) unzerror("max size for MIX is 32");
        if (cp[2]>=i) unzerror("MIX j >= i");
        if (cp[3]<1 || cp[3]>i-cp[2]) unzerror("MIX m not in 1..i-j");
        int m=cp[3];  
        assert(m>=1);
        cr.c=(size_t(1)<<cp[1]); 
        cr.cm.resize(m, cp[1]);  
        for (size_t j=0; j<cr.cm.size(); ++j)
          cr.cm[j]=65536/m;
        break;
      }
      case ISSE:  
        if (cp[1]>32) unzerror("max size for ISSE is 32");
        if (cp[2]>=i) unzerror("ISSE j >= i");
        cr.ht.resize(64, cp[1]);
        cr.cm.resize(512);
        for (int j=0; j<256; ++j) {
          cr.cm[j*2]=1<<15;
          cr.cm[j*2+1]=clamp512k(stretch(st.cminit(j)>>8)*1024);
        }
        break;
      case SSE: 
        if (cp[1]>32) unzerror("max size for SSE is 32");
        if (cp[2]>=i) unzerror("SSE j >= i");
        if (cp[3]>cp[4]*4) unzerror("SSE start > limit*4");
        cr.cm.resize(32, cp[1]);
        cr.limit=cp[4]*4;
        for (size_t j=0; j<cr.cm.size(); ++j)
          cr.cm[j]=squash((j&31)*64-992)<<17|cp[3];
        break;
      default: unzerror("unknown component type");
    }
    assert(compsize[*cp]>0);
    cp+=compsize[*cp];
    assert(cp>=&z.header[7] && cp<&z.header[z.cend]);
  }
}
int unzPredictor::predict() {
  assert(c8>=1 && c8<=255);
  int n=z.header[6];
  assert(n>0 && n<=255);
  const uint8_t* cp=&z.header[7];
  assert(cp[-1]==n);
  for (int i=0; i<n; ++i) {
    assert(cp>&z.header[0] && cp<&z.header[z.header.isize()-8]);
    unzComponent& cr=comp[i];
    switch(cp[0]) {
      case CONS:  
        break;
      case CM:  
        cr.cxt=h[i]^hmap4;
        p[i]=stretch(cr.cm(cr.cxt)>>17);
        break;
      case ICM: 
        assert((hmap4&15)>0);
        if (c8==1 || (c8&0xf0)==16) cr.c=find(cr.ht, cp[1]+2, h[i]+16*c8);
        cr.cxt=cr.ht[cr.c+(hmap4&15)];
        p[i]=stretch(cr.cm(cr.cxt)>>8);
        break;
      case MATCH: 
        assert(cr.cm.size()==(size_t(1)<<cp[1]));
        assert(cr.ht.size()==(size_t(1)<<cp[2]));
        assert(cr.a<=255);
        assert(cr.c==0 || cr.c==1);
        assert(cr.cxt<8);
        assert(cr.limit<cr.ht.size());
        if (cr.a==0) p[i]=0;
        else {
          cr.c=(cr.ht(cr.limit-cr.b)>>(7-cr.cxt))&1; 
          p[i]=stretch(dt2k[cr.a]*(cr.c*-2+1)&32767);
        }
        break;
      case AVG: 
        p[i]=(p[cp[1]]*cp[3]+p[cp[2]]*(256-cp[3]))>>8;
        break;
      case MIX2: { 
        cr.cxt=((h[i]+(c8&cp[5]))&(cr.c-1));
        assert(cr.cxt<cr.a16.size());
        int w=cr.a16[cr.cxt];
        assert(w>=0 && w<65536);
        p[i]=(w*p[cp[2]]+(65536-w)*p[cp[3]])>>16;
        assert(p[i]>=-2048 && p[i]<2048);
      }
        break;
      case MIX: {  
        int m=cp[3];
        assert(m>=1 && m<=i);
        cr.cxt=h[i]+(c8&cp[5]);
        cr.cxt=(cr.cxt&(cr.c-1))*m; 
        assert(cr.cxt<=cr.cm.size()-m);
        int* wt=(int*)&cr.cm[cr.cxt];
        p[i]=0;
        for (int j=0; j<m; ++j)
          p[i]+=(wt[j]>>8)*p[cp[2]+j];
        p[i]=clamp2k(p[i]>>8);
      }
        break;
      case ISSE: { 
        assert((hmap4&15)>0);
        if (c8==1 || (c8&0xf0)==16)
          cr.c=find(cr.ht, cp[1]+2, h[i]+16*c8);
        cr.cxt=cr.ht[cr.c+(hmap4&15)];  
        int *wt=(int*)&cr.cm[cr.cxt*2];
        p[i]=clamp2k((wt[0]*p[cp[2]]+wt[1]*64)>>16);
      }
        break;
      case SSE: { 
        cr.cxt=(h[i]+c8)*32;
        int pq=p[cp[2]]+992;
        if (pq<0) pq=0;
        if (pq>1983) pq=1983;
        int wt=pq&63;
        pq>>=6;
        assert(pq>=0 && pq<=30);
        cr.cxt+=pq;
        p[i]=stretch(((cr.cm(cr.cxt)>>10)*(64-wt)+(cr.cm(cr.cxt+1)>>10)*wt)
             >>13);
        cr.cxt+=wt>>5;
      }
        break;
      default:
        unzerror("component predict not implemented");
    }
    cp+=compsize[cp[0]];
    assert(cp<&z.header[z.cend]);
    assert(p[i]>=-2048 && p[i]<2048);
  }
  assert(cp[0]==NONE);
  return squash(p[n-1]);
}
void unzPredictor::update(int y) {
  assert(y==0 || y==1);
  assert(c8>=1 && c8<=255);
  assert(hmap4>=1 && hmap4<=511);
  const uint8_t* cp=&z.header[7];
  int n=z.header[6];
  assert(n>=1 && n<=255);
  assert(cp[-1]==n);
  for (int i=0; i<n; ++i) {
    unzComponent& cr=comp[i];
    switch(cp[0]) {
      case CONS:  
        break;
      case CM:  
        train(cr, y);
        break;
      case ICM: { 
        cr.ht[cr.c+(hmap4&15)]=st.next(cr.ht[cr.c+(hmap4&15)], y);
        uint32_t& pn=cr.cm(cr.cxt);
        pn+=int(y*32767-(pn>>8))>>2;
      }
        break;
      case MATCH: 
      {
        assert(cr.a<=255);
        assert(cr.c==0 || cr.c==1);
        assert(cr.cxt<8);
        assert(cr.cm.size()==(size_t(1)<<cp[1]));
        assert(cr.ht.size()==(size_t(1)<<cp[2]));
        assert(cr.limit<cr.ht.size());
        if (int(cr.c)!=y) cr.a=0;  
        cr.ht(cr.limit)+=cr.ht(cr.limit)+y;
        if (++cr.cxt==8) {
          cr.cxt=0;
          ++cr.limit;
          cr.limit&=(1<<cp[2])-1;
          if (cr.a==0) {  
            cr.b=cr.limit-cr.cm(h[i]);
            if (cr.b&(cr.ht.size()-1))
              while (cr.a<255
                     && cr.ht(cr.limit-cr.a-1)==cr.ht(cr.limit-cr.a-cr.b-1))
                ++cr.a;
          }
          else cr.a+=cr.a<255;
          cr.cm(h[i])=cr.limit;
        }
      }
        break;
      case AVG:  
        break;
      case MIX2: { 
        assert(cr.a16.size()==cr.c);
        assert(cr.cxt<cr.a16.size());
        int err=(y*32767-squash(p[i]))*cp[4]>>5;
        int w=cr.a16[cr.cxt];
        w+=(err*(p[cp[2]]-p[cp[3]])+(1<<12))>>13;
        if (w<0) w=0;
        if (w>65535) w=65535;
        cr.a16[cr.cxt]=w;
      }
        break;
      case MIX: {   
        int m=cp[3];
        assert(m>0 && m<=i);
        assert(cr.cm.size()==m*cr.c);
        assert(cr.cxt+m<=cr.cm.size());
        int err=(y*32767-squash(p[i]))*cp[4]>>4;
        int* wt=(int*)&cr.cm[cr.cxt];
        for (int j=0; j<m; ++j)
          wt[j]=clamp512k(wt[j]+((err*p[cp[2]+j]+(1<<12))>>13));
      }
        break;
      case ISSE: { 
        assert(cr.cxt==uint32_t(cr.ht[cr.c+(hmap4&15)]));
        int err=y*32767-squash(p[i]);
        int *wt=(int*)&cr.cm[cr.cxt*2];
        wt[0]=clamp512k(wt[0]+((err*p[cp[2]]+(1<<12))>>13));
        wt[1]=clamp512k(wt[1]+((err+16)>>5));
        cr.ht[cr.c+(hmap4&15)]=st.next(cr.cxt, y);
      }
        break;
      case SSE:  
        train(cr, y);
        break;
      default:
        assert(0);
    }
    cp+=compsize[cp[0]];
    assert(cp>=&z.header[7] && cp<&z.header[z.cend] 
           && cp<&z.header[z.header.isize()-8]);
  }
  assert(cp[0]==NONE);
  c8+=c8+y;
  if (c8>=256) {
    z.run(c8-256);
    hmap4=1;
    c8=1;
    for (int i=0; i<n; ++i) h[i]=z.H(i);
  }
  else if (c8>=16 && c8<32)
    hmap4=(hmap4&0xf)<<5|y<<4|1;
  else
    hmap4=(hmap4&0x1f0)|(((hmap4&0xf)*2+y)&0xf);
}
size_t unzPredictor::find(Array<uint8_t>& ht, int sizebits, uint32_t cxt) {
  assert(ht.size()==size_t(16)<<sizebits);
  int chk=cxt>>sizebits&255;
  size_t h0=(cxt*16)&(ht.size()-16);
  if (ht[h0]==chk) return h0;
  size_t h1=h0^16;
  if (ht[h1]==chk) return h1;
  size_t h2=h0^32;
  if (ht[h2]==chk) return h2;
  if (ht[h0+1]<=ht[h1+1] && ht[h0+1]<=ht[h2+1])
    return memset(&ht[h0], 0, 16), ht[h0]=chk, h0;
  else if (ht[h1+1]<ht[h2+1])
    return memset(&ht[h1], 0, 16), ht[h1]=chk, h1;
  else
    return memset(&ht[h2], 0, 16), ht[h2]=chk, h2;
}
class unzDecoder {
public:
  unzReader* in;        
  unzDecoder(unzZPAQL& z);
  int decompress();  
  void init();       
private:
  uint32_t low, high;     
  uint32_t curr;          
  unzPredictor pr;      
  int decode(int p); 
};
unzDecoder::unzDecoder(unzZPAQL& z):
    in(0), low(1), high(0xFFFFFFFF), curr(0), pr(z) {
}
void unzDecoder::init() {
  pr.init();
  if (pr.isModeled()) low=1, high=0xFFFFFFFF, curr=0;
  else low=high=curr=0;
}
int unzDecoder::decode(int p) {
  assert(p>=0 && p<65536);
  assert(high>low && low>0);
  if (curr<low || curr>high) unzerror("archive corrupted");
  assert(curr>=low && curr<=high);
  uint32_t mid=low+uint32_t(((high-low)*uint64_t(uint32_t(p)))>>16);  
  assert(high>mid && mid>=low);
  int y=curr<=mid;
  if (y) high=mid; else low=mid+1; 
  while ((high^low)<0x1000000) { 
    high=high<<8|255;
    low=low<<8;
    low+=(low==0);
    int c=in->get();
    if (c<0) unzerror("unexpected end of file");
    curr=curr<<8|c;
  }
  return y;
}
int unzDecoder::decompress() {
  if (pr.isModeled()) {  
    if (curr==0) {  
      for (int i=0; i<4; ++i)
        curr=curr<<8|in->get();
    }
    if (decode(0)) {
      if (curr!=0) unzerror("decoding end of input");
      return -1;
    }
    else {
      int c=1;
      while (c<256) {  
        int p=pr.predict()*2+1;
        c+=c+decode(p);
        pr.update(c&1);
      }
      return c-256;
    }
  }
  else {
    if (curr==0) {  
      for (int i=0; i<4; ++i)
        curr=curr<<8|in->get();
      if (curr==0) return -1;
    }
    assert(curr>0);
    --curr;
    return in->get();
  }
}
class unzPostProcessor {
  int state;   
  int hsize;   
  int ph, pm;  
public:
  unzZPAQL z;     
  unzPostProcessor(): state(0), hsize(0), ph(0), pm(0) {}
  void init(int h, int m);  
  int write(int c);  
  void setOutput(unzWriter* out) {z.output=out;}
  void setSHA1(unzSHA1* sha1ptr) {z.sha1=sha1ptr;}
  int getState() const {return state;}
};
void unzPostProcessor::init(int h, int m) {
  state=hsize=0;
  ph=h;
  pm=m;
  z.clear();
}
int unzPostProcessor::write(int c) {
  assert(c>=-1 && c<=255);
  switch (state) {
    case 0:  
      if (c<0) unzerror("Unexpected EOS");
      state=c+1;  
      if (state>2) unzerror("unknown post processing type");
      if (state==1) z.clear();
      break;
    case 1:  
      if (c>=0) z.outc(c);
      break;
    case 2: 
      if (c<0) unzerror("Unexpected EOS");
      hsize=c;  
      state=3;
      break;
    case 3:  
      if (c<0) unzerror("Unexpected EOS");
      hsize+=c*256;  
      if (hsize<1) unzerror("Empty PCOMP");
      z.header.resize(hsize+300);
      z.cend=8;
      z.hbegin=z.hend=z.cend+128;
      z.header[4]=ph;
      z.header[5]=pm;
      state=4;
      break;
    case 4:  
      if (c<0) unzerror("Unexpected EOS");
      assert(z.hend<z.header.isize());
      z.header[z.hend++]=c;  
      if (z.hend-z.hbegin==hsize) {  
        hsize=z.cend-2+z.hend-z.hbegin;
        z.header[0]=hsize&255;  
        z.header[1]=hsize>>8;
        z.initp();
        state=5;
      }
      break;
    case 5:  
      z.run(c);
      break;
  }
  return state;
}
class unzDecompresser {
public:
  unzDecompresser(): z(), dec(z), pp(), state(BLOCK), decode_state(FIRSTSEG) {}
  void setInput(unzReader* in) {dec.in=in;}
  bool findBlock();
  bool findFilename(unzWriter* = 0);
  void readComment(unzWriter* = 0);
  void setOutput(unzWriter* out) {pp.setOutput(out);}
  void setSHA1(unzSHA1* sha1ptr) {pp.setSHA1(sha1ptr);}
  void decompress();  
  void readSegmentEnd(char* sha1string = 0);
private:
  unzZPAQL z;
  unzDecoder dec;
  unzPostProcessor pp;
  enum {BLOCK, FILENAME, COMMENT, DATA, SEGEND} state;  
  enum {FIRSTSEG, SEG} decode_state;  
};
bool unzDecompresser::findBlock() {
  assert(state==BLOCK);
  uint32_t h1=0x3D49B113, h2=0x29EB7F93, h3=0x2614BE13, h4=0x3828EB13;
  int c;
  while ((c=dec.in->get())!=-1) {
    h1=h1*12+c;
    h2=h2*20+c;
    h3=h3*28+c;
    h4=h4*44+c;
    if (h1==0xB16B88F1 && h2==0xFF5376F1 && h3==0x72AC5BF1 && h4==0x2F909AF1)
      break;  
  }
  if (c==-1) return false;
  if ((c=dec.in->get())!=1 && c!=2) unzerror("unsupported ZPAQ level");
  if (dec.in->get()!=1) unzerror("unsupported unzZPAQL type");
  z.read(dec.in);
  if (c==1 && z.header.isize()>6 && z.header[6]==0)
    unzerror("ZPAQ level 1 requires at least 1 component");
  state=FILENAME;
  decode_state=FIRSTSEG;
  return true;
}
bool unzDecompresser::findFilename(unzWriter* filename) {
  assert(state==FILENAME);
  int c=dec.in->get();
  if (c==1) {  
    while (true) {
      c=dec.in->get();
      if (c==-1) unzerror("unexpected EOF");
      if (c==0) {
        state=COMMENT;
        return true;
      }
      if (filename) filename->put(c);
    }
  }
  else if (c==255) {  
    state=BLOCK;
    return false;
  }
  else
    unzerror("missing segment or end of block");
  return false;
}
void unzDecompresser::readComment(unzWriter* comment) {
  assert(state==COMMENT);
  state=DATA;
  while (true) {
    int c=dec.in->get();
    if (c==-1) unzerror("unexpected EOF");
    if (c==0) break;
    if (comment) comment->put(c);
  }
  if (dec.in->get()!=0) unzerror("missing reserved byte");
}
void unzDecompresser::decompress() {
  assert(state==DATA);
  if (decode_state==FIRSTSEG) {
    dec.init();
    assert(z.header.size()>5);
    pp.init(z.header[4], z.header[5]);
    decode_state=SEG;
  }
  while ((pp.getState()&3)!=1)
    pp.write(dec.decompress());
  while (true) {
    int c=dec.decompress();
    pp.write(c);
    if (c==-1) {
      state=SEGEND;
      return;
    }
  }
}
void unzDecompresser::readSegmentEnd(char* sha1string) {
  assert(state==SEGEND);
  int c=dec.in->get();
  if (c==254) {
    if (sha1string) sha1string[0]=0;  
  }
  else if (c==253) {
    if (sha1string) sha1string[0]=1;
    for (int i=1; i<=20; ++i) {
      c=dec.in->get();
      if (sha1string) sha1string[i]=c;
    }
  }
  else
    unzerror("missing end of segment marker");
  state=FILENAME;
}
uint64_t offset=0;  
void unzerror(const char* msg) {
  myprintf("\nError at offset %1.0f: %s\n", double(offset), msg);
  exit(1);
}
class unzInputFile: public unzReader {
  FILE* f;  
  enum {BUFSIZE=4096};
  uint64_t offset;  
  unsigned p, end;  
  unzAES_CTR* aes;  
  char unzBuf[BUFSIZE];  
  int64_t filesize;
public:
  unzInputFile(): f(0), offset(0), p(0), end(0), aes(0),filesize(-1) {}
  void open(const char* filename, const char* key);
  int get() {
    if (f && p>=end) {
      p=0;
      end=fread(unzBuf, 1, BUFSIZE, f);
      if (aes) aes->encrypt(unzBuf, end, offset);
    }
    if (p>=end) return -1;
    ++offset;
    return unzBuf[p++]&255;
  }
  uint64_t tell() {return offset;}
  int64_t getfilesize() {return filesize;}
};
void unzInputFile::open(const char* filename, const char* key) {
  f=fopen(filename, "rb");
  if (!f) {
    perror(filename);
    return ;
  }
	fseeko(f, 0, SEEK_END);
	filesize=ftello(f);
	fseeko(f, 0, SEEK_SET);
  if (key) {
    char salt[32], stretched_key[32];
    unzSHA256 sha256;
    for (int i=0; i<32; ++i) salt[i]=get();
    if (offset!=32) unzerror("no salt");
    while (*key) sha256.put(*key++);
    stretchKey(stretched_key, sha256.result(), salt);
    aes=new unzAES_CTR(stretched_key, 32, salt);
    if (!aes) unzerror("out of memory");
    aes->encrypt(unzBuf, end, 0);
  }
}
class unzOutputFile: public unzWriter {
  FILE* f;  
  unsigned p;  
  enum {BUFSIZE=4096};
  char unzBuf[BUFSIZE];  
public:
  unzOutputFile(): f(0), p(0) {}
  void open(const char* filename);
  void close();
  void put(int c) {
    if (f) {
      unzBuf[p++]=c;
      if (p==BUFSIZE) fwrite(unzBuf, 1, p, f), p=0;
    }
  }
  virtual ~unzOutputFile() {close();}
};
void unzOutputFile::open(const char* filename) {
  close();
  f=fopen(filename, "rb");
  if (f) {
    fclose(f);
    f=0;
    myprintf( "file exists: %s\n", filename);
  }
  f=fopen(filename, "wb");
  if (!f) perror(filename);
}
void unzOutputFile::close() {
  if (f && p>0) fwrite(unzBuf, 1, p, f);
  if (f) fclose(f), f=0;
  p=0;
}
struct unzBuf: public unzWriter {
  size_t limit;  
  std::string s;  
  unzBuf(size_t l): limit(l) {}
  void put(int c) {
    if (s.size()>=limit) unzerror("output overflow");
    s+=char(c);
  }
};
void verify_date(uint64_t date) {
  int year=date/1000000/10000;
  int month=date/100000000%100;
  int day=date/1000000%100;
  int hour=date/10000%100;
  int min=date/100%100;
  int sec=date%100;
  if (year<1900 || year>2999 || month<1 || month>12 || day<1 || day>31
      || hour<0 || hour>59 || min<0 || min>59 || sec<0 || sec>59)
    unzerror("invalid date");
}
void unzverify_utf8(const char* s) {
  while (true) {
    int c=uint8_t(*s);
    if (c==0) return;
    if ((c>=128 && c<194) || c>=245) unzerror("invalid UTF-8 first byte");
    int len=1+(c>=192)+(c>=224)+(c>=240);
    for (int i=1; i<len; ++i)
      if ((s[i]&192)!=128) unzerror("invalid UTF-8 extra byte");
    if (c==224 && uint8_t(s[1])<160) unzerror("UTF-8 3 byte long code");
    if (c==240 && uint8_t(s[1])<144) unzerror("UTF-8 4 byte long code");
    s+=len;
  }
}
uint64_t unzget8(const char* p) {
  uint64_t r=0;
  for (int i=0; i<8; ++i)
    r+=(p[i]&255ull)<<(i*8);
  return r;
}
uint32_t unzget4(const char* p) {
  uint32_t r=0;
  for (int i=0; i<4; ++i)
    r+=(p[i]&255u)<<(i*8);
  return r;
}
struct unzDT {		
  uint64_t date;    
  uint64_t attr;  
  std::vector<uint32_t> ptr;  
  char sha1hex[FRANZOFFSETSHA256];		 
  char sha1decompressedhex[FRANZOFFSETSHA256];		 
  std::string sha1fromfile;		 
  unzDT(): date(0), attr(0) {sha1hex[0]=0x0;sha1decompressedhex[0]=0x0;sha1fromfile="";}
};
typedef std::map<std::string, unzDT> unzDTMap;
bool unzcomparesha1hex(unzDTMap::iterator i_primo, unzDTMap::iterator i_secondo) 
{
	return (strcmp(i_primo->second.sha1hex,i_secondo->second.sha1hex)<0);
}
bool unzcompareprimo(unzDTMap::iterator i_primo, unzDTMap::iterator i_secondo) 
{
	return (i_primo->first<i_secondo->first);
}
int decode_franz_block(const bool i_isdirectory,const char* i_franz_block,string& o_hashtype,string& o_hashvalue,string& o_crc32value)
{
	int	risultato;
	if (i_franz_block==NULL)
	{
		o_hashtype="";
		o_hashvalue="";
		o_crc32value="";
		return -1;
	}
	if (i_franz_block[0]==0)
		if (i_franz_block[0+8]!=0)
		{
			if (i_franz_block[0+40]==0)
			o_hashtype="XXHASH64";
			o_hashvalue=i_franz_block+8;
			risultato=FRANZO_XXHASH64; 
		}
	if (i_franz_block[41]!=0)
		if (i_franz_block[41+8]==0)
		{
			if (i_isdirectory)
				o_crc32value="        ";
			else
				o_crc32value=i_franz_block+41;
		}
	if (i_franz_block[0]=='0')
		if (i_franz_block[1]=='8') 
			if (i_franz_block[0+66]==0)
			{
				risultato=FRANZO_SHA_1; 
				o_hashtype="SHA-1";
				o_hashvalue=i_franz_block+2;
				if (i_isdirectory)
					o_crc32value="        ";
				else
				{
					if (i_franz_block[67]!=0)
						if (i_franz_block[67+8]==0)
							o_crc32value=i_franz_block+67;
				}
			}
	if (i_franz_block[0]=='0')
		if (i_franz_block[1]=='9') 
			if (i_franz_block[0+66]==0)
			{
				risultato=FRANZO_XXH3; 
				o_hashtype="XXH3";
				o_hashvalue=i_franz_block+2;
				if (i_isdirectory)
					o_crc32value="        ";
				else
				{
					if (i_franz_block[67]!=0)
						if (i_franz_block[67+8]==0)
							o_crc32value=i_franz_block+67;
				}
			}
	if (i_franz_block[0]=='0')
		if (i_franz_block[1]=='4')
			if (i_franz_block[0+66]==0)
			{
				risultato=FRANZO_SHA_256; 
				o_hashtype="SHA-256";
				o_hashvalue=i_franz_block+2;
				if (i_isdirectory)
					o_crc32value="        ";
				else
				{
					if (i_franz_block[67]!=0)
						if (i_franz_block[67+8]==0)
							o_crc32value=i_franz_block+67;
				}
			}
	if (i_franz_block[0]=='0')
		if (i_franz_block[1]=='3') 
			if (i_franz_block[0+66]==0)
			{
				risultato=FRANZO_BLAKE3; 
				o_hashtype="BLAKE3";
				o_hashvalue=i_franz_block+2;
				if (i_isdirectory)
					o_crc32value="        ";
				else
				{
					if (i_franz_block[67]!=0)
						if (i_franz_block[67+8]==0)
							o_crc32value=i_franz_block+67;
				}
			}
	if (i_franz_block[0]=='0')
		if (i_franz_block[1]=='2') 
			if (i_franz_block[0+66]==0)
			{
				risultato=FRANZO_SHA3; 
				o_hashtype="SHA-3";
				o_hashvalue=i_franz_block+2;
				if (i_isdirectory)
					o_crc32value="        ";
				else
				{
					if (i_franz_block[67]!=0)
						if (i_franz_block[67+8]==0)
							o_crc32value=i_franz_block+67;
				}
			}
	if (i_franz_block[0]=='0')
		if (i_franz_block[1]=='1') 
			if (i_franz_block[0+66]==0)
			{
				risultato=FRANZO_MD5; 
				o_hashtype="MD5";
				o_hashvalue=i_franz_block+2;
				if (i_isdirectory)
					o_crc32value="        ";
				else
				{
					if (i_franz_block[67]!=0)
						if (i_franz_block[67+8]==0)
							o_crc32value=i_franz_block+67;
				}
			}
	return risultato;
}				
static std::string base64encode(const std::string data) 
{
    static constexpr char sEncodingTable[] = {
      'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H',
      'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P',
      'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X',
      'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f',
      'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n',
      'o', 'p', 'q', 'r', 's', 't', 'u', 'v',
      'w', 'x', 'y', 'z', '0', '1', '2', '3',
      '4', '5', '6', '7', '8', '9', '+', '/'
    };
    size_t in_len = data.size();
    if (in_len == 0)
      return "";
    size_t out_len = 4 * ((in_len + 2) / 3);
    std::string ret(out_len, '\0');
    size_t i;
    char *p = const_cast<char*>(ret.c_str());
    if (in_len == 1) {
      ret[0] = sEncodingTable[(data[0] >> 2) & 0x3F];
      ret[1] = sEncodingTable[((data[0] & 0x3) << 4)];
      ret[2] = '=';
      ret[3] = '=';
      return ret;
    }
    if (in_len == 2) {
      ret[0] = sEncodingTable[(data[0] >> 2) & 0x3F];
      ret[1] = sEncodingTable[((data[0] & 0x3) << 4) | ((int)(data[1] & 0xF0) >> 4)];
      ret[2] = sEncodingTable[((data[1] & 0xF) << 2)];
      ret[3] = '=';
      return ret;
    }
    for (i = 0; i < in_len - 2; i += 3) {
      *p++ = sEncodingTable[(data[i] >> 2) & 0x3F];
      *p++ = sEncodingTable[((data[i] & 0x3) << 4) | ((int) (data[i + 1] & 0xF0) >> 4)];
      *p++ = sEncodingTable[((data[i + 1] & 0xF) << 2) | ((int) (data[i + 2] & 0xC0) >> 6)];
      *p++ = sEncodingTable[data[i + 2] & 0x3F];
    }
    if (i < in_len) {
      *p++ = sEncodingTable[(data[i] >> 2) & 0x3F];
      if (i == (in_len - 1)) {
        *p++ = sEncodingTable[((data[i] & 0x3) << 4)];
        *p++ = '=';
      }
      else {
        *p++ = sEncodingTable[((data[i] & 0x3) << 4) | ((int) (data[i + 1] & 0xF0) >> 4)];
        *p++ = sEncodingTable[((data[i + 1] & 0xF) << 2)];
      }
      *p++ = '=';
    }
    return ret;
}
string Jidac::sanitizzanomefile(string i_filename,int i_filelength,int& io_collisioni,MAPPAFILEHASH& io_mappacollisioni)
{
	if  (i_filename=="")
		return("");
	string percorso			=extractfilepath(i_filename);
	string nome				=prendinomefileebasta(i_filename);
	string estensione		=prendiestensione(i_filename);
	string senzaestensione	=percorso+nome;
	string newname;
	int lunghezza=FRANZMAXPATH;
	if (i_filelength>0)
		if (i_filelength<FRANZMAXPATH)
			lunghezza=i_filelength;
	lunghezza-=9; 
	if (lunghezza<10)
		lunghezza=10;
	char numero[60];
	if (flagparanoid) 
	{
		sprintf(numero,"%08d_",++io_collisioni);
		newname=numero;
		DTMap::iterator p=dt.find(i_filename);
		string myhashtype	="";
		string myhash		="";
		string mycrc32		="";
		if (p!=dt.end())
		{
			decode_franz_block(isdirectory(i_filename),p->second.franz_block,
			myhashtype,
			myhash,
			mycrc32);
			if (myhashtype!="")
				if (myhash!="")
				{
					p->second.hexhash=myhash;
					myhash=myhash.substr(0, 10);
					newname+="$"+myhashtype+"!"+myhash+"%";
					p->second.hashtype=myhashtype;
				}
		}
		else
			myprintf("24501: not found %s\n",i_filename.c_str());
		if (flagdebug)
			myprintf("24389: paranoid filename <<%s>>\n",newname.c_str());
		return newname;
	}
	if (flagflat) 
	{
		string temp=purgeansi(nome.substr(0, 20));
		temp=base64encode(temp);
		sprintf(numero,"%08d_%05d_",++io_collisioni,(unsigned int)i_filename.length());
		newname=numero;
		newname.append(temp.c_str());
		estensione=purgeansi(estensione);
		for (unsigned int j=0;j<forbiddenstringsize;j++)
			myreplaceall(estensione,stringtolower(forbiddenstring[j]),"_");
		if ((estensione.size())>3)
			estensione=myleft(estensione,3);
		if (estensione!="")
			newname+="."+estensione;
		if (flagdebug)
			myprintf("25396: flatted filename <<%s>>\n",newname.c_str());
		return newname;
	}
	if (flagutf)
	{
		string prenome=nome;
		nome=purgeansi(forcelatinansi(utf8toansi(nome)),false);		
		if (flagdebug)
			if (nome!=prenome)
			{
				myprintf("25410: flagutf pre  %s\n",prenome.c_str());
				myprintf("25410: utf8toansi   %s\n",utf8toansi(nome).c_str());
				myprintf("25410: force2ansi   %s\n",forcelatinansi(utf8toansi(nome)).c_str());
				myprintf("25411: purgeansi    %s\n",nome.c_str());
			}
		if (flagfixeml)
		{
			if (estensione=="eml")
			{
				prenome=compressemlfilename(nome);
				if (nome!=prenome)
				{
					if (flagdebug)
					{
						myprintf("18109: eml pre  %s\n",nome.c_str());
						myprintf("18110: eml post %s\n",prenome.c_str());
					}
					nome=prenome;
				}
			}
			else
			{
				for (int i=0;i<10;i++)
					myreplaceall(newname,"  "," ");
			}
		}
		string prepercorso=percorso;
		percorso=purgeansi(forcelatinansi(utf8toansi(percorso)),true);		
		if (flagdebug)
			if (percorso!=prepercorso)
			{
				myprintf("25452: flagutf pre  perc %s\n",prepercorso.c_str());
				myprintf("25453: flagutf post perc %s\n",percorso.c_str());
			}
	}
	if (flagdebug)
	{
		myprintf("18041: First    %03d %s\n",(int)i_filename.length(),i_filename.c_str());
		myprintf("18042: Percorso %03d %s\n",(int)percorso.length(),percorso.c_str());
		myprintf("18043: nome     %03d %s\n",(int)nome.length(),nome.c_str());
		myprintf("18044: ext      %03d %s\n",(int)estensione.length(),estensione.c_str());
		myprintf("18045: Senza ex %03d %s\n",(int)senzaestensione.length(),senzaestensione.c_str());
	}
	if (flagfix255)
	{
		int	lunghezzalibera=lunghezza-percorso.length();
		if (lunghezzalibera<10)
		{
			if (flagdebug)
			{
				myprintf("\n\n\n18046: Path too long: need shrink %08d %s\n",(int)percorso.length(),percorso.c_str());
				myprintf("lunghezzalibera %d\n",lunghezzalibera);
			}
			vector<string> esploso;
			string temppercorso=percorso;
			size_t barra;
			while (1==1)
			{
				if (flagdebug)
					myprintf("18031: temppercorso %s\n",temppercorso.c_str());
				barra=temppercorso.find('/');
				if (flagdebug)
					myprintf("18034: Barra %ld\n",(long int)barra);
				if (barra==string::npos)
					break;
				if (flagdebug)		
					myprintf("18038: Eureka!!\n");
				esploso.push_back(temppercorso.substr(0, barra));
				temppercorso=temppercorso.substr(barra+1,temppercorso.length());
			}
			int lunghezzamassima=0;
			int indicelunghezzamassima=-1;
			for (unsigned int i=0;i<esploso.size();i++)
			{
				if ((int)esploso[i].length()>lunghezzamassima)
				{
					indicelunghezzamassima=i;
					lunghezzamassima=esploso[i].length();
				}
				if (flagdebug)
					myprintf("18087: Esploso %d %03d %s\n",(int)i,(int)esploso[i].length(),esploso[i].c_str());
			}
			int lunghezzacheserve=lunghezza-10-(percorso.length()-lunghezzamassima);
			if (lunghezzacheserve<lunghezzamassima)
			{
				esploso[indicelunghezzamassima]=esploso[indicelunghezzamassima].substr(0,lunghezzacheserve);
				string imploso;
				for (unsigned 	int i=0;i<esploso.size();i++)
					imploso+=esploso[i]+'/';
				if (flagdebug)
					myprintf("18114: Imploso           %d %s\n",(int)imploso.length(),imploso.c_str());
				percorso=imploso;
				lunghezzalibera=lunghezza-percorso.length();
				makepath(percorso);
			}
			else
			{
				myprintf("18088: HOUSTON\n");
			}						
		}
	}
	newname=nome;
	int lunghezzalibera=lunghezza-percorso.length();
	if (flagdebug)
		myprintf("18098:lunghezze per %03d nome %03d tot %03d\n",(int)percorso.length(),lunghezzalibera,(int)(percorso.length()+lunghezzalibera));
	if (newname.length()>(unsigned int)lunghezzalibera)
	{
		newname=newname.substr(0,lunghezzalibera-9);
		if (flagdebug)
			myprintf("18143:Trimmone newname %d %s\n",(int)newname.length(),newname.c_str());
	}
	newname=percorso+newname;
	if (flagdebug)
		myprintf("%d: newname %s\n",__LINE__,newname.c_str());
	std::map<string,string>::iterator collisione;
	string candidato=newname;
	if (estensione!="")
		candidato=candidato+'.'+estensione;
	if (flagfix255)	
	{
#ifndef ESX		
std::for_each(candidato.begin(), candidato.end(), [](char & c)
		{
			c = ::tolower(c);	
		});
	}
	if (flagdebug)
	myprintf("25570: candidato %s\n",candidato.c_str());
	collisione=io_mappacollisioni.find(candidato); 
	if (collisione!=io_mappacollisioni.end()) 
	{
		if (flagdebug)
			myprintf("18255 found  1 %s\n",candidato.c_str());
		if (collisione->second!=candidato)
		{
			if (flagdebug)
			{
				myprintf("25582: Collisione %s\n",collisione->second.c_str());
				myprintf("25583: newname    %s\n",collisione->second.c_str());
			}
			sprintf(numero,"_%d",io_collisioni++);
			newname+=numero;
			if (flagdebug)
				myprintf("18267: postname   %s\n\n\n\n\n",newname.c_str());
		}
	}
	io_mappacollisioni.insert(std::pair<string, string>(candidato,i_filename));
	if (estensione!="")
		newname+="."+estensione;
	if (flagdebug)
		myprintf("18195: Finalized %d %s\n",(int)newname.length(),newname.c_str());
	if (newname.length()>255)
	{
		myprintf("18123: WARN pre  %08d   %s\n",(int)i_filename.length(),i_filename.c_str());
		myprintf("18124: WARN post %08d   %s\n",(int)newname.length(),newname.c_str());
		myprintf("\n");
	}
	return newname;
}
void print_progress(int64_t ts, int64_t td,int64_t i_scritti,int i_percentuale) 
{
	static int ultimapercentuale=0;
	static int ultimaeta=0;
	if (flagnoeta==true)
		return;
	if (td>ts) 
		td=ts;
	if (td<1000000)
		return;
	double eta=0.001*(mtime()-g_start)*(ts-td)/(td+1.0);
	int secondi=(mtime()-g_start)/1000;
	if (secondi==0)
		secondi=1;
	int percentuale=int(td*100.0/(ts+0.5));
	if (flagpakka)
	{
		if (eta<350000)
		if (((percentuale%10)==0) ||(percentuale==1))
			if ((percentuale!=ultimapercentuale) || (percentuale==1))
			{
				ultimapercentuale=percentuale;
				myprintf("%03d%% %02d:%02d:%02d %20s of %20s %s/sec\r", percentuale,
					int(eta/3600), int(eta/60)%60, int(eta)%60, migliaia(td), migliaia2(ts),migliaia3(td/secondi));
			}
	}
	else 
	{
		if (int(eta)!=ultimaeta)
		if (eta<350000)
		{
			ultimaeta=int(eta);
			if (i_percentuale>0)
				myprintf("(%03d%%) %6.2f%% %02d:%02d:%02d (%10s)->(%10s) of (%10s) %10s/sec\r", i_percentuale,td*100.0/(ts+0.5),int(eta/3600), int(eta/60)%60, int(eta)%60, tohuman(td),tohuman2(i_scritti),tohuman3(ts),tohuman4(td/secondi));
			else
			{
				if (i_scritti>0)
			myprintf("       %6.2f%% %02d:%02d:%02d (%10s)->(%10s) of (%10s) %10s/sec\r", td*100.0/(ts+0.5),
			int(eta/3600), int(eta/60)%60, int(eta)%60, tohuman(td),tohuman2(i_scritti),tohuman3(ts),tohuman4(td/secondi));
			else
			myprintf("       %6.2f%% %02d:%02d:%02d (%10s) of (%10s) %10s/sec\r", td*100.0/(ts+0.5),
			int(eta/3600), int(eta/60)%60, int(eta)%60, tohuman(td),tohuman2(ts),tohuman3(td/secondi));
			}
		}
	}				
}
void avanzamento(int64_t i_lavorati,int64_t i_totali,int64_t i_inizio)
{
	static int ultimapercentuale=0;
	if (flagnoeta==true)
		return;
	int percentuale=int(i_lavorati*100.0/(i_totali+0.5));
	if (percentuale>0)
		if (((percentuale%10)==0)  || (percentuale==1))
	if (percentuale!=ultimapercentuale)
	{
		ultimapercentuale=percentuale;
		double eta=0.001*(mtime()-i_inizio)*(i_totali-i_lavorati)/(i_lavorati+1.0);
		int secondi=(mtime()-i_inizio)/1000;
		if (secondi==0)
			secondi=1;
		if (eta<356000)
		myprintf("%03d%% %02d:%02d:%02d (%10s) of (%10s) %20s /sec\n", percentuale,
		int(eta/3600), int(eta/60)%60, int(eta)%60, tohuman(i_lavorati), tohuman2(i_totali),migliaia3(i_lavorati/secondi));
		fflush(stdout);
	}
}
bool myavanzamento(int64_t i_lavorati,int64_t i_totali,int64_t i_inizio,bool i_barran=true)
{
	bool	hostampato=false;
	static int ultimapercentuale=0;
	int percentuale=int(i_lavorati*100.0/(i_totali+0.5));
	if (percentuale>100)
		percentuale=100;
	if (((percentuale%5)==0) && (percentuale>0))
	if (percentuale!=ultimapercentuale)
	{
		ultimapercentuale=percentuale;
		double eta=0.001*(mtime()-i_inizio)*(i_totali-i_lavorati)/(i_lavorati+1.0);
		int secondi=(mtime()-i_inizio)/1000;
		if (secondi==0)
			secondi=1;
		if (eta<356000)
		{
			myprintf("%03d%% %02d:%02d:%02d (%10s) of (%10s) %20s/sEc", percentuale,
		int(eta/3600), int(eta/60)%60, int(eta)%60, tohuman(i_lavorati), tohuman2(i_totali),migliaia3(i_lavorati/secondi));
			if (i_barran)
				myprintf("\n");
			else
				myprintf("\r");
			hostampato=true;
		}
		fflush(stdout);
	}
	return hostampato;
}
bool myavanzamentoby1sec(int64_t i_lavorati,int64_t i_totali,int64_t i_inizio,bool i_barran=true)
{
	bool	hostampato=false;
	static int ultimotempo=0;
	int secondi=(mtime()-i_inizio)/1000;
	int percentuale=int(i_lavorati*100.0/(i_totali+0.5));
if (percentuale>100)
		percentuale=100;
	if (secondi!=ultimotempo)
	{
		ultimotempo=secondi;
		double eta=0.001*(mtime()-i_inizio)*(i_totali-i_lavorati)/(i_lavorati+1.0);
		if (secondi==0)
			secondi=1;
		if (eta<356000)
		{
			myprintf("%03d%% %02d:%02d:%02d (%10s) of (%10s) %20s/SeC", percentuale,
		int(eta/3600), int(eta/60)%60, int(eta)%60, tohuman(i_lavorati), tohuman2(i_totali),migliaia3(i_lavorati/secondi));
			if (i_barran)
				myprintf("\n");
			else
				myprintf("\r");
			hostampato=true;
		}
		fflush(stdout);
	}
	return hostampato;
}
bool compareFragmentList(DTMap::const_iterator p, DTMap::const_iterator q) {
  if (p->second.size!=q->second.size) return p->second.size>q->second.size;
  if (p->second.ptr<q->second.ptr) return true;
  if (q->second.ptr<p->second.ptr) return false;
  if (p->second.data!=q->second.data) return p->second.data<q->second.data;
  return p->first<q->first;
}
bool compareFilename(DTMap::iterator ap, DTMap::iterator bp) 
{
  if (ap->second.data!=bp->second.data)
    return ap->second.data<bp->second.data;
  return ap->first<bp->first;
}
bool comparedatethenfilename(DTMap::iterator ap, DTMap::iterator bp) 
{
	if (ap->second.date!=bp->second.date)
		return ap->second.date<bp->second.date;
	return ap->first<bp->first;
}
bool comparehexhash0(DTMap::iterator ap, DTMap::iterator bp) {
  if (ap->second.data!=bp->second.data)
    return ap->second.data<bp->second.data;
  return ap->first<bp->first;
}
bool comparehexhash1(DTMap::iterator ap, DTMap::iterator bp) 
{
	if (ap->second.date!=bp->second.date)
		return ap->second.date<bp->second.date;
	return ap->second.hexhash<bp->second.hexhash;
}
bool comparehexhash2(DTMap::iterator ap, DTMap::iterator bp) 
{
  if (ap->second.data!=bp->second.data)
    return ap->second.data<bp->second.data;
	return ap->second.hexhash<bp->second.hexhash;
}
bool comparehexhash3(DTMap::iterator a, DTMap::iterator b) 
{
	char a_start[40];
	char b_start[40];
	sprintf(a_start,"%014lld",(long long)a->second.size);
	sprintf(b_start,"%014lld",(long long)b->second.size);
	string	sizea=a_start;
	string	sizeb=b_start;
	return a_start+a->second.hexhash<b_start+b->second.hexhash;
}
bool comparehexhash4(DTMap::iterator a, DTMap::iterator b) 
{
	char a_start[40];
	char b_start[40];
	sprintf(a_start,"%014lld",(long long)a->second.size);
	sprintf(b_start,"%014lld",(long long)b->second.size);
	string	sizea=a_start;
	string	sizeb=b_start;
	return a_start+a->second.hexhash>b_start+b->second.hexhash;
}
bool comparehexhash5(DTMap::iterator a, DTMap::iterator b) 
{
	char a_start[40];
	char b_start[40];
	sprintf(a_start,"%014lld",(long long)a->second.data);
	sprintf(b_start,"%014lld",(long long)b->second.data);
	string	sizea=a_start;
	string	sizeb=b_start;
	return a_start+a->second.hexhash<b_start+b->second.hexhash;
}
bool comparehexhash6(DTMap::iterator a, DTMap::iterator b) 
{
	char a_start[40];
	char b_start[40];
	sprintf(a_start,"%014lld",(long long)a->second.data);
	sprintf(b_start,"%014lld",(long long)b->second.data);
	string	sizea=a_start;
	string	sizeb=b_start;
	return a_start+a->second.hexhash>b_start+b->second.hexhash;
}
bool comparehexhash7(DTMap::iterator a, DTMap::iterator b) 
{
	string a_estensione=prendiestensione(a->first);
	string b_estensione=prendiestensione(b->first);
	char a_start[40];
	char b_start[40];
	sprintf(a_start,"%014lld",(long long)a->second.size);
	sprintf(b_start,"%014lld",(long long)b->second.size);
	string	sizea=a_start;
	string	sizeb=b_start;
	return a_estensione+a_start+a->second.hexhash<b_estensione+b_start+b->second.hexhash;
}
bool comparehexhash8(DTMap::iterator a, DTMap::iterator b) 
{
	string a_estensione=prendiestensione(a->first);
	string b_estensione=prendiestensione(b->first);
	string	a_nomefile=prendinomefileebasta(a->first);
	string	b_nomefile=prendinomefileebasta(b->first);
	char a_start[40];
	char b_start[40];
	sprintf(a_start,"%014lld",(long long)a->second.size);
	sprintf(b_start,"%014lld",(long long)b->second.size);
	string	sizea=a_start;
	string	sizeb=b_start;
	return a_nomefile+a->second.hexhash>b_nomefile+b->second.hexhash;
	return a_estensione+a_nomefile+a->second.hexhash>b_estensione+b_nomefile+b_start+b->second.hexhash;
}
bool compareorderby(DTMap::iterator a, DTMap::iterator b) 
{
	if (g_theorderby.size()==0)
		return false;
	string 	a_ext		=prendiestensione(a->first);
	string 	b_ext		=prendiestensione(b->first);
	string	a_name		=prendinomefileebasta(a->first);
	string	b_name		=prendinomefileebasta(b->first);
	string	a_hash		=a->second.hexhash;
	string	b_hash		=b->second.hexhash;
	string	a_nilsimsa	=a->second.hexhash;
	string	b_nilsimsa	=b->second.hexhash;
	string	a_date		=dateToString(a->second.date);
	string	b_date		=dateToString(b->second.date);
	char buffer[40];
	sprintf(buffer,"%014lld",(long long)a->second.size);
	string	a_size=buffer;
	sprintf(buffer,"%014lld",(long long)b->second.size);
	string	b_size=buffer;
	sprintf(buffer,"%08X",(unsigned int)a->second.data);
	string	a_data=buffer;
	sprintf(buffer,"%08X",(unsigned int)b->second.data);
	string	b_data=buffer;
	string	a_compare=orderby;
	myreplaceall(a_compare,"ext;"		,a_ext);
	myreplaceall(a_compare,"size;"		,a_size);
	myreplaceall(a_compare,"name;"		,a_name);
	myreplaceall(a_compare,"hash;"		,a_hash);
	myreplaceall(a_compare,"date;"		,a_date);
	myreplaceall(a_compare,"data;"		,a_data);
	myreplaceall(a_compare,"nilsimsa;"	,a_nilsimsa);
	string	b_compare=orderby;
	myreplaceall(b_compare,"ext;"		,b_ext);
	myreplaceall(b_compare,"size;"		,b_size);
	myreplaceall(b_compare,"name;"		,b_name);
	myreplaceall(b_compare,"hash;"		,b_hash);
	myreplaceall(b_compare,"date;"		,b_date);
	myreplaceall(b_compare,"data;"		,b_data);
	myreplaceall(b_compare,"nilsimsa;"	,b_nilsimsa);
	if (flagdesc)
	{
		if (a_compare!=b_compare)
			return a_compare>b_compare;
	}
	else
	{
		if (a_compare!=b_compare)
			return a_compare<b_compare;
	}
	return a->first<b->first;
}
void help_printhash(bool i_flagadd)
{
	moreprint("+ : -crc32        Ancient but ubiquitous, superfast");
	moreprint("+ : -xxh3         One of the fastest (128 bit), strong");
	moreprint("+ : -xxhash       Very fast (64 bit), low CPU");
	moreprint("+ : -sha1         Fair speed, very reliable, some collisions known");
	moreprint("+ : -sha256       CPU intensive, one of the most reliable. Legal proof in EU");
	moreprint("+ : -sha3         Latest NIST standard, very, very strong");
	moreprint("+ : -blake3       Fast, CPU intensive (on Win64 HW acceleration), very reliable");
	moreprint("+ : -md5          Very common, widespread usage");
	if (!i_flagadd)
	{
		moreprint("+ : -crc32c       'Castagnoli', HW accelerated");
		moreprint("+ : -wyhash       Maybe the fastest, limited 'strength'");
		moreprint("+ : -whirlpool    Slow but very reliable");
		moreprint("+ : -nilsimsa     Look for similarities");
		moreprint("+ : -entropy      Quick-and-dirty entropy estimator");
	}
}
void help_printhashline(bool i_flagadd)
{
	moreprint("+ : -crc32  -xxhash -md5 -sha1 -xxh3 -blake3 -sha256 -sha3");
	if (!i_flagadd)
		moreprint("+ : -crc32c -wyhash -whirlpool -nilsimsa -entropy");
}
void help_b(bool i_usage,bool i_example)
{
	if (i_usage)
	{
		moreprint("CMD   b (benchmark and CPU stresser)");
		moreprint("<>:               Rough benchmarking of hash-checksum");
		moreprint("<>:               franzomips (fake index) showed if no switch selected");
		moreprint("<>:               By default test ALL for 5 seconds with 400.000 bytes");
		moreprint("<>:               NOTE: THIS IS THE MAXIMUM PERFORMANCES, not the real one!");
		moreprint("<>: -verbose      Verbose output");
		moreprint("<>: -n X          Set time limit to X s (<1000)");
		moreprint("<>: -minsize Y    Run on chunks of Y bytes (<2000000000)");
		help_printhash(false);
		moreprint("+ : -all          Multithread run (CPU cooker)");
		moreprint("+ : -tX           With -all limit to X threads");
	}
	if (i_usage && i_example) moreprint("    Examples:");
	if (i_example)
	{
		moreprint("Benchmark all:                       b");
		moreprint("Benchmark all on 1.86GB:             b -minsize 2000000000");
		moreprint("Benchmark all on 1MB:                b -minsize 1048576");
		moreprint("Benchmark SHA256 and BLAKE3:         b -sha256 -blake 3 -minsize 1048576");
		moreprint("Benchmark for 10 second each:        b -n 10 -sha256 -blake3 -minsize 1048576");
		moreprint("Cook the CPU (all cores):            b -all -n 20 -blake3");
		moreprint("Cook the CPU (8 cores):              b -all -t8 -n 20 -blake3");
	}
}
void help_setpassword(bool i_usage,bool i_example)
{
	if (i_usage)
	{
		moreprint("CMD   password    Change/remove password of single archive (no multipart)");
		moreprint("<>:               By default DRY RUN (only test)");
		moreprint("<>: -force        Overwrite output if exists");
		moreprint("<>: -space        Do not check for free space");
		moreprint("<>: -key2 X       Use X as new password");
	}
	if (i_usage && i_example) moreprint("    Examples:");
	if (i_example)
	{
		moreprint("Change pass from X to Y:             password z:\\x.zpaq z:\\y.zpaq -key X -key2 Y");
		moreprint("Add password X to NON encrypted:     password z:\\nocrypt.zpaq z:\\yescrypt.zpaq -key2 X");
		moreprint("Remove password X from encrypted:    password z:\\crypt.zpaq z:\\nocrypt.zpaq -key X");
	}
}
void help_trim(bool i_usage,bool i_example)
{
	if (i_usage)
	{
		moreprint("CMD   trim        Trim incomplete .zpaq file");
		moreprint("<>:               By default DRY RUN (only test)");
		moreprint("<>: -kill         Do a 'wet' (effective) in-place run");
		moreprint("<>: -to tiny.zpaq Trim on tiny.zpaq");
		moreprint("<>: -verify       Check the copy before trim");
	}
	if (i_usage && i_example) moreprint("    Examples:");
	if (i_example)
	{
		moreprint("Trim file (dry run):                 trim z:\\1.zpaq");
		moreprint("Trim file IN PLACE (wet run):        trim z:\\1.zpaq -kill");
		moreprint("Trim file on other (safer):          trim z:\\1.zpaq -to d:\\small.zpaq");
		moreprint("Trim file w/verify:                  trim z:\\1.zpaq -to d:\\small.zpaq -verify");
	}
}
void help_a(bool i_usage,bool i_example)
{
	if (i_usage)
	{
		moreprint("CMD   a (add)");
		moreprint("<>:               zpaqfranz store CRC-32/XXH of each file, detecting SHA-1 collisions,");
		moreprint("                  while zpaq cannot by design. Can be disabled by -crc32 or -715,");
		moreprint("                  on modern CPU slow down ~10%.");
		moreprint("                  In archive and files substitute $hour $min $sec $weekday $year $month $day");
		moreprint("                  $week $date $time $datetime");
		moreprint("<>:               By default do NOT store ADSs on Windows (essentially useless).");
		moreprint("<>:               By default every .XLS file is forcibily added (old Excel change metafiles).");
		moreprint("+ : -verbose      Verbose output");
		moreprint("+ : -n X          Show X files to be added, before and after sort");
		moreprint("+ : -debug        Show LOTS of infos");
		moreprint("+ : -summary      Be brief");
		moreprint("+ : -noeta        Do not show ETA (redirect output to log file)");
		moreprint("+ : -pakka        New-style output (by chunks)");
		moreprint("<>: -forcewindows Store ADS stuff                (default: NO)");
		moreprint("<>: -xls          Do NOT force adding of XLS/PPT (default: NO)");
		moreprint("<>: -forcezfs     Do NOT ignore .zfs             (default: YES)");
		moreprint("<>: -715          Runs just about like 7.15");
		moreprint("+ : -debug -zero       Add files but zero-filled (debugging)");
		moreprint("+ : -debug -zero -kill Add 0-byte long file (debugging)");
		moreprint("+ : -nochecksum   Disable zpaqfranz additional checks (faster, less sure)");
		moreprint("+ : -nodedup      Turn off deduplicator");
		moreprint("+ : -tar          Tar mode: no deduplication, no compression");
		moreprint("+ : -touch        Force 'touch' on date (converting 7.15 to zpaqfranz)");
		moreprint("+ : -norecursion  Do not recurse into folders (default: YES)");
		help_printhash(true);
		moreprint("+ : -test         Do a post-add test (doveryay, no proveryay).");
		moreprint("+ : -verify       Verify hashes against filesystem");
		moreprint("+ : -verify -ssd  Verify hashes against filesystem MULTITHREAD (do NOT use on spinning drives)");
		moreprint("+ : -paranoid     Test for file with same size and timestamp, but !=hash (-ssd multithread)");
		moreprint("+ : -vss          Volume Shadow Copies (Win with admin rights) to backup files from %users%.");
		moreprint("+ : -timestamp X  Setting version datetime @X, ex 2021-12-30_01:03:04 to freeze zfs snapshots");
		moreprint("                  Must be monotonic. increasing (v[i+1].date>v[i]+date)");
		moreprint("+ : -comment foo  Add a version with ASCII text 'foo'");
		moreprint("+ : -filelist     Add the list of file to be added in a VFILE");
		moreprint("+ : -copy z:\\two  Make a 2nd copy of the written data into another folder");
		moreprint("+ : -exec_ok p.sh After successful run launch p.sh with archive name as parameter");
		moreprint("+ : -freeze kajo  If current archive size > maxsize, move to kajo folder");
		moreprint("+ : -orderby x    Sort files by (one or more of) ext;size;name;hash;date;data;nilsimsa;");
		moreprint("+ : -desc         Descending sort (if -orderby)");
	}
	if (i_usage && i_example) 
		moreprint("    Examples:");
	if (i_example)
	{
		moreprint("Add two folders to archive:          a z:\\1.zpaq c:\\data\\* d:\\pippo\\*");
		moreprint("Add folder, storing full hash SHA3:  a z:\\2.zpaq c:\\nz\\ -sha3");
		moreprint("Add folder, then verification:       a z:\\3.zpaq c:\\nz\\ -test");
		moreprint("Add two files:                       a z:\\4.zpaq.zpaq c:\\vecchio.sql r:\\1.txt");
		moreprint("Add as zpaq 7.15 (no checksum):      a z:\\5.zpaq c:\\audio -715");
		moreprint("Add and mark version:                a z:\\6.zpaq c:\\data\\* -comment first_copy");
		moreprint("Add folder with timestamping (zfs):  a z:\\8.zpaq c:\\data\\* -timestamp 2021-12-30_01:03:04");
		moreprint("Create multipart archive:            a \"z:\\9_????.zpaq\" c:\\data\\");
		moreprint("Create indexed multipart archive:    a \"z:\\a_???.zpaq\" c:\\data\\ -index z:\\a_000.zpaq");
		moreprint("Add folder, with encryption:         a z:\\b.zpaq c:\\nz\\ -key mygoodpassword");
		moreprint("Add folder, maximum compress:        a z:\\c.zpaq c:\\nz\\ -m5");
		moreprint("Store the filelist VFILE:            a z:\\d.zpaq c:\\nz\\ -filelist");
		moreprint("Add WITHOUT CRC-32/hash (like 715):  a z:\\e.zpaq c:\\nz\\ -nochecksum");
		moreprint("Add 2nd copy to USB drive (U):       a \"z:\\f_???.zpaq\" c:\\nz\\ -copy u:\\usb");
		moreprint("Launch pippo.bat after OK:           a \"z:\\g_???.zpaq\" c:\\nz\\ -exec_ok u:\\pippo.bat");
		moreprint("Archive file if bigger of 10GB:      a z:\\h.zpaq c:\\nz\\ -freeze y:\\archived -maxsize 10000000000");
		moreprint("Prepare a debug archive...for me     a z:\\1.zpaq c:\\nz\\ -debug -zero");
		moreprint("In-place 7.15 to zpaqfranz  1/2      a z:\\1.zpaq c:\\nz\\ -touch");
		moreprint("In-place 7.15 to zpaqfranz  2/2      a z:\\1.zpaq c:\\nz\\");
		moreprint("Hard-check of files                  a z:\\1.zpaq c:\\nz\\ -paranoid");
		moreprint("Hard-check of files multithread      a z:\\1.zpaq c:\\nz\\ -paranoid -ssd");
		moreprint("Archive, without recursion           a z:\\1.zpaq f:\\zarc\\*.* -norecursion");
	}
}
void help_rd(bool i_usage,bool i_example)
{
	if (i_usage)
	{
		moreprint("CMD   rd (remove directory on Windows)");
		moreprint("+ :               Delete hard-to-remove dir (like rd /s or rm -r)");
		moreprint("+ : -kill         Wet run (default: DRY run)\n");
		moreprint("+ : -force        Remove folder if not-zero files present\n");
		moreprint("+ : -space        Do not check if writeable (ex. 0 bytes free)\n");
	}
	if (i_usage && i_example) moreprint("    Examples:");
	if (i_example)
		moreprint("Remove folder z:\\kajo:     rd z:\\kajo -force -kill -space");
}
void help_w(bool i_usage,bool i_example)
{
	if (i_usage)
	{
		moreprint("CMD   w (Chunked-extraction)");
		moreprint("+ :               Extract/test in chunks, on disk or 'ramdisk' (RAM)");
		moreprint("+ :               The output -to folder MUST BE EMPTY");
		moreprint("+ : -maxsize X    Maxsize of the chunk @ X bytes\n");
		moreprint("+ : -ramdisk      Use 'RAMDISK'\n");
		moreprint("+ : -frugal       Use less possible RAM (default: get 75% of free RAM)'\n");
		moreprint("+ : -ssd          Multithread writing from ramdisk\n");
		moreprint("+ : -test         Do not write on media\n");
		moreprint("+ : -verbose      Show useful infos\n");
		moreprint("+ : -checksum     Do CRC-32 / hashes test\n");
		moreprint("+ : -verify       Do a 'check-against-filesystem'\n");
		moreprint("+ : -paranoid     Extract to filesystem, then delete if OK (need -verify)\n");
	}
	if (i_usage && i_example) moreprint("    Examples:");
	if (i_example)
	{
		moreprint("Extract to a spinning drive:         w z:\\1.zpaq -to p:\\muz7\\ -ramdisk -longpath");
		moreprint("Paranoid check into folder muz7:     w z:\\1.zpaq -to z:\\muz7\\ -paranoid -verify -verbose -frugal -longpath");
		moreprint("Paranoid  max chunksize 1000000000:  w z:\\1.zpaq -to z:\\muz7\\ -paranoid -verify -maxsize 1000000000");
		moreprint("Test in RAM (no disk write,M/T)      w z:\\1.zpaq -ramdisk -test -checksum -ssd -frugal");
		moreprint("Top test (W/disk write on SSD z:\\)   w z:\\1.zpaq -to z:\\kajo -ramdisk -paranoid -verify -checksum -longpath -ssd");
	}
}
void help_x(bool i_usage,bool i_example)
{
	if (i_usage)
	{
		moreprint("CMD   x (extract)");
		moreprint("+ :               During extraction,if CRC-32s are present, the codes are checked.");
		moreprint("+ : -checksum     force a full hash-code verify (if added with -checksum)");
		moreprint("+ : -zero         extract to dummy, 0-length files. Da a empty-full restore.");
		moreprint("+ : -zero -debug  extract full-sized files, 0 filled (Dry restore)");
		moreprint("+ : -utf          change everything non latin to latin (Linux/*Nix => NTFS compatibility)");
		moreprint("+ : -fix255       shrink max file name, avoid different case collision (Linux => NTFS)");
		moreprint("                  (pippo.txt and PIPPO.txt are be silently overwritten by 7.15).");
		moreprint("+ : -fixeml       compress .eml filenames.");
		moreprint("+ : -flat         emergency restore of everything into a single folder (Linux => NTFS)");
		moreprint("+ : -filelist     show (if any) a stored filelist");
		moreprint("+ : -force        Force overwrite AND extracting of corrupted files (if any)");
		moreprint("+ : -space        Do not check free space before extract");
		moreprint("+ : -find/replace Replace part of text");
		moreprint("+ : -replace X    Juxtapose X to stored path");
	}
	if (i_usage && i_example) moreprint("    Examples:");
	if (i_example)
	{
		moreprint("Extract into folder muz7:            x z:\\1.zpaq -to z:\\muz7\\");
		moreprint("0-bytes files (check restoration):   x z:\\1.zpaq -to z:\\muz7\\ -kill");
		moreprint("Extract into single directory:       x z:\\1.zpaq -to z:\\muz7\\ -flat");
		moreprint("Extract without utf,<255,.eml:       x z:\\1.zpaq -to z:\\muz7\\ -utf -fix255 -fixeml");
		moreprint("Extract forcing overwrite:           x z:\\1.zpaq -to z:\\muz7\\ -force");
		moreprint("Extract version K:                   x z:\\1.zpaq -to z:\\muz7\\ -until K");
		moreprint("Extract last versions of multipart:  x \"z:\\a_???\" -to z:\\ugo");
		moreprint("Extract into muz7 every versions:    x z:\\1.zpaq -to z:\\muz7\\ -all");
		moreprint("Show the filelist (if any):          x z:\\1.zpaq -filelist");
		moreprint("Show the filelist (if any) of v3:    x z:\\1.zpaq -filelist -until 3");
		moreprint("Extract all *.xls into new archive:  x z:\\1.zpaq *.xls -repack onlyxls.zpaq");
		moreprint("Extract from a VSS (Windows):        x z:\\1.zpaq \\\\?\\GLOBALROOT\\Device\\HarddiskVolumeShadowCopy1\\path -to d:\\output");
		moreprint("Replace path in extract              x 1.zpaq -find /tank/ -replace z:\\uno\\");
		moreprint("Change path in extract, longpath     x 1.zpaq -replace z:\\uno\\ -longpath");		
	}
}
void help_l(bool i_usage,bool i_example)
{
	if (i_usage)
	{
		moreprint("CMD   l (list)");
		moreprint("+ :               If source folders are specified, do a compare of the archive's content.");
		moreprint("                  A 'verify' more than a 'list', much faster than the standard,");
		moreprint("                  as it performs a block calc  codes of source files, but not of");
		moreprint("                  the archived ones; also checks the CRC-32, to intercept any SHA1 collisions.");
		moreprint("                  Use the exact same parameters of add(), just use l instead of a.");
		moreprint("+ : -force        Shows all files (even marked as corrupted)");
		moreprint("+ : -checksum     Shows CRC-32/hash, if any");
		moreprint("+ : -summary      Compact file list");
		moreprint("+ : -comment foo  Extract version foo, if possible");
		moreprint("+ : -find pippo   Just like |grep -i pippo");
		moreprint("+ : -replace foo  Replace -find with -replace in the output");
		moreprint("+ : -to knb       Do the standard rename()");
		moreprint("+ : -utc          Do not convert to localtime (show UTC)");
	}
	if (i_usage && i_example) moreprint("    Examples:");
	if (i_example)
	{
		moreprint("Last version:                        l z:\\1.zpaq");
		moreprint("Last version w/checksums:            l z:\\1.zpaq -checksum");
		moreprint("Compact output:                      l z:\\1.zpaq -checksum -summary");
		moreprint("Compact output renamed:              l z:\\1.zpaq -checksum -summary -to z:\\knb");
		moreprint("All (every) version:                 l z:\\1.zpaq -all");
		moreprint("Version comments (if any):           l z:\\1.zpaq -comment");
		moreprint("V.comments verbose (if any):         l z:\\1.zpaq -comment -all");
		moreprint("Only stored 'zpaq.cpp':              l z:\\1.zpaq -find zpaq.cpp -pakka");
		moreprint("Find-and-replace (like awk or sed)   l r:\\1.zpaq -find c:/biz/ -replace z:\\mydir\\");
		moreprint("List the 10 greatest file            l z:\\1.zpaq -n 10");
	}
}
void help_i(bool i_usage,bool i_example)
{
	if (i_usage)
	{
		moreprint("CMD   i (info)");
		moreprint("+ :               Directly shows the versions into the archive, with size and comments");
		moreprint("+ : -stat         Count 'weird' files");
	}
	if (i_usage && i_example) moreprint("    Examples:");
	if (i_example)
	{
		moreprint("Show versions info (command i):      i z:\\1.zpaq");
		moreprint("Count 'not good filenames'):         i z:\\1.zpaq -stat");
	}
}
void help_q(bool i_usage,bool i_example)
{
	if (i_usage)
	{
		moreprint("CMD   q Windows archiving of C: (*** admin rights mandatory ***)");
		moreprint("+ :               Take as much C: as possible (no Windows and swapfile)");
		moreprint("+ :               This is NOT a full backup (aka: bare-metal restorable)");
		moreprint("+ : -forcewindows INCLUDE Windows folder");
		moreprint("+ : -frugal       Exclude Windows, %programfiles% and %temp%");
		moreprint("+ : -all          Get everything (except swapfile)");
		moreprint("+ : -to c:\\piz    Use c:\\piz for snap (default c:\\franzsnap)");
		moreprint("+ :               It is possible to use $pcname as placeholder");
		moreprint("+ :               Just about all switches of add() (-key -m -only ...)");
		moreprint("+ :               except files selection (always C:/*)");
		moreprint("+ :     ****      The folder franzsnap MUST NOT EXIST and be on C:");
	}
	if (i_usage && i_example) moreprint("    Examples:");
	if (i_example)
	{
		moreprint("NOT C:\\WINDOWS, NOT RECYCLE BIN      q z:\\1.zpaq");
		moreprint("Everything                           q z:\\1.zpaq -all");
		moreprint("Everything NOT C:\\DROPBOX            q z:\\1.zpaq -all -not c:/franzsnap/dropbox");
		moreprint("NOT C:\\WINDOWS, NOT %programs%       q z:\\1.zpaq -frugal");
		moreprint("Only C/C++ files and header          q z:\\1.zpaq -only *.c* -only *.h*");
		moreprint("For multi-PC 'backup' on one zpaq    q z:\\1.zpaq -frugal -to c:\\snap_$pcname -verbose");
	}
}
void help_g(bool i_usage,bool i_example)
{
	if (i_usage)
	{
		moreprint("CMD   g Run a q command (Windows archiving of C:)");
		moreprint("+ :               If the user is in the administrator group, BUT");
		moreprint("+ :               the current shell does not have admin rights, you");
		moreprint("+ :               the current shell does not have admin rights, you");
	}
	if (i_usage && i_example) moreprint("    Examples:");
	if (i_example)
	{
		moreprint("NOT C:\\WINDOWS, NOT RECYCLE BIN      g z:\\1.zpaq");
		moreprint("... same as command q, but with g");
	}
}
void help_dirsize(bool i_usage,bool i_example)
{
	if (i_usage)
	{
		moreprint("CMD   dirsize Show cumulative folder(s) size");
		moreprint("                  Case INsensitive ENDING with parameters (unless -force)");
		moreprint("                  i.e. marcus == /1/marcus, /tank/d/documenti/MARCUS");
		moreprint("+ : -force        Exact match; /tank/marcus != /tank/MARCUS");
	}
	if (i_usage && i_example) moreprint("    Examples:");
	if (i_example)
	{
			moreprint("Search with 2 parameters       :       dirsize z:\\1.zpaq marcus vanessa");
			moreprint("Getting size (insensitive)     :       dirsize z:\\1.zpaq /tank/d/documenti/marcus -force");
	}
}
void help_sfx(bool i_usage,bool i_example)
{
	if (i_usage)
	{
		moreprint("CMD   sfx (sfx module, with encryption support)");
		moreprint("+ :               (no switch): Write SFX along the .zpaq");
		moreprint("                  (w/switch) : Convert .zpaq (max 2GB) to Windows .EXE");
	}
	if (i_usage && i_example) moreprint("    Examples:");
	if (i_example)
	{
		moreprint("Create  z:\\1.exe               :      sfx z:\\1.zpaq");
		moreprint("Convert 1.zpaq to 2.exe        :      sfx z:\\1.zpaq -sfx z:\\2.exe");
	}
}
void help_rsync(bool i_usage,bool i_example)
{
	if (i_usage)
	{
		moreprint("CMD   rsync Delete dangling temporary rsync file");
		moreprint("+ : -kill         Wet run (default: dry run)");
	}
	if (i_usage && i_example) moreprint("    Examples:");
	if (i_example)
	{
		moreprint("Purge temporary (dry run):            rsync \\\\nas\\thebackup");
		moreprint("Purge temporary (WET run):            rsync \\\\nas\\thebackup -kill");
	}
}
void help_t(bool i_usage,bool i_example)
{
	if (i_usage)
	{
		moreprint("CMD   t (test)");
		moreprint("+ :               Check that all block are OK, and the CRC-32s of the individual ");
		moreprint("                  files corresponds to what would be generated by actually extracting.");
		moreprint("+ : -checksum     Enable hash checksums");
		moreprint("+ : -verify       Do a filesystem post-check: STORED CRC==DECOMPRESSED==FROM FILE.");
		moreprint("+ : -verify -ssd  Multithread verify (do NOT use on spinning drives)");
		moreprint("+ : -find pippo   For path-rework of verify");
		moreprint("+ : -replace plu  For path-rework of verify (find and replace)");
		moreprint("+ : -paranoid     Extract all into -to something, check every file with stored hash");
		moreprint("+ :               delete every equal files");
	}
	if (i_usage && i_example) moreprint("    Examples:");
	if (i_example)
	{
		moreprint("Last version:                        t z:\\1.zpaq");
		moreprint("All versions:                        t z:\\1.zpaq -all");
		moreprint("Compare against filesystem:          t z:\\1.zpaq -verify");
		moreprint("Against filesystem, 4 threads:       t z:\\1.zpaq -verify -ssd -t4");
		moreprint("Real paranoid: extract all           t z:\\1.zpaq -to z:\\knb -paranoid");
		moreprint("Fast-SHA1 (nz the source dir):       t z:\\1.zpaq c:\\nz");
		moreprint("Cnk-SHA1+hash (nz the source dir):   t z:\\1.zpaq c:\\nz -checksum");
	}
}
void help_v(bool i_usage,bool i_example)
{
	if (i_usage)
	{
		moreprint("CMD   v (verify)");
		moreprint("+ :               Verify all files (by hashes) against filesystem");
		moreprint("+ : -ssd          Multithread (for SSD/NVMe). Do NOT use on spinning drives");
		moreprint("+ : -tX           Limit -ssd to X threads");
		moreprint("+ : -until Y      Check the version Y");
		moreprint("+ : -find pippo   For path-rework of verify");
		moreprint("+ : -replace plu  For path-rework of verify (find and replace)");
		moreprint("+ : -verbose      Show distinct errors");
		moreprint("+ : -debug        Show lots of info");
		moreprint("+ : -output x.txt Put errors in x.txt (alias -out)");
	}
	if (i_usage && i_example) moreprint("    Examples:");
	if (i_example)
	{
		moreprint("Last version:                        v z:\\1.zpaq");
		moreprint("Show errors line by line:            v z:\\1.zpaq -verbose");
		moreprint("2n version:                          v z:\\1.zpaq -until 2");
		moreprint("Remake path:                         v z:\\1.zpaq -find c:\\dropbox -replace z:\\knb");
		moreprint("1st version, multithread:            v z:\\1.zpaq -until 1 -ssd");
	}
}
void help_p(bool i_usage,bool i_example)
{
	if (i_usage)
	{
		moreprint("CMD   p (paranoid test)");
		moreprint("+ :               Test the archive (** NOT multipart **) in a very paranoid fashion.");
		moreprint("                  ZPAQ reference decompressor is used to extract blocks in RAM.");
		moreprint("                  Runs on unzpaq206.cpp source instead of 7.15 extract: double check");
		moreprint("                  to avoid the risk of 'silent' bugs. The RAM needed can");
		moreprint("                  quickly become unmanageable (warn: be very careful with 32bit versions).");
		moreprint("+ : -noeta        Brief");
		moreprint("+ : -verbose      Shows positive checks");
		moreprint("+ : -verify       Next level (mine) of paranoia: check hashes against the filesystem.");
		moreprint("                  Essentially equivalent to extracting in a temporary folder and check");
		moreprint("                  against initial folders. For very paranoid people, or debug reason.");
	}
	if (i_usage && i_example) moreprint("    Examples:");
	if (i_example)
	{
		moreprint("Paranoid, use lots of RAM:           p z:\\1.zpaq");
		moreprint("Very paranoid, use lots of RAM:      p z:\\1.zpaq -verify");
	}
}
void help_c(bool i_usage,bool i_example)
{
	if (i_usage)
	{
		moreprint("CMD   c (compare dirs)");
		moreprint("+ :               Compare a 'master' directory (d0) against N 'slaves' (d1, d2... dN).");
		moreprint("                  The slaves are made by zpaq restores, or rsync, robocopy, zfs replica.");
		moreprint("                  It is not easy to check on different filesystems (ex. NAS-Linux, NTFS)");
		moreprint("                  By default check file name and file size (excluding .zfs), not the content.");
		moreprint("+ : -ssd          Concurrent threads will be created, each scan a slave dir (-t K to limit).");
		moreprint("                  NOT good for single spinning drives, good for multiple slaves on different media.");
		help_printhash(false);
		moreprint("+ : -maxsize X    Filter out on filesize");
		moreprint("+ : -minsize X    Filter out on filesize");
		moreprint("+ : -715          Work as 7.15 (with .zfs and ADS)");
		moreprint("+ : -forcezfs     Include .zfs");
	}
	if (i_usage && i_example) moreprint("    Examples:");
	if (i_example)
	{
		moreprint("Compare master d0 against d1,d2,d3:  c c:\\d0 k:\\d1 j:\\d2 p:\\d3");
		moreprint("Multithread compare:                 c c:\\d0 k:\\d1 j:\\d2 p:\\d3 -ssd");
		moreprint("Hashed compare d0 against d1,d2,d3:  c c:\\d0 k:\\d1 j:\\d2 p:\\d3 -verify");
	}
}
void help_s(bool i_usage,bool i_example)
{
	if (i_usage)
	{
		moreprint("CMD   s (size)");
		moreprint("+ :               Cumulative size of N directory, and free space (estimate for *Nix).");
		moreprint("                  Everything containing .zfs and :$DATA (Windows's ADS) ignored by default");
		moreprint("                  Very quick-and-dirty check of rsynced folders against the master");
		moreprint("+ : -ssd          for multithreaded executions (warning for single spinning drive)");
		moreprint("+ : -maxsize X    Filter out on filesize");
		moreprint("+ : -minsize X    Filter out on filesize");
		moreprint("+ : -715          Work as 7.15 (with .zfs and ADS)");
		moreprint("+ : -forcezfs     Include .zfs");
		moreprint("+ : -minsize X    Show a warning if free space < X");
		}
	if (i_usage && i_example) moreprint("    Examples:");
	if (i_example)
	{
		moreprint("Dir cumulative size (no .zfs/NTFS):  s r:\\vbox s:\\uno");
		moreprint("Multithreaded size:                  s r:\\vbox s:\\uno -ssd");
	}
}
void help_r(bool i_usage,bool i_example)
{
	if (i_usage)
	{
		moreprint("CMD   r ('robocopy')");
		moreprint("+ :               Mirror a master folder, just like robocopy /mir or rsync -a --delete");
		moreprint("                  to one or more slaves (destination) folders");
		moreprint("                  In archive and files substitute $hour $min $sec $weekday $year $month $day");
		moreprint("                  $week $date $time $datetime");
		moreprint("                  ENFORCING XLS, ignore .zfs and ADS by default");
		moreprint("+ : -kill         wet run (default: dry-run");
		moreprint("+ : -space        do not exit if not enough space reported");
		moreprint("+ : -ssd          run one thread for folder");
		moreprint("+ : -verify       after copy quick check if OK (only filename and size)");
		moreprint("+ : -checksum     heavy (hash) test of equality. Suggest: -xxh3 fast and reliable.");
		moreprint("+ : -maxsize X    Filter out on filesize");
		moreprint("+ : -minsize X    Filter out on filesize");
		moreprint("+ : -xls          Do not enforce backup of XLS/PPT");
		moreprint("+ : -715          Work as 7.15 (with .zfs and ADS)");
		moreprint("+ : -forcezfs     Include .zfs");
		moreprint("+ : -append       Only append data (*risky, use with zpaq archives)");
		moreprint("+ : -zero         Fill all output file with zeros (for debug)");
	}
	if (i_usage && i_example) moreprint("    Examples:");
	if (i_example)
	{
		moreprint("Robocopy d0 in d1,d2 (dry run):      r c:\\d0 k:\\d1 j:\\d2 p:\\d3");
		moreprint("Robocopy d0 in d1,d2 (WET run):      r c:\\d0 k:\\d1 j:\\d2 p:\\d3 -kill");
		moreprint("Robocopy with verify (WET run):      r c:\\d0 k:\\d1 j:\\d2 p:\\d3 -kill -verify");
		moreprint("Robocopy with hash verify (WET run): r c:\\d0 k:\\d1 j:\\d2 p:\\d3 -kill -verify -checksum -xxh3");
		moreprint("Robocopy d0 in d1, forced WET run:   r c:\\d0 k:\\d1 j:\\d2 -kill -space");
		moreprint("Robocopy append mode with subst      r c:\\d0 z:\\backup_$day -append -kill");
	}
}
void help_cp(bool i_usage,bool i_example)
{
	if (i_usage)
	{
		moreprint("CMD   cp ('friendly copy') ");
		moreprint("+ :               Copy files (with wildcards) into -to folder");
		moreprint("+ :               with 1 sec progression feedback. Huge file, tiny bandwidth");
		moreprint("                  and unreliable media (-verify)");
		moreprint("+ :               By default overwrite, use -paranoid to create unique name");
		moreprint("+ : -verify       Do an heavy (XXH3) check of copied data");
		moreprint("+ : -paranoid     Rename output file to do not overwrite");
		moreprint("+ : -append       Only append data (*risky, use with zpaq archives)");
		moreprint("+ : -force        Do no check if destination is writeable");
		moreprint("+ : -space        Do no check if enoungh destination free space");
	}
	if (i_usage && i_example) moreprint("    Examples:");
	if (i_example)
	{
		moreprint("Copy k:\\*.mp4 d:\\a.txt in z:\\pluto   cp k:\\*.mp4 d:\\a.txt -to z:\\pluto");
		moreprint("Copy with verify                     cp k:\\*.mp4 -to z:\\pluto -verify");
		moreprint("Copy WITHOUT overwrite               cp k:\\*.mp4 -to z:\\pluto -paranoid");
	}
}
void help_zfs(bool i_usage,bool i_example)
{
	if (i_usage)
	{
		moreprint("      Auxiliary zfs commands (typically for FreeBSD)");
		moreprint("      The user must have the rights to do this kind of stuff!");
		moreprint("      NOTE: you can use -output xx.sh (alias -out) to redirect the output");
		moreprint("      and edit your own script");
		moreprint("      !zpaqfranz cowardly do NOT execute!");
		moreprint("");
		moreprint("****  LUKE... REMEMBER... !USE THE DOUBLEQUOTES! ...");
		moreprint("");
		if ((g_optional=="zfslist") || (g_optional==""))
		moreprint("CMD   zfslist       Show (/filtering) existing zfs snapshot");	
		if ((g_optional=="zfspurge") || (g_optional==""))
		moreprint("CMD   zfspurge      Destroy selected zfs snapshot (works like zfslist)");	
		if ((g_optional=="zfsadd") || (g_optional==""))
		{
		moreprint("CMD   zfsadd        Freeze into an archive a selection of snapshots");
		moreprint("+ : -force        Do the freezing (wet run)");
		}
		moreprint("+ : -output pi.sh Write a script-ready on pi.sh (alias -out)");
		moreprint("+ : -pakka        Remove first line in output");
	}
	if (i_usage && i_example) moreprint("    Examples:");
	if (i_example)
	{
		if ((g_optional=="zfsadd") || (g_optional==""))
		{
		moreprint("zfsadd \"tank/d@2021\" \"--60d\" \"/temporaneo/kongo60.zpaq\" ");
		moreprint("zfsadd \"tank/d@2021\" \"--60d\" \"/temporaneo/kongo60.zpaq\" \"scanner\"");
		moreprint("zfsadd \"tank/d@2021\" \"--60d\" \"/temporaneo/kongo60.zpaq\" \"scanner\" -force");
		moreprint("zfsadd \"tank/d@2021\" \"--60d\" \"/temporaneo/kongo60.zpaq\" \"scanner\" -output ./dothejob.sh");
		}
		if ((g_optional=="zfslist") || (g_optional==""))
		{
		moreprint("zfslist  \"tank/d@\"");
		moreprint("zfslist  \"*\"");
		moreprint("zfslist  \"*\" \"syncoid\"");
		}
		if ((g_optional=="zfspurge") || (g_optional==""))
		{
		moreprint("zfspurge \"tank/d@2021\" \"--60d\"");
		moreprint("zfspurge \"*\" \"*\"");
		moreprint("zfspurge \"tank\" \"--7d\"");
		moreprint("zfspurge \"tank\" \"--7d\" -output mygoodscript.sh");
		}
	}
}
void help_z(bool i_usage,bool i_example)
{
	if (i_usage)
	{
		moreprint("CMD   z (delete empty directories, zero length)");
		moreprint("+ :               Remove empty directories in d0...dK folders. Conservative (ex hidden Thumbs.db)");
		moreprint("+ : -kill         Do a wet run (default dry run)");
		moreprint("+ : -verbose      Show infos");
	}
	if (i_usage && i_example) moreprint("    Examples:");
	if (i_example)
	{
		moreprint("Delete empty dirs in d0,d1(dry run): z c:\\d0 k:\\d1");
		moreprint("Delete empty dirs in d0,d1(WET run): z c:\\d0 k:\\d1 -kill -longpath");
	}
}
void help_m(bool i_usage,bool i_example)
{
	if (i_usage)
	{
	moreprint("CMD   m (merge, consolidate)");
	moreprint("+ :                   Merge a splitted (multipart) archive into a single one,");
	moreprint("                      just like a concatenated cat or copy /b");
	moreprint("+ : -force            Overwrite existing output");
	moreprint("+ : -space            Ignore lack of free space");
	moreprint("+ : -verify           Double-check (XXH3 hash test)");
	}
	if (i_usage && i_example) moreprint("    Examples:");
	if (i_example)
	{
		moreprint("Merge (consolidate) multipart:       m \"p:\\test\\prova_???\" z:\\cons.zpaq -verify");
	}
}
void help_d(bool i_usage,bool i_example)
{
	if (i_usage)
	{
		moreprint("CMD   d (deduplicate)");
		moreprint("+ :               Deduplicate a single folder WITHOUT ASKING ANYTHING!");
		moreprint("+ :               Please note: a FOLDER==ending with /");
		moreprint("+ : -ssd          Multithread run");
		moreprint("+ : -force        Wet run (default: dry-run)");
		moreprint("+ : -verbose      Show duplicated files");
		moreprint("+ : -(somehash)   Use (somehash), one of the available next two lines, for detection");
		help_printhashline(false);
	}
	if (i_usage && i_example) moreprint("    Examples:");
	if (i_example)
	{
		moreprint("Deduplicate d0 (dry run, w/xxh3) :   d c:\\d0\\");
		moreprint("Deduplicate d0 (dry run,xxh3,M/T):   d c:\\d0\\ -ssd");
		moreprint("Deduplicate d0 WITHOUT MERCY (wet):  d c:\\d0\\ -kill");
		moreprint("Dedup WITHOUT MERCY (wet run,sha256):d c:\\d0\\ -force -sha256");
	}
}
void help_utf(bool i_usage,bool i_example)
{
	if (i_usage)
	{
		moreprint("CMD   utf (deal with strange filenames)");
		moreprint("+ :               Check (or sanitize) paths with non-latin chars and/or >260 length and/or case.");
		moreprint("                  Can become a real problem extracting on different filesystems (ex. *nix => NTFS)");
		moreprint("+ : -kill         Wet run (default dry run)");
		moreprint("+ : -utf          Sanitize filenames (strip non-latin)");
		moreprint("+ : -fix255       Sanitize file length and filecase collisions pippo.txt PIPPO.txt)");
		moreprint("+ : -fixeml       Sanitize .eml filenames (Fwd Fwd Fwd => Fwd)");
		moreprint("+ : -dirlength X  Set the 'fix' limit");
		moreprint("+ : -filelength Y Set the 'fix' limit");
	}
	if (i_usage && i_example) moreprint("    Examples:");
	if (i_example)
	{
		moreprint("Check UTF-filenames (dry run):       utf z:\\knb");
		moreprint("Sanitize UTF-filenames (wet run):    utf z:\\knb -kill");
		moreprint("Check >255 and case collisions:      utf z:\\knb -fix255");
		moreprint("Fix .eml filenames (dry run):        utf z:\\knb -fixeml");
	}
}
void help_f(bool i_usage,bool i_example)
{
	if (i_usage)
	{
		moreprint("CMD   f (fill, or wipe)");
		moreprint("+ :               Fill (wipe) 99% of free disk space in 500MB chunks");
		moreprint("                  Check if disk-controller-system-RAM-cache-cables are working fine");
		moreprint("+ : -verbose      Show write speed (useful to check speed consistency)");
		moreprint("+ : -force        Do NOT delete (after run) the temporary filename. By default free");
		moreprint("+ : -zero         Zero-fill instead of random. Use to prepare a thin VMDK shrink");
		moreprint("+ : -verify       For -zero: do a verify.");
	}
	if (i_usage && i_example) moreprint("    Examples:");
	if (i_example)
	{
		moreprint("Fill (wipe) almost all free space:   f z:\\");
		moreprint("Fill (wipe) keep temp files:         f z:\\ -force -verbose");
		moreprint("Zero free space (VM shrink):         f z:\\ -zero");
		moreprint("Zero free space (WITH verify):       f z:\\ -zero -verify");
	}
}
void help_sha1(bool i_usage,bool i_example)
{
	if (i_usage)
	{
		moreprint("CMD   sum");
		moreprint("CMD   sha1        (retained for historical reasons, 7.15 always uses SHA-1 only)");
		moreprint("+ :               Calculate hash/cksum of files/dirs, dupes and cumulative GLOBAL SHA256");
		moreprint("                  (If two directories have the same GLOBAL SHA256 they are ==)");
		moreprint("                  With no switches, by default, use SHA-1 (reliable, but not very fast)");
		help_printhash(false);
		moreprint("+ : -ssd          make N thread (do not use with spinning HDDs, but SSDs and NVMes)");
		moreprint("+ : -mm           use memory mapped file instead of 'regular' fread");
		moreprint("+ : -kill         show the files to be deleted to manually deduplicate");
		moreprint("+ : -checksum     get a 1-level checksum, for comparing hierarchically user-organized folders.");
		moreprint("+ : -summary      show only GLOBAL (fast manual compare of directories)");
		moreprint("+ : -forcezfs     force .zfs path (DEFAULT: skip)");
		moreprint("+ : -kill -force  runs a deduplication without ask anything!");
		moreprint("+ : -maxsize X    Filter out on filesize");
		moreprint("+ : -minsize X    Filter out on filesize");
		moreprint("+ : -715          Work as 7.15 (with .zfs and ADS)");
		moreprint("+ : -forcezfs     Include .zfs");
	}
	if (i_usage && i_example) moreprint("    Examples:");
	if (i_example)
	{
		moreprint("SHA1 of all files (and duplicated):  sum z:\\knb");
		moreprint("SHA1 multithread, only summary:      sum z:\\knb -ssd -summary");
		moreprint("XXH3 multithread:                    sum z:\\knb -ssd -xxh3");
		moreprint("CRC-32c HW accelerated:              sum z:\\knb -crc32c -pakka -noeta");
		moreprint("Hashes to be compared (dir1):        sum c:\\nz  -pakka -noeta -nosort -crc32c -find c:\\nz  -replace bakdir >1.txt");
		moreprint("Hashes to be compared (dir2):        sum z:\\knb -pakka -noeta -nosort -crc32c -find z:\\knb -replace bakdir >2.txt");
		moreprint("Duplicated files with sha256:        sum z:\\knb -kill -sha256");
		moreprint("Duplicated files minsize 1000000:    sum z:\\knb -kill -ssd -minsize 1000000");
		moreprint("MAGIC cumulative hashes of 1-level:  sum p:\\staff -xxh3 -checksum");
		moreprint("BLAKE3 multithread from memory map:  sum z:\\knb -ssd -blake3 -mm");
	}
}
void help_dir(bool i_usage,bool i_example)
{
	if (i_usage)
	{
		moreprint("CMD   dir (yes, dir as in Windows).");
		moreprint("+ :               I really hate ls: does not show the cumulative filesize (!)");
		moreprint("                  'Mini clone' of Windows's dir command, with the main switches");
		moreprint("+ : /s            Recursive (note: Win-switch must be BEFORE 'normal' switch");
		moreprint("+ : /os           Order by size");
		moreprint("+ : /a            Show all (hidden)");moreprint("+ : -checksum     Show hashes for every file");
		moreprint("+ : -(somehash)   Use (somehash) to find duplicate/show checksums");
		help_printhashline(false);
		moreprint("+ : -n X          like |tail -X");
		moreprint("+ : -maxsize X    Filter out on filesize");
		moreprint("+ : -minsize X    Filter out on filesize");
	}
	if (i_usage && i_example) moreprint("    Examples:");
	if (i_example)
	{
		moreprint("Windows-dir command clone:           dir /root/script /od");
		moreprint("Show the 10 largest .mp4 file in c:\\:dir c:\\ /s /os -n 10 -find .mp4");
		moreprint("Find .mp4 duplicate in C:\\:          dir c:\\ /s -crc32 -find .mp4");
		moreprint("How big is c:\\z,with subdirs?:       dir c:\\z /s -n 1");
		moreprint("100 biggest dup. files in c:\\z?:     dir c:\\z /s -crc32 -n 100");
		moreprint("Show -md5 cheksum, recurse by size:  dir z:\\cb /s /os -checksum -md5");
		moreprint("Like dir:                            dir z:\\cb\\*.avi");
	}
}
void help_k(bool i_usage,bool i_example)
{
	if (i_usage)
	{
		moreprint("CMD   k (kill, risky!)");
		moreprint("+ :               Kill (delete) all files and directories that arent in an archive");
		moreprint("                  removing excess files");
	}
	if (i_usage && i_example) moreprint("    Examples:");
	if (i_example)
	{
		moreprint("   RISKY COMMAND: DO NOT USE IF YOU DO NOT UNDERSTAND!");
		moreprint("Create an archive                    a z:\\1.zpaq c:\\z");
		moreprint("Extract into z:\\knb                  x z:\\1.zpaq c:\\z -to z:\\knb");
		moreprint("... something happens (change) in");
		moreprint("z:\\knb and we want to turn back");
		moreprint("WITHOUT delete everything and ");
		moreprint("extract again (maybe it's huge):     k z:\\1.zpaq c:\\z -to z:\\knb");
	}
}
void help_n(bool i_usage,bool i_example)
{
	if (i_usage)
	{
		moreprint("CMD   n (decimatioN)");
		moreprint("+ :               Keep -n X files in a folder (NO recursive scan), delete all the others");
		moreprint("                  At least one * must be used to filter.");
		moreprint("                  with -exec execute external command");
		moreprint("+ : -kill         Do a wet run (default dry run)");
		moreprint("+ : -exec p.bat   Instead of delete launch p.bat with parameter");
		moreprint("+ : /od           Order by date (default)");
		moreprint("+ : /on           Order by name");
		moreprint("+ : -verbose      Show infos");
		moreprint("+ : -force        Continue even if >50 files founded");
	}
	if (i_usage && i_example) moreprint("    Examples:");
	if (i_example)
	{
		moreprint("   RISKY COMMAND: DO NOT USE IF YOU DO NOT UNDERSTAND!");
		moreprint("Keep 10 newest files in z:\\1\\        n z:\\1\\*.txt -n 10 -kill");
		moreprint("Keep 20 ordered by name              n z:\\1\\dumpy_*.sql -n 20 -kill -force /on");
		moreprint("Keep 30 txt ordered by name          n z:\\1\\*.txt -n 20 -kill -force /on");
		moreprint("Check the last file with ugo.bat     n z:\\1\\*.txt -kill -exec ugo.bat");
	}
}
void help_mainswitches(bool i_usage,bool i_example)
{
	if (i_usage) 
		if (i_example)
			i_example=i_usage;
	moreprint("  -all [N]:     All versions (default 4 digits)");
	moreprint("  -key X:       Archive password X");
	moreprint("  -mN -method N:0=no compression, 1..5=faster..better ");
	moreprint("  -force:       Always overwrite");
	moreprint("  -test:        Verify (extract/add)");
	moreprint("  -kill:        Allow destructive operations ('wet runs')");
	moreprint("  -to out...:   Prefix files to out");
	moreprint("  -until N:     Roll back to N'th version");
}
void help_switches(bool i_usage,bool i_example)
{
	if (i_usage) 
		if (i_example)
			i_example=i_usage;
	char buffer[200];
	time_t now=time(NULL);
	tm* t=gmtime(&now);
	int64_t date=(t->tm_year+1900)*10000000000LL+(t->tm_mon+1)*100000000LL
      +t->tm_mday*1000000+t->tm_hour*10000+t->tm_min*100+t->tm_sec;
	sprintf(buffer,"  -until %s   Set date, roll back (UT, default time: 235959)",dateToString(date).c_str());
	moreprint(buffer);
	moreprint("  -not files...   Exclude. * and ? match any string or char");
	moreprint("       =[+-#^?]   List: exclude by comparison result");
	moreprint("  -only files...  Include only matches (default: *) example *pippo*.mp4");
	moreprint("  -always files   Always (force) adding some file");
	moreprint("  -noattributes   Ignore/don't save file attributes or permissions");
	moreprint("  -index F        Extract: create index F for archive");
	moreprint("                  Add: create suffix for archive indexed by F, update F");
	moreprint("  -sN -summary N  If >0 show only summary (sha1())");
}
void help_franzswitches(bool i_usage,bool i_example)
{
	if (i_usage) 
		if (i_example)
			i_example=i_usage;
	moreprint("+ : -utc          Do not convert to localtime (use UTC, like 715)");
	moreprint("+ : -715          Works just about like v7.15");
	moreprint("+ : -checksum     Store SHA1+CRC32 for every file");
	moreprint("+ : -verify       Force re-read of file during t (test command) or c");
	moreprint("+ : -noeta        Do not show ETA");
	moreprint("+ : -pakka        Output for PAKKA (briefly)");
	moreprint("+ : -verbose      Show more (alias -v)");
	moreprint("+ : -silent       Be mute (!)");
	moreprint("+ : -zfs          Skip paths including .zfs");
	moreprint("+ : -forcezfs     Force paths including .zfs");
	moreprint("+ : -noqnap       Skip path including @Recently-Snapshot and @Recycle");
	moreprint("+ : -forcewindows Take $DATA$ and System Volume Information");
	moreprint("+ : -xls          Do NOT always force XLS/PPT");
	moreprint("+ : -nopath       Do not store path");
	moreprint("+ : -nosort       Do not sort file when adding or listing");
	moreprint("+ : -find       X Search for X in full filename (ex. list)");
	moreprint("+ : -replace    Y Replace X with Y in full filename (ex. list)");
	moreprint("+ : -n          X Only print last X lines in dir (like tail)/first X (list)");
	moreprint("+ : -limit      X (like -n)");
	moreprint("+ : -minsize    X Skip files by length (add(), list(), dir())");
	moreprint("+ : -maxsize    X Skip files by length (add(), list(), dir())");
	moreprint("+ : -filelength X Utf command: find file with length>X, extract maxfilelen");
	moreprint("+ : -dirlength  X Utf command: find dirs with length>X, extract maxdirlen");
	moreprint("+ : -comment foo  Add/find ASCII comment string to versions");
	help_printhash(false);
	moreprint("+ : -exec_ok f.sh After OK launch f.sh");
	moreprint("+ : -exec_error z After NOT OK launch z");
	moreprint("+ : -exec_warn cz At Warn launch cz");
	moreprint("+ : -exec pip.bat Launch pip.bat %1 with command n");
	moreprint("+ : -output s.txt Output on s.txt too (alias: -out)");
	moreprint("+ : -kill         Show 'script-ready' log of dup files");
	moreprint("+ : -kill         In extraction write 0-bytes file instead of data");
	moreprint("+ : -utf          Remove non-utf8 chars");
	moreprint("+ : -utf8         Like -utf");
	moreprint("+ : -fix255       Shrink total file length and case collisions (NTFS)");
	moreprint("+ : -fixeml       Heuristically compress .eml filenames (Fwd Fwd Fwd =>Fwd)");
	moreprint("+ : -flat         Everything in single path (emergency extract of strange files)");
	moreprint("+ : -debug        Show lot of infos (superverbose)");
	moreprint("+ : -timestamp X  Set version datetime@X 14 digit (2021-12-30_01:03:04)"); 	
	moreprint("+ : -filelist     Store the add() list in VFILE-l-filelist.txt");
	moreprint("+ : -nodedup      Disabling deduplication");
	moreprint("+ : -orderby x    Sort file by ext;size;name;hash;date;data;nilsimsa;");
	moreprint("+ : -desc         Descending sort (if -orderby)");
	moreprint("+ : -tar          tar mode: turn off deduplication and compression");
	moreprint("+ : -norecursion  Do not recurse into folders (default: YES)");
}
void help_voodooswitches(bool i_usage,bool i_example)
{
	if (i_usage) 
		if (i_example)
			i_example=i_usage;
	moreprint("  -repack F [X]   Extract to new archive F with key X (default: none)");
	moreprint("  -tN -threads N  Use N threads (default: 0 = all cores)");
	moreprint("  -fragment N     Use 2^N KiB average fragment size (default: 6)");
	moreprint("  -mNB -method NB Use 2^B MiB blocks (0..11, default: 04, 14, 26..56)");
	moreprint("  -method {xs}B[,N2]...[{ciawmst}[N1[,N2]...]]...  Advanced:");
	moreprint("  x=journaling (default). s=streaming (no dedupe)");
	moreprint("    N2: 0=no pre/post. 1,2=packed,byte LZ77. 3=BWT. 4..7=0..3 with E8E9");
	moreprint("    N3=LZ77 min match. N4=longer match to try first (0=none). 2^N5=search");
	moreprint("    depth. 2^N6=hash table size (N6=B+21: suffix array). N7=lookahead");
	moreprint("    Context modeling defaults shown below:");
	moreprint("  c0,0,0: context model. N1: 0=ICM, 1..256=CM max count. 1000..1256 halves");
	moreprint("    memory. N2: 1..255=offset mod N2, 1000..1255=offset from N2-1000 byte");
	moreprint("    N3...: order 0... context masks (0..255). 256..511=mask+byte LZ77");
	moreprint("    parse state, >1000: gap of N3-1000 zeros");
	moreprint("  i: ISSE chain. N1=context order. N2...=order increment");
	moreprint("  a24,0,0: MATCH: N1=hash multiplier. N2=halve buffer. N3=halve hash tab");
	moreprint("  w1,65,26,223,20,0: Order 0..N1-1 word ISSE chain. A word is bytes");
	moreprint("    N2..N2+N3-1 ANDed with N4, hash mulitpiler N5, memory halved by N6");
	moreprint("  m8,24: MIX all previous models, N1 context bits, learning rate N2");
	moreprint("  s8,32,255: SSE last model. N1 context bits, count range N2..N3");
	moreprint("  t8,24: MIX2 last 2 models, N1 context bits, learning rate N2");
}
void Jidac::load_help_map()
{
	help_map.insert(std::pair<string, voidhelpfunction>("trim",help_trim));
	help_map.insert(std::pair<string, voidhelpfunction>("password",help_setpassword));
	help_map.insert(std::pair<string, voidhelpfunction>("dirsize",help_dirsize));
	help_map.insert(std::pair<string, voidhelpfunction>("b",help_b));
	help_map.insert(std::pair<string, voidhelpfunction>("n",help_n));
	help_map.insert(std::pair<string, voidhelpfunction>("f",help_f));
	help_map.insert(std::pair<string, voidhelpfunction>("a",help_a));
	help_map.insert(std::pair<string, voidhelpfunction>("l",help_l));
	help_map.insert(std::pair<string, voidhelpfunction>("i",help_i));
	help_map.insert(std::pair<string, voidhelpfunction>("t",help_t));
	help_map.insert(std::pair<string, voidhelpfunction>("v",help_v));
	help_map.insert(std::pair<string, voidhelpfunction>("x",help_x));
	help_map.insert(std::pair<string, voidhelpfunction>("w",help_w));
	help_map.insert(std::pair<string, voidhelpfunction>("s",help_s));
	help_map.insert(std::pair<string, voidhelpfunction>("c",help_c));
	help_map.insert(std::pair<string, voidhelpfunction>("p",help_p));
	help_map.insert(std::pair<string, voidhelpfunction>("r",help_r));
	help_map.insert(std::pair<string, voidhelpfunction>("cp",help_cp));
	help_map.insert(std::pair<string, voidhelpfunction>("z",help_z));
	help_map.insert(std::pair<string, voidhelpfunction>("m",help_m));
	help_map.insert(std::pair<string, voidhelpfunction>("d",help_d));
	help_map.insert(std::pair<string, voidhelpfunction>("dir",help_dir));
	help_map.insert(std::pair<string, voidhelpfunction>("sum",help_sha1));
	help_map.insert(std::pair<string, voidhelpfunction>("utf",help_utf));
	help_map.insert(std::pair<string, voidhelpfunction>("k",help_k));
	help_map.insert(std::pair<string, voidhelpfunction>("rsync",help_rsync));
	help_map.insert(std::pair<string, voidhelpfunction>("zfs",help_zfs));
	switches_map.insert(std::pair<string, voidhelpfunction>("main",help_mainswitches));
	switches_map.insert(std::pair<string, voidhelpfunction>("normal",help_switches));
	switches_map.insert(std::pair<string, voidhelpfunction>("franz",help_franzswitches));
	switches_map.insert(std::pair<string, voidhelpfunction>("voodoo",help_voodooswitches));
}
void Jidac::usage() 
{
	moreprint("Usage: zpaqfranz command archive[.zpaq] files|directory... -switches...");
	moreprint("             h: **** Help on Help ****|  With great power comes great  ...  help!");
	moreprint("             a: Append files          |          t: Test (integrity)");
	moreprint("             x: Extract versions      |          l: List files");
	moreprint("             v: Verify on filesystem  |          i: Info (show versions)");
	moreprint(" c d0 d1 d2...: Compare d0 to d1,d2.. | s d0 d1 d2: Cumulative size of d0, d1, d2");
	moreprint(" r d0 d1 d2...: Mirror  d0 in d1...   |       d d0: Deduplicate d0  WITHOUT MERCY");
	moreprint(" z d0 d1 d2...: Delete empty dirs     |        m X: Merge multipart archive");
	moreprint("          f d0: Fill /wipe free space |     utf d0: Detox filenames  in  d0");
	moreprint("  sum d0 d1...: Hashing/deduplication |     dir d0: Win dir (/s /a /os /od)");
	moreprint("     n d0 -n X: Keep X files in d0    |          b: CPU benchmarking (-all)");
	moreprint("   rsync d0 d1: Purge temporary rsync | cp X -to Y: Copy files (w/wildcards) to Y");
	moreprint("          trim: Trim incomplete add() |    dirsize: Get size of archive's folders");
	moreprint("      password: Add/remove/change pwd |");
	moreprint(" zfsadd zfslist zfspurge              =>  zfs-specific commands (typically FreBSD)");
	moreprint("                                 Main | switches");
	moreprint("      -all [N]: All versions N digit  |     -key X: Use/set archive password to X");
	moreprint(" -mN -method N: 0..5= faster..better  |     -force: Always overwrite (extraction)");
	moreprint("         -test: Test (extract/add)    |      -kill: Allow destructive (NO dryrun)");
	moreprint("    -to out...: Prefix files to out   |   -until N: Roll back to N'th version");
	seppuku();
}
void Jidac::helphelp()
{
	load_help_map();
	string 	lista		="";
	string	listaswitch	="OR one set of SWITCHES:  ";
	for (MAPPAHELP::iterator p=help_map.begin(); p!=help_map.end(); ++p) 
		lista+=p->first+" ";
	for (MAPPAHELP::iterator p=switches_map.begin(); p!=switches_map.end(); ++p) 
		listaswitch+=p->first+" ";
	moreprint("");
	moreprint("zpaq fork that stores by default CRC32+XXHASH64 (SHA-1|SHA-2|SHA-3|MD5|XXH3|BLAKE3)");
	moreprint("with full backward zpaq 7.15 compatibility. Swiss army knife for disaster managers:");
	moreprint("comparing,hashing,deduplication,utf-8,empty dirs,SFX,ZFS & VSS support... and more.");
	moreprint("Doveryay, no proveryay;  trust, but verify; fidarsi e' bene, non fidarsi e' meglio.");
	moreprint("");
	moreprint("Runs on                  Win 32/64, Linux, Free/OpenBSD, Solaris, MacOS and others.");
	moreprint("www.francocorbelli.com   sourceforge.net/projects/zpaqfranz    github.com/fcorbelli");
	printbar('=');
	moreprint("Help ALL IN EVERYTHING : zpaqfranz h h                       zpaqfranz /? /?");
	moreprint("Help     on SOMETHING  : zpaqfranz h   SOMETHING             zpaqfranz /? SOMETHING");
	moreprint("Help     on SOMETHING  : zpaqfranz -?  SOMETHING             zpaqfranz -h SOMETHING");
	moreprint("Examples of SOMETHING  : zpaqfranz -he SOMETHING");
	moreprint("");
	moreprint("SOMETHING is a COMMAND");
	printbar('-');
	moreprint(lista.c_str());
	printbar('-');
	moreprint(listaswitch.c_str());
	printbar('-');
}	
void Jidac::usageall(string i_command) 
{
	load_help_map();
	MAPPAHELP::iterator a=help_map.find(i_command);
	if (a==help_map.end())
	{
		if (i_command!="")
		{
			MAPPAHELP::iterator b=switches_map.find(i_command);
			if (b!=switches_map.end())
			{
				(*b->second)(true,true);
				seppuku();
			}
		}
		usage();
		moreprint("Usage full:");
		for (MAPPAHELP::iterator p=help_map.begin(); p!=help_map.end(); ++p) 
		{
			(*p->second)(true,true);
			morebar('-');
		}
		morebar('-');
		moreprint("Extended switches:");
		help_switches(true,true);
		morebar('-');
		moreprint("zpaqfranz switches:");
		help_franzswitches(true,true);
		morebar('-');
		moreprint("Voodoo switches");
		help_voodooswitches(true,true);
	}
	else
	{	
		(*a->second)(true,true);
		morebar('-');
	}
	seppuku();
}
void Jidac::examples(string i_command) 
{
	load_help_map();	
	MAPPAHELP::iterator a=help_map.find(i_command);
	if (a==help_map.end())
	{
		for (MAPPAHELP::iterator p=help_map.begin(); p!=help_map.end(); ++p) 
		{
			(*p->second)(false,true);
			morebar('-');
		}
	}
	else
	{	
		(*a->second)(false,true);
		morebar('-');
	}
}
void open_output(string i_filename)
{
	if (i_filename!="")
		if (g_output_handle==0)
		{
			g_output=i_filename;
			g_output_handle=fopen(i_filename.c_str(),"wb");
			if (g_output_handle==NULL)
				printf("28342: ERROR OPENING LOG FILE %s\n",i_filename.c_str());
		}
}
string tail(string const& i_source, size_t const i_length) 
{
	if (i_length>=i_source.size()) 
		return i_source;
	return i_source.substr(i_source.size()-i_length);
}
string Jidac::rename(string name) 
{
	if (replaceto!="")
	{
		if (searchfrom!="")
		{
			replace(name,searchfrom,replaceto);	
			if (flagdebug)
				myprintf("27144: name after search - replace %s\n",name.c_str());
		}
		else
		{
			name=replaceto+name;
			if (flagdebug)
				myprintf("27192: name after replace %s\n",name.c_str());
		}
	}
	if (flagnopath)
	{
		string myname=name;
		for (unsigned i=0; i<files.size(); ++i) 
		{
			string pathwithbar=files[i];
			if (pathwithbar[pathwithbar.size()-1]!='/')
				pathwithbar+="/";
			  if (strstr(name.c_str(), pathwithbar.c_str())!=0)
			  {
				myreplace(myname,pathwithbar,"");
				if (flagverbose)
					myprintf("Cutting path <<%s>> to <<%s>>\n",files[i].c_str(),myname.c_str());
				return myname;
			  }
		}
		return myname;
	}
	if (files.size()==0 && tofiles.size()>0)  
		name=append_path(tofiles[0], name);
	else 
	{  
		const int n=name.size();
		for (unsigned i=0; i<files.size() && i<tofiles.size(); ++i) 
		{
			const int fn=files[i].size();
			if (fn<=n && files[i]==name.substr(0, fn))
				return tofiles[i]+name.substr(fn);
        }
	}
  return name;
}
string Jidac::getpassword()
{
	char myline[251];
	unsigned int i=0;
    int c;
	myprintf("\nEnter password (max %d chars):",(int)sizeof(myline)-1);
	string myresult="";
	while (1)
	{
		while (( (c = getchar())!='\n') && (c!= EOF) && (i< sizeof(myline)-1) )
			myline[i++] = c;
		myline[i] = '\0';
		myresult=myline;
		if (myresult!="")
		{
			if (myresult[0]=='-')
			{
				myprintf("Password starting with - can be confused with switches, enter another one!\n");
				i=0;
				myresult="";
			}
			else
				break;
		}
	}
	return myresult;
}
int Jidac::doCommand(int argc, const char** argv) 
{
	fullcommandline		="";
  	plainpassword		="";
	g_franzsnap			="c:/franzsnap";
	g_vss_shadow		="";
	g_franzotype		=2; 
	g_sfx				="";
	g_sfxto				="";
	g_sfxnot			="";
	g_sfxonly			="";
	g_sfxuntil			="";
	g_sfxflagforce		=false;
	g_sfxflagall		=false;
	g_freeze			="";
	g_archive			="";
	g_output_handle		=NULL;
	g_output			="";
	g_exec_error		="";
	g_255				=0; 
	g_exec_warn			="";
	g_exec_ok			="";
	g_exec				="";
	g_exec_text			="";
	g_copy				="";
	command				=0;
	flagforce			=false;
	flagzero			=false;
	flagnoattributes	=false;
	flagbarraod			=false;
	flagbarraon			=false;
	flagbarraos			=false;
	flagdebug			=false;
	flagnodedup			=false;
	flagtar				=false;
	flagramdisk			=false;
	flagssd				=false;
	flagnorecursion		=false;
	flagsilent			=false;
	flagtouch			=false;
	flagfrugal			=false;
	flagstat			=false;
	flagdesc			=false;
	flagtest			=false;
	flagskipzfs			=false; 
	flagverbose			=false;
	flagnoqnap			=false;
	flagforcewindows	=false;
	flagnopath			=false;
	flagnoeta			=false;
	flagpakka			=false;
	flagvss				=false;
	flagnosort			=false;
	flagchecksum		=false;
	flagnochecksum		=false;
	flagcrc32c			=false;
	flagentropy			=false;
	flagsha1			=false;
	flagverify			=false;
	flagkill			=false;
	flagutf				=false;
	flagfix255			=false;
	flagfixeml			=false;
	flagflat			=false;
	flagparanoid		=false;
	flagxxh3			=false;
	flagcrc32			=false;
	flagsha256			=false;
	flagwyhash			=false;
	flagwhirlpool		=false;
	flagmd5				=false;
	flagsha3			=false;
	flagblake3			=false;
	flagxxhash64		=false;
	flagdonotforcexls	=false;
	flagcomment			=false;
	flag715				=false;
	flagfilelist		=false;
	flagmm				=false;
	flagappend			=false;
	flagutc				=false;
	flaghw				=false;
	fragment			=6;
	minsize				=0;
	maxsize				=0;
	dirlength			=0;
	filelength			=0;
	all					=0;
	password			=0;  
	index				=0;
	method				="";  
	repack				="";
	new_password		=0;
	summary				=-1; 
	menoenne			=0;
	versioncomment		="";
	searchfrom			="";
	orderby				="";
	replaceto			="";
	searchhash			="";
	zpaqfranzexename	="";
	howmanythreads		=0; 
	version				=DEFAULT_VERSION;
	date				=0;
	if (argc>1)
		for (int i=1; i<argc; i++)
		{
			string temp=argv[i];
			fullcommandline+=temp+" ";
		}
	if (argc>0)
	{
		zpaqfranzexename=argv[0];
	}		
	string myexename=extractfilename(zpaqfranzexename);
	if (myexename=="dir")
	{
		files.clear();
		int i=0;
		while (++i<argc && argv[i][0]!='-')  
			files.push_back(argv[i]);
		return dir();
	}
	for (int i=0; i<argc; i++)
	{
		const string parametro=argv[i];
		if (stringcomparei(parametro,"-pakka"))
			flagpakka=true;
	}
	if (!flagpakka)
	{
		moreprint("zpaqfranz-bsd v" ZPAQ_VERSION " archiver, " ZSFX_VERSION " compiled " __DATE__);
	}
	if (argc==1) 
	{
		usage();
		seppuku();
	}
	if (argc==2) 
	{
		const string parametro=argv[1];
		if  ((stringcomparei(parametro,"help"))
			||
			(stringcomparei(parametro,"-h"))
			||
			(stringcomparei(parametro,"h"))
			||
			(stringcomparei(parametro,"?"))
			||
			(stringcomparei(parametro,"-?"))
			||
			(stringcomparei(parametro,"/?"))
			||
			(stringcomparei(parametro,"--help"))
			||
			(stringcomparei(parametro,"-help")))
			{
				helphelp();
				seppuku();
			}
		if ((stringcomparei(parametro,"-he"))
			||
			(stringcomparei(parametro,"-helpe"))
			||
			(stringcomparei(parametro,"-example"))
			||
			(stringcomparei(parametro,"-examples")))
			{
				examples("");
				seppuku();
			}
	}
	if (argc==3) 
	{
		const string parametro=argv[1];
		const string comando=argv[2];
		if  ((stringcomparei(parametro,"help"))
			||
			(stringcomparei(parametro,"-h"))
			||
			(stringcomparei(parametro,"h"))
			||
			(stringcomparei(parametro,"?"))
			||
			(stringcomparei(parametro,"/?"))
			||
			(stringcomparei(parametro,"-?"))
			||
			(stringcomparei(parametro,"--help"))
			||
			(stringcomparei(parametro,"-help")))
			{
				if (comando=="h") 
					usageall("");
				else
					usageall(comando);
				seppuku();
			}
		if ((stringcomparei(parametro,"-he"))
			||
			(stringcomparei(parametro,"-helpe"))
			||
			(stringcomparei(parametro,"-example"))
			||
			(stringcomparei(parametro,"-examples")))
			{
				examples(comando);
				seppuku();
			}
	}
	ht.resize(1);  
	ver.resize(1); 
	dhsize=dcsize=0;
	time_t now=time(NULL);
	tm* t=gmtime(&now);
	date=(t->tm_year+1900)*10000000000LL+(t->tm_mon+1)*100000000LL
      +t->tm_mday*1000000+t->tm_hour*10000+t->tm_min*100+t->tm_sec;
	g_optional="";
	for (int i=1; i<argc; ++i) 
	{
		const string opt=argv[i];  
		if (opt=="-715") 			
		{			
			flag715=true;
		}
		else
		if (opt=="/od")
		{
			flagbarraod=true;
		}
		else
		if (opt=="/on")
		{
			flagbarraon=true;
		}
		else
		if (opt=="/os")
		{
			flagbarraos=true;
		}
		else
		if ((opt=="benchmark") || (opt=="b"))
		{
			command='b';
		}
		else
		if ((opt=="trim"))
		{
			command='4'; 
			while (++i<argc && argv[i][0]!='-')  
				files.push_back(argv[i]);
			i--;
		}
		else
		if ((opt=="password"))
		{
			command='6'; 
			while (++i<argc && argv[i][0]!='-')  
				files.push_back(argv[i]);
			i--;
		}
		else 
		if ((opt=="zfslist") || (opt=="zfspurge") || (opt=="zfsadd"))
		{
			command='9';
			g_optional=opt;
			while (++i<argc)  
			{
				string dummy=argv[i];
				if (dummy=="-force")
					flagforce=true;
				else
					files.push_back(argv[i]);
			}
			--i;
		}
		else
		if ((
		opt=="add" 		|| 
		opt=="extract" 	|| 
		opt=="list" 	|| 
		opt=="k" 		|| 
		opt=="a"  		|| 
		opt=="x" 		|| 
		opt=="p" 		|| 
		opt=="t" 		||
		opt=="test" 	|| 
		opt=="l" 		|| 
		opt=="v"		||
		opt=="w"		||
		opt=="i" 		|| 
		opt=="q" 		|| 
		opt=="g" 		|| 
		opt=="sfx" 		|| 
		opt=="m"		||
		opt=="dirsize")
        && i<argc-1 && argv[i+1][0]!='-' && command==0) 
		{
			command=opt[0];
			if (opt=="extract") 
				command='x';
			if (opt=="test") 
				command='t';
			if (opt=="sfx")
				command='y';
			if (opt=="dirsize")
			{
				command='5';
				g_optional="dirsize";
			}
			archive=argv[++i];  
			const char* slash=strrchr(argv[i], '/');
			const char* dot=strrchr(slash ? slash : argv[i], '.');
			if (!dot && archive!="") 
				archive+=".zpaq";
			while (++i<argc && argv[i][0]!='-')  
				files.push_back(argv[i]);
			--i;
		}
		else if ((opt=="sha1") || (opt=="sum"))
		{
			command='1'; 
			while (++i<argc && argv[i][0]!='-')  
				files.push_back(argv[i]);
			i--;
		}
		else if ((opt=="rsync"))
		{
			command='3'; 
			while (++i<argc && argv[i][0]!='-')  
				files.push_back(argv[i]);
			i--;
		}
		else if (opt=="d")
		{
			command='d';
			while (++i<argc && argv[i][0]!='-')  
				files.push_back(argv[i]);
			i--;
		}
		else if (opt=="dir")
		{
			command='2'; 
			while (++i<argc && argv[i][0]!='-')  
				files.push_back(argv[i]);
			i--;
		}
		else if (
		(opt=="n") 			|| 
		(opt=="f") 			|| 
		(opt=="c") 			|| 
		(opt=="s") 			|| 
		(opt=="utf") 		|| 
		(opt=="r") 			|| 
		(opt=="robocopy") 	|| 
		(opt=="cp") 	|| 
		opt=="z")
		{
			command=opt[0];
			if (opt=="cp")
					command='o';
			while (++i<argc && argv[i][0]!='-')
			{
				string candidate=argv[i];
				cutdoublequote(candidate);
				if (havedoublequote(candidate))
				{
					myprintf("WARNING: double quote founded in command line and cutted\n");
					candidate.pop_back();
					myprintf("||%s||\n",candidate.c_str());
				}
#endif	
			files.push_back(candidate);
			}
			i--;
		}
		else if (opt.size()<2 || opt[0]!='-') usage();
		else 
		if (opt=="-all") 
		{
			all=4;
			if (i<argc-1 && isdigit(argv[i+1][0])) 	all				=atoi(argv[++i]);
		}
		else if (opt=="-fragment" 	&& i<argc-1)	fragment		=atoi(argv[++i]);
		else if (opt=="-minsize" 	&& i<argc-1) 	minsize			=atoll(argv[++i]);
		else if (opt=="-maxsize" 	&& i<argc-1) 	maxsize			=atoll(argv[++i]);
		else if (opt=="-filelength" && i<argc-1) 	filelength		=atoi(argv[++i]);
		else if (opt=="-dirlength" 	&& i<argc-1) 	dirlength		=atoi(argv[++i]);
		else if (opt=="-n" 			&& i<argc-1) 	menoenne		=atoi(argv[++i]);
		else if (opt=="-limit" 		&& i<argc-1) 	menoenne		=atoi(argv[++i]);
		else if (opt=="-index" 		&& i<argc-1) 	index			=argv[++i];
		else if (opt=="-method" 	&& i<argc-1) 	method			=argv[++i];
		else if (opt=="-threads" 	&& i<argc-1) 	howmanythreads	=atoi(argv[++i]);
		else if ((opt[0]=='-') && (isdigit(opt[2])))
		{
			if (opt[1]=='m') method			=argv[i]+2;
			if (opt[1]=='s') summary		=atoi(argv[i]+2);
			if (opt[1]=='t') howmanythreads	=atoi(argv[i]+2);
		}
		else if (opt=="-summary" 	&& i<argc-1)	
		{
			if(argv[i+1][0]!='-')
				summary=atoi(argv[++i]);
			else
				summary=1;	
		}
		else if (opt=="-summary" 	&& i>=argc-1)	
		{
			summary=1;
		}
		else if ((opt=="-find") || (opt=="-search"))
		{
			if (i!=argc-1) 
			if (searchfrom=="" && strlen(argv[i+1])>=1)
			{
				searchfrom=argv[i+1];
				i++;
			}
		}
		else if (opt=="-orderby")
		{
			if (i!=argc-1) 
			if (orderby=="" && strlen(argv[i+1])>=1)
			{
				orderby=argv[i+1];
				i++;
			}
		}
		else if ((opt=="-findhash") || (opt=="-searchhash"))
		{
			if (i!=argc-1) 
			if (searchhash=="" && strlen(argv[i+1])>=1)
			{
				searchhash=argv[i+1];
				i++;
			}
		}
		else if (opt=="-replace")
		{
			if (i!=argc-1) 
			if (replaceto=="" && strlen(argv[i+1])>=1)
			{
				replaceto=argv[i+1];
				i++;
			}
		}
		else if ((opt=="-exec_error") || (opt=="-exec_err"))
		{
			if (g_exec_error=="")
			{
				if (++i<argc && argv[i][0]!='-')  
					g_exec_error=argv[i];
				else
					i--;
			}
		}
		else if (opt=="-exec_warn")
		{
			if (g_exec_warn=="")
			{
				if (++i<argc && argv[i][0]!='-')  
					g_exec_warn=argv[i];
				else
					i--;
			}
		}	
		else if (opt=="-exec_ok")
		{
			if (g_exec_ok=="")
			{
				if (++i<argc && argv[i][0]!='-')  
					g_exec_ok=argv[i];
				else
					i--;
			}
		}
		else if (opt=="-copy")
		{
			if (g_copy=="")
			{
				if (++i<argc && argv[i][0]!='-')  
					g_copy=argv[i];
				else
					i--;
			}
		}
		else if (opt=="-freeze")
		{
			if (g_freeze=="")
			{
				if (++i<argc && argv[i][0]!='-')  
					g_freeze=argv[i];
				else
					i--;
			}
		}
		else if ((opt=="-output") || (opt=="-out"))
		{
			if (g_output=="")
			{
				if (++i<argc && argv[i][0]!='-')  
					g_output=argv[i];
				else
					i--;
			}
		}
		else if (opt=="-sfx")
		{
			if (g_sfx=="")
			{
				if (++i<argc && argv[i][0]!='-')  
					g_sfx=argv[i];
				else
					i--;
			}
		}
		else if (opt=="-sfxto")
		{
			if (g_sfxto=="")
			{
				if (++i<argc && argv[i][0]!='-')  
					g_sfxto=argv[i];
				else
					i--;
			}
		}
		else if (opt=="-exec")
		{
			if (g_exec=="")
			{
				if (++i<argc && argv[i][0]!='-')  
					g_exec=argv[i];
				else
					i--;
			}
		}
		else if (opt=="-comment")
		{
			flagcomment=true;
			if (++i<argc && argv[i][0]!='-')  
				versioncomment=argv[i];
			else
				i--;
		}
		else if (opt=="-timestamp") 	
		{
			if (i+1<argc)
				if (strlen(argv[i+1])>=1)
				{
					string mytimestamp=argv[i+1];
					i++;
					int64_t newdate=encodestringdate(mytimestamp);
					if (newdate!=-1)
					{
						myprintf("franz: -timestamp change from %s => %s\n",dateToString(date).c_str(),dateToString(newdate).c_str());
						date=newdate;
					}
				}
		}
		else if (opt=="-force" || opt=="-f") 		flagforce			=true;
		else if (opt=="-sfxforce") 					g_sfxflagforce		=true;
		else if (opt=="-sfxall") 					g_sfxflagall		=true;
		else if (opt=="-zero") 						flagzero			=true;
		else if (opt=="-noattributes") 				flagnoattributes	=true;
		else if (opt=="-test") 						flagtest			=true;
		else if (opt=="-zfs") 						flagskipzfs			=true;
		else if (opt=="-forcezfs") 					flagforcezfs		=true;
		else if (opt=="-space") 					flagspace   		=true;
		else if (opt=="-filelist") 					flagfilelist		=true;
		else if (opt=="-xls") 						flagdonotforcexls	=true;
		else if (opt=="-verbose") 					flagverbose			=true;
		else if (opt=="-v") 						flagverbose			=true;
		else if (opt=="-debug") 					flagdebug			=true;
		else if (opt=="-nodedup") 					flagnodedup			=true;
		else if (opt=="-tar") 						flagtar				=true;
		else if (opt=="-ramdisk") 					flagramdisk			=true;
		else if (opt=="-ssd") 						flagssd				=true;
		else if (opt=="-norecursion") 				flagnorecursion		=true;
		else if (opt=="-silent") 					flagsilent			=true;
		else if (opt=="-touch") 					flagtouch			=true;
		else if (opt=="-frugal") 					flagfrugal			=true;
		else if (opt=="-stat") 						flagstat			=true;
		else if (opt=="-desc") 						flagdesc			=true;
		else if (opt=="-noqnap") 					flagnoqnap			=true;
		else if (opt=="-nopath") 					flagnopath			=true;
		else if (opt=="-nosort") 					flagnosort			=true;
		else if (opt=="-checksum") 					flagchecksum		=true;
		else if (opt=="-nochecksum") 				flagnochecksum		=true;
		else if (opt=="-crc32c") 					flagcrc32c			=true;
		else if (opt=="-entropy") 					flagentropy			=true;
		else if (opt=="-sha1") 						flagsha1			=true;
		else if (opt=="-xxh3") 						flagxxh3			=true;
		else if (opt=="-sha256") 					flagsha256			=true;
		else if (opt=="-blake3") 					flagblake3			=true;
		else if (opt=="-mm") 						flagmm				=true;
		else if (opt=="-append") 					flagappend			=true;
		else if (opt=="-utc") 						flagutc				=true;
		else if (opt=="-whirlpool")					flagwhirlpool		=true;
		else if (opt=="-md5")						flagmd5				=true;
		else if (opt=="-sha3")						flagsha3			=true;
		else if (opt=="-nilsimsa")					flagnilsimsa		=true;
		else if (opt=="-wyhash")
		{		flagwyhash			=true;
				myprintf("\n****** WARNING: WYHASH IMPLEMENTATION IS JUST FOR TEST *******\n\n");
		}
		else if (opt=="-xxhash") 					flagxxhash64		=true;
		else if (opt=="-crc32") 					flagcrc32			=true;
		else if (opt=="-verify") 					flagverify			=true;
		else if (opt=="-kill") 						flagkill			=true;
		else if (opt=="-utf") 						flagutf				=true;
		else if (opt=="-utf8") 						flagutf				=true;
		else if (opt=="-fix255") 					flagfix255			=true;
		else if (opt=="-fixeml") 					flagfixeml			=true;
		else if (opt=="-flat") 						flagflat			=true;
		else if (opt=="-paranoid") 					flagparanoid		=true;
		else if (opt=="-noeta") 					flagnoeta			=true;
		else if (opt=="-pakka") 					flagpakka			=true;  
		else if (opt=="-vss") 						flagvss				=true;
		else if (opt=="-forcewindows") 				flagforcewindows	=true;
		else if (opt=="-not") 
		{  
			while (++i<argc && argv[i][0]!='-') 
			{
				if (argv[i][0]=='=')
					nottype=argv[i];
				else
					notfiles.push_back(argv[i]);
			}
			--i;
		}
		else if (opt=="-sfxnot") 
		{  
			while (++i<argc && argv[i][0]!='-') 
			{
				if (argv[i][0]=='=')
					sfxnottype=argv[i];
				else
					sfxnotfiles.push_back(argv[i]);
			}
			--i;
		}
		else if (opt=="-only") 
		{  
			while (++i<argc && argv[i][0]!='-')
				onlyfiles.push_back(argv[i]);
			--i;
		}
		else if (opt=="-sfxonly") 
		{  
			while (++i<argc && argv[i][0]!='-')
				sfxonlyfiles.push_back(argv[i]);
			--i;
		}
		else if (opt=="-always") 
		{  
			while (++i<argc && argv[i][0]!='-')
				alwaysfiles.push_back(argv[i]);
			--i;
		}
		else if (opt=="-key") 
		{
			if (i<argc-1) 
				if (argv[i+1][0]!='-') 
				{
					plainpassword="";
					libzpaq::SHA256 sha256;
					for (const char* p=argv[++i]; *p; ++p)
					{
						sha256.put(*p);
						plainpassword+=*p;
					}
					memcpy(password_string, sha256.result(), 32);
					password=password_string;
				}
			if (password==NULL)
			{
				string spassword=getpassword();
				if (spassword!="")
				{
					libzpaq::SHA256 sha256;
					for (unsigned int i=0;i<spassword.size();i++)
						sha256.put(spassword[i]);
					memcpy(password_string, sha256.result(), 32);
					password=password_string;
				}
			}
		}
		else if (opt=="-key2") 
		{
			if (i<argc-1) 
				if (argv[i+1][0]!='-') 
				{
					libzpaq::SHA256 sha256;
					for (const char* p=argv[++i]; *p; ++p)
						sha256.put(*p);
					memcpy(new_password_string, sha256.result(), 32);
					new_password=new_password_string;
				}
			if (new_password==NULL)
			{
				string spassword=getpassword();
				if (spassword!="")
				{
					libzpaq::SHA256 sha256;
					for (unsigned int i=0;i<spassword.size();i++)
						sha256.put(spassword[i]);
					memcpy(new_password_string, sha256.result(), 32);
					new_password=new_password_string;
				}
			}
		}
		else
		if (opt=="-repack" && i<argc-1) 
		{
			repack=argv[++i];
			string estensione=prendiestensione(repack);
			if (estensione=="")
				repack+=".zpaq";
			if (i<argc-1 && argv[i+1][0]!='-') 
			{
				libzpaq::SHA256 sha256;
				for (const char* p=argv[++i]; *p; ++p) 
					sha256.put(*p);
				memcpy(new_password_string, sha256.result(), 32);
				new_password=new_password_string;
			}
		}
		else if (opt=="-to") 
		{  
			while (++i<argc && argv[i][0]!='-')
			{
				string mytemp=mytrim(argv[i]);
				myreplaceall(mytemp,"\"","");
				tofiles.push_back(mytemp);
			}
			if (tofiles.size()==0)
				tofiles.push_back("");
			--i;
		}
		else 
		if (opt=="-until" && i+1<argc) 
		{  
			version=0;
			int digits=0;
			if (argv[i+1][0]=='-')
			{  
				version=atol(argv[i+1]);
				if (version>-1)
					usage();
				++i;
			}
			else 
			{  
				while (++i<argc && argv[i][0]!='-') 
				{
					for (int j=0; ; ++j) 
					{
						if (isdigit(argv[i][j])) 
						{
							version=version*10+argv[i][j]-'0';
							++digits;
						}
						else 
						{
							if (digits==1)
								version=version/10*100+version%10;
							digits=0;
							if (argv[i][j]==0)
								break;
						}
					}
				}
				--i;
			}
			if (version>=19000000LL     && version<=29991231LL)
				version=version*100+23;
			if (version>=1900000000LL   && version<=2999123123LL)
				version=version*100+59;
			if (version>=190000000000LL && version<=299912312359LL)
				version=version*100+59;
			if (version>9999999) 
			{
				if (version<19000101000000LL || version>29991231235959LL) 
				{
					fflush(stdout);
					myprintf("Version date %1.0f must be 19000101000000 to 29991231235959\n",double(version));
					g_exec_text="Version date must be 19000101000000 to 29991231235959";
					exit(1);
				}
				date=version;
			}
		}
		else
		if (opt=="-sfxuntil" && i+1<argc) 
		{  
			if (g_sfxuntil=="")
			{
				if (++i<argc && argv[i][0]!='-')  
					g_sfxuntil=argv[i];
				else
					i--;
			}
		}
		else 
		{
			myprintf("Unknown option ignored: %s\n", argv[i]);
		}
	}
	if (!flagpakka)
	{
		string franzparameters="";
		if (flagbarraod)
			franzparameters+="Order by date (/od) ";
		if (flagbarraon)
			franzparameters+="Order by name (/on) ";
		if (flagbarraos)
			franzparameters+="Order by size (/os) ";
		if (flagforcezfs)
		{
			franzparameters+="force ZFS on (-forcezfs) ";
			flagskipzfs=false; 
		}
		if (flagskipzfs)
			franzparameters+="SKIP ZFS (-zfs) ";
		if (flag715)
			franzparameters+="mode -715 activated  " ;
		if (flagfilelist)
			franzparameters+="-flagfilelist " ;
		if (flagnoqnap)
			franzparameters+="Exclude QNAP snap & trash (-noqnap) ";
		if (flagforcewindows)
			franzparameters+="Force Windows stuff (-forcewindows) ";
		if (flagnopath)
			franzparameters+="Do not store path (-nopath) ";
		if (flagzero)
			franzparameters+="Zero file ";
		if (flagnosort)
			franzparameters+="-nosort ";
		if (flagdonotforcexls)
			franzparameters+="Do not force XLS/PPT (-xls) ";
		if (flagspace)
			franzparameters+="Do not check free space/writeability ";
		if (flagverbose)
			franzparameters+="-verbose ";
		if (flagchecksum)
			franzparameters+="-checksum ";
		if (flagnochecksum)
			franzparameters+="NO checksum (-nochecksum) ";
		if (flagcrc32c)
			franzparameters+="-crc32c ";
		if (flagentropy)
			franzparameters+="-entropy ";
		if (flagsha1)
			franzparameters+="-sha1 ";
		if (flagcrc32)
			franzparameters+="-crc32 ";
		if (flagxxh3)
			franzparameters+="-xxh3 ";
		if (flagsha256)
			franzparameters+="-sha256 ";
		if (flagwyhash)
			franzparameters+="-wyhash ";
		if (flagwhirlpool)
			franzparameters+="-whirlpool ";
		if (flagnilsimsa)
			franzparameters+="-nilsimsa ";
		if (flagmd5)
			franzparameters+="-md5 ";
		if (flagsha3)
			franzparameters+="-sha3 ";
		if (flagblake3)
			franzparameters+="-blake3 ";
		if (flagxxhash64)
			franzparameters+="xxhash64 (-xxhash) ";
		if (flagmm)
			franzparameters+="memory mapped file (-mm) ";
		if (flagappend)
			franzparameters+="append in copy (-append) ";
		if (flagutc)
			franzparameters+="UTC instead of local time (-utc) ";
		if (flagverify)
			franzparameters+="-verify ";
		if (flagkill)
			franzparameters+="do a wet run! (-kill) ";
		if (flagutf)
			franzparameters+="flagutf (-utf / -utf8) ";
		if (flagfix255)
			franzparameters+="-fix255 ";
		if (flagfixcase)
			flagstat=true;
		if (flagfixeml)
			franzparameters+="Fix eml filenames (-fixeml) ";
		if (flagflat)
			franzparameters+="Flat filenames (-flat) ";
		if (flagparanoid)
			franzparameters+="-paranoid ";
		if (flagnodedup)
			franzparameters+="-nodedup ";
		if (flagtar)
			franzparameters+="TAR mode ";
		if (flagramdisk)
			franzparameters+="-ramdisk ";
		if (flagssd)
			franzparameters+="-ssd ";
		if (flagnorecursion)
			franzparameters+="-norecursion ";
		if (flagtouch)
			franzparameters+="-touch ";
		if (flagfrugal)
			franzparameters+="-frugal ";
		if (flagstat)
			franzparameters+="-stat ";
		if (flagdebug)
			franzparameters+="DEBUG very verbose (-debug) ";
		if (flagdesc)
			if (orderby!="")
				franzparameters+="desc sort ";
		if (flagcomment)
			franzparameters+="Use comment (-comment) ";
		if (summary>0)
			franzparameters+="-summary ";
		char	temp[100];
		if (minsize)
		{
			sprintf(temp,"minsize %s ",migliaia(minsize));
			franzparameters+=temp;
		}
		if (maxsize)
		{
			sprintf(temp,"maxsize %s ",migliaia(maxsize));
			franzparameters+=temp;
		}
		if (dirlength)
		{
			sprintf(temp,"dirlength %s ",migliaia(dirlength));
			franzparameters+=temp;
		}
		if (filelength)
		{
			sprintf(temp,"filelength %s ",migliaia(filelength));
			franzparameters+=temp;
		}
		if (menoenne)
		{
			sprintf(temp,"limit (-n -limit) %u ",menoenne);
			franzparameters+=temp;
		}
		if (franzparameters!="")
			myprintf("franz:%s\n",franzparameters.c_str());
		if (orderby!="")
			myprintf("franz:orderby    <<%s>>\n",orderby.c_str());
		if (searchhash!="")
			myprintf("franz:find hash  <<%s>>\n",searchhash.c_str());
		if (searchfrom!="")
			myprintf("franz:find       <<%s>>\n",searchfrom.c_str());
		if (replaceto!="")
			myprintf("franz:replace    <<%s>>\n",replaceto.c_str());
		if (g_exec_error!="")
			myprintf("franz:exec_error <<%s>>\n",g_exec_error.c_str());
		if (g_exec_warn!="")
			myprintf("franz:exec_warn  <<%s>>\n",g_exec_warn.c_str());
		if (g_exec_ok!="")
			myprintf("franz:exec_ok    <<%s>>\n",g_exec_ok.c_str());
		if (g_exec!="")
			myprintf("franz:exec       <<%s>>\n",g_exec.c_str());
		if (g_copy!="")
			myprintf("franz:copy       <<%s>>\n",g_copy.c_str());
		if (g_output!="")
		{
			myprintf("franz:output     <<%s>>\n",g_output.c_str());
			open_output(g_output);
		}
		if (g_sfx!="")
			myprintf("franz:sfx        <<%s>>\n",g_sfx.c_str());
		if (g_sfxto!="")
			myprintf("franz:sfxto      <<%s>>\n",g_sfxto.c_str());
	}
	if (howmanythreads<1) 
		howmanythreads=numberOfProcessors();
	if (now==-1 || date<19000000000000LL || date>30000000000000LL)
		error("date is incorrect, use -until YYYY-MM-DD HH:MM:SS to set");
	if (version<0) 
	{
		Jidac jidac(*this);
		jidac.version=DEFAULT_VERSION;
		jidac.read_archive(archive.c_str());
		version+=jidac.ver.size()-1;
		myprintf("Version %1.0f\n", version+.0);
	}
	archive=format_datetime(archive);
	for (unsigned int i=0;i<files.size();i++)
		files[i]=format_datetime(files[i]);
	if (flag715)
	{
		flagutc				=true;
		flagzero			=false;
		flagforcezfs		=true;
		flagdonotforcexls	=true;
		flagforcewindows	=true;
		flagcrc32			=false;
		flagentropy			=false;
		flagchecksum		=false;
		flagnochecksum		=true;
		flagfilelist		=false;
		flagxxh3			=false; 
		flagxxhash64		=false; 
		flagfixeml			=false;
		flagfix255			=false;
		flagtouch			=false;
		flagramdisk			=false;
		flagnorecursion		=false;
		flagutf				=false;
		flagflat			=false;
		flagparanoid		=false;
		g_franzotype		=0;
		myprintf("**** Activated V7.15 mode ****\n");
		myprintf("T forcezfs,donotforcexls,forcewindows; F crc32,checksum,filelist,xxhash,xxh3,fixeml,fix255,fixreserved,longpath,utf,flat\n");
	}
	if (command=='a' && files.size()>0) 
	{
		if (flagtar)
		{
			flagnodedup=true;
			method='0';
		}
		flagfixeml			=false;
		flagfix255			=false;
		flagutf				=false;
		flagfixcase			=false;
		flagflat			=false;
		if (flag715 || flagnochecksum)
			g_franzotype=FRANZO_NONE;
		else
		if (flagcrc32)
			g_franzotype=FRANZO_CRC_32;
		else
		if (flagsha1 || flagchecksum) 
			g_franzotype=FRANZO_SHA_1; 
		else
		if (flagsha256)
			g_franzotype=FRANZO_SHA_256;
		else
		if (flagxxh3)
			g_franzotype=FRANZO_XXH3;
		else
		if (flagblake3)
			g_franzotype=FRANZO_BLAKE3;
		else
		if (flagsha3)
			g_franzotype=FRANZO_SHA3;
		else
		if (flagmd5)
			g_franzotype=FRANZO_MD5;
		else
			g_franzotype=FRANZO_XXHASH64; 
		return add();
	}
	else if (command=='n') return decimation();
	else if (command=='1') return summa();
	else if (command=='2') return dir();
	else if (command=='3') return purgersync();
	else if (command=='4') return trim();
	else if (command=='5') return zpaqdirsize();
	else if (command=='6') return setpassword();
	else if (command=='7') return rd();
	else if (command=='b') return benchmark();
	else if (command=='c') return dircompare(false,false);
	else if (command=='d') return deduplicate();
	else if (command=='f') return fillami();
	else if (command=='i') return info();
	else if (command=='k') return kill();
	else if (command=='l') return list();
	else if (command=='m') return consolidate(archive);
	else if (command=='o') return mycopy();
	else if (command=='p') return paranoid();
	else if (command=='r') return robocopy();
	else if (command=='s') return dircompare(true,false); 
	else if (command=='t') return test();
	else if (command=='u') return utf();
	else if (command=='v') return verify(true);
	else if (command=='w') return extractw();
	else if (command=='x') return extract();
	else if (command=='y') return sfx();
	else if (command=='z') return zero();
	else if (command=='9') return zfs(g_optional);
	else usage();
	return 0;
}
bool Jidac::getfoldersize(string i_folder,uint64_t& o_totalsize,uint32_t & o_totalfile,uint32_t& o_totaldir,uint32_t& o_longfiles)
{
	o_totalsize	=0;
	o_totalfile	=0;
	o_totaldir	=0;
	o_longfiles	=0;
	if (i_folder=="")
		return false;
	if (isdirectory(i_folder))
		i_folder=i_folder.substr(0,i_folder.size()-1);
	DTMap mydestinationdir;
	if (flagdebug)
	{
		myprintf("29247: Scanning dir <<");
		printUTF8(i_folder.c_str());
		myprintf(">>\n");
	}
	scandir(true,mydestinationdir,i_folder);
	printbar(' ',false);
	myprintf("\r");
	for (DTMap::iterator p=mydestinationdir.begin(); p!=mydestinationdir.end(); ++p) 
	{
		string fn=p->first;
		if (fn.size()>255)
			o_longfiles++;
		if (!isdirectory(p->first))
		{
			o_totalsize+=p->second.size;
			o_totalfile++;
		}
		else
			o_totaldir++;
	}
	if (flagdebug)
		myprintf("29260: files %s dirs %s size %s long %s\n",migliaia(o_totalfile),migliaia2(o_totaldir),migliaia3(o_totalsize),migliaia4(o_longfiles));
	if (o_totalfile || o_totaldir || o_totalsize)
		return true;
	return false;
}
int Jidac::rd()
{
	myprintf("Remove Directory ");
	if (files.size()==0)
	{
		myprintf("29241: rd exactly at least one folder\n");
		return 2;
	}
	for (unsigned int i=0;i<files.size();i++)
	{
		if (isdirectory(files[i]))
			files[i]=files[i].substr(0, files[i].size()-1);
		uint64_t 		totalsize	=0;
		unsigned int 	totalfile	=0;
		unsigned int 	totaldir	=0;
		unsigned int 	longfiles	=0;
		if (!direxists(files[i]))
		{
			myprintf("\nFolder %d does not exist? ",i);
			printUTF8(files[i].c_str());
			myprintf("\n");
			return 1;
		}
		if (!getfoldersize(files[i],totalsize,totalfile,totaldir,longfiles))
		{
			myprintf("29284: cannot enumerate folder %d ",i);
			printUTF8(files[i].c_str());
			myprintf("\n");
			return 1;
		}
		if (!flagspace)
			if (!saggiascrivibilitacartella(files[i]))
			{
				myprintf("\n29289: cannot write into %d ",i);
				printUTF8(files[i].c_str());
				myprintf(" -space to bypass");
				return 1;
			}
		myprintf("\n");
		printbar('=');
		myprintf("Files %s for %s bytes (%s) longpath %s\n",migliaia(totalfile),migliaia2(totalsize),tohuman(totalsize),migliaia3(longfiles));
		if (totalsize>0) 
			if (!flagforce)
			{
				myprintf("29301: the folder size is not zero, use -force to bypass\n");
				return 2;
			}
		if (flagkill)
		{
			if (totalsize>0)
				if (!getcaptcha("y","Remove folder WITH subfolders?"))
					return 1;
			if (stermina(files[i],totalfile))
			{
				myprintf("\nOK: folder %i does not seems to exist anymore ",i);
				printUTF8(files[i].c_str());
				myprintf("\n");
			}
			else
			{
				return 2;
			}
		}
		else
		{
			myprintf("29310: dry run. Use -kill for a wet-run\n");
			return 2;
		}
	}
	return 0;
}
uint32_t checkfilename(
const string&	i_filename,
int* 			o_toolongfilenames,
int* 			o_adsfilenames,
int* 			o_utf8names,
int* 			o_reservedfilenames,
int*			o_windowspath,
int*			o_windowsunc)
{
	if (i_filename=="")
		return 0;
	uint32_t	risultato=0;
	if (o_toolongfilenames)
		if (i_filename.length()>255)
		{
			(*o_toolongfilenames)++;
			risultato&=FIX_TOOLONG;
		}
	if (o_adsfilenames)
		if (strstr(i_filename.c_str(), ":$DATA"))
			if (mypos("VCOMMENT",i_filename)!=0)
			{
				(*o_adsfilenames)++;
				risultato&=FIX_ADS;
			}
	if (o_utf8names)
		if (i_filename!=utf8toansi(i_filename))
		{
			(*o_utf8names)++;
			risultato&=FIX_UTF8;
		}	
	if (o_reservedfilenames)
	{
		string fixed;
		if (isreserved(i_filename,fixed))
		{
			(*o_reservedfilenames)++;
			risultato&=FIX_RESERVED;
		}	
	}
	if (o_windowspath)
		if (iswindowspath(i_filename))
		{
			(*o_windowspath)++;
			risultato&=FIX_WINDOWSPATH;
		}
	if (o_windowsunc)
		if (iswindowsunc(i_filename))
		{
			(*o_windowsunc)++;
			risultato&=FIX_WINDOWSUNC;
		}
	return risultato;
}
int64_t Jidac::read_archive(const char* arc, int *errors, int i_myappend,bool i_quiet) 
{
	if (errors) *errors=0;
	dcsize=dhsize=0;
	assert(ver.size()==1);
	const bool i_renamed=command=='l' || command=='a' || command=='5' ; 
	const bool i_isinfo=(command=='i') && (!flagstat); 
	unsigned files=0;  
	InputArchive in(arc, password);
	if (!in.isopen()) 
	{
		if (command!='a') 
		{
			fflush(stdout);
			printUTF8(arc);
			myprintf( " not found.\n");
			g_exec_text=arc;
			g_exec_text+=" not found";
			if (errors) ++*errors;
		}
		return 0;
	}
	if (!i_quiet)
		if (!flagpakka)
		{
			printUTF8(arc);
			if (version==DEFAULT_VERSION) myprintf(": ");
				else 
			myprintf(" -until %1.0f: ", version+0.0);
			fflush(stdout);
		}
	char s[4]={0};
	const int nr=in.read(s, 4);
	if (nr>0 && memcmp(s, "7kSt", 4) && (memcmp(s, "zPQ", 3) || s[3]<1))
	{
		myprintf("zpaqfranz error:password incorrect\n");
		error("password incorrect");
	}
    in.seek(-nr, SEEK_CUR);
	string lastfile=archive; 
	if (lastfile.size()>5 && lastfile.substr(lastfile.size()-5)==".zpaq")
		lastfile=lastfile.substr(0, lastfile.size()-5); 
	int64_t block_offset=32*(password!=0);  
	int64_t data_offset=block_offset;    
	bool found_data=false;   
	bool first=true;         
	StringBuffer os(32832);  
	int toolongfilenames	=0;
	int adsfilenames		=0;
	int utf8names			=0;
	int casecollision		=0;
	int reservedfilenames	=0;
	int windowsunc			=0;
	int windowspath			=0;
	uint64_t parts			=0;
	bool done=false;
	if (!i_quiet)
		myprintf("\n");
	uint64_t startblock=mtime();
	while (!done) 
	{
		libzpaq::Decompresser d;
		try 
		{
			d.setInput(&in);
			double mem=0;
			while (d.findBlock(&mem)) 
			{
				found_data=true;
				StringWriter filename, comment;
				int segs=0;  
				bool skip=false;  
				while (d.findFilename(&filename)) 
				{
					if (filename.s.size()) 
					{
						for (unsigned i=0; i<filename.s.size(); ++i)
							if (filename.s[i]=='\\') 
								filename.s[i]='/';
						lastfile=filename.s.c_str();
					}
					comment.s="";
					d.readComment(&comment);
					if (comment.s.size()>=4 && comment.s.substr(comment.s.size()-4)=="jDC\x01") 
					{
						if (filename.s.size()!=28 || filename.s.substr(0, 3)!="jDC")
							error("bad journaling block name");
						if (skip) 
							error("mixed journaling and streaming block");
						int64_t usize=0;
						unsigned i;
						for (i=0; i<comment.s.size() && isdigit(comment.s[i]); ++i) 
						{
							usize=usize*10+comment.s[i]-'0';
							if (usize>0xffffffff) 
								error("journaling block too big");
						}
						int64_t fdate=0, num=0;
						for (i=3; i<17 && isdigit(filename.s[i]); ++i)
							fdate=fdate*10+filename.s[i]-'0';
						if (i!=17 || fdate<19000000000000LL || fdate>=30000000000000LL)
							error("bad date");
						for (i=18; i<28 && isdigit(filename.s[i]); ++i)
							num=num*10+filename.s[i]-'0';
						if (i!=28 || num>0xffffffff) 
							error("bad fragment");
						os.resize(0);
						os.setLimit(usize);
						d.setOutput(&os);
						libzpaq::SHA1 sha1;
						d.setSHA1(&sha1);
						if (strchr("chi", filename.s[17])) 
						{
							if (mem>1.5e9) 
								error("index block requires too much memory");
							d.decompress();
							char sha1result[21]={0};
							d.readSegmentEnd(sha1result);
							if ((int64_t)os.size()!=usize) 
								error("bad block size");
							if (usize!=int64_t(sha1.usize())) 
								error("bad checksum size");
							if (sha1result[0] && memcmp(sha1result+1, sha1.result(), 20))
								error("bad checksum");
							if ( ++parts % 1000 ==0)
								if (!flagnoeta)
									myprintf("Block %10s K %12s (block/s)\r",migliaia(parts/1000),migliaia2(parts/((mtime()-startblock+1)/1000.0)));
						}
						else
							d.readSegmentEnd();
						if (filename.s[17]=='c') 
						{
							if (os.size()<8) 
								error("c block too small");
							data_offset=in.tell()+1-d.buffered();
							const char* s=os.c_str();
							int64_t jmp=btol(s);
							if (jmp<0) 
								myprintf("Incomplete transaction ignored\n");
							if (jmp<0 || 
							(version<19000000000000LL && int64_t(ver.size())>version)
							|| (version>=19000000000000LL && version<fdate)) 
							{
								done=true;  
								goto endblock;	
							}
							else 
							{
								dcsize+=jmp;
								if (jmp) in.seek(data_offset+jmp, SEEK_SET);
								ver.push_back(VER());
								ver.back().firstFragment=ht.size();
								ver.back().offset=block_offset;
								ver.back().data_offset=data_offset;
								ver.back().date=ver.back().lastdate=fdate;
								ver.back().csize=jmp;
								if (all) 
								{
									string fn=itos(ver.size()-1, all)+"/"; 
									if (i_renamed) 
										fn=rename(fn);
									if (isselected(fn.c_str(), false,-1))
										dt[fn].date=fdate;
								}
								if (jmp) 
									goto endblock;
							}
						}
						else 
						if (filename.s[17]=='h') 
						{
							assert(ver.size()>0);
							if (fdate>ver.back().lastdate) 
								ver.back().lastdate=fdate;
							if (os.size()%24!=4) 
								error("bad h block size");
							const unsigned n=(os.size()-4)/24;
							if (num<1 || num+n>0xffffffff) 
								error("bad h fragment");
							const char* s=os.c_str();
							const unsigned bsize=btoi(s);
							dhsize+=bsize;
							assert(ver.size()>0);
							if (int64_t(ht.size())>num) 
							{
								fflush(stdout);
								myprintf(
								  "Unordered fragment tables: expected >= %d found %1.0f\n",
								  int(ht.size()), double(num));
								 g_exec_text="Unordered fragment tables";
							}
							for (unsigned i=0; i<n; ++i) 
							{
								if (i==0) 
								{
									block.push_back(Block(num, data_offset));
									block.back().usize=8;
									block.back().bsize=bsize;
									block.back().frags=os.size()/24;
								}
								while (int64_t(ht.size())<=num+i) 
									ht.push_back(HT());
								memcpy(ht[num+i].sha1, s, 20);
								s+=20;
								assert(block.size()>0);
								unsigned f=btoi(s);
								if (f>0x7fffffff) 
									error("fragment too big");
								block.back().usize+=(ht[num+i].usize=f)+4u;
							 }
							data_offset+=bsize;
						}
						else 
						if (filename.s[17]=='i') 
						{
							assert(ver.size()>0);
							if (fdate>ver.back().lastdate) 
								ver.back().lastdate=fdate;
							const char* s=os.c_str();
							const char* const end=s+os.size();
							while (s+9<=end) 
							{
								DT dtr;
								dtr.date=btol(s);  
								if (dtr.date) 
									++ver.back().updates;
								else 
									++ver.back().deletes;
								const int64_t len=strlen(s);
								if (len>65535) 
									error("filename too long");
								string fn=s;  
								if (!i_isinfo)
								{
								if ((flagstat) && (command!='5') && (command!='6'))
								{
									checkfilename(fn,
									&toolongfilenames,
									&adsfilenames,
									&utf8names,
									NULL,
									&windowspath,
									&windowsunc);
									string fixed;
								}
								else
									if (all) 
									{
										if (i_myappend)
											fn=itos(ver.size()-1, all)+"|$1"+fn;
										else
											fn=append_path(itos(ver.size()-1, all), fn);
									}
								}
					bool issel=false;
						if (!i_isinfo)
							issel=isselected(fn.c_str(), i_renamed,-1);
					s+=len+1;  
					if (s>end) 
						error("filename too long");
					if (dtr.date) 
					{
						++files;
						if (s+4>end) 
							error("missing attr");
						unsigned na=0;
						na=btoi(s);  
						if (s+na>end || na>65535) 
							error("attr too long");
						if (!i_isinfo)
						if (na>FRANZOFFSET) 
						{
							assert((na-8)<FRANZOFFSETSHA256); 
							for (unsigned int i=0;i<(na-8);i++)
								dtr.franz_block[i]=*(s+(na-(na-8))+i);
							dtr.franz_block_size=(na-8);
							dtr.franz_block[(na-8)]=0x0;
							if (flagstat)
							{
								string myhashtype="";
								string myhash="";
								string mycrc32="";
								decode_franz_block(false,dtr.franz_block,
								myhashtype,
								myhash,
								mycrc32);	
								if (strstr(myhash.c_str(),"!ERROR!"))
								{
									if (flagforce)
									{
										if (flagverbose)
											myprintf("27752: *** 'strange' but -force     -> included ");
									}
									else
									{
										if (flagverbose)
											myprintf("27754: *** 'strange' and NOT -force -> skipped  ");
										issel=false;
										if (errors)
											(*errors)++;
									}
									if (flagverbose)
									{
										printUTF8(fn.c_str());
										myprintf("\n");
									}
								}
							}
						}
						for (unsigned i=0; i<na; ++i, ++s)  
							if (i<8) 
								dtr.attr+=int64_t(*s&255)<<(i*8);
						if (flagnoattributes) 
							dtr.attr=0;
						if (s+4>end) 
							error("missing ptr");
						unsigned ni=btoi(s);  
						if (ni>(end-s)/4u) 
							error("ptr list too long");
						if (issel) 
							dtr.ptr.resize(ni);
						for (unsigned i=0; i<ni; ++i) 
						{  
							const unsigned j=btoi(s);
							if (issel) 
								dtr.ptr[i]=j;
						}
					}
					if (!i_isinfo)		
						if (issel)
							dt[fn]=dtr;
				}  
            }  
            else 
			{
				myprintf("Skipping %s %s\n",filename.s.c_str(), comment.s.c_str());
				error("Unexpected journaling block");
            }
          }  
          else 
		  {
            if (ver.size()==1) 
			{
				if (version<1) 
				{
					done=true;
					goto endblock;
				}
				ver.push_back(VER());
				ver.back().firstFragment=ht.size();
				ver.back().offset=block_offset;
				ver.back().csize=-1;
			}
			char sha1result[21]={0};
			d.readSegmentEnd(sha1result);
            skip=true;
            string fn=lastfile;
            if (all) fn=append_path(itos(ver.size()-1, all), fn); 
            if (isselected(fn.c_str(), i_renamed,-1)) {
              DT& dtr=dt[fn];
              if (filename.s.size()>0 || first) {
                ++files;
                dtr.date=date;
                dtr.attr=0;
                dtr.ptr.resize(0);
                ++ver.back().updates;
              }
              dtr.ptr.push_back(ht.size());
            }
            assert(ver.size()>0);
            if (segs==0 || block.size()==0)
              block.push_back(Block(ht.size(), block_offset));
            assert(block.size()>0);
            ht.push_back(HT(sha1result+1, -1));
          }  
          ++segs;
          filename.s="";
          first=false;
        }  
        if (!done) block_offset=in.tell()-d.buffered();
      }  
      done=true;
    }  
    catch (std::exception& e) {
      in.seek(-d.buffered(), SEEK_CUR);
      fflush(stdout);
      myprintf( "Skipping block at %1.0f: %s\n", double(block_offset),
              e.what());
		g_exec_text="Skipping block";
      if (errors) ++*errors;
    }
endblock:;
  }  
  if (in.tell()>32*(password!=0) && !found_data)
    error("archive contains no data");
	if (!i_quiet)
	if (!flagpakka)
	myprintf("%d versions, %s files, %s fragments, %s blocks, %s bytes (%s)\n", 
      int(ver.size()-1), migliaia(files), migliaia2(unsigned(ht.size())-1),
      migliaia3(parts),migliaia4(block_offset),tohuman(block_offset));
	if (!i_quiet)
	{
		if (toolongfilenames)
		{
			if (!flagtest)
			myprintf("Long filenames (>255)  %9s\n",migliaia(toolongfilenames));
		}
		if (utf8names)
			myprintf("Non-latin (UTF-8)      %9s\n",migliaia(utf8names));
		if (adsfilenames)
			myprintf("ADS ($:DATA)           %9s\n",migliaia(adsfilenames));
		if (windowspath)
			myprintf("Windows path           %9s\n",migliaia(windowspath));
		if (windowsunc)
			myprintf("Windows UNC            %9s\n",migliaia(windowsunc));
		if (reservedfilenames)
		{
			myprintf("Reserved filenames     %9s\n",migliaia(reservedfilenames));
		}
	}
	for (DTMap::iterator p=dt.begin(); p!=dt.end(); ++p) 
		for (unsigned i=0; i<p->second.ptr.size(); ++i) 
		{
			unsigned j=p->second.ptr[i];
			if (j>0 && j<ht.size() && p->second.size>=0) 
			{
				if (ht[j].usize>=0) 
					p->second.size+=ht[j].usize;
				else 
					p->second.size=-1;  
			}
		}
	return block_offset;
}
bool Jidac::isselected(const char* filename, bool rn,int64_t i_size) 
{
	if (g_optional=="dirsize")
		return true; 
	if (g_optional=="zfsadd")
		return true; 
	bool matched=true;
	if (!flagforcezfs)
		if (flagskipzfs) 
			if (iszfs(filename))
			{
				if (flagverbose)
					myprintf("Verbose: Skip .zfs %s\n",filename);
				return false;
			}
	if (flagnoqnap) 
		if (
			(strstr(filename, "@Recently-Snapshot")) 
			||
			(strstr(filename, "@Recycle")) 
			)
			{
				if (flagverbose)
					myprintf("Verbose: Skip qnap %s\n",filename);
				return false;
			}
	if (!flagforcewindows) 
	{
		if (strstr(filename, "System Volume Information")) 
		{
			if (flagverbose)
				myprintf("Verbose: Skip System Volume Information %s\n",filename);
			return false;
		}
		if (strstr(filename, "$RECYCLE.BIN")) 
		{
			if (flagverbose)
				myprintf("Verbose: Skip trash %s\n",filename);
			return false;
		}
	}			
	if (isads(filename))
	{
		if (mypos("VCOMMENT ",filename)>-1)
			return true;
		if (mypos("VFILE-",filename)>-1)
			return true;
	}
	if  (!flagforcewindows)
		if (isads(filename))
			return false;
	if (i_size>0)
	{
		if (maxsize)
			if (maxsize<(uint64_t)i_size)
			{
				if (flagverbose)
					myprintf("Verbose: (-maxsize) too big   %19s %s\n",migliaia(i_size),filename);
				return false;
			}
		if (minsize)
			if (minsize>(uint64_t)i_size)
			{
				if (flagverbose)
					myprintf("Verbose: (-minsize) too small %19s %s\n",migliaia(i_size),filename);
				return false;
			}
	}
  if (files.size()>0) {
    matched=false;
    for (unsigned i=0; i<files.size() && !matched; ++i) {
      if (rn && i<tofiles.size()) {
        if (ispath(tofiles[i].c_str(), filename)) matched=true;
      }
      else if (ispath(files[i].c_str(), filename)) matched=true;
    }
  }
  if (!matched) return false;
  if (onlyfiles.size()>0) 
  {
	matched=false;
    for (unsigned i=0; i<onlyfiles.size() && !matched; ++i)
	{
	 if (ispath(onlyfiles[i].c_str(), filename))
	 {
        matched=true;
	 }
	}
  }
  if (!matched) return false;
  for (unsigned i=0; i<notfiles.size(); ++i) {
    if (ispath(notfiles[i].c_str(), filename))
      return false;
  }
  return true;
}
int64_t dim(string i_filename)
{
    FILE* inFile = freadopen(i_filename.c_str());
    if (inFile==NULL) 
		return 0;
	int64_t realsize=prendidimensionehandle(inFile);
	fclose(inFile);
	return realsize;
}		
void Jidac::scandir(bool i_checkifselected,DTMap& i_edt,string filename, bool i_recursive)
{
  for (unsigned i=0; i<notfiles.size(); ++i)
    if (ispath(notfiles[i].c_str(), filename.c_str()))
      return;
	if (!flagforcezfs)
		if (flagskipzfs)
			if (iszfs(filename))
			{
				if (flagverbose)
					myprintf("Verbose: Skip .zfs ----> %s\n",filename.c_str());
				return;
			}
	if (flagnoqnap)
	{
		if (filename.find("@Recently-Snapshot")!=std::string::npos)
		{
			if (flagverbose)
				myprintf("Verbose: Skip qnap snapshot ----> %s\n",filename.c_str());
			return;
		}
		if (filename.find("@Recycle")!=std::string::npos)
		{
			if (flagverbose)
				myprintf("Verbose: Skip qnap recycle ----> %s\n",filename.c_str());
			return;
		}
	}
	while (filename.size()>1 && filename[filename.size()-1]=='/')
		filename=filename.substr(0, filename.size()-1);  
	struct stat sb;
	if (!lstat(filename.c_str(), &sb)) 
	{
		if (S_ISREG(sb.st_mode))
			addfile(i_checkifselected,i_edt,filename, decimal_time(sb.st_mtime), sb.st_size,'u'+(sb.st_mode<<8));
		if (S_ISDIR(sb.st_mode)) 
		{
			addfile(i_checkifselected,i_edt,filename=="/" ? "/" : filename+"/", decimal_time(sb.st_mtime),0, 'u'+(int64_t(sb.st_mode)<<8));
			DIR* dirp=opendir(filename.c_str());
			if (dirp) 
			{
				for (dirent* dp=readdir(dirp); dp; dp=readdir(dirp)) 
				{
					if (strcmp(".", dp->d_name) && strcmp("..", dp->d_name)) 
					{
						string s=filename;
						if (s!="/") s+="/";
						s+=dp->d_name;
						if (i_recursive)        
							scandir(i_checkifselected,i_edt,s);
						else
						{
							if (!lstat(s.c_str(), &sb)) 
							{
								if (S_ISREG(sb.st_mode))
									addfile(i_checkifselected,i_edt,s, decimal_time(sb.st_mtime), sb.st_size,'u'+(sb.st_mode<<8));
								if (S_ISDIR(sb.st_mode)) 
									addfile(i_checkifselected,i_edt,s=="/" ? "/" :s+"/", decimal_time(sb.st_mtime),0, 'u'+(int64_t(sb.st_mode)<<8));
							}
						}          			
					}
				}
				closedir(dirp);
			}
			else
				perror(filename.c_str());
		}
	}
	else
		perror(filename.c_str());
}
void Jidac::addfile(bool i_checkifselected,DTMap& i_edt,string filename, int64_t edate,
                    int64_t esize, int64_t eattr) 
{
	if (i_checkifselected)
		if (!isselected(filename.c_str(), false,esize)) 
			return;
	if (command=='q')
		if (filename.size()>250)
			myreplace(filename,g_franzsnap,g_vss_shadow);
	DT& d=i_edt[filename];
	d.date=edate;
	d.size=esize;
	d.attr=flagnoattributes?0:eattr;
	d.data=0;
	g_bytescanned+=esize;
	g_filescanned++;
	if (flagnoeta==false)
		if (!(i_edt.size() % 1000))
		{
			double scantime=mtime()-g_start+1;
			myprintf("Scanning %10s %2.2fs %10s file/s (%21s)\r",migliaia(i_edt.size()),scantime/1000.0,migliaia3((int)(i_edt.size()/(scantime/1000.0))),migliaia2(g_bytescanned));
			fflush(stdout);
		}
}
inline void puti(libzpaq::StringBuffer& sb, uint64_t x, int n) {
  for (; n>0; --n) sb.put(x&255), x>>=8;
}
struct CJ {
  enum {EMPTY, FULL, COMPRESSING, COMPRESSED, WRITING} state;
  StringBuffer in;       
  StringBuffer out;      
  string filename;       
  string comment;        
  string method;         
  Semaphore full;        
  Semaphore compressed;  
  CJ(): state(EMPTY) {}
};
class CompressJob {
public:
  Mutex mutex;           
private:
  int job;               
  CJ* q;                 
  unsigned qsize;        
  int front;             
  libzpaq::Writer* out;  
  Semaphore empty;       
  Semaphore compressors; 
public:
  friend ThreadReturn compressThread(void* arg);
  friend ThreadReturn writeThread(void* arg);
  CompressJob(int threads, int buffers, libzpaq::Writer* f):
      job(0), q(0), qsize(buffers), front(0), out(f) {
    q=new CJ[buffers];
    if (!q) throw std::bad_alloc();
    init_mutex(mutex);
    empty.init(buffers);
    compressors.init(threads);
    for (int i=0; i<buffers; ++i) {
      q[i].full.init(0);
      q[i].compressed.init(0);
    }
  }
  ~CompressJob() {
    for (int i=qsize-1; i>=0; --i) {
      q[i].compressed.destroy();
      q[i].full.destroy();
    }
    compressors.destroy();
    empty.destroy();
    destroy_mutex(mutex);
    delete[] q;
  }      
  void write(StringBuffer& s, const char* filename, string method,
             const char* comment=0);
  vector<int> csize;  
};
void CompressJob::write(StringBuffer& s, const char* fn, string method,
                        const char* comment) {
  for (unsigned k=(method=="")?qsize:1; k>0; --k) {
    empty.wait();
    lock(mutex);
    unsigned i, j;
    for (i=0; i<qsize; ++i) {
      if (q[j=(i+front)%qsize].state==CJ::EMPTY) {
        q[j].filename=fn?fn:"";
        q[j].comment=comment?comment:"jDC\x01";
        q[j].method=method;
        q[j].in.resize(0);
        q[j].in.swap(s);
        q[j].state=CJ::FULL;
        q[j].full.signal();
        break;
      }
    }
    release(mutex);
    assert(i<qsize);  
  }
}
ThreadReturn compressThread(void* arg) {
  CompressJob& job=*(CompressJob*)arg;
  int jobNumber=0;
  try {
    lock(job.mutex);
    jobNumber=job.job++;
    assert(jobNumber>=0 && jobNumber<int(job.qsize));
    CJ& cj=job.q[jobNumber];
    release(job.mutex);
    while (true) {
      cj.full.wait();
      lock(job.mutex);
      if (cj.method=="") {
        cj.compressed.signal();
        release(job.mutex);
        return 0;
      }
      assert(cj.state==CJ::FULL);
      cj.state=CJ::COMPRESSING;
      release(job.mutex);
      job.compressors.wait();
	       libzpaq::compressBlock(&cj.in, &cj.out, cj.method.c_str(),
          cj.filename.c_str(), cj.comment=="" ? 0 : cj.comment.c_str());
      cj.in.resize(0);
      lock(job.mutex);
	  cj.state=CJ::COMPRESSED;
      cj.compressed.signal();
      job.compressors.signal();
      release(job.mutex);
    }
  }
  catch (std::exception& e) {
    lock(job.mutex);
    fflush(stdout);
    myprintf( "job %d: %s\n", jobNumber+1, e.what());
	g_exec_text="job error";
    release(job.mutex);
    exit(1);
  }
  return 0;
}
ThreadReturn writeThread(void* arg) {
  CompressJob& job=*(CompressJob*)arg;
  try {
    while (true) {
      CJ& cj=job.q[job.front];  
      cj.compressed.wait();
      lock(job.mutex);
      if (cj.method=="") {
        release(job.mutex);
        return 0;
      }
      assert(cj.state==CJ::COMPRESSED);
      cj.state=CJ::WRITING;
      job.csize.push_back(cj.out.size());
      if (job.out && cj.out.size()>0) {
        release(job.mutex);
        assert(cj.out.c_str());
        const char* p=cj.out.c_str();
        int64_t n=cj.out.size();
		g_scritti+=n; 
		const int64_t N=1<<30;
        while (n>N) {
          job.out->write(p, N);
          p+=N;
          n-=N;
        }
        job.out->write(p, n);
        lock(job.mutex);
      }
      cj.out.resize(0);
      cj.state=CJ::EMPTY;
      job.front=(job.front+1)%job.qsize;
      job.empty.signal();
      release(job.mutex);
    }
  }
  catch (std::exception& e) {
    fflush(stdout);
    myprintf( "zpaqfranz exiting from writeThread: %s\n", e.what());
	g_exec_text="exiting from writethread";
    exit(1);
  }
  return 0;
}
void writeJidacHeader(libzpaq::Writer *out, int64_t date,
                      int64_t cdata, unsigned htsize) {
  if (!out) return;
  assert(date>=19000000000000LL && date<30000000000000LL);
  StringBuffer is;
  puti(is, cdata, 8);
  libzpaq::compressBlock(&is, out, "0",
      ("jDC"+itos(date, 14)+"c"+itos(htsize, 10)).c_str(), "jDC\x01");
}
class HTIndex {
  vector<HT>& htr;  
  libzpaq::Array<unsigned> t;  
  unsigned htsize;  
  unsigned hash(const char* sha1) {
    return (*(const unsigned*)sha1)&(t.size()-1);
  }
public:
  HTIndex(vector<HT>& r, size_t sz): htr(r), t(0), htsize(1) {
    int b;
    for (b=1; sz*3>>b; ++b);
    t.resize(1, b-1);
    update();
  }
  unsigned find(const char* sha1) {
    unsigned h=hash(sha1);
    for (unsigned i=0; i<t.size(); ++i) {
      if (t[h^i]==0) return 0;
      if (memcmp(sha1, htr[t[h^i]].sha1, 20)==0) return t[h^i];
    }
    return 0;
  }
  void update() {
    char zero[20]={0};
    while (htsize<htr.size()) {
      if (htsize>=t.size()/4*3) {
        t.resize(t.size(), 1);
        htsize=1;
      }
      if (htr[htsize].usize>=0 && memcmp(htr[htsize].sha1, zero, 20)!=0) {
        unsigned h=hash((const char*)htr[htsize].sha1);
        for (unsigned i=0; i<t.size(); ++i) {
          if (t[h^i]==0) {
            t[h^i]=htsize;
            break;
          }
        }
      }
      ++htsize;
    }
  }    
};
struct WriterPair: public libzpaq::Writer {
  OutputArchive *a, *b;
  void put(int c) {
    if (a) a->put(c);
    if (b) b->put(c);
  }
  void write(const char* buf, int n) {
    if (a) a->write(buf, n);
    if (b) b->write(buf, n);
  }
  WriterPair(): a(0), b(0) {}
};
void Jidac::write715attr(libzpaq::StringBuffer& i_sb, uint64_t i_data, unsigned int i_quanti)
{
	assert(i_sb);
	assert(i_quanti<=8);
	puti(i_sb, i_quanti, 4);
	puti(i_sb, i_data, i_quanti);
}
void Jidac::writefranzattr(libzpaq::StringBuffer& i_sb, uint64_t i_data, unsigned int i_quanti,string i_filename,uint32_t i_crc32fromfragments,uint32_t i_crc32,string i_thehash)
{
	assert(i_sb);
	assert(i_filename.length()>0); 	
	assert(i_quanti<8);				
	assert(i_filename!="");
	uint32_t writtencrc;
	if (flagverify)
		writtencrc=i_crc32fromfragments;
	else
		writtencrc=i_crc32;
	if (g_franzotype==FRANZO_NONE)	
	{
		write715attr(i_sb,i_data,i_quanti);
		return;
	}
	if (flagverify)
		if (i_crc32!=i_crc32fromfragments)
		{
			myprintf("\nGURU-C: on file %s\n",i_filename.c_str());
			myprintf("GURU: CRC-32 from fragments %08X\n",i_crc32fromfragments);
			myprintf("GURU: CRC-32 from file      %08X\n",i_crc32);
		}
	if (g_franzotype==FRANZO_CRC_32) 
	{
		char mybuffer[FRANZOFFSET]={0};
		sprintf(mybuffer+41,"%08X",writtencrc);
		puti(i_sb, 8+FRANZOFFSET, 4); 	
		puti(i_sb, i_data, i_quanti);
		puti(i_sb, 0, (8 - i_quanti));  
		i_sb.write(mybuffer,FRANZOFFSET);
		if (flagdebug)
			myprintf("Mode1: CRC32 by frag <<%s>> %s\n",mybuffer+41,i_filename.c_str());
	}
	else
	if (g_franzotype==FRANZO_XXHASH64) 
	{
		assert(i_thehash.length()==32);
		char mybuffer[FRANZOFFSET]={0};
		sprintf(mybuffer+8,	"%s",i_thehash.c_str());
		sprintf(mybuffer+41,"%08X",writtencrc);
		puti(i_sb, 8+FRANZOFFSET, 4); 	
		puti(i_sb, i_data, i_quanti);
		puti(i_sb, 0, (8 - i_quanti));  
		i_sb.write(mybuffer,FRANZOFFSET);
		if (flagdebug)
				myprintf("Mode2: XXHASH64: <<%s>> CRC32 <<%s>> %s\n",mybuffer+8,mybuffer+41,i_filename.c_str());
	}
	else
	if (g_franzotype==FRANZO_SHA_1)  
	{
		char mybuffer[FRANZOFFSETSHA256]={0};
		sprintf(mybuffer,	"08"); 
		sprintf(mybuffer+2,	"%s",i_thehash.c_str());
		sprintf(mybuffer+2+64+1,"%08X",writtencrc);
		puti(i_sb, 8+FRANZOFFSETSHA256, 4); 	
		puti(i_sb, i_data, i_quanti);
		puti(i_sb, 0, (8 - i_quanti));  
		i_sb.write(mybuffer,FRANZOFFSETSHA256); 
		if (flagdebug)
				myprintf("Model8: SHA1 <<%s>> CRC32 <<%s>> %s\n",mybuffer+2,mybuffer+67,i_filename.c_str());
	}
	else
	if (g_franzotype==FRANZO_SHA_256) 
	{
		assert(i_thehash.length()==64);
		char mybuffer[FRANZOFFSETSHA256]={0};
		sprintf(mybuffer,	"04"); 
		sprintf(mybuffer+2,	"%s",i_thehash.c_str());
		sprintf(mybuffer+2+64+1,"%08X",writtencrc);
		puti(i_sb, 8+FRANZOFFSETSHA256, 4); 	
		puti(i_sb, i_data, i_quanti);
		puti(i_sb, 0, (8 - i_quanti));  
		i_sb.write(mybuffer,FRANZOFFSETSHA256);
		if (flagdebug)
				myprintf("Mode4: SHA256 <<%s>> CRC32 <<%s>> %s\n",mybuffer+2,mybuffer+67,i_filename.c_str());
	}
	else
	if (g_franzotype==FRANZO_SHA3) 
	{
		assert(i_thehash.length()==64);
		char mybuffer[FRANZOFFSETSHA256]={0};
		sprintf(mybuffer,	"02"); 
		sprintf(mybuffer+2,	"%s",i_thehash.c_str());
		sprintf(mybuffer+2+64+1,"%08X",writtencrc);
		puti(i_sb, 8+FRANZOFFSETSHA256, 4); 	
		puti(i_sb, i_data, i_quanti);
		puti(i_sb, 0, (8 - i_quanti));  
		i_sb.write(mybuffer,FRANZOFFSETSHA256); 
		if (flagdebug)
				myprintf("Mode7: SHA3 <<%s>> CRC32 <<%s>> %s\n",mybuffer+2,mybuffer+67,i_filename.c_str());
	}
	else
	if (g_franzotype==FRANZO_MD5) 
	{
		assert(i_thehash.length()==32);
		char mybuffer[FRANZOFFSETSHA256]={0};
		sprintf(mybuffer,	"01"); 
		sprintf(mybuffer+2,	"%s",i_thehash.c_str());
		sprintf(mybuffer+2+64+1,"%08X",writtencrc);
		puti(i_sb, 8+FRANZOFFSETSHA256, 4); 	
		puti(i_sb, i_data, i_quanti);
		puti(i_sb, 0, (8 - i_quanti));  
		i_sb.write(mybuffer,FRANZOFFSETSHA256); 
		if (flagdebug)
				myprintf("Mode8: MD5 <<%s>> CRC32 <<%s>> %s\n",mybuffer+2,mybuffer+67,i_filename.c_str());
	}
	else
	if (g_franzotype==FRANZO_BLAKE3) 
	{
		assert(i_thehash.length()==64);
		char mybuffer[FRANZOFFSETSHA256]={0};
		sprintf(mybuffer,	"03"); 
		sprintf(mybuffer+2,	"%s",i_thehash.c_str());
		sprintf(mybuffer+2+64+1,"%08X",writtencrc);
		puti(i_sb, 8+FRANZOFFSETSHA256, 4); 	
		puti(i_sb, i_data, i_quanti);
		puti(i_sb, 0, (8 - i_quanti));  
		i_sb.write(mybuffer,FRANZOFFSETSHA256); 
		if (flagdebug)
				myprintf("Mode6: BLAKE3 <<%s>> CRC32 <<%s>> %s\n",mybuffer+2,mybuffer+67,i_filename.c_str());
	}
	else
	if (g_franzotype==FRANZO_XXH3) 
	{	
		assert(i_thehash.length()==32);
		char mybuffer[FRANZOFFSETSHA256]={0};
		sprintf(mybuffer,	"09"); 
		sprintf(mybuffer+2,	"%s",i_thehash.c_str());
		sprintf(mybuffer+2+64+1,"%08X",writtencrc);
		puti(i_sb, 8+FRANZOFFSETSHA256, 4); 	
		puti(i_sb, i_data, i_quanti);
		puti(i_sb, 0, (8 - i_quanti));  
		i_sb.write(mybuffer,FRANZOFFSETSHA256); 
		if (flagdebug)
				myprintf("Mode5: XXH3: <<%s>> CRC32 <<%s>> %s\n",mybuffer+2,mybuffer+67,i_filename.c_str());
	}
	else
		perror("22144: unknown franzotype");
}
bool Jidac::equal(DTMap::const_iterator p, const char* filename,uint32_t &o_crc32,string i_myhashtype,string i_myhash,string& o_hash) 
{
	o_crc32=0;
	o_hash="";
	if (i_myhash=="FAKE")
		o_hash="FAKE";
	if (filename==0) 
	{
		static const char zero[20]={0};
		for (unsigned i=0; i<p->second.ptr.size(); ++i) 
		{
			unsigned j=p->second.ptr[i];
			if (j<1 || j>=ht.size() || ht[j].usize<0 || !memcmp(ht[j].sha1, zero, 20))
				return false;
		}
		return true;
	}
	if (p->second.date==0) 
		return !exists(filename);
	if (p->first!="" && isdirectory(p->first))
		return exists(filename);
	FP in=fopen(filename, RB);
	if (in==FPNULL) 
		return false;
	fseeko(in, 0, SEEK_END);
	if (ftello(in)!=p->second.size) 
		return fclose(in), false;
	fseeko(in, 0, SEEK_SET);
	libzpaq::SHA1 sha1;
	const int BUFSIZE=4096;
	char buf[BUFSIZE];
	bool	flagshow=false;
	if (!flagnoeta)
		if (flagverbose || (p->second.size>100000000)) 
			flagshow=true;
	if (flagshow)
		myprintf("\n");
	int64_t 	done				=0;
	int 		ultimapercentuale	=-1;
	uint64_t myseed = 0;
	XXHash64 myhash(myseed);
	SHA3 sha3;
	MD5 md5;
	blake3_hasher hasher;
	blake3_hasher_init(&hasher);
	franzSHA256 mysha256;
	XXH3_state_t state128;
    (void)XXH3_128bits_reset(&state128);
	libzpaq::SHA1 mysha1;
	int64_t timestart=mtime();
	for (unsigned i=0; i<p->second.ptr.size(); ++i) 
	{
		unsigned f=p->second.ptr[i];
		if (f<1 || f>=ht.size() || ht[f].usize<0) 
			return fclose(in), false;
		double percentuale=0;
		if (flagshow)
		{
			percentuale=100.0*((double)i/(double)p->second.ptr.size());
			int proper=percentuale;
			if (percentuale>0)
				if (proper!=ultimapercentuale)
				{
					if (proper==99)
							proper=100;
					double tempo=(mtime()-timestart+1)/1000.0;
					int myspeed=done/tempo;
					myprintf("SHA1 %03d %% (%12s) @ %12s/s\r",proper,tohuman(done),tohuman2(myspeed));
					ultimapercentuale=percentuale;
				}
		}
		for (int j=0; j<ht[f].usize;) 
		{
			int n=ht[f].usize-j;
			if (n>BUFSIZE) 
				n=BUFSIZE;
			int r=fread(buf, 1, n, in);
			o_crc32=crc32_16bytes(buf,r,o_crc32);
			done+=r;
			g_worked+=r;
			if (flagchecksum)
			{
				if (i_myhashtype=="XXHASH64")
					myhash.add(buf,r);
				if (i_myhashtype=="SHA-3")
					sha3.add(buf,r);
				if (i_myhashtype=="MD5")
					md5.add(buf,r);
				if (i_myhashtype=="BLAKE3")
					blake3_hasher_update(&hasher,buf,r);
				if (i_myhashtype=="SHA-256")
					mysha256.update((const uint8_t*)buf,r);
				if (i_myhashtype=="XXH3")
					(void)XXH3_128bits_update(&state128,buf,r);
				if (i_myhashtype=="SHA-1")
					mysha1.write(buf,r);
			}
			if (r!=n) 
			{
				return fclose(in), false;
			}
			sha1.write(buf, n);
			j+=n;
		}
		if (memcmp(sha1.result(), ht[f].sha1, 20)!=0) 
		{	
			return fclose(in), false;
		}
	}
	if (fread(buf, 1, BUFSIZE, in)!=0) 
		return fclose(in), false;
	fclose(in);
	if (flagchecksum)
	{
		if (i_myhashtype=="XXHASH64")
		{
			char temp[33];
			sprintf(temp,"%016llX",(unsigned long long)myhash.hash());
			o_hash=temp;
		}
		else
		if (i_myhashtype=="SHA-3")
			o_hash= sha3.getHash();
		else
		if (i_myhashtype=="MD5")
			o_hash=md5.getHash();
		else
		if (i_myhashtype=="BLAKE3")
		{
			uint8_t output[BLAKE3_OUT_LEN];
			blake3_hasher_finalize(&hasher, output, BLAKE3_OUT_LEN);
			o_hash=binarytohex((const unsigned char*)output,BLAKE3_OUT_LEN);	
		}
		else
		if (i_myhashtype=="SHA-256")
			o_hash=mysha256.gethex();
		else
		if (i_myhashtype=="XXH3")
		{
			XXH128_hash_t myhash=XXH3_128bits_digest(&state128);
			char buf[33];
			sprintf(buf,"%016llX%016llX",(unsigned long long)myhash.high64,(unsigned long long)myhash.low64);
			o_hash=buf;
		}
		else
		if (i_myhashtype=="SHA-1")
		{
			char sha1result[20];
			memcpy(sha1result, mysha1.result(), 20);
			o_hash=binarytohex((const unsigned char*)sha1result,20);
		}
		else
			myprintf("\n29573: WARNING unknown hasher algo %s\n",i_myhashtype.c_str());
	}
	return true;
}
struct ExtractJob {         
	int	chunk;
  Mutex mutex;              
  Mutex write_mutex;        
  int job;                  
  Jidac& jd;                
  FP outf;                  
  DTMap::iterator lastdt;   
  double maxMemory;         
  int64_t total_size;       
  int64_t total_done;       
  ExtractJob(Jidac& j): chunk(0),job(0), jd(j), outf(FPNULL), lastdt(j.dt.end()),
      maxMemory(0), total_size(0), total_done(0) {
    init_mutex(mutex);
    init_mutex(write_mutex);
  }
  ~ExtractJob() {
    destroy_mutex(mutex);
    destroy_mutex(write_mutex);
  }
};
ThreadReturn decompressThread(void* arg) {
  ExtractJob& job=*(ExtractJob*)arg;
  int jobNumber=0;
	char	byte0={0};
  lock(job.mutex);
  jobNumber=++job.job;
  release(job.mutex);
  InputArchive in(job.jd.archive.c_str(), job.jd.password);
  if (!in.isopen()) return 0;
  StringBuffer out;
  int next=0;  
  while (true) {
    lock(job.mutex);
    for (unsigned i=0; i<=job.jd.block.size(); ++i) {
      unsigned k=i+next;
      if (k>=job.jd.block.size()) k-=job.jd.block.size();
      if (i==job.jd.block.size()) {  
        release(job.mutex);
        return 0;
      }
      Block& b=job.jd.block[k];
      if (b.state==Block::READY && b.size>0 && b.usize>=0) {
        b.state=Block::WORKING;
        release(job.mutex);
        next=k;
        break;
      }
    }
    Block& b=job.jd.block[next];
    unsigned output_size=0;  
    assert(b.start>0);
    for (unsigned j=0; j<b.size; ++j) {
      assert(b.start+j<job.jd.ht.size());
      assert(job.jd.ht[b.start+j].usize>=0);
      output_size+=job.jd.ht[b.start+j].usize;
    }
    double mem=0;  
    try {
      assert(b.start>0);
      assert(b.start<job.jd.ht.size());
      assert(b.size>0);
      assert(b.start+b.size<=job.jd.ht.size());
      in.seek(b.offset, SEEK_SET);
      libzpaq::Decompresser d;
      d.setInput(&in);
      out.resize(0);
      assert(b.usize>=0);
      assert(b.usize<=0xffffffffu);
      out.setLimit(b.usize);
      d.setOutput(&out);
      if (!d.findBlock(&mem)) error("archive block not found");
      if (mem>job.maxMemory) job.maxMemory=mem;
      while (d.findFilename()) {
        d.readComment();
        while (out.size()<output_size && d.decompress(1<<14))
		{
		};
        lock(job.mutex);
		print_progress(job.total_size, job.total_done,-1,-1);
	  release(job.mutex);
        if (out.size()>=output_size) break;
        d.readSegmentEnd();
      }
      if (out.size()<output_size) {
        lock(job.mutex);
        fflush(stdout);
        myprintf( "output [%u..%u] %d of %u bytes\n",
             b.start, b.start+b.size-1, int(out.size()), output_size);
        release(job.mutex);
        error("unexpected end of compressed data");
      }
      uint64_t q=0;  
      libzpaq::SHA1 sha1;
      assert(b.extracted==0);
      for (unsigned j=b.start; j<b.start+b.size; ++j) {
        assert(j>0 && j<job.jd.ht.size());
        assert(job.jd.ht[j].usize>=0);
        assert(job.jd.ht[j].usize<=0x7fffffff);
        if (q+job.jd.ht[j].usize>out.size())
          error("Incomplete decompression");
        char sha1result[20];
        sha1.write(out.c_str()+q, job.jd.ht[j].usize);
        memcpy(sha1result, sha1.result(), 20);
        q+=job.jd.ht[j].usize;
        if (memcmp(sha1result, job.jd.ht[j].sha1, 20)) {
          lock(job.mutex);
          fflush(stdout);
          myprintf( "Job %d: fragment %u size %d checksum failed\n",
                 jobNumber, j, job.jd.ht[j].usize);
		g_exec_text="fragment checksum failed";
          release(job.mutex);
          error("bad checksum");
        }
        ++b.extracted;
      }
    }
    catch (std::bad_alloc& e) {
      lock(job.mutex);
      fflush(stdout);
      myprintf( "Job %d killed: %s\n", jobNumber, e.what());
	  g_exec_text="Job killed";
      b.state=Block::READY;
      b.extracted=0;
      out.resize(0);
      release(job.mutex);
      return 0;
    }
    catch (std::exception& e) {
      lock(job.mutex);
      fflush(stdout);
      myprintf( "Job %d: skipping [%u..%u] at %1.0f: %s\n",
              jobNumber, b.start+b.extracted, b.start+b.size-1,
              b.offset+0.0, e.what());
      release(job.mutex);
      continue;
    }
    lock(job.write_mutex);
    for (unsigned ip=0; ip<b.files.size(); ++ip) {
      DTMap::iterator p=b.files[ip];
      if (p->second.date==0 || p->second.data<0
          || p->second.data>=int64_t(p->second.ptr.size()))
        continue;  
      const vector<unsigned>& ptr=p->second.ptr;
      int64_t offset=0;  
      for (unsigned j=0; j<ptr.size(); ++j) {
        if (ptr[j]<b.start || ptr[j]>=b.start+b.extracted) {
          offset+=job.jd.ht[ptr[j]].usize;
          continue;
        }
        if (p!=job.lastdt) {
          if (job.outf!=FPNULL) {
            assert(job.lastdt!=job.jd.dt.end());
            assert(job.lastdt->second.date);
            assert(job.lastdt->second.data
                   <int64_t(job.lastdt->second.ptr.size()));
            fclose(job.outf);
            job.outf=FPNULL;
          }
          job.lastdt=job.jd.dt.end();
        }
		string filename;
        if (job.lastdt==job.jd.dt.end()) 
		{
			filename=job.jd.rename(p->first);
			if (flagramdisk)
				if (!isdirectory(filename))
					if (p->second.pramfile==NULL)
					{
						p->second.pramfile=new franzfs;
						(*p->second.pramfile).init(p->second.size);
					}
			assert(job.outf==FPNULL);
			if (p->second.data==0) 
			{
				if (!job.jd.flagtest) 
				{
					if (flagdebug)
					{
						myprintf("17544: MAKEPATH:");
						printUTF8(filename.c_str());
						myprintf("\n");
					}
					makepath(filename);
				}
				lock(job.mutex);
				print_progress(job.total_size, job.total_done,-1,-1);
				release(job.mutex);
				if (!job.jd.flagtest) 
				{
				job.outf=fopen(filename.c_str(), WB);
				if (job.outf==FPNULL) 
				{
					lock(job.mutex);
					printerr("17451",filename.c_str(),0);
					release(job.mutex);
				}
            }
          }
          else if (!job.jd.flagtest)
		  {
			job.outf=fopen(filename.c_str(), RBPLUS);  
          }
		  if (!job.jd.flagtest && job.outf==FPNULL) break;  
          job.lastdt=p;
          assert(job.jd.flagtest || job.outf!=FPNULL);
        }
        assert(job.lastdt==p);
        uint64_t q=0;  
        for (unsigned k=b.start; k<ptr[j]; ++k) {
          assert(k>0);
          assert(k<job.jd.ht.size());
          if (job.jd.ht[k].usize<0) error("streaming fragment in file");
          assert(job.jd.ht[k].usize>=0);
          q+=job.jd.ht[k].usize;
        }
        assert(q+job.jd.ht[ptr[j]].usize<=out.size());
        assert(offset>=0);
        ++p->second.data;
        uint64_t usize=job.jd.ht[ptr[j]].usize;
        assert(usize<=0x7fffffff);
        assert(b.start+b.size<=job.jd.ht.size());
        while (j+1<ptr.size() && ptr[j+1]==ptr[j]+1
               && ptr[j+1]<b.start+b.size
               && job.jd.ht[ptr[j+1]].usize>=0
               && usize+job.jd.ht[ptr[j+1]].usize<=0x7fffffff) {
          ++p->second.data;
          assert(p->second.data<=int64_t(ptr.size()));
          assert(job.jd.ht[ptr[j+1]].usize>=0);
          usize+=job.jd.ht[ptr[++j]].usize;
        }
        assert(usize<=0x7fffffff);
        assert(q+usize<=out.size());
        uint64_t nz=q;  
        while (nz<q+usize && out.c_str()[nz]==0) ++nz;
        if ((nz<q+usize || j+1==ptr.size())) 
			{
				if (offset>g_scritti)
					g_scritti=offset;
				uint32_t crc;
				crc=crc32_16bytes(out.c_str()+q, usize);
				s_crc32block myblock;
				myblock.crc32=crc;
				myblock.crc32start=offset;
				myblock.crc32size=usize;
				myblock.filename=job.lastdt->first;
				g_crc32.push_back(myblock);
			}
		if (job.jd.flagtest && (nz<q+usize || j+1==ptr.size())) 
			if (flagramdisk)
					if (!isdirectory(filename))
						if (p->second.pramfile!=NULL)
							(*p->second.pramfile).ramwrite(offset,(char*)out.c_str()+q,usize);
		if (!job.jd.flagtest && (nz<q+usize || j+1==ptr.size())) 
		{
			if (flagzero)
			{
				if (flagdebug)
				{
					fseeko(job.outf, offset+usize, SEEK_SET);
					fwrite(&byte0, 1, 1, job.outf);
				}
			}
			else
			{				
				if (flagdebug)
					myprintf("17716:OFFSET-WRITE   %19s  size  %12s %s\n",migliaia(offset),migliaia2(usize),job.lastdt->first.c_str());
				if (flagramdisk)
				{
					if (!isdirectory(filename))
						if (p->second.pramfile!=NULL)
							(*p->second.pramfile).ramwrite(offset,(char*)out.c_str()+q,usize);
				}
				else
				{	
					fseeko(job.outf, offset, SEEK_SET);
					fwrite(out.c_str()+q, 1, usize, job.outf);
				}
			}
		}	
        offset+=usize;
        lock(job.mutex);
        job.total_done+=usize;
        release(job.mutex);
        if (p->second.data==int64_t(ptr.size())) {
          assert(p->second.date);
          assert(job.lastdt!=job.jd.dt.end());
          assert(job.jd.flagtest || job.outf!=FPNULL);
          if (!job.jd.flagtest) {
            assert(job.outf!=FPNULL);
            string fn=job.jd.rename(p->first);
            int64_t attr=p->second.attr;
            int64_t date=p->second.date;
            if ((p->second.attr&0x1ff)=='w'+256) attr=0;  
            if (p->second.data!=int64_t(p->second.ptr.size()))
              date=attr=0;  
            close(fn.c_str(), date, attr, job.outf);
            job.outf=FPNULL;
          }
          job.lastdt=job.jd.dt.end();
        }
      } 
    } 
    release(job.write_mutex);
  } 
  return 0;
}
ThreadReturn decompressthreadramdisk(void* arg) 
{
	ExtractJob& job=*(ExtractJob*)arg;
	int jobNumber=0;
	lock(job.mutex);
	jobNumber=++job.job;
	release(job.mutex);
	InputArchive in(job.jd.archive.c_str(), job.jd.password);
	if (!in.isopen()) 
		return 0;
	StringBuffer out;
	int next=0;  
	while (true) 
	{
		lock(job.mutex);
		for (unsigned i=0; i<=job.jd.block.size(); ++i) 
		{
			unsigned k=i+next;
			if (k>=job.jd.block.size()) 
				k-=job.jd.block.size();
			if (i==job.jd.block.size()) 
			{  
				release(job.mutex);
				return 0;
			}
			Block& b=job.jd.block[k];
			if (b.state==Block::READY && b.size>0 && b.usize>=0) 
			{
				b.state=Block::WORKING;
				release(job.mutex);
				next=k;
				break;
			}
		}
		Block& b=job.jd.block[next];
		unsigned output_size=0;  
		assert(b.start>0);
		for (unsigned j=0; j<b.size; ++j) 
		{
			assert(b.start+j<job.jd.ht.size());
			assert(job.jd.ht[b.start+j].usize>=0);
			output_size+=job.jd.ht[b.start+j].usize;
		}
    double mem=0;  
	try 
	{
		assert(b.start>0);
		assert(b.start<job.jd.ht.size());
		assert(b.size>0);
		assert(b.start+b.size<=job.jd.ht.size());
		in.seek(b.offset, SEEK_SET);
		libzpaq::Decompresser d;
		d.setInput(&in);
		out.resize(0);
		assert(b.usize>=0);
		assert(b.usize<=0xffffffffu);
		out.setLimit(b.usize);
		d.setOutput(&out);
		if (!d.findBlock(&mem)) 
			error("31284 archive block not found");
		if (mem>job.maxMemory) 
			job.maxMemory=mem;
		while (d.findFilename()) 
		{
			d.readComment();
        	while (out.size()<output_size && d.decompress(1<<14))
				;
			lock(job.mutex);
			print_progress(job.total_size, job.total_done,-1,-1);
			release(job.mutex);
			if (out.size()>=output_size) 
				break;
			d.readSegmentEnd();
		}
		if (out.size()<output_size)
		{
			lock(job.mutex);
			fflush(stdout);
			myprintf( "31836 output [%u..%u] %d of %u bytes\n",b.start, b.start+b.size-1, int(out.size()), output_size);
			release(job.mutex);
			error("31838 unexpected end of compressed data");
		}
		uint64_t q=0;  
		libzpaq::SHA1 sha1;
		assert(b.extracted==0);
		for (unsigned j=b.start; j<b.start+b.size; ++j) 
		{
			assert(j>0 && j<job.jd.ht.size());
			assert(job.jd.ht[j].usize>=0);
			assert(job.jd.ht[j].usize<=0x7fffffff);
			if (q+job.jd.ht[j].usize>out.size())
				error("31318 Incomplete decompression");
			if (flagchecksum)
			{
				char sha1result[20];
				sha1.write(out.c_str()+q, job.jd.ht[j].usize);
				memcpy(sha1result, sha1.result(), 20);
				q+=job.jd.ht[j].usize;
				if (memcmp(sha1result, job.jd.ht[j].sha1, 20)) 
				{
					lock(job.mutex);
					fflush(stdout);
					myprintf( "31327 Job %d: fragment %u size %d checksum failed\n",jobNumber, j, job.jd.ht[j].usize);
					g_exec_text="31327 fragment checksum failed";
					release(job.mutex);
					error("31330 bad checksum");
				}
			}
			else
				q+=job.jd.ht[j].usize;
			++b.extracted;
		}
    }
    catch (std::bad_alloc& e) 
	{
		lock(job.mutex);
		fflush(stdout);
		myprintf( "31341 Job %d killed: %s\n", jobNumber, e.what());
		g_exec_text="31341 Job killed";
		b.state=Block::READY;
		b.extracted=0;
		out.resize(0);
		release(job.mutex);
		return 0;
    }
    catch (std::exception& e) 
	{
		lock(job.mutex);
		fflush(stdout);
		myprintf( "31355 Job %d: skipping [%u..%u] at %1.0f: %s\n",jobNumber, b.start+b.extracted, b.start+b.size-1,b.offset+0.0, e.what());
		release(job.mutex);
		continue;
    }
    lock(job.write_mutex);
    for (unsigned ip=0; ip<b.files.size(); ++ip) 
	{
		DTMap::iterator p=b.files[ip];
		if (p->second.date==0 || p->second.data<0
          || p->second.data>=int64_t(p->second.ptr.size()))
        continue;  
		const vector<unsigned>& ptr=p->second.ptr;
		int64_t offset=0;  
		for (unsigned j=0; j<ptr.size(); ++j) 
		{
			if (ptr[j]<b.start || ptr[j]>=b.start+b.extracted) 
			{
				offset+=job.jd.ht[ptr[j]].usize;
				continue;
			}
			if (p!=job.lastdt) 
				job.lastdt=job.jd.dt.end();
			if (job.lastdt==job.jd.dt.end()) 
			{
				if (!isdirectory(job.jd.rename(p->first)))
					if (p->second.pramfile==NULL)
					{
						p->second.pramfile=new franzfs;
						(*p->second.pramfile).init(p->second.size);
					}
				if (p->second.pramfile==NULL)
					error("31399 cannot init ramdisk");
				if (p->second.data==0) 
				{
					lock(job.mutex);
					print_progress(job.total_size, job.total_done,-1,-1);
					release(job.mutex);
				}
				job.lastdt=p;
			}
			assert(job.lastdt==p);
			uint64_t q=0;  
			for (unsigned k=b.start; k<ptr[j]; ++k) 
			{
				assert(k>0);
				assert(k<job.jd.ht.size());
				if (job.jd.ht[k].usize<0) 
					error("31420 streaming fragment in file");
				assert(job.jd.ht[k].usize>=0);
				q+=job.jd.ht[k].usize;
			}
			assert(q+job.jd.ht[ptr[j]].usize<=out.size());
			assert(offset>=0);
			++p->second.data;
			uint64_t usize=job.jd.ht[ptr[j]].usize;
			assert(usize<=0x7fffffff);
			assert(b.start+b.size<=job.jd.ht.size());
			while (j+1<ptr.size() && ptr[j+1]==ptr[j]+1
				   && ptr[j+1]<b.start+b.size
				   && job.jd.ht[ptr[j+1]].usize>=0
				   && usize+job.jd.ht[ptr[j+1]].usize<=0x7fffffff) 
			{
				++p->second.data;
				assert(p->second.data<=int64_t(ptr.size()));
				assert(job.jd.ht[ptr[j+1]].usize>=0);
				usize+=job.jd.ht[ptr[++j]].usize;
			}
			assert(usize<=0x7fffffff);
			assert(q+usize<=out.size());
			uint64_t nz=q;  
			while (nz<q+usize && out.c_str()[nz]==0) ++nz;
			if ((nz<q+usize || j+1==ptr.size())) 
			{
				if (offset>g_scritti)
					g_scritti=offset;
				if (!(flagzero && flagdebug))		
					if (p->second.pramfile!=NULL)
						(*p->second.pramfile).ramwrite(offset,(char*)out.c_str()+q,usize);
			}
			offset+=usize;
			lock(job.mutex);
			job.total_done+=usize;
			release(job.mutex);
			if (p->second.data==int64_t(ptr.size())) 
			{
				assert(job.lastdt!=job.jd.dt.end());
				job.lastdt=job.jd.dt.end();
			}
		} 
	} 
    release(job.write_mutex);
  } 
  return 0;
}
struct OutputFile: public libzpaq::Writer {
  FP f;
  void put(int c) {
    char ch=c;
    if (f!=FPNULL) fwrite(&ch, 1, 1, f);
  }
  void write(const char* buf, int n) {if (f!=FPNULL) fwrite(buf, 1, n, f);}
  OutputFile(FP out=FPNULL): f(out) {}
};
int64_t copywitheta(int64_t i_tobecopied,libzpaq::Reader& in, libzpaq::Writer& out, uint64_t n=~0ull) 
{
  const unsigned BUFSIZE=4096;
  int64_t result=0;
  char buf[BUFSIZE];
  int64_t	inizio=mtime();
  while (n>0) 
  {
    int nc=n>BUFSIZE ? BUFSIZE : n;
    int nr=in.read(buf, nc);
    if (nr<1) break;
		out.write(buf, nr);
    result+=nr;
	avanzamento(result,i_tobecopied,inizio);
    n-=nr;
  }
  return result;
}
int64_t copy(libzpaq::Reader& in, libzpaq::Writer& out, uint64_t n=~0ull) 
{
  const unsigned BUFSIZE=4096;
  int64_t result=0;
  char buf[BUFSIZE];
  while (n>0) 
  {
    int nc=n>BUFSIZE ? BUFSIZE : n;
    int nr=in.read(buf, nc);
    if (nr<1) break;
		out.write(buf, nr);
    result+=nr;
	 n-=nr;
  }
  return result;
}
uint32_t crchex2int(const char *hex) 
{
	assert(hex);
	uint32_t val = 0;
	for (int i=0;i<8;i++)
	{
        uint8_t byte = *hex++; 
        if (byte >= '0' && byte <= '9') byte = byte - '0';
        else if (byte >= 'a' && byte <='f') byte = byte - 'a' + 10;
        else if (byte >= 'A' && byte <='F') byte = byte - 'A' + 10;    
        val = (val << 4) | (byte & 0xF);
    }
    return val;
}
void Jidac::printsanitizeflags()
{
		myprintf("\n");
		myprintf("******\n");
		if (flagflat)
			myprintf("****** WARNING: all files FLATted, without non-latin chars, max %d length\n",(int)FRANZMAXPATH);
		else
		{
			if (flagutf)
				myprintf("****** -utf    No Non-latin chars\n");
			if (flagfix255)
				myprintf("****** -fix255 Shrink filenames to %d, case insensitive\n",(int)FRANZMAXPATH);
			if (flagfixeml)
				myprintf("****** -fixeml Heuristic compress .eml filenames (Fwd Fwd Fwd=>Fwd etc)\n");
		}
		myprintf("******\n\n");
}
int Jidac::testverify() 
{
	getpasswordifempty();
	if (files.size()<=0)
		return -1;
	if (archive=="")
		return -1;
	myprintf("Compare archive content of:");
	read_archive(archive.c_str());
	uint64_t howmanyfiles=0;
	g_bytescanned=0;
	g_filescanned=0;
	g_worked=0;
	files_count.clear();
	edt.clear();
	for (unsigned i=0; i<files.size(); ++i)
	{
		scandir(true,edt,files[i].c_str());
		files_count.push_back(edt.size()-howmanyfiles);
		howmanyfiles=edt.size();
	}
	myprintf("\n");
 	for (unsigned i=0; i<files.size(); ++i)
		if (isdirectory(files[i]))
			myprintf("%9s in <<%s>>\n",migliaia(files_count[i]),files[i].c_str());
	if (files.size()) 
		myprintf("Total files found: %s\n", migliaia(edt.size()));
	myprintf("\n");
	DTMap* dp[2]={&dt, &edt};
	for (int i=0; i<2; ++i) 
		for (DTMap::iterator p=dp[i]->begin(); p!=dp[i]->end(); ++p) 
		{
			int len=p->first.size();
			if (len>0 && p->first[len]!='/') 
				for (int j=0; j<len; ++j) 
					if (p->first[j]=='/') 
					{
						DTMap::iterator q=dp[i]->find(p->first.substr(0, j+1));
						if (q!=dp[i]->end())
							q->second.size+=p->second.size;
					}
		}
	vector<DTMap::iterator> filelist;
	for (DTMap::iterator p=edt.begin(); p!=edt.end(); ++p) 
	{
		DTMap::iterator a=dt.find(rename(p->first));
		if (a!=dt.end() && (all || a->second.date)) 
		{
			a->second.data='-';
			filelist.push_back(a);
		}
		p->second.data='+';
		filelist.push_back(p);
	}
	for (DTMap::iterator a=dt.begin(); a!=dt.end(); ++a) 
		if (a->second.data!='-' && (all || a->second.date)) 
		{
			a->second.data='-';
			filelist.push_back(a);
		}
	int64_t usize=0;
	unsigned matches=0, mismatches=0, internal=0, external=0,hashmatches=0;
	uint32_t crc32fromfile;
	int64_t	hashchecked=0;
	int64_t	tobetested=0;
	vector<string> risultati;
	vector<bool> risultati_utf8;
	char linebuffer[1000];
	unsigned int ultimapercentuale=200;
	unsigned int percentuale;
	for (unsigned fi=0;fi<filelist.size(); ++fi) 
	{
		DTMap::iterator p=filelist[fi];
		if (menoenne)
			if ((mismatches+external+internal)>menoenne)
				break;
		if (!flagnoeta)
		{
			percentuale=100*fi/filelist.size();
			if (ultimapercentuale!=percentuale)
			{
				myprintf("Done %02d%% %10s of %10s, diff %s bytes so far\r",percentuale,tohuman(g_worked),tohuman2(g_bytescanned),migliaia2(usize));
				ultimapercentuale=percentuale;
			}
		}
		if (p->second.data=='-' && fi+1<filelist.size() && filelist[fi+1]->second.data=='+') 
		{
			DTMap::iterator p1=filelist[fi+1];
			string myhashtype="";
			string myhash="";
			string mycrc32="";
			string hashfromfile="";
			if (!isdirectory(p1->first))
			{
					decode_franz_block(false,p->second.franz_block,
					myhashtype,
					myhash,
					mycrc32);
					tobetested+=p->second.size;
			}
			if (equal(p, p1->first.c_str(),crc32fromfile,myhashtype,myhash,hashfromfile)) 
			{
				if (!isdirectory(p1->first))
				{
					if (hashfromfile!="")
					{
						if (flagdebug)
							myprintf("Check hash for %s\n",p->first.c_str());
						hashchecked+=p->second.size;
						if (hashfromfile!=myhash)
						{
							p->second.data='#';
							sprintf(linebuffer,"\nHASH %s NOT MATCH STORED %s vs FROM FILE %s ",myhashtype.c_str(),myhash.c_str(),hashfromfile.c_str());
							risultati.push_back(linebuffer);
							risultati_utf8.push_back(false);
							sprintf(linebuffer,"%s\n",p1->first.c_str());
							risultati.push_back(linebuffer);
							risultati_utf8.push_back(true);
						}
						else
						{	
							hashmatches++;
							p->second.data='=';
							++fi;
						}
					}
					else
					if (mycrc32!="")
					{
						if (flagdebug)
							myprintf("Check CRC-32 for %s\n",p->first.c_str());
						uint32_t crc32stored=crchex2int(mycrc32.c_str());
						if (crc32stored!=crc32fromfile)
						{
							p->second.data='#';
							sprintf(linebuffer,"\nCRC-32 NOT MATCH STORED %s vs FROM FILE %08X ",mycrc32.c_str(),crc32fromfile);
							risultati.push_back(linebuffer);
							risultati_utf8.push_back(false);
							sprintf(linebuffer,"%s\n",p1->first.c_str());
							risultati.push_back(linebuffer);
							risultati_utf8.push_back(true);
						}
						else
						{	
							p->second.data='=';
							++fi;
						}
					}
					else
					{
						if (flagdebug)
							myprintf("No zpaqfranz check for %s\n",p->first.c_str());
						p->second.data='=';
						++fi;
					}
				}	
				else
				{
					p->second.data='=';
					++fi;
				}
			}
			else
			{
				p->second.data='#';
				p1->second.data='!';
			}
		}
		if (p->second.data=='=') ++matches;
		if (p->second.data=='#') ++mismatches;
		if (p->second.data=='-') ++internal;
		if (p->second.data=='+') ++external;
		if (p->second.data!='=') 
		{
			if (!isdirectory(p->first))
				usize+=p->second.size;
			sprintf(linebuffer,"%c %s %19s ", char(p->second.data),dateToString(p->second.date).c_str(), migliaia(p->second.size));
			risultati.push_back(linebuffer);
			risultati_utf8.push_back(false);
			sprintf(linebuffer,"%s\n",p->first.c_str());
			risultati.push_back(linebuffer);
			risultati_utf8.push_back(true);
			if (p->second.data=='!')
			{
				sprintf(linebuffer,"\n");
				risultati.push_back(linebuffer);
				risultati_utf8.push_back(false);
			}
		}
	}  
	myprintf("\n\n");
	bool myerror=false;
	if (menoenne)
		if ((mismatches+external+internal)>menoenne)
			myprintf("**** STOPPED BY TOO MANY ERRORS -n %d\n",menoenne);
	if  (mismatches || external || internal)
		for (unsigned int i=0;i<risultati.size();i++)
		{
			if (risultati_utf8[i])
				printUTF8(risultati[i].c_str());
			else
			myprintf("%s",risultati[i].c_str());
		}
	if (matches)
		myprintf("%08d = same\n",matches);
	if (hashmatches)
	{
		myprintf("%08d ==very same (hash checked) %19s\n",hashmatches,migliaia(hashchecked));
		myprintf("               to be tested by hash %19s\n",migliaia(tobetested));
		if (hashchecked!=tobetested)
		{
			myprintf("****** WARN: something strange hash checking    *******\n");
			myprintf("******       some file(s) stored without hash?  *******\n");
			myprintf("******       hash does not match?               *******\n");
		}
	}
	if (mismatches)
	{
		myprintf("%08d #different\n",mismatches);
		myerror=true;
	}
	if (external)
	{
		myprintf("%08d +external (file missing in ZPAQ)\n",external);
		myerror=true;
	}
	if (internal)
	{
		myprintf("%08d -internal (file in ZPAQ but not on disk)\n",internal);
		myerror=true;
	}
	myprintf("Total different file size: %s bytes\n",migliaia(usize));
 	if (myerror)
		return 2;
	else
		return 0;
}
int Jidac::info() 
{
	flagcomment=true;
	versioncomment="";
	all=4;
	return enumeratecomments();
}
int Jidac::zpaqdirsize() 
{
	if (archive=="")
	{
		myprintf("31002: empty archive name\n");
		return 2;
	}
	if (files.size()==0)
	{
		myprintf("30969: at least one folder needed\n");
		return 2;
	}
	getpasswordifempty();
	int errors=0;
	read_archive(archive.c_str(),&errors,0,true); 
	if (flagdebug)
		myprintf("\n\n31016: dtsize %s\n\n",migliaia(dt.size()));
	DTMap* dp[2]={&dt, &edt};
	for (int i=0; i<2; ++i) 
		for (DTMap::iterator p=dp[i]->begin(); p!=dp[i]->end(); ++p) 
		{
			int len=p->first.size();
			if (len>0 && p->first[len]!='/') 
				for (int j=0; j<len; ++j) 
				{
					if (p->first[j]=='/') 
					{
						DTMap::iterator q=dp[i]->find(p->first.substr(0, j+1));
						if (q!=dp[i]->end())
							q->second.size+=p->second.size;
					}
				}
		}
	vector<DTMap::iterator> filelist;
	myprintf("\n\n");
	if (flagforce)
	{
		myprintf("31019: case sensitive == search, because of -force switch\n");
		for (unsigned int i=0;i<files.size();i++)
		{
			if (!isdirectory(files[i]))
					files[i]+='/';
			DTMap::iterator a=dt.find(files[i]);
			if (a!=dt.end())
				filelist.push_back(a);
			else
			{
				if (flagdebug)
					myprintf("31004: WARNING cannot find folder in the zpaq %s\n",files[i].c_str());
			}
		}
	}
	else
	{
		myprintf("31038: case iNSeNsITIVE right search, because NO -force switch\n");
		for (unsigned int i=0;i<files.size();i++)
		{
			if (!isdirectory(files[i]))
					files[i]+='/';
			files[i]=stringtolower(files[i]);
			unsigned int oldsize=filelist.size();
			for (DTMap::iterator a=dt.begin(); a!=dt.end(); ++a)
				if (isdirectory(a->first))
				{
					int posizione=myposi(files[i],a->first);
					if (posizione>-1)
						if ((unsigned int)posizione==(unsigned int)(a->first.size()-files[i].size()))
							filelist.push_back(a);
				}
			if (flagdebug)
				if (filelist.size()==oldsize)
					myprintf("31053: WARNING cannot find folder in the zpaq <<%s>>\n",files[i].c_str());
		}
	}
	sort(filelist.begin(), filelist.end(), compareFragmentList);
	myprintf("\n\n");
	for (unsigned fi=0;fi<filelist.size(); ++fi) 
	{
		DTMap::iterator p=filelist[fi];
		myprintf("%19s [%s] <<",migliaia(p->second.size),dateToString(p->second.date).c_str());
		printUTF8(p->first.c_str());
		myprintf(">>\n");
	}
	if (flagforce) 
	{
		if (filelist.size()==files.size())
			return 0;
		else
		{
			myprintf("31094: folder searched %s != founded %s\n",migliaia(files.size()),migliaia2(filelist.size()));
			return 1;
		}
	}
	return 0;
}
int Jidac::list() 
{
	getpasswordifempty();
	if (flagcomment)
	{
		enumeratecomments();
		return 0;
	}
	if (files.size()>=1)
		return testverify();
  int64_t csize=0;
  int errors=0;
  bool flagshow;
	if (archive!="") csize=read_archive(archive.c_str(),&errors,1); 
	myprintf("\n");
	g_bytescanned=0;
	g_filescanned=0;
	g_worked=0;
	vector<DTMap::iterator> filelist;
	for (DTMap::iterator a=dt.begin(); a!=dt.end(); ++a) 
		if (a->second.data!='-' && (all || a->second.date)) 
		{
			a->second.data='-';
			filelist.push_back(a);
		}
 	if (menoenne) 
	{
		myprintf("Sort by size desc, limit to %d\n",menoenne);
		sort(filelist.begin(), filelist.end(), compareFragmentList);
	}
	int64_t usize=0;
	map<int, string> mappacommenti;
	for (unsigned i=0;i<filelist.size();i++) 
	{
		DTMap::iterator p=filelist[i];
		if (isads(p->first))
		{
			string fakefile=p->first;
			myreplace(fakefile,":$DATA","");
			size_t found = fakefile.find("VCOMMENT "); 
			if (found != string::npos)
			{
    			string numeroversione=fakefile.substr(found+9,8);
#ifdef ESX
 int numver=0;
#else		
int numver=std::stoi(numeroversione.c_str());
#endif
				string commento=fakefile.substr(found+9+8+1,65000);
				mappacommenti.insert(std::pair<int, string>(numver, commento));
			}
		}
	}
	unsigned fi;
	for (fi=0;fi<filelist.size(); ++fi) 
	{
		if (menoenne) 
			if (fi>=menoenne)
				break;
		DTMap::iterator p=filelist[fi];
		flagshow=true;
		if (isads(p->first))
			if (strstr(p->first.c_str(),"VCOMMENT "))
				flagshow=false;
		if (searchfrom!="")
			flagshow=stristr(p->first.c_str(),searchfrom.c_str());
		if (flagchecksum)
			if (isdirectory(p->first))
				flagshow=false;
		if ((minsize>0) || (maxsize>0))
			if (isdirectory(p->first))
				flagshow=false;
		if (maxsize>0)
		{
			if (maxsize<(uint64_t)p->second.size) 
				flagshow=false;
		}
		if (minsize>0)
		{
			if (minsize>(uint64_t)p->second.size)
				flagshow=false;
		}
		if (flagshow)
		{
			if (!strchr(nottype.c_str(), p->second.data)) 
			{
				if (p->first!="" && (!isdirectory(p->first)))
					usize+=p->second.size;
				if (summary<=0) 
				{
					myprintf("%c %s %19s ", char(p->second.data),dateToString(p->second.date).c_str(), migliaia(p->second.size));
					if (!flagnoattributes)
					myprintf("%s ", attrToString(p->second.attr).c_str());
				}
				string myfilename=p->first;
				string myhashtype="";
				string myhash="";
				string mycrc32="";
				if (flagchecksum)
				{
					int franzotypedetected=
						decode_franz_block(isdirectory(myfilename),p->second.franz_block,
						myhashtype,
						myhash,
						mycrc32);
					if (franzotypedetected>1)
					{
						if ((myhashtype!="") && (myhash!=""))
							myhash=myhashtype+": "+myhash+" ";
						if (mycrc32!="")
							mycrc32="CRC32: "+mycrc32+" ";
					}
				}		
				if (all)
				{
					string rimpiazza="|";
					if (!isdirectory(myfilename))
					{
						rimpiazza+=myhash;
						rimpiazza+=mycrc32;
					}
					if (!myreplace(myfilename,"|$1",rimpiazza))
						myreplace(myfilename,"/","|");
				}
				else
				{
					if (tofiles.size()>0)
						myfilename=rename(myfilename);
					myfilename=myhash+mycrc32+myfilename;	
				}
				if ((searchfrom!="") && (replaceto!=""))
					replace(myfilename,searchfrom,replaceto);
				printUTF8(myfilename.c_str());
				unsigned v;  
			if (all>0 && p->first.size()==all+1u && (v=atoi(p->first.c_str()))>0
          && v<ver.size()) 
				{  
					std::map<int,string>::iterator commento;
					commento=mappacommenti.find(v); 
					if(commento== mappacommenti.end()) 
						myprintf(" +%d -%d -> %s", ver[v].updates, ver[v].deletes,
						(v+1<ver.size() ? migliaia(ver[v+1].offset-ver[v].offset) : migliaia(csize-ver[v].offset)));
					else
						myprintf(" +%d -%d -> %s <<%s>>", ver[v].updates, ver[v].deletes,
						(v+1<ver.size() ? migliaia(ver[v+1].offset-ver[v].offset) : migliaia(csize-ver[v].offset)),commento->second.c_str());
				}
				myprintf("\n");
			}
		}
	}  
	int64_t ddsize=0, allsize=0;
	unsigned nfiles=0, nfrags=0, unknown_frags=0, refs=0;
	vector<bool> ref(ht.size());
	for (DTMap::const_iterator p=dt.begin(); p!=dt.end(); ++p) 
	{
		if (p->second.date) 
		{
			++nfiles;
			for (unsigned j=0; j<p->second.ptr.size(); ++j) 
			{
				unsigned k=p->second.ptr[j];
				if (k>0 && k<ht.size()) 
				{
					++refs;
					if (ht[k].usize>=0) 
						allsize+=ht[k].usize;
					if (!ref[k]) 
					{
						ref[k]=true;
						++nfrags;
						if (ht[k].usize>=0) 
							ddsize+=ht[k].usize;
						else 
						++unknown_frags;
					}
				}
			}
		}
	}
	myprintf("\n%21s (%s) of %s (%s) in %s files shown\n",migliaia(usize),tohuman(usize),migliaia2(allsize),tohuman2(allsize),migliaia3(fi));
	myprintf("%21s compressed \n",migliaia((csize+dhsize-dcsize)));
  if (unknown_frags)
    myprintf("%u fragments have unknown size\n", unknown_frags);
  if (dhsize!=dcsize)  
    myprintf("Note: %s of %s compressed bytes are in archive\n",
        migliaia(dcsize+0.0), migliaia2(dhsize+0.0));
  return 0;
}
string sha3_calc_file(const char * i_filename,bool i_flagcalccrc32,uint32_t& o_crc32,const int64_t i_inizio,const int64_t i_totali,int64_t& io_lavorati)
{
	o_crc32=0;
	FILE* myfile = freadopen(i_filename);
	if(myfile==NULL )
 		return "";
	int64_t lunghezza	=prendidimensionehandle(myfile);
	int64_t	letti		=0;
	const int BUFSIZE	=65536*8;
	unsigned char 				unzBuf[BUFSIZE];
	int 				n=BUFSIZE;
	SHA3 sha3;
	while (1)
	{
		int r=fread(unzBuf, 1, n, myfile);
		sha3.add(unzBuf,r);
		if (i_flagcalccrc32)
			o_crc32=crc32_16bytes(unzBuf,r,o_crc32);
 		io_lavorati+=r;
		letti+=r;
		if (r!=n) 
			break;
		if ((flagnoeta==false) && (i_inizio>0))
			myavanzamentoby1sec(io_lavorati,i_totali,i_inizio,false);
	}
	fclose(myfile);
    string risultato = sha3.getHash();
	if (lunghezza!=letti)
	{
		myprintf("\n29884: *** CORRUPTED FILE DETECTED! expected %s readed %s bytes *** ",migliaia(lunghezza),migliaia2(letti));
		printUTF8(i_filename);
		myprintf("\n");
	}
	return risultato;
}
string md5_calc_file(const char * i_filename,bool i_flagcalccrc32,uint32_t& o_crc32,const int64_t i_inizio,const int64_t i_totali,int64_t& io_lavorati)
{
	o_crc32=0;
	FILE* myfile = freadopen(i_filename);
	if(myfile==NULL )
 		return "";
	int64_t lunghezza	=prendidimensionehandle(myfile);
	int64_t	letti		=0;
	const int BUFSIZE	=65536*8;
	unsigned char 				unzBuf[BUFSIZE];
	int 				n=BUFSIZE;
	MD5 md5;
	while (1)
	{
		int r=fread(unzBuf, 1, n, myfile);
		md5.add(unzBuf,r);
		if (i_flagcalccrc32)
			o_crc32=crc32_16bytes(unzBuf,r,o_crc32);
 		io_lavorati+=r;
		letti+=r;
		if (r!=n) 
			break;
		if ((flagnoeta==false) && (i_inizio>0))
			myavanzamentoby1sec(io_lavorati,i_totali,i_inizio,false);
	}
	fclose(myfile);
    string risultato = md5.getHash();
	if (lunghezza!=letti)
	{
		myprintf("\n29926: *** CORRUPTED FILE DETECTED! expected %s readed %s bytes *** ",migliaia(lunghezza),migliaia2(letti));
		printUTF8(i_filename);
		myprintf("\n");
	}
	return risultato;
}
string whirlpool_calc_file(const char * i_filename,bool i_flagcalccrc32,uint32_t& o_crc32,const int64_t i_inizio,const int64_t i_totali,int64_t& io_lavorati)
{
	o_crc32=0;
	FILE* myfile = freadopen(i_filename);
	if(myfile==NULL )
 		return "";
	int64_t lunghezza	=prendidimensionehandle(myfile);
	int64_t	letti		=0;
	const int BUFSIZE	=65536*8;
	unsigned char 				unzBuf[BUFSIZE];
	int 				n=BUFSIZE;
	NESSIEstruct hasher;
	NESSIEinit(&hasher);
	while (1)
	{
		int r=fread(unzBuf, 1, n, myfile);
		NESSIEadd(unzBuf,r*8,&hasher);
		if (i_flagcalccrc32)
			o_crc32=crc32_16bytes(unzBuf,r,o_crc32);
 		io_lavorati+=r;
		letti+=r;
		if (r!=n) 
			break;
		if ((flagnoeta==false) && (i_inizio>0))
			myavanzamentoby1sec(io_lavorati,i_totali,i_inizio,false);
	}
	fclose(myfile);
	unsigned char buffer[512]={0};
	NESSIEfinalize(&hasher,buffer);
	if (lunghezza!=letti)
	{
		myprintf("\n29970: *** CORRUPTED FILE DETECTED! expected %s readed %s bytes *** ",migliaia(lunghezza),migliaia2(letti));
		printUTF8(i_filename);
		myprintf("\n");
	}
	return binarytohex(buffer,64);
}
string sha1_calc_file(const char * i_filename,bool i_flagcalccrc32,uint32_t& o_crc32,const int64_t i_inizio,const int64_t i_totali,int64_t& io_lavorati)
{
	o_crc32=0;
	FILE* myfile = freadopen(i_filename);
	if(myfile==NULL )
 		return "";
	int64_t lunghezza	=prendidimensionehandle(myfile);
	int64_t	letti		=0;
	const int BUFSIZE	=65536*8;
	char 				unzBuf[BUFSIZE];
	int 				n=BUFSIZE;
	libzpaq::SHA1 sha1;
	while (1)
	{
		int r=fread(unzBuf, 1, n, myfile);
		sha1.write(unzBuf,r);
		if (i_flagcalccrc32)
			o_crc32=crc32_16bytes(unzBuf,r,o_crc32);
		io_lavorati+=r;
		letti+=r;
		if (r!=n) 
			break;
		if ((flagnoeta==false) && (i_inizio>0))
			myavanzamentoby1sec(io_lavorati,i_totali,i_inizio,false);
	}
	fclose(myfile);
	char sha1result[20];
	memcpy(sha1result, sha1.result(), 20);
	if (lunghezza!=letti)
	{
		myprintf("\n30056: *** CORRUPTED FILE DETECTED! expected %s readed %s bytes *** ",migliaia(lunghezza),migliaia2(letti));
		printUTF8(i_filename);
		myprintf("\n");
	}
	return binarytohex((const unsigned char*)sha1result,20);
}
string fileentropy(const char * i_filename,const int64_t i_inizio,const int64_t i_totali,int64_t& io_lavorati)
{
	FILE* myfile = freadopen(i_filename);
	if(myfile==NULL )
 		return "";
	int64_t lunghezza	=prendidimensionehandle(myfile);
	int64_t	letti		=0;
	const int BUFSIZE	=65536*8;
	unsigned char 		buf[BUFSIZE];
	int 				n=BUFSIZE;
	size_t f[256] = { 0 };
	while (1)
	{
		int r=fread(buf, 1, n, myfile);
		io_lavorati+=r;
		letti+=r;
		for(int i=0;i<r;i++)
			f[buf[i]]++;
		if (r!=n) 
			break;
		if (flagnoeta==false)
			myavanzamentoby1sec(io_lavorati,i_totali,i_inizio,false);
	}
	fclose(myfile);
	if (lunghezza!=letti)
	{
		myprintf("\n31357: *** CORRUPTED FILE DETECTED! expected %s readed %s bytes *** ",migliaia(lunghezza),migliaia2(letti));
		printUTF8(i_filename);
		myprintf("\n");
	}
	double entropy=0.0;
	double byteletti=letti;
	if (letti>0)
		for(size_t i=0;i<256; i++)
			if (f[i])
			{
				double prob=(double)f[i]/byteletti;
				entropy += prob * log2(prob);
			}
	char buffer[32];
	if (entropy)
		snprintf(buffer, sizeof(buffer), "%8.4f", (float)-entropy);
	else
		snprintf(buffer, sizeof(buffer), "%8.4f", (float)0); 
	return buffer;
}	
string crc32_calc_file(const char * i_filename,const int64_t i_inizio,const int64_t i_totali,int64_t& io_lavorati)
{
	FILE* myfile = freadopen(i_filename);
	if(myfile==NULL )
		return "";
	int64_t lunghezza	=prendidimensionehandle(myfile);
	int64_t	letti		=0;
	char data[65536*16];
    uint32_t crc=0;
	int got=0;
	while ((got=fread(data,sizeof(char),sizeof(data),myfile)) > 0) 
	{
		crc=crc32_16bytes (data, got, crc);
		io_lavorati+=got;	
		letti+=got;
		if ((flagnoeta==false) && (i_inizio>0))
			myavanzamentoby1sec(io_lavorati,i_totali,i_inizio,false);
	}
	fclose(myfile);
	char temp[9];
	sprintf(temp,"%08X",crc);
	if (lunghezza!=letti)
	{
		myprintf("\n30090: *** CORRUPTED FILE DETECTED! expected %s readed %s bytes *** ",migliaia(lunghezza),migliaia2(letti));
		printUTF8(i_filename);
		myprintf("\n");
	}
	return temp;
}
std::string xxhash64_calc_file(const char * i_filename,bool i_flagcalccrc32,uint32_t& o_crc32,const int64_t i_inizio,const int64_t i_totali,int64_t& io_lavorati)
{
	o_crc32=0;
	FILE* myfile = freadopen(i_filename);
	if(myfile==NULL )
 		return "";
	int64_t lunghezza	=prendidimensionehandle(myfile);
	int64_t	letti		=0;
	const int BUFSIZE	=65536*8;
	char 				unzBuf[BUFSIZE];
	int 				n=BUFSIZE;
	uint64_t myseed = 0;
    XXHash64 myhash(myseed);
	while (1)
	{
		int r=fread(unzBuf, 1, n, myfile);
		myhash.add(unzBuf,r);
		if (i_flagcalccrc32)
			o_crc32=crc32_16bytes(unzBuf,r,o_crc32);
		io_lavorati+=r;
		letti+=r;
 		if (r!=n) 
			break;
		if ((flagnoeta==false) && (i_inizio>0))
			myavanzamentoby1sec(io_lavorati,i_totali,i_inizio,false);
	}
	fclose(myfile);
	char temp[33];
	sprintf(temp,"%016llX",(unsigned long long)myhash.hash());
	if (lunghezza!=letti)
	{
		myprintf("\n30134: *** CORRUPTED FILE DETECTED! expected %s readed %s bytes *** ",migliaia(lunghezza),migliaia2(letti));
		printUTF8(i_filename);
		myprintf("\n");
	}
	return temp;
}
string wyhash_calc_file(const char * i_filename,bool i_flagcalccrc32,uint32_t& o_crc32,const int64_t i_inizio,const int64_t i_totali,int64_t& io_lavorati)
{
	o_crc32=0;
	int64_t lunghezza=prendidimensionefile(i_filename);
	int64_t	letti		=0;
	int myfilehandle=open(i_filename,O_RDONLY);
	if (myfilehandle<=0)
	{
		myprintf("25098 in open\n");
		return "";
	}
	char *data=(char *)mmap(0,lunghezza,PROT_READ,MAP_PRIVATE,myfilehandle,0);
	if (data==MAP_FAILED)
	{
        myprintf("25098: map failed\n");
		if (myfilehandle>0)
			close(myfilehandle);
        return "";
    }
	string risultato="";
	uint64_t _wyp[4];
	make_secret(0,_wyp);
	if (data)
	{
		uint64_t mywyhash=wyhash(data,lunghezza,0,_wyp);
		char buffer[33];
		sprintf(buffer,"%16llX",(unsigned long long)mywyhash);
		risultato=buffer;
		if (i_flagcalccrc32)
			o_crc32=crc32_16bytes(data,lunghezza,o_crc32);
		io_lavorati+=lunghezza;	
		letti+=lunghezza;
		if (flagnoeta==false)
			myavanzamentoby1sec(io_lavorati,i_totali,i_inizio,false);
	}
	if (myfilehandle!=0)
		close(myfilehandle);
	if (lunghezza>0)
	{
		int errore=munmap(data,lunghezza);
		if (errore!=0)
		{
			myprintf("25109: unmapping guru\n");
			return "";
		}
	}
	if (lunghezza!=letti)
	{
		myprintf("\n30227: *** CORRUPTED FILE DETECTED! expected %s readed %s bytes *** ",migliaia(lunghezza),migliaia2(letti));
		printUTF8(i_filename);
		myprintf("\n");
	}
	return risultato;
}
string mm_hash_calc_file(int i_algo,const char * i_filename,bool i_flagcalccrc32,uint32_t& o_crc32,const int64_t i_inizio,const int64_t i_totali,int64_t& io_lavorati)
{
	o_crc32=0;
	char buffer[100];
	string risultato	="26304:ERROR";
	int64_t lunghezza	=prendidimensionefile(i_filename);
	char* data	=NULL;
	char zero			=0; 
	int myfilehandle=0; 
	if (lunghezza==0)
	{	
		data=&zero;
	}
	else
	{
		myfilehandle=open(i_filename,O_RDONLY);
		if (myfilehandle<=0)
			return "26364: ERROR IN OPEN";
		data=(char *)mmap(0,lunghezza,PROT_READ,MAP_PRIVATE,myfilehandle,0);
		if (data==MAP_FAILED)
		{
			if (myfilehandle>0)
				close(myfilehandle);
			return "26369: map failed";
		}
	}
	if (data)
	{
		if (i_algo==ALGO_NILSIMSA)
		{
			nilsimsa_compute(data,lunghezza,buffer);
			risultato=binarytohex((const unsigned char*)buffer,64);
		}
		else
		if (i_algo==ALGO_WYHASH)
		{
			uint64_t _wyp[4];
			make_secret(0,_wyp);
			uint64_t mywyhash=wyhash(data,lunghezza,0,_wyp);
			sprintf(buffer,"%16llX",(unsigned long long)mywyhash);
			risultato=buffer;
		}
		else
		if (i_algo==ALGO_XXHASH64)
		{
			uint64_t myseed = 0;
			XXHash64 myhash(myseed);
			myhash.add(data,lunghezza);
			sprintf(buffer,"%016llX",(unsigned long long)myhash.hash());
			risultato=buffer;
		}
		else
		if (i_algo==ALGO_SHA1)
		{
			libzpaq::SHA1 sha1;
			for (int64_t i=0;i<lunghezza;i++)
				sha1.put(*(data+i));
			char sha1result[20];
			memcpy(sha1result, sha1.result(), 20);
			risultato=binarytohex((const unsigned char*)sha1result,20);
		}
		else
		if (i_algo==ALGO_SHA256)
		{
			libzpaq::SHA256 sha256;
			for (int64_t i=0;i<lunghezza;i++)
				sha256.put(*(data+i));
			char sha256result[32];
			memcpy(sha256result, sha256.result(), 32);
			risultato=binarytohex((const unsigned char*)sha256result,32);
		}
		else
		if (i_algo==ALGO_BLAKE3)
		{
			blake3_hasher hasher;
			blake3_hasher_init(&hasher);
			blake3_hasher_update(&hasher,data,lunghezza);
			uint8_t output[BLAKE3_OUT_LEN];
			blake3_hasher_finalize(&hasher, output, BLAKE3_OUT_LEN);
			risultato=binarytohex((const unsigned char*)output,BLAKE3_OUT_LEN);
		}
		else
		if (i_algo==ALGO_WHIRLPOOL)
		{
			NESSIEstruct hasher;
			NESSIEinit(&hasher);
			NESSIEadd64((const unsigned char*)data,lunghezza*8,&hasher); 
			NESSIEfinalize(&hasher,(unsigned char*)buffer);
			risultato=binarytohex((const unsigned char*)buffer,64);
		}
		else
		if (i_algo==ALGO_MD5)
		{
			MD5 md5;
			md5.add(data,lunghezza);
			string mymd5 = md5.getHash();
			risultato=mymd5;
		}
		else
		if (i_algo==ALGO_SHA3)
		{
			SHA3 sha3;
			sha3.add(data,lunghezza);
			string mysha3 = sha3.getHash();
			risultato=mysha3;
		}
		else
		if (i_algo==ALGO_XXH3)
		{
			XXH3_state_t state128;
			(void)XXH3_128bits_reset(&state128);
			(void)XXH3_128bits_update(&state128,data,lunghezza);
			XXH128_hash_t myhash=XXH3_128bits_digest(&state128);
			char buffer[33];
			sprintf(buffer,"%016llX%016llX",(unsigned long long)myhash.high64,(unsigned long long)myhash.low64);
			risultato=buffer;
		}
		else
		if (i_algo==ALGO_CRC32C)
		{
			uint32_t crc=0;
			crc=crc32c(crc, (const unsigned char*)data,lunghezza);
			char buffer[33];
			sprintf(buffer,"%08X",crc);
			risultato=buffer;
		}
		else
		if ((i_algo==ALGO_CRC32) || (i_flagcalccrc32))
		{
			o_crc32=crc32_16bytes(data,lunghezza,o_crc32);
			char buffer[33];
			sprintf(buffer,"%08X",o_crc32);
			risultato=buffer;
		}
		else
		{
			perror("25087: unknown algo");
		}
		io_lavorati+=lunghezza;	
		if ((flagnoeta==false) && (i_inizio>0))
			myavanzamentoby1sec(io_lavorati,i_totali,i_inizio,false);
	}
	if (myfilehandle!=0)
		close(myfilehandle);    
	if (lunghezza>0)
	{
		int errore=munmap(data,lunghezza);
		if (errore!=0)
			return "26506: unmapping guru";
	}
	return risultato;
}
string nilsimsa_calc_file(const char * i_filename,bool i_flagcalccrc32,uint32_t& o_crc32,const int64_t i_inizio,const int64_t i_totali,int64_t& io_lavorati)
{
	return mm_hash_calc_file(ALGO_NILSIMSA,i_filename,i_flagcalccrc32,o_crc32,i_inizio,i_totali,io_lavorati);
}
string sha256_calc_file(const char * i_filename,bool i_flagcalccrc32,uint32_t& o_crc32,const int64_t i_inizio,const int64_t i_totali,int64_t& io_lavorati)
{
	o_crc32=0;
	FILE* myfile = freadopen(i_filename);
	if(myfile==NULL )
 		return "";
	int64_t lunghezza	=prendidimensionehandle(myfile);
	int64_t	letti		=0;
	const int BUFSIZE	=65536*8;
	unsigned char 		buf[BUFSIZE];
	int 				n=BUFSIZE;
	franzSHA256 mysha256;
	while (1)
	{
		int r=fread(buf, 1, n, myfile);
		mysha256.update(buf,r);
		if (i_flagcalccrc32)
			o_crc32=crc32_16bytes(buf,r,o_crc32);
 		io_lavorati+=r;
		letti+=r;
		if (r!=n) 
			break;
		if (flagnoeta==false)
			myavanzamentoby1sec(io_lavorati,i_totali,i_inizio,false);
	}
	fclose(myfile);
	if (lunghezza!=letti)
	{
		myprintf("\n30410: *** CORRUPTED FILE DETECTED! expected %s readed %s bytes *** ",migliaia(lunghezza),migliaia2(letti));
		printUTF8(i_filename);
		myprintf("\n");
	}
	return mysha256.gethex();
}	
string xxhash_calc_file(const char * i_filename,bool i_flagcalccrc32,uint32_t& o_crc32,const int64_t i_inizio,const int64_t i_totali,int64_t& io_lavorati)
{
	o_crc32=0;
	FILE* inFile = freadopen(i_filename);
	if (inFile==NULL) 
		return "";
	int64_t lunghezza	=prendidimensionehandle(inFile);
	int64_t	letti		=0;
	size_t const blockSize = 65536;
	unsigned char buffer[blockSize];
	size_t readSize;
	XXH3_state_t state128;
    (void)XXH3_128bits_reset(&state128);
	while ((readSize = fread(buffer, 1, blockSize, inFile)) > 0) 
	{
		(void)XXH3_128bits_update(&state128, buffer, readSize);
		if (i_flagcalccrc32)
			o_crc32=crc32_16bytes(buffer,readSize,o_crc32);
		io_lavorati+=readSize;
		letti+=readSize;
		if (flagnoeta==false) 
				myavanzamentoby1sec(io_lavorati,i_totali,i_inizio,false);
	}
	fclose(inFile);
	XXH128_hash_t myhash=XXH3_128bits_digest(&state128);
	char buf[33];
	sprintf(buf,"%016llX%016llX",(unsigned long long)myhash.high64,(unsigned long long)myhash.low64);
	string risultato=buf;
	if (lunghezza!=letti)
	{
		myprintf("\n30463: *** CORRUPTED FILE DETECTED! expected %s readed %s bytes *** ",migliaia(lunghezza),migliaia2(letti));
		printUTF8(i_filename);
		myprintf("\n");
	}
	return risultato;
}
string blake3_calc_file(const char * i_filename,bool i_flagcalccrc32,uint32_t& o_crc32,const int64_t i_inizio,const int64_t i_totali,int64_t& io_lavorati)
{
	o_crc32=0;
    FILE* inFile = freadopen(i_filename);
	if (inFile==NULL) 
		return "";
	int64_t lunghezza	=prendidimensionehandle(inFile);
	int64_t	letti		=0;
	blake3_hasher hasher;
	blake3_hasher_init(&hasher);
	unsigned char buffer[65536];
	ssize_t readSize;
	while ((readSize = fread(buffer, 1, sizeof(buffer), inFile)) > 0) 
	{
		blake3_hasher_update(&hasher, buffer, readSize);
		if (i_flagcalccrc32)
			o_crc32=crc32_16bytes(buffer,readSize,o_crc32);
		io_lavorati+=readSize;
		letti+=readSize;
		if (flagnoeta==false)
				myavanzamentoby1sec(io_lavorati,i_totali,i_inizio,false);
	}
	fclose(inFile);
	uint8_t output[BLAKE3_OUT_LEN];
	blake3_hasher_finalize(&hasher, output, BLAKE3_OUT_LEN);
	if (lunghezza!=letti)
	{
		myprintf("\n30505: *** CORRUPTED FILE DETECTED! expected %s readed %s bytes *** ",migliaia(lunghezza),migliaia2(letti));
		printUTF8(i_filename);
		myprintf("\n");
	}
	return binarytohex((const unsigned char*)output,BLAKE3_OUT_LEN);	
}
#define SIZE (262144*3)
#define CHUNK SIZE
string crc32c_calc_file(const char * i_filename,const int64_t i_inizio,const int64_t i_totali,int64_t& io_lavorati)
{
	FILE* myfile = freadopen(i_filename);
	if( myfile==NULL )
    	return 0;
	int64_t lunghezza	=prendidimensionehandle(myfile);
	int64_t	letti		=0;
	char buffer[SIZE];
    ssize_t got;
    size_t off, n;
    uint32_t crc=0;
    while ((got = fread(buffer, sizeof(char),SIZE,myfile)) > 0) 
	{
		off = 0;
        do 
		{
            n = (size_t)got - off;
            if (n > CHUNK)
                n = CHUNK;
            crc = crc32c(crc, (const unsigned char*)buffer + off, n);
            off += n;
        } while (off < (size_t)got);
		io_lavorati+=got;
		letti+=got;
		if (flagnoeta==false)
			if (i_totali)
			myavanzamentoby1sec(io_lavorati,i_totali,i_inizio,false);
    }
    fclose(myfile);
	char buf[9];
	sprintf(buf,"%08X",crc);
	string risultato=buf;
	if (lunghezza!=letti)
	{
		myprintf("\n30556: *** CORRUPTED FILE DETECTED! expected %s readed %s bytes *** ",migliaia(lunghezza),migliaia2(letti));
		printUTF8(i_filename);
		myprintf("\n");
	}
	return risultato;
}
string hash_calc_file(int i_algo,const char * i_filename,bool i_flagcalccrc32,uint32_t& o_crc32,const int64_t i_inizio,const int64_t i_totali,int64_t& io_lavorati)
{
	o_crc32=0;
	if (flagmm)
	{
		return mm_hash_calc_file(i_algo,i_filename,i_flagcalccrc32,o_crc32,i_inizio,i_totali,io_lavorati);
	}
	if (i_algo==ALGO_BLAKE3)
		return blake3_calc_file(i_filename,i_flagcalccrc32,o_crc32,i_inizio,i_totali,io_lavorati);
	else
	if (i_algo==ALGO_NILSIMSA)		
		return nilsimsa_calc_file(i_filename,i_flagcalccrc32,o_crc32,i_inizio,i_totali,io_lavorati);
	else
	if (i_algo==ALGO_WYHASH)		
		return wyhash_calc_file(i_filename,i_flagcalccrc32,o_crc32,i_inizio,i_totali,io_lavorati);
	else
	if (i_algo==ALGO_WHIRLPOOL)		
		return whirlpool_calc_file(i_filename,i_flagcalccrc32,o_crc32,i_inizio,i_totali,io_lavorati);
	else
	if (i_algo==ALGO_MD5)		
		return md5_calc_file(i_filename,i_flagcalccrc32,o_crc32,i_inizio,i_totali,io_lavorati);
	else
	if (i_algo==ALGO_SHA3)		
		return sha3_calc_file(i_filename,i_flagcalccrc32,o_crc32,i_inizio,i_totali,io_lavorati);
	else
	if (i_algo==ALGO_XXHASH64)
		return xxhash64_calc_file(i_filename,i_flagcalccrc32,o_crc32,i_inizio,i_totali,io_lavorati);
	else
	if (i_algo==ALGO_SHA1)
		return sha1_calc_file(i_filename,i_flagcalccrc32,o_crc32,i_inizio,i_totali,io_lavorati);
	else
	if (i_algo==ALGO_CRC32C)
		return crc32c_calc_file(i_filename,i_inizio,i_totali,io_lavorati);
	else
	if (i_algo==ALGO_CRC32)
		return crc32_calc_file(i_filename,i_inizio,i_totali,io_lavorati);
	else
	if (i_algo==ALGO_ENTROPY)
		return fileentropy(i_filename,i_inizio,i_totali,io_lavorati);
	else
	if (i_algo==ALGO_XXH3)
		return xxhash_calc_file(i_filename,i_flagcalccrc32,o_crc32,i_inizio,i_totali,io_lavorati);
	else
	if (i_algo==ALGO_SHA256)
		return sha256_calc_file(i_filename,i_flagcalccrc32,o_crc32,i_inizio,i_totali,io_lavorati);
	else
		error("GURU 13480 algo ??");
	return "";
}
string shash_calc_file(string i_algo,const char * i_filename,bool i_flagcalccrc32,uint32_t& o_crc32,const int64_t i_inizio,const int64_t i_totali,int64_t& io_lavorati)
{
	o_crc32=0;
	if (i_algo=="BLAKE3")
		return blake3_calc_file(i_filename,i_flagcalccrc32,o_crc32,i_inizio,i_totali,io_lavorati);
	else
	if (i_algo=="WYHASH")		
		return wyhash_calc_file(i_filename,i_flagcalccrc32,o_crc32,i_inizio,i_totali,io_lavorati);
	else
	if (i_algo=="WHIRLPOOL")		
		return whirlpool_calc_file(i_filename,i_flagcalccrc32,o_crc32,i_inizio,i_totali,io_lavorati);
	else
	if (i_algo=="MD5")		
		return md5_calc_file(i_filename,i_flagcalccrc32,o_crc32,i_inizio,i_totali,io_lavorati);
	else
	if (i_algo=="NILSIMSA")		
		return nilsimsa_calc_file(i_filename,i_flagcalccrc32,o_crc32,i_inizio,i_totali,io_lavorati);
	else
	if (i_algo=="SHA-3")		
		return sha3_calc_file(i_filename,i_flagcalccrc32,o_crc32,i_inizio,i_totali,io_lavorati);
	else
	if (i_algo=="XXHASH64")
		return xxhash64_calc_file(i_filename,i_flagcalccrc32,o_crc32,i_inizio,i_totali,io_lavorati);
	else
	if (i_algo=="SHA-1")
		return sha1_calc_file(i_filename,i_flagcalccrc32,o_crc32,i_inizio,i_totali,io_lavorati);
	else
	if (i_algo=="CRC32-C")
		return crc32c_calc_file(i_filename,i_inizio,i_totali,io_lavorati);
	else
	if (i_algo=="CRC-32")
		return crc32_calc_file(i_filename,i_inizio,i_totali,io_lavorati);
	else
	if (i_algo=="ENTROPY")
		return fileentropy(i_filename,i_inizio,i_totali,io_lavorati);
	else
	if (i_algo=="XXH3")
		return xxhash_calc_file(i_filename,i_flagcalccrc32,o_crc32,i_inizio,i_totali,io_lavorati);
	else
	if (i_algo=="SHA-256")
		return sha256_calc_file(i_filename,i_flagcalccrc32,o_crc32,i_inizio,i_totali,io_lavorati);
	else
		error("GURU 31223 algo ??");
	return "";
}
bool 	iszpaqfranzvirtualfile(const string& i_filename)
{
	if (mypos("VCOMMENT ",i_filename)>-1)
		return true;
	if (mypos("VFILE-",i_filename)>-1)
		return true;
	return false;
}
bool isletterpath(const string& i_filename)
{
	if (i_filename.size()<3)
			return false;
	if (isalpha(i_filename[0]))
		if (i_filename[1]==':')
			if ((i_filename[2]=='/') || (i_filename[2]=='\\'))
				return true;
	return false;
}
int Jidac::setpassword() 
{
	if (files.size()!=2)
	{
		myprintf("32447: setpassword require exactly two file-parameters: source and destination\n");
		return 2;
	}
	archive=files[0];
	if (!iszpaq(archive))
			archive+=".zpaq";
	repack=files[1];
	if (!iszpaq(repack))
			repack+=".zpaq";
	string part0=subpart(archive,0);
	if (part0!=archive) 
	{  
		myprintf("32528: so sorry, this seems a multipart archive, abort\n");
		return 2;
	}
	if (!flagspace)
		if (!saggiascrivibilitacartella(repack.c_str()))
		{
			myprintf("32471: Cannot write on output %s\n",repack.c_str());
			myprintf("32472: Aborting. Use -space to bypass and enforcing.\n");
			return 2;
		}
	myprintf("\n\nOpening the source achive\n");
	getpasswordifempty();
	if (password!=NULL)
	{
		myprintf("32479: please take note: if the source password is incorrect\n");
		myprintf("32480: the output file will be silently corrupted\n");
		myprintf("\n\n");
	}
	if (new_password==NULL)
	{
		myprintf("New password (-key2) empty, enter . for NO password\n");
		string spassword=getpassword();
		if (spassword==".")
			myprintf("32478: password in output removed\n");
		else
		{
			if (spassword!="")
			{
				libzpaq::SHA256 sha256;
				for (unsigned int i=0;i<spassword.size();i++)
					sha256.put(spassword[i]);
				memcpy(new_password_string, sha256.result(), 32);
				new_password=new_password_string;
			}
		}
	}
	InputArchive in(archive.c_str(), password);
	int64_t lavoro=in.totalsize();
	if (!flagspace)
	{
		int64_t spazio=getfreespace(repack);
		if (spazio<lavoro+1024)
		{
			myprintf("32515: The free space seems tiny %s on %s\n",migliaia(spazio),repack.c_str());
			myprintf("32516: Aborting. Use -space to bypass and enforcing.\n");
			return 2;
		}
	}
	if (flagforce) 
		delete_file(repack.c_str());
	if (exists(repack)) 
		error("32507: output file exists and no -force");
	char salt[32]={0};
	if (new_password) 
		libzpaq::random(salt, 32);
	myprintf("Running for %s bytes\n",migliaia(in.totalsize()));
	if (password!=NULL)
		myprintf("Source password:       present\n");
	else
		myprintf("Source password:       none\n");
	if (new_password!=NULL)
		myprintf("Destination password:  present\n");
	else
		myprintf("Destination password:  none\n");
	OutputArchive out(repack.c_str(), new_password, salt, 0);
	copywitheta(lavoro,in, out);
	myprintf("\n");
	myprintf("Source      %19s <<", migliaia(in.tell()));
	printUTF8(archive.c_str());
	myprintf(">>\n");
	myprintf("Destination %19s <<", migliaia(out.tell()));
	printUTF8(repack.c_str());
	myprintf(">>\n");
	out.close();
	myprintf("\nNow quick check of the output file\n");
	password=new_password;
	read_archive(repack.c_str()); 
	return 0;
}
struct tparametriramtodisk
{
	vector<string> 	filenameondisk;
	vector<int64_t>	filedate;
	vector<int64_t>	fileattr;
	vector<string> 	algo;
	vector<string> 	filehash;
	vector<int64_t>	filesize;
	vector<char*>	data;
	vector<string> 	filecrc;
	vector<uint32_t> filefix;
	int				tnumber;
	uint64_t		timestart;
	bool			flagtest;
	uint64_t		o_timeend;
	int64_t			o_hashedsize;
	int64_t			o_crcsize;
	int64_t			o_writtenbythread;
	int64_t			o_timecrc;
	int64_t			o_timehash;
	int64_t			o_timefilesystem;
	int64_t			o_timewrite;
	uint32_t		o_writeerror;
	uint32_t		o_fileok;
	uint32_t		o_fileerror;
	uint32_t		o_filesnotchecked;
	uint32_t		o_filewithoutcrc;
	uint32_t		o_filecrc;
	uint32_t		o_filecrcok;
	uint32_t		o_filecrcerror;
};
void * scriviramtodisk(void *t) 
{
	assert(t);
	tparametriramtodisk* par= ((struct tparametriramtodisk*)(t));
	char buffer[100];
	string hashstringato;
	string crc32fromram;
	string hashfromfile		="";
	par->o_crcsize			=0;
	par->o_hashedsize		=0;
	par->o_writtenbythread	=0;
	par->o_timecrc			=0;
	par->o_timehash			=0;
	par->o_timefilesystem	=0;
	par->o_timewrite		=0;
	par->o_writeerror		=0;
	par->o_fileok			=0;
	par->o_fileerror		=0;
	par->o_filesnotchecked	=0;
	par->o_filewithoutcrc	=0;
	par->o_filecrc			=0;
	par->o_filecrcok		=0;
	par->o_filecrcerror		=0;
	for (unsigned int i=0;i<par->filenameondisk.size();i++)
	{
		if (flagchecksum)
		if (!isdirectory(par->filenameondisk[i]))
			if (par->data[i]!=NULL)
				{
					hashfromfile="";
					if (par->filecrc[i]!="")
					{
						int64_t startcrc=mtime();
						par->o_filecrc++;
						uint32_t crc=0;
						crc=crc32_16bytes (par->data[i],par->filesize[i],crc);
						sprintf(buffer,"%08X",crc);
						crc32fromram=buffer;
						if (crc32fromram==par->filecrc[i])
							par->o_filecrcok++;
						else
						{
							if (flagverbose)
								myprintf("33162: ERROR CRC stored %s  from ram|%s|\n",par->filecrc[i].c_str(),crc32fromram.c_str());
							par->o_filecrcerror++;
						}
						par->o_crcsize+=par->filesize[i];
						par->o_timecrc+=(mtime()-startcrc);
					}
					else
					par->o_filewithoutcrc++;
					int64_t starthash=mtime();
					if (par->algo[i]=="")
						par->o_filesnotchecked++;
					else
					if (par->algo[i]=="XXHASH64")
					{
						uint64_t myseed = 0;
						XXHash64 myhash64(myseed);
						myhash64.add(par->data[i],par->filesize[i]);
						sprintf(buffer,"%016llX",(unsigned long long)myhash64.hash());
						hashstringato=buffer;
						par->o_hashedsize+=par->filesize[i];
					}
					else
					if (par->algo[i]=="SHA-1")
					{
						libzpaq::SHA1 sha1;
						sha1.write(par->data[i],par->filesize[i]);
						char sha1result[20];
						memcpy(sha1result, sha1.result(), 20);
						hashstringato=binarytohex((const unsigned char*)sha1result,20);
						par->o_hashedsize+=par->filesize[i];
					}
					else
					if (par->algo[i]=="SHA-256")
					{
						libzpaq::SHA256 sha256;
						for (int64_t i=0;i<par->filesize[i];i++)
							sha256.put(*(par->data[i]+i));
						char sha256result[32];
						memcpy(sha256result, sha256.result(), 32);
						hashstringato=binarytohex((const unsigned char*)sha256result,32);
						par->o_hashedsize+=par->filesize[i];
					}
					else
					if (par->algo[i]=="BLAKE3")
					{
						blake3_hasher hasher;
						blake3_hasher_init(&hasher);
						blake3_hasher_update(&hasher,par->data[i],par->filesize[i]);
						uint8_t output[BLAKE3_OUT_LEN];
						blake3_hasher_finalize(&hasher, output, BLAKE3_OUT_LEN);
						hashstringato=binarytohex((const unsigned char*)output,BLAKE3_OUT_LEN);
						par->o_hashedsize+=par->filesize[i];
					}
					else
					if (par->algo[i]=="SHA-3")
					{
						SHA3 sha3;
						sha3.add(par->data[i],par->filesize[i]);
						hashstringato=sha3.getHash();
						par->o_hashedsize+=par->filesize[i];
					}
					else
					if (par->algo[i]=="MD5")
					{
						MD5 md5;
						md5.add(par->data[i],par->filesize[i]);
						hashstringato=md5.getHash();
						par->o_hashedsize+=par->filesize[i];
					}
					else
					if (par->algo[i]=="XXH3")
					{
						XXH3_state_t state128;
						(void)XXH3_128bits_reset(&state128);
						(void)XXH3_128bits_update(&state128,par->data[i],par->filesize[i]);
						XXH128_hash_t myhash=XXH3_128bits_digest(&state128);
						char buffer[33];
						sprintf(buffer,"%016llX%016llX",(unsigned long long)myhash.high64,(unsigned long long)myhash.low64);
						hashstringato=buffer;
						par->o_hashedsize+=par->filesize[i];
					}
					else
						error("33964: unknown myhashtype");
					if (flagdebug)
						myprintf("33966: INFO hash stored %s %s  from ram|%s| %s\n",par->algo[i].c_str(),par->filecrc[i].c_str(),hashstringato.c_str(),par->filenameondisk[i].c_str());
					if (par->filehash[i]!=hashstringato)
					{
						par->o_fileerror++;
						if (flagverbose)
							myprintf("33968: ERROR hash stored %s %s  from ram|%s| %s\n",par->algo[i].c_str(),par->filecrc[i].c_str(),hashstringato.c_str(),par->filenameondisk[i].c_str());
					}
					else
					{
						if (hashstringato!="")
							par->o_fileok++;
					}
					int64_t temp=(mtime()-starthash);
					par->o_timehash+=temp;
				}
		if (!par->flagtest)
		{
			int64_t startfilesystem=mtime();
			makepath(par->filenameondisk[i], par->filedate[i],par->fileattr[i]);
			FP myfile=fopen(par->filenameondisk[i].c_str(), WB);
			par->o_timefilesystem+=(mtime()-startfilesystem);
			int64_t startwrite=mtime();
			int64_t	scritti=0;
			int64_t	n=1000000000;
			int64_t w=0;
			while (1)
			{
				int64_t dascrivere=par->filesize[i]-scritti;
				if (dascrivere>n)
						dascrivere=n;
				w=fwrite(par->data[i]+scritti,1,dascrivere,myfile);
				scritti+=w;
				if (w!=n)
					break;
			}
			par->o_writtenbythread+=scritti;
			fclose(myfile);
			close(par->filenameondisk[i].c_str(),par->filedate[i],par->fileattr[i]);
			par->o_timewrite+=(mtime()-startwrite);
			if (scritti!=par->filesize[i])
			{
				if (flagverbose)
				{
					myprintf("33549: written != expected %21s %21s on ",migliaia(scritti),migliaia2(par->filesize[i]));
					printUTF8(par->filenameondisk[i].c_str());
					myprintf("\n");
				}
				par->o_writeerror++;
			}
		}
		myavanzamentoby1sec(g_fwritten,g_ramdisksize,par->timestart,false);
	}
	par->o_timeend=mtime();
	pthread_exit(NULL);
	return 0;
}
int Jidac::extract() 
{
	getpasswordifempty();
	if (flagparanoid)
	{
		if (tofiles.size()==0)
		{
			myprintf("-paranoid needs a -to\n");
			return 2;
		}
		if (command=='x')
		{
			myprintf("30244: -paranoid is a t (test) thing\n");
			return 1;
		}
	}
	if (!flagspace)
		if (tofiles.size()==1)
		{
			if (files.size()==1)
				if (isdirectory(tofiles[0]))
					if (!isdirectory(files[0]))
					{
						if (iswildcards(files[0]))
						{
							if (flagdebug)
								myprintf("31745: wildcard in files[0]: do nothing\n");
						}
						else
						{
							if (flagdebug)
								myprintf("31749: no wildcard, check if a filename is selected\n");
							string onlyname=extractfilename(files[0]);
							if (onlyname!="")
							{
								tofiles[0]+=onlyname;
								myprintf("31744: MAGIC: selected 1 file extracting to a folder => merge to %s\n",tofiles[0].c_str());
							}
						}
					}
			if (!saggiascrivibilitacartella(tofiles[0].c_str()))
			{
				myprintf("Cannot write on <<-to %s>>\n",tofiles[0].c_str());
				myprintf("Aborting. Use -space to bypass and enforcing.\n");
				return 2;
			}
		}
	if (flagzero)
	{
		if (flagforce)
		{
			myprintf("-kill incompatible with -force\n");
			return 2;
		}
		myprintf("\n");
		myprintf("****** WARNING: -zero switch. Create 0 bytes files (NO data written)\n");
		myprintf("****** Full-scale extraction test (UTF-8 strange filenames, path too long...)\n");
		myprintf("****** Highly suggested output on RAMDISK\n\n");
	}
	string kunfile=g_gettempdirectory()+"VFILE-kun.txt";
	myreplaceall(kunfile,"\\","/");
	kunfile=nomefileseesistegia(kunfile);
	if (flagfilelist)
	{
		myprintf("Autoselect\n"); 
			files.clear();
		files.push_back("VFILE-l-filelist.txt");
		flagforce=true;
		tofiles.clear();
		tofiles.push_back(kunfile);
	}
	g_scritti=0;
	if ((repack!="") && all) 
	{
		if (files.size()>0 || tofiles.size()>0 || onlyfiles.size()>0 || flagnoattributes || version!=DEFAULT_VERSION || method!="")
			error("-repack -all does not allow partial copy");
		string part0=subpart(archive, 0);
		if (part0!=archive) 
		{  
			myprintf("32528: so sorry, this seems a multipart archive, abort\n");
			return 2;
		}
		InputArchive in(archive.c_str(), password);
		if (flagforce) 
			delete_file(repack.c_str());
		if (exists(repack)) 
			error("output file exists");
    	char salt[32]={0};
		if (new_password) 
			libzpaq::random(salt, 32);
		myprintf("Changing password for %s bytes\n\n",migliaia(in.totalsize()));
		OutputArchive out(repack.c_str(), new_password, salt, 0);
		copywitheta(in.totalsize(),in, out);
		myprintf("\n");
		myprintf("Source      %19s <<", migliaia(in.tell()));
		printUTF8(archive.c_str());
		myprintf(">>\n");
		myprintf("Destination %19s <<", migliaia(out.tell()));
		printUTF8(repack.c_str());
		myprintf(">>\n");
		out.close();
		return 0;
  }
	int	errors=0;
	int64_t sz=read_archive(archive.c_str(),&errors);
	if (sz<1) error("archive not found");
	if (flagcomment)
		if (versioncomment.length()>0)
		{
			vector<DTMap::iterator> myfilelist;
			int versione=searchcomments(versioncomment,myfilelist);
			if (versione>0)
			{
				myprintf("Found version -until %d scanning again...\n",versione);
				version=versione;
				ver.clear();
				block.clear();
				dt.clear();
				ht.clear();
				ht.resize(1);  
				ver.resize(1); 
				dhsize=dcsize=0;
				sz=read_archive(archive.c_str());
			}
			else
			if (versione==0)
				error("Cannot find version comment");
			else
				error("Multiple match for version comment. Please use -until");
		}
  for (unsigned i=0; i<block.size(); ++i) {
    if (block[i].bsize<0) error("negative block size");
    if (block[i].start<1) error("block starts at fragment 0");
    if (block[i].start>=ht.size()) error("block start too high");
    if (i>0 && block[i].start<block[i-1].start) error("unordered frags");
    if (i>0 && block[i].start==block[i-1].start) error("empty block");
    if (i>0 && block[i].offset<block[i-1].offset+block[i-1].bsize)
      error("unordered blocks");
    if (i>0 && block[i-1].offset+block[i-1].bsize>block[i].offset)
      error("overlapping blocks");
  }
  if (index) {
    if (ver.size()<2) error("no journaling data");
    if (flagforce) delete_file(index);
    if (exists(index)) error("index file exists");
    char salt[32];
    if (ver[1].offset==32) {  
      FP fp=fopen(subpart(archive, 1).c_str(), RB);
      if (fp==FPNULL) error("cannot read part 1");
      if (fread(salt, 1, 32, fp)!=32) error("cannot read salt");
      salt[0]^='7'^'z';  
      fclose(fp);
    }
    InputArchive in(archive.c_str(), password);
    OutputArchive out(index, password, salt, 0);
    for (unsigned i=1; i<ver.size(); ++i) {
      if (in.tell()!=ver[i].offset) error("I'm lost");
      static char hdr[256]={0};  
      int hsize=ver[i].data_offset-ver[i].offset;
      if (hsize<70 || hsize>255) error("bad C block size");
      if (in.read(hdr, hsize)!=hsize) error("EOF in header");
      if (hdr[hsize-36]!=9  
          || (hdr[hsize-22]&255)!=253  
          || (hdr[hsize-1]&255)!=255) {  
        for (int j=0; j<hsize; ++j)
          myprintf("%d%c", hdr[j]&255, j%10==9 ? '\n' : ' ');
        myprintf("at %1.0f\n", ver[i].offset+.0);
        error("C block in weird format");
      }
      memcpy(hdr+hsize-34, 
          "\x00\x00\x00\x00\x00\x00\x00\x00"  
          "\x00\x00\x00\x00"  
          "\xfd"  
          "\x05\xfe\x40\x57\x53\x16\x6f\x12\x55\x59\xe7\xc9\xac\x55\x86"
          "\x54\xf1\x07\xc7\xe9"  
          "\xff", 34);  
      out.write(hdr, hsize);
      in.seek(ver[i].csize, SEEK_CUR);  
      int64_t end=sz;
      if (i+1<ver.size()) end=ver[i+1].offset;
      int64_t n=end-in.tell();
      if (copy(in, out, n)!=n) error("EOF");  
    }
    printUTF8(index);
    myprintf(" -> %s\n", migliaia(out.tell()));
    out.close();
    return 0;
  }
  ExtractJob job(*this);
  int total_files=0, skipped=0;
  int tobeerased=0,erased=0;
  int real_dirs=0;
  uint32_t crc32fromfile;
	int kollision=0;
	if ((flagutf) || (flagflat) || flagfix255 || flagfixcase || (flagparanoid))
	{
		printsanitizeflags();
		int64_t filesbefore=0;
		int64_t dirsbefore=0;
		if (flagdebug)
			for (DTMap::iterator p=dt.begin(); p!=dt.end(); ++p) 
			{
				if ((p->second.date && p->first!="") && (!isdirectory(p->first)))
					dirsbefore++;
				else
					filesbefore++;
			}
		DTMap mymap;
		int kollisioni=0;
		MAPPAFILEHASH mappacollisioni;
		for (DTMap::iterator p=dt.begin(); p!=dt.end(); ++p) 
		{
			string newname=sanitizzanomefile(p->first,filelength,kollisioni,mappacollisioni);
			auto ret=mymap.insert( std::pair<string,DT>(newname,p->second) );
			if (ret.second==false) 
				myprintf("18298: KOLLISION! %s\n",newname.c_str());
		}
		dt=mymap;
		if (flagdebug)
		{
			int64_t filesafter=0;
			int64_t dirsafter=0;
			for (DTMap::iterator p=dt.begin(); p!=dt.end(); ++p) 
			{
				if ((p->second.date && p->first!="") && (!isdirectory(p->first)))
					dirsafter++;
				else
					filesafter++;
			}
			myprintf("18181:size  before %12s\n",migliaia(dt.size()));
			myprintf("17995:Files before %12s\n",migliaia(filesbefore));
			myprintf("17996:dirs  before %12s\n",migliaia(dirsbefore));
			myprintf("\n\n");
			myprintf("18181:size  after  %12s\n",migliaia(dt.size()));
			myprintf("17995:Files before %12s\n",migliaia(filesafter));
			myprintf("17996:dirs  before %12s\n",migliaia(dirsafter));
		}
	}
	for (DTMap::iterator p=dt.begin(); p!=dt.end(); ++p) 
	{
		p->second.data=-1;  
		if (p->second.date && p->first!="") 
		{
			string fn=rename(p->first);
			const bool isdir=isdirectory(p->first);
			if (isdir)
				real_dirs++;
			string dummy="";
			if ((repack=="") && !flagtest && flagforce && !isdir && equal(p, fn.c_str(),crc32fromfile,"","",dummy)) 
			{
				if (flagverbose)
				{
					myprintf("= ");
					printUTF8(fn.c_str());
					myprintf("\n");
				}
				close(fn.c_str(), p->second.date, p->second.attr);
				++skipped;
			}
			else 
			if ((repack=="") && !flagtest && !flagforce && exists(fn)) 
			{  
				if (flagverbose)
				{
					myprintf("? ");
					printUTF8(fn.c_str());
					myprintf("\n");
				}
				++skipped;
			}
			else 
			if (isdir)  
				p->second.data=0;
			else 
			if (block.size()>0) 
			{  
				p->second.data=0;
				unsigned lo=0, hi=block.size()-1;  
				for (unsigned i=0; p->second.data>=0 && i<p->second.ptr.size(); ++i) 
				{
					unsigned j=p->second.ptr[i];  
					if (j==0 || j>=ht.size() || ht[j].usize<-1) 
					{
						fflush(stdout);
						printUTF8(p->first.c_str());
						myprintf( ": bad frag IDs, skipping...\n");
						p->second.data=-1;  
						continue;
					}
					assert(j>0 && j<ht.size());
					if (lo!=hi || lo>=block.size() || j<block[lo].start
						|| (lo+1<block.size() && j>=block[lo+1].start)) 
					{
						lo=0;  
						hi=block.size()-1;
						while (lo<hi) 
						{
							unsigned mid=(lo+hi+1)/2;
							assert(mid>lo);
							assert(mid<=hi);
							if (j<block[mid].start) 
								hi=mid-1;
							else 
							(lo=mid);
						}
					}
					assert(lo==hi);
					assert(lo>=0 && lo<block.size());
					assert(j>=block[lo].start);
					assert(lo+1==block.size() || j<block[lo+1].start);
					unsigned c=j-block[lo].start+1;
					if (block[lo].size<c) block[lo].size=c;
					if (block[lo].files.size()==0 || block[lo].files.back()!=p)
						block[lo].files.push_back(p);
				}
				++total_files;
				job.total_size+=p->second.size;
				if (!flagtest)
				if (fileexists(fn))
				{
					if (flagverbose)
					{
						myprintf("* ");
						printUTF8(fn.c_str());
						myprintf("\n");
					}
					tobeerased++;
					if (delete_file(fn.c_str()))
						erased++;
					else
					myprintf("************ HIGHLANDER FILE! %s\n",fn.c_str());
				}
			}
		}  
	}  
	if (!flagforce && skipped>0)
		myprintf("%08d ?existing files skipped (-force overwrites).\n", skipped);
	if (flagforce && skipped>0)
		myprintf("%08d =identical files skipped.\n", skipped);
	if (flagforce && tobeerased>0)
		myprintf("%08d !=different files to be owerwritten => erased %08d\n",tobeerased,erased);
	if (tobeerased!=erased)
		myprintf("**** GURU **** WE HAVE SOME HIGHLANDER!\n");
	if (repack!="") 
	{
    if (ver.size()<2) error("cannot repack streaming archive");
    int64_t csize=0;  
    for (unsigned i=0; i<block.size(); ++i) {
      if (block[i].bsize<1) error("empty block");
      if (block[i].size>0) csize+=block[i].bsize;
    }
    InputArchive in(archive.c_str(), password);
    if (!flagforce && exists(repack)) 
		error("repack output exists");
    delete_file(repack.c_str());
    char salt[32]={0};
    if (new_password) libzpaq::random(salt, 32);
    OutputArchive out(repack.c_str(), new_password, salt, 0);
    int64_t cstart=out.tell();
    writeJidacHeader(&out, ver[1].date, -1, 1);
    int64_t dstart=out.tell();
    for (unsigned i=0; i<block.size(); ++i) {
      if (block[i].size>0) {
        in.seek(block[i].offset, SEEK_SET);
        copy(in, out, block[i].bsize);
      }
    }
    myprintf("Data %s -> ",migliaia(csize));
    csize=out.tell()-dstart;
    myprintf(" %s\n", migliaia(csize));
    for (unsigned i=0; i<block.size(); ++i) {
      if (block[i].size>0) {
        StringBuffer is;
        puti(is, block[i].bsize, 4);
        for (unsigned j=0; j<block[i].frags; ++j) {
          const unsigned k=block[i].start+j;
          if (k<1 || k>=ht.size()) error("frag out of range");
          is.write((const char*)ht[k].sha1, 20);
          puti(is, ht[k].usize, 4);
        }
        libzpaq::compressBlock(&is, &out, "0",
            ("jDC"+itos(ver.back().date, 14)+"h"
            +itos(block[i].start, 10)).c_str(),
            "jDC\x01");
      }
    }
    unsigned dtcount=0;
    StringBuffer is;
    for (DTMap::iterator p=dt.begin();; ++p) {
      if (p!=dt.end() && p->second.date>0 && p->second.data>=0) {
        string filename=rename(p->first);
        puti(is, p->second.date, 8);
        is.write(filename.c_str(), strlen(filename.c_str()));
        is.put(0);
        if ((p->second.attr&255)=='u') 
				write715attr(is,p->second.attr,3);
		else 
		if ((p->second.attr&255)=='w') 
				write715attr(is,p->second.attr,5);
		else 
			puti(is, 0, 4);  
        puti(is, p->second.ptr.size(), 4);  
        for (unsigned i=0; i<p->second.ptr.size(); ++i)
          puti(is, p->second.ptr[i], 4);
      }
      if (is.size()>16000 || (is.size()>0 && p==dt.end())) {
        libzpaq::compressBlock(&is, &out, "1",
            ("jDC"+itos(ver.back().date)+"i"+itos(++dtcount, 10)).c_str(),
            "jDC\x01");
        is.resize(0);
      }
      if (p==dt.end()) break;
    }
    printUTF8(archive.c_str());
    myprintf(" %s -> ", migliaia(sz));
    printUTF8(repack.c_str());
    myprintf(" %s\n", migliaia(out.tell()));
    out.seek(cstart, SEEK_SET);
    writeJidacHeader(&out, ver[1].date, csize, 1);
    out.close();
    return 0;
  }
	g_crc32.clear();
	myprintf("Extracting %s bytes (%s) in %s files (%s folders) with %d threads\n",migliaia(job.total_size), tohuman(job.total_size),migliaia2(total_files), migliaia4(real_dirs),howmanythreads);
	if (!flagspace)
		if (tofiles.size()==1)
		{
			if (!saggiascrivibilitacartella(tofiles[0].c_str()))
			{
				myprintf("Cannot write on <<-to %s>>\n",tofiles[0].c_str());
				myprintf("Aborting. Use -space to bypass and enforcing.\n");
				error("Path seems not writeable");
			}
			{
				int64_t spazio=getfreespace(tofiles[0]);
				if (spazio<job.total_size)
				{
					myprintf("Free space on <<-to %s>>\n",tofiles[0].c_str());
					myprintf("is      %21s\n",migliaia(spazio));
					myprintf("needed  %21s\n",migliaia(job.total_size));
					if (!isdirectory(tofiles[0]))
						myprintf("33646: -to is a single file, NOT a folder. Maybe you miss the final /?\n");
					myprintf("Aborting extraction. Use -space to bypass and enforcing.\n");
					error("Not enough free space");
				}
			}
		}
	vector<ThreadID> tid(howmanythreads);
	for (unsigned i=0; i<tid.size(); ++i) 
		run(tid[i], decompressThread, &job);
	unsigned segments=0;  
	InputArchive in(archive.c_str(), password);
	if (in.isopen()) 
	{
		FP outf=FPNULL;
		DTMap::iterator dtptr=dt.end();
		for (unsigned i=0; i<block.size(); ++i) 
		{
			if (block[i].usize<0 && block[i].size>0) 
			{
				Block& b=block[i];
				try 
				{
					in.seek(b.offset, SEEK_SET);
					libzpaq::Decompresser d;
					d.setInput(&in);
					if (!d.findBlock()) 
						error("block not found");
					StringWriter filename;
					for (unsigned j=0; j<b.size; ++j) 
					{
						if (!d.findFilename(&filename)) 
							error("segment not found");
						d.readComment();
						if (filename.s!="" || segments==0) 
						{
							unsigned k;
							for (k=0; k<b.files.size(); ++k) 
							{  
								if (b.files[k]->second.ptr.size()>0
									&& b.files[k]->second.ptr[0]==b.start+j
									&& b.files[k]->second.date>0
									&& b.files[k]->second.data==0)
								break;
							}
							if (k<b.files.size()) 
							{  
								if (outf!=FPNULL) 
									fclose(outf);
								outf=FPNULL;
								string outname=rename(b.files[k]->first);
								dtptr=b.files[k];
								lock(job.mutex);
									myprintf("> ");
									printUTF8(outname.c_str());
									myprintf("\n");
									if (!flagtest) 
									{
										makepath(outname);
										outf=fopen(outname.c_str(), WB);
										if (outf==FPNULL) 
										{
											printerr("18330",outname.c_str(),0);
										}
									}
								release(job.mutex);
							}
							else 
							{  
								if (outf!=FPNULL) 
									fclose(outf);
								outf=FPNULL;
								dtptr=dt.end();
							}
						}
						libzpaq::SHA1 sha1;
						d.setSHA1(&sha1);
						OutputFile o(outf);
						d.setOutput(&o);
						d.decompress();
						char sha1result[21];
						d.readSegmentEnd(sha1result);
						if (sha1result[0]==1) 
						{
							if (memcmp(sha1result+1, sha1.result(), 20)!=0)
								error("checksum failed");
						}
						else 
						if (sha1result[0]!=0)
							error("unknown checksum type");
						++b.extracted;
						if (dtptr!=dt.end()) 
							++dtptr->second.data;
						filename.s="";
						++segments;
					}
				}
				catch(std::exception& e) 
				{
					lock(job.mutex);
					myprintf("Skipping block: %s\n", e.what());
					release(job.mutex);
				}
			}
		}
		if (outf!=FPNULL) 
			fclose(outf);
	}
	if (segments>0) 
		myprintf("%u streaming segments extracted\n", segments);
  for (unsigned i=0; i<tid.size(); ++i) join(tid[i]);
  if (!flagtest) {
    for (DTMap::reverse_iterator p=dt.rbegin(); p!=dt.rend(); ++p) {
      if (p->second.data>=0 && p->second.date && p->first!="") {
        string s=rename(p->first);
        if (p->first[p->first.size()-1]=='/')
          makepath(s, p->second.date, p->second.attr);
        else if ((p->second.attr&0x1ff)=='w'+256)  
          close(s.c_str(), 0, p->second.attr);
      }
    }
  }
	if (flagramdisk)
	{
		myprintf("\n");
		myprintf("RAM       %12s (heap memory used %s bytes)",tohuman(g_ramdisksize),migliaia(g_ramdisksize)); 
		myprintf("34079: writing from ramdisk to disk\n");
		int64_t startwrite=mtime();
		uint64_t expected=0;
		uint64_t written=0;
		for (DTMap::iterator p=dt.begin(); p!=dt.end(); ++p) 
		{
			string fn=rename(p->first);
			makepath(fn);
			if (!isdirectory(fn))
			{
				if (p->second.pramfile!=NULL)
				{
					myprintf("not dir %s\n",fn.c_str());
					expected+=(*p->second.pramfile).filesize;
					if (flagdebug)
						myprintf("34092: ramdisk-out  %12s %s\n",migliaia((*p->second.pramfile).filesize),fn.c_str());
					FP myfile=fopen(fn.c_str(), WB);
					int64_t	scritti=0;
					int64_t	n=1000000000;
					int64_t w=0;
					while (1)
					{
						int64_t dascrivere=(*p->second.pramfile).filesize-scritti;
						if (dascrivere>n)
							dascrivere=n;
						w=fwrite((*p->second.pramfile).data+scritti,1,dascrivere,myfile);
						scritti+=w;
						if (w!=n)
							break;
					}
					written+=scritti;
					fclose(myfile);
				}
			}
		}
		double writetime=(1+mtime()-startwrite)*0.001;
		myprintf("34093: written %21s expected %21s time %f @ %s\n",migliaia(written),migliaia2(expected),writetime,migliaia3((written/writetime)));
	}
  unsigned extracted=0;
	if (!flagramdisk)
	{
		for (DTMap::iterator p=dt.begin(); p!=dt.end(); ++p) 
		{
			string fn=rename(p->first);
			if (p->second.data>=0 && p->second.date
				&& fn!="" && fn[fn.size()-1]!='/') 
			{
				++extracted;
				if (p->second.ptr.size()!=unsigned(p->second.data)) 
				{
					fflush(stdout);
					if (++errors==1)
						myprintf("\nFailed (extracted/total fragments, file):\n");
					myprintf( "33783: UKONE %u/%u ",int(p->second.data), int(p->second.ptr.size()));
					printUTF8(fn.c_str());
					myprintf( "\n");
				}
			}
		 }
	}
	if (kollision>0)
		myprintf("\nFilenames collisions %08d\n",(int)kollision);	
	if (errors>0) 
	{
		fflush(stdout);
		myprintf("\nExtracted %s files (%s errors) using %s bytes x %d threads\n",
			migliaia(extracted), migliaia3(errors), migliaia4(job.maxMemory),
			int(tid.size()));
	}
  	if (flagfilelist)
		if (errors==0)
		{
			if (fileexists(kunfile))
			{
				FILE* myfile = freadopen(kunfile.c_str());
				if (myfile!=NULL)
				{
					char data[65536*16];
					int got=0;
					while ((got=fread(data,sizeof(char),sizeof(data),myfile)) > 0) 
						fwrite(data,1,got,stdout);
					fclose(myfile);
					delete_file(kunfile.c_str());
				}
			}
			else
			{
				myprintf("\n20543: Cannot work the filelist. Archive created without -filelist ?\n");
				errors=1;
			}
		}
	if (flagparanoid)
	{
		myprintf("\n\nFULL-extract hashing check (aka:paranoid)\n");
		int64_t	dimensionetotale=0;
		int		dalavorare=0;
		for (DTMap::iterator p=dt.begin(); p!=dt.end(); ++p) 
			if (p->second.date && p->first!="") 
			{
				string fn=rename(p->first);
				if (!isdirectory(fn))
				{
				if (fileexists(fn))
					if (p->second.hashtype!="")
					{
						dimensionetotale+=p->second.size;
						dalavorare++;
					}
				}
			}
		int64_t inizio=mtime();
		int		uguali=0;
		int		diversi=0;
		int64_t lavorati=0;
		for (DTMap::iterator p=dt.begin(); p!=dt.end(); ++p) 
			if (p->second.date && p->first!="") 
			{
				string fn=rename(p->first);
				if (iszpaqfranzvirtualfile(p->first))
				{
					if (flagdebug)
					myprintf("33042: found a virtualfile %s\n",fn.c_str());
					if (fileexists(fn))
						delete_file(fn.c_str());
				}
				if (!isdirectory(fn))
					if (p->second.hashtype!="")
						if (fileexists(fn))			
						{
							uint32_t dummycrc;
							string hashfromfile=shash_calc_file(
							p->second.hashtype,
							fn.c_str(),
							false,				
							dummycrc,	
							inizio,				
							dimensionetotale,	
							lavorati);			
							if (hashfromfile==p->second.hexhash)
							{
								uguali++;
								delete_file(fn.c_str());
							}
							else
							{
								diversi++;
								if (flagverbose)
									myprintf("!= from file %s from archive %s <<%s>>\n",hashfromfile.c_str(),p->second.hexhash.c_str(),fn.c_str());
							}
						}
			}
		if (dalavorare>0)
		{
			myprintf("Total bytes          %s\n",migliaia(dimensionetotale));
			myprintf("Bytes checked        %s\n",migliaia(lavorati));
			myprintf("Files to be checked  %08d\n",dalavorare);
			myprintf("Files ==             %08d\n",uguali);
			myprintf("Files !=             %08d\n",diversi);
			if ((dalavorare!=uguali) || (lavorati!=dimensionetotale))
			{
				myprintf("*** ERROR IN PARANOID EXTRACT CHECK! ***\n");
				errors=1;
			}
			removetempdirifempty(tofiles[0],true);
		}
  }
  return errors>0;
}
int Jidac::searchcomments(string i_testo,vector<DTMap::iterator> &filelist)
{
	unsigned int quanti=0;
	int versione=-1;
	filelist.clear();
	for (DTMap::iterator a=dt.begin(); a!=dt.end(); ++a) 
	{
		a->second.data='-';
		filelist.push_back(a);
	}
	for (unsigned i=0;i<filelist.size();i++) 
	{
		DTMap::iterator p=filelist[i];
		if (isads(p->first))
		{
			string fakefile=p->first;
			myreplace(fakefile,":$DATA","");
			size_t found = fakefile.find("VCOMMENT "); 
			if (found != string::npos)
			{
				string numeroversione=fakefile.substr(found+9,8);
#ifdef ESX
	int numver=0;
#else
int numver=std::stoi(numeroversione.c_str());
#endif
				string commento=fakefile.substr(found+9+8+1,65000);
				if (i_testo.length()>0)
				{
					if (!stringcomparei(commento,i_testo))
						continue;
				}
    			mappacommenti.insert(std::pair<int, string>(numver, commento));
				versione=numver;
				quanti++;
			}
		}
	}
	if (quanti==1)
		return versione;
	else
	if (quanti==0)
		return 0;
	else
		return -1;
}
int Jidac::enumeratecomments()
{
	getpasswordifempty();
	int64_t csize=0;
	int errors=0;
	if (archive!="") 
		csize=read_archive(archive.c_str(),&errors,1); 
	myprintf("\nVersion(s) enumerator\n");
	vector<DTMap::iterator> filelist;
	searchcomments(versioncomment,filelist);
	for (MAPPACOMMENTI::const_iterator p=mappacommenti.begin(); p!=mappacommenti.end(); ++p) 
			myprintf("%08d <<%s>>\n",p->first,p->second.c_str());
	for (DTMap::iterator p=edt.begin(); p!=edt.end(); ++p) 
	{
		DTMap::iterator a=dt.find(rename(p->first));
		if (a!=dt.end() && (true || a->second.date)) 
		{
			a->second.data='-';
			filelist.push_back(a);
		}
		p->second.data='+';
		filelist.push_back(p);
	}
	for (DTMap::iterator a=dt.begin(); a!=dt.end(); ++a) 
		if (a->second.data!='-' && (true || a->second.date)) 
		{
			a->second.data='-';
			filelist.push_back(a);
		}
	if (all)
	{
		myprintf("-------------------------------------------------------------------------\n");
		myprintf("< Ver  > <  date  > < time >  < added > <removed>    <    bytes added   >\n");
		myprintf("-------------------------------------------------------------------------\n");
		for (unsigned fi=0;fi<filelist.size() ; ++fi) 
		{
			DTMap::iterator p=filelist[fi];
			unsigned v;  
			if (p->first.size()==all+1u && (v=atoi(p->first.c_str()))>0 && v<ver.size()) 
			{
				myprintf("%08u %s ",v,dateToString(p->second.date).c_str());
				myprintf(" +%08d -%08d -> %20s", ver[v].updates, ver[v].deletes,
					migliaia((uint64_t)((v+1<ver.size() ? ver[v+1].offset : csize)-ver[v].offset+0.0)));
				std::map<int,string>::iterator commento;
				commento=mappacommenti.find(v); 
				if(commento!= mappacommenti.end()) 
					myprintf(" <<%s>>", commento->second.c_str());
				myprintf("\n");
			}
		}
	}
	return 0;		   
}
string myto_string(int64_t i_number)
{
	char buffer[100];
	sprintf(buffer,"%lld",(long long)i_number);
	string risultato=buffer; 
	return risultato;
}
int Jidac::kill() 
{
	getpasswordifempty();
	myprintf("KILL of:");
	if (files.size()<=0)
		return -1;
	if (archive=="")
		return -1;
	read_archive(archive.c_str());
	g_bytescanned=0;
	g_filescanned=0;
	g_worked=0;
	files_count.clear();
	edt.clear();
	string cartellaoutput=tofiles[0];
	scandir(false,edt,cartellaoutput);
	if (edt.size()) 
		myprintf("Total files found: %s\n", migliaia(edt.size()));
	else	
	{
		myprintf("Found nothing in filesystem\n");
		return 1;
	}
	myprintf("\n");
	vector<string> inzpaqrinominato;
	vector<string> tobekilled;
	vector<string> dirtobekilled;
	for (DTMap::iterator a=dt.begin(); a!=dt.end(); ++a) 
	{
		string dentrofile=a->first;
		myreplace(dentrofile,files[0],tofiles[0]);
		if (a->second.date==0)
		{
			if (flagverbose)
				myprintf("DELETED ");
		}
		else
			inzpaqrinominato.push_back(dentrofile);
		if (flagverbose)
			myprintf("Into zpaq %s  > renamed %s\n",a->first.c_str(),dentrofile.c_str());
	}
	std::sort(inzpaqrinominato.begin(), inzpaqrinominato.end());
	uint64_t		sizetobekilled=0;
	for (DTMap::iterator a=edt.begin(); a!=edt.end(); ++a) 
		if (binary_search(inzpaqrinominato.begin(),inzpaqrinominato.end(),a->first)==false)
		{
			if (isdirectory(a->first))
				dirtobekilled.push_back(a->first);
			else
			{
				tobekilled.push_back(a->first);
				sizetobekilled+=a->second.size;
			}
		}
	for (unsigned int i=0;i<dirtobekilled.size();i++)
	{
		myprintf("Dir  to be killed ");
		printUTF8(dirtobekilled[i].c_str());
		myprintf("\n");
	}
	for (unsigned int i=0;i<tobekilled.size();i++)
	{
		myprintf("File to be killed ");
		printUTF8(tobekilled[i].c_str());
		myprintf("\n");
	}
	myprintf("\n");
	unsigned int 	totaltobekilled=dirtobekilled.size()+tobekilled.size();
	if (totaltobekilled==0)
	{
		myprintf("Nothing to do\n");
		return 0;
	}
	myprintf("Directories to be removed %s\n",migliaia(dirtobekilled.size()));
	myprintf("Files       to be removed %s (%s bytes)\n",migliaia2(tobekilled.size()),migliaia(sizetobekilled));
#ifdef ESX
	string captcha="KILL";
#else	
	string captcha="kilL"+myto_string(dirtobekilled.size()+tobekilled.size()+sizetobekilled);
#endif
	myprintf("Captcha to continue %s\n",captcha.c_str());
	char myline[81];
    int dummy=scanf("%80s", myline);
	if (dummy==888888)
		myprintf("no-warning-please\n");
	if (myline!=captcha)
	{
		myprintf("Wrong captcha\n");
		return 1;
	}
	myprintf("Captcha OK\n");
	unsigned int killed=0;
	unsigned int killeddir=0;
	for (unsigned int i=0;i<tobekilled.size();i++)
		if (delete_file(tobekilled[i].c_str()))
				killed++;
	while (killeddir!=dirtobekilled.size())
		for (unsigned int i=0;i<dirtobekilled.size();i++)
			if (delete_dir(dirtobekilled[i].c_str()))
				killeddir++;
	myprintf("Dir  to be removed %s -> killed %s\n",migliaia(dirtobekilled.size()),migliaia2(killeddir));
	myprintf("File to be removed %s -> killed %s\n",migliaia(tobekilled.size()),migliaia2(killed));
	if ((killeddir+killed)!=(dirtobekilled.size()+tobekilled.size())) 
	{	
		myprintf("FAILED !! some highlander !!\n");
		return 1;
	}
	return 0;
}
struct tparametrihash
{
	vector<string> 	o_hashcalculated;
	vector<string> 	originalfilenames;
	vector<string> 	filestobehashed;
	vector<string> 	filehash;
	vector<string> 	algo;
	uint64_t		timestart;
	uint64_t		timeend;
	int64_t			inizio;
	int64_t 		dimensione;
	int				tnumber;
};
void * scansionahash(void *t) 
{
	assert(t);
	tparametrihash* par= ((struct tparametrihash*)(t));
	vector<string>& tmpfilestobehashed	= par->filestobehashed;
	vector<string>& tmpalgo				= par->algo;
	if (tmpfilestobehashed.size()!=tmpalgo.size())
	{
		myprintf("51569: FILETOBEHASHED != ALGO\n");
		seppuku();
	}
	vector<string>& tmphashcalculated	= par->o_hashcalculated;
	for (unsigned int i=0;i<tmpfilestobehashed.size();i++)
	{
		uint32_t dummycrc;
		tmphashcalculated.push_back(hash_calc_file(string2algo(tmpalgo[i]),tmpfilestobehashed[i].c_str(),false,dummycrc,par->inizio,par->dimensione,g_dimensione));
	}
	pthread_exit(NULL);
	return 0;
}
bool ischecksum()
{
	return (flagcrc32 || flagcrc32c || flagxxh3 || flagxxhash64 || flagsha1 || flagsha256 || flagblake3 || flagwyhash || flagwhirlpool || flagmd5 || flagnilsimsa || flagsha3 || flagentropy);
}	
int Jidac::deduplicate() 
{
	myprintf("*** DIRECTLY DELETE DUPLICATED FILES ***\n");
	if (files.size()==0)
	{
		myprintf("Sorry, works only on exactly 1 dir\n");
		return 1;
	}
	if (files.size()>1)
	{
		myprintf("Sorry, works only on exactly 1 dir\n");
		return 1;
	}
	if (!isdirectory(files[0]))
	{
		myprintf("Sorry, you must enter a directory\n");
		return 1;
	}
	if (flagverbose)
	summary=-1;
	else
	summary=1;
	flagchecksum=false;
	flagverify=true;
	if (!ischecksum())
		flagxxh3=true;
	flagkill=true;
	if (!flagforce)
		myprintf("-force not present: dry run\n");
	return summa();
}
struct tparametribenchmark
{
	int 		chunksize;		
	uint32_t* 	buffer32bit;
	int			timelimit;
	string		runningalgo;
	int			tnumber;
	string		risultato;
	double		speed;
};
string do_benchmark(int i_tnumber,int i_timelimit,string i_runningalgo,int i_chunksize,uint32_t* buffer32bit,double& o_speed)
{
	int64_t lavorati=0;
	uint64_t starttutto=mtime();	
	uint64_t totalrandtime=0;
	uint64_t totalhashtime=0;
	int	ultimotrascorso=0;	
	int	buffersize=i_chunksize*4-7;
	int i=0;
	while (1)
	{
		uint64_t startrandom=mtime();
		populateRandom_xorshift128plus(buffer32bit, i_chunksize,324+i,4444+i);
		uint64_t randtime=mtime()-startrandom;
		if (i_runningalgo=="XXH3")
		{
			XXH3_state_t state128;
			(void)XXH3_128bits_reset(&state128);
			(void)XXH3_128bits_update(&state128, buffer32bit, buffersize);
		}
		else
		if (i_runningalgo=="SHA-1")
		{
			libzpaq::SHA1 sha1;
			sha1.write((const char*)buffer32bit,buffersize);
		}
		else
		if (i_runningalgo=="SHA-256")
		{
			franzSHA256 mysha256;
			mysha256.update((const uint8_t*)buffer32bit,buffersize);
		}
		else
		if (i_runningalgo=="WYHASH")
		{
			uint64_t _wyp[4];
			make_secret(0,_wyp);
			wyhash((const char*)buffer32bit,buffersize,0,_wyp);
		}
		else
		if (i_runningalgo=="MD5")
		{
			MD5 md5;
    		md5.add((const char*)buffer32bit,buffersize);
		}
		else
		if (i_runningalgo=="SHA-3")
		{
			SHA3 sha3;
    		sha3.add((const char*)buffer32bit,buffersize);
		}
		else
		if (i_runningalgo=="WHIRLPOOL")
		{
				NESSIEstruct hasher;
				NESSIEinit(&hasher);
				NESSIEadd((const unsigned char*)buffer32bit,buffersize*8,&hasher);
		}
		else
		if (i_runningalgo=="BLAKE3")
		{
			blake3_hasher hasher;
			blake3_hasher_init(&hasher);
			blake3_hasher_update(&hasher, (const char*)buffer32bit,buffersize);
		}
		else
		if (i_runningalgo=="CRC-32")
		{
			uint32_t crc=0;
			crc=crc32_16bytes ((const char*)buffer32bit,buffersize, crc);
		}
		else
		if (i_runningalgo=="CRC-32C")
		{
			uint32_t crc=0;
			crc = crc32c(crc, (const unsigned char*)buffer32bit,buffersize);
		}
		else
		if (i_runningalgo=="XXHASH64")
		{
			uint64_t myseed = 0;
			XXHash64 myhash(myseed);
			myhash.add((const unsigned char*)buffer32bit,buffersize);
		}
		totalhashtime=mtime()-starttutto-randtime;
		if (totalhashtime<=0)
			totalhashtime=1;
		lavorati+= (i_chunksize*4);
		totalrandtime	+=randtime;
		double hashingtime=totalhashtime/1000.0;
		o_speed=lavorati/hashingtime;
		int trascorso=(int)((mtime()-starttutto+1)/1000.0);
		if (trascorso!=ultimotrascorso)
		{
			if (i_tnumber<0) 
			{
				myprintf("%03d s %12s: speed (%11s/s) ",trascorso,i_runningalgo.c_str(),
				tohuman3((uint64_t)o_speed));
				if (flagverbose)
					myprintf("\n");
				else
					myprintf("\r");
			}
			else
			{
				pthread_mutex_lock(&g_mylock);
				if (!flagsilent)
				{
					setupConsole();
					printf("\033[%d;0H",(int)i_tnumber+1);
					restoreConsole();
				}
				myprintf("Thread %02d %03d s %12s: speed (%11s/s)",i_tnumber,trascorso,i_runningalgo.c_str(),tohuman3((uint64_t)o_speed));
				pthread_mutex_unlock(&g_mylock);	
			}
			ultimotrascorso=trascorso;
		}
		if ((int)((mtime()-starttutto)/1000)>=i_timelimit)
			break;
		i++;
	}
	double hashingtime=totalhashtime/1000.0;
	o_speed=lavorati/hashingtime;
	lavorati+=mtime()-starttutto;
	int trascorso=(int)((mtime()-starttutto+1)/1000.0);
	myprintf("%08d s %12s: speed (%11s/s) ",trascorso,i_runningalgo.c_str(),tohuman3((uint64_t)o_speed));
	myprintf("\n");
	char buf[100];
	sprintf(buf,"%12s: %11s/s (done %11s)",i_runningalgo.c_str(),tohuman((uint64_t)o_speed),tohuman2((uint64_t)lavorati));
	string risultato=buf;
	return risultato;
}
void * benchmark_thread(void *t) 
{
	assert(t);
	tparametribenchmark* par= ((struct tparametribenchmark*)(t));
	par->risultato=do_benchmark(par->tnumber,par->timelimit,par->runningalgo,par->chunksize,par->buffer32bit,par->speed);
	pthread_exit(NULL);
	return 0;
}
struct s_benchmark
{
    string	algoritmo;
	double	speed;
	string 	risultati;
};
bool compare_s_benchmark(const s_benchmark &a, const s_benchmark &b)
{
    return a.speed < b.speed;
}
string filecopy(bool i_singlefile,bool i_append,string i_infile,string i_outfile,bool i_verify,bool i_donotcheckspace,bool i_overwrite)
{
	if ((i_infile)=="")
		return "";
	if ((i_outfile)=="")
		return "";
	string nowarn;
	if (i_append)
		nowarn="NO-WARN";
	string percorso=i_outfile;
	if (i_singlefile)
		percorso=extractfilepath(i_outfile);
	if (!isdirectory(percorso))
		percorso+="/";
	if (!direxists(percorso))
		makepath(percorso);
	int64_t dimensionedacopiare	=prendidimensionefile(i_infile.c_str());
	if (!i_donotcheckspace)
	{
		int64_t spaziolibero	=getfreespace(percorso);
		if (spaziolibero<dimensionedacopiare)
		{
			myprintf("34878: impossible to make a copy of %s insufficient free space %s on <<%s>>\n",migliaia(dimensionedacopiare),migliaia2(spaziolibero),percorso.c_str());
			return "";
		}
	}
	string solofile=extractfilename(i_infile);
	string filedefinitivo=percorso+solofile;
	if (i_singlefile)
			filedefinitivo=i_outfile;
	if (!i_overwrite)
	{
		if (flagdebug)
			myprintf("Pre not overwrite %s\n",filedefinitivo.c_str());
		filedefinitivo=nomefileseesistegia(filedefinitivo);
		if (flagdebug)
			myprintf("Post not overwrite %s\n",filedefinitivo.c_str());
	}
	if (flagdebug)
		myprintf("ready to make a copy in %s\n",filedefinitivo.c_str());
	int64_t	lunghezzadefinitivo=0;
	FILE* outFile=NULL;	
	if (lunghezzadefinitivo>0)
	outFile=fopen(filedefinitivo.c_str(), "ab");
	else
	outFile=fopen(filedefinitivo.c_str(), "wb");
	if (outFile==NULL)
	{
		myprintf("32827 :CANNOT OPEN outfile %s\n",filedefinitivo.c_str());
		return "";
	}
	size_t const blockSize = 65536;
	unsigned char buffer[blockSize];
	int64_t donesize=0;
	XXH3_state_t state128;
    (void)XXH3_128bits_reset(&state128);
	if (i_verify)
		if (flagverbose)
			myprintf("verify: trust, but check...\n");
	FILE* inFile = freadopen(i_infile.c_str());
	if (inFile==NULL) 
	{
	int err=1;
	myprintf("\32849: ERR <%s> kind %d\n",i_infile.c_str(),err); 
	if (outFile!=NULL)
		fclose(outFile);
	return "";
	}
	size_t readSize;
	int64_t	chunk_readed=0;
	int64_t	chunk_written=0;
	int64_t startcopy=mtime();
	bool	hostampato=false;
	while ((readSize = fread(buffer, 1, blockSize, inFile)) > 0) 
	{
		int64_t written=fwrite(buffer,1,readSize,outFile);
		chunk_written+=written;
		chunk_readed+=readSize;
		donesize+=written;
		if (lunghezzadefinitivo==0) 
			if (flagverify)
				(void)XXH3_128bits_update(&state128, buffer, readSize);
		if (!flagnoeta)
			hostampato |= myavanzamentoby1sec(donesize,dimensionedacopiare,startcopy,false);
	}
	if (hostampato)
		myprintf("                                                                         \r");
	fclose(inFile);
	fclose(outFile);
	if (flagdebug)
	{
		myprintf("Done\n");
		myprintf("Written  %20s\n",migliaia(donesize));
		myprintf("Expected %20s\n\n",migliaia(dimensionedacopiare));
	}
	if (donesize!=dimensionedacopiare)
	{
		myprintf("32876: GURU bytes written does not match expected\n");
		return "";
	}
	if (flagverify)
	{
		if (!flagnoeta)
		{
			printbar('=');
			myprintf("Checking ...\n");
		}
		XXH128_hash_t myhash=XXH3_128bits_digest(&state128);
		char risultato[33];
		sprintf(risultato,"%016llX%016llX",(unsigned long long)myhash.high64,(unsigned long long)myhash.low64);
		uint32_t dummycrc32;
		int64_t startverify=mtime();
		int64_t io_lavorati=0;
		string hashreloaded=xxhash_calc_file(filedefinitivo.c_str(),false,dummycrc32,startverify,dimensionedacopiare,io_lavorati);
		if (flagdebug)
		{
			myprintf("Expected   XXH3 hash of the output file %s\n",risultato);
			myprintf("Calculated XXH3 hash of the output file %s\n",hashreloaded.c_str());
		}
		if (hashreloaded!=risultato)
		{
			myprintf("29658: GURU hash of output file does not match!\n");
			return "";
		}
	}
	return filedefinitivo;
}
int Jidac::trim()
{
	if (files.size()!=1)
	{
		myprintf("33679: TRIM works with ONLY one single .zpaq file (no multipart)\n");
		return 2;
	}
	if (tofiles.size()>1)
	{
		myprintf("33856: TROM -to with only ONE output, please\n");
		return 2;
	}
	archive=files[0];  
	if (!iszpaq(archive))
			archive+=".zpaq";
	myprintf("TRIMMING on %s\n",archive.c_str());
	int64_t archivesize=prendidimensionefile(archive.c_str());
	getpasswordifempty();
	int errors=0;
	string arcname=archive;  
	if (index) 
		arcname=index;
	int64_t header_pos=0;
	if (exists(subpart(arcname, 1).c_str()))
		header_pos=read_archive(arcname.c_str(), &errors);
	arcname=archive;  
	int64_t offset=0;  
	char salt[32]={0};  
	if (password) 
		libzpaq::random(salt, 32);
	if (index) 
		error("33709: cannot trim with an index");
    string part0=subpart(archive, 0);
    if (part0!=archive) 
	{  
		myprintf("34084: so sorry, this seems a multipart archive, abort\n");
		return 2;
    }
    if (password) {
      FP fp=fopen(subpart(archive, 1).c_str(), RB);
      if (fp==FPNULL) {
        if (header_pos>32) error("archive first part not found");
        header_pos=32;
      }
      else {
        if (fread(salt, 1, 32, fp)!=32) error("cannot read salt");
        fclose(fp);
      }
    }
	if (!exists(arcname))
	{
		myprintf("33763: archive does not seems to exists ");
		printUTF8(arcname.c_str());
		myprintf("\n");
		return 2;
	}
	if (header_pos+offset>archivesize)
	{
		myprintf("33771: invalid offset %s vs filesize %s\n",migliaia(header_pos+offset),migliaia2(archivesize));
		return 2;
	}
	if (header_pos+offset==archivesize)
	{
		myprintf("33779: TRIM seems not necessary on size %s\n",migliaia(header_pos+offset));
		return 1;
	}
	if (tofiles.size()==1)
	{
		string	trimmeddestination=tofiles[0];
		if (isdirectory(trimmeddestination))
		{
			myprintf("33962: error -to is a folder, must be a file\n");
			return 2;
		}
		if (!iszpaq(trimmeddestination))
			trimmeddestination+=".zpaq";
		if (!flagforce)
			if (!saggiascrivibilitacartella(trimmeddestination))
			{
				myprintf("33700: sorry -to folder seems not writeable. Use -force to bypass\n");
				return 2;
			}
		int64_t spaziolibero=0;
		spaziolibero=getfreespace(trimmeddestination);
		if (spaziolibero<archivesize)
		{
			myprintf("\n");
			printbar('*');
			myprintf("WARNING FREE SPACE SEEMS %s NEEDED %s\n",migliaia(spaziolibero),migliaia2(archivesize));
			printbar('*');
		}
		myprintf("DOING COPY (before trimming)\n");
		string risultato;
		risultato=filecopy(
		true, 
		false, 
		archive,trimmeddestination,
		flagverify, 
		true,  
		false 
		); 
		if (risultato=="")
		{
			myprintf("33729: ERROR: %s\n",risultato.c_str());
			return 2;
		}
		arcname=risultato;
	}
	myprintf("Trim ");
	printUTF8(arcname.c_str());
	myprintf(" at offset %s + %s\n", migliaia(header_pos), migliaia2(offset));
	if ((tofiles.size()==0) && (!flagkill))
	{
		myprintf("33783: dry run without -to: -kill to execute in-place\n");
		return 1;
	}
	if (truncate(arcname.c_str(),header_pos+offset))
	{
		myprintf("33772: something wrong in trimming\n");
		return 2;
	}
	int64_t nuovadim=prendidimensionefile(arcname.c_str());
	if (nuovadim==(header_pos+offset))
	{
		myprintf("34019: DONE on ");
		printUTF8(arcname.c_str());
		myprintf(" (%s)\n",migliaia(nuovadim));
	}
	return 0;
}
int Jidac::purgersync()
{
	myprintf("PURGING RSYNC TEMPORARY FILES ");
	if (!flagkill)
			myprintf(" : DRY RUN (no -kill)");
	myprintf("\n");
	if (files.size()==0)
	{
		myprintf("No folder selected\n");
		return 1;
	}
	DTMap	myedt;
	for (unsigned int i=0;i<files.size();i++)
	{
		myprintf("SCAN FOLDER %02d ",i);
		printUTF8(files[i].c_str());
		myprintf("\n");
		scandir(false,myedt,files[i].c_str(),true);
	}
	myprintf("Files to be checked %s\n",migliaia(myedt.size()));
	int	erased=0;
	int tobeerased=0;
	for (DTMap::iterator p=myedt.begin(); p!=myedt.end(); ++p) 
	{
		string	filename=p->first;
		myreplaceall(filename,"\\","/");
		string percorso=extractfilepath(filename);
		filename=extractfilename(filename);
		int		lunghezza=filename.length();
		if (lunghezza>10)
		{
			if (filename[0]=='.')
				if (filename[lunghezza-7]=='.')
				{
					string estensionefinale=myright(filename,6);
					bool	spazzatura=true;
					for (unsigned int i=0;i<estensionefinale.length();i++)
					{
						if ((!isdigit(estensionefinale[i])) && (!isalpha(estensionefinale[i])))
						{
							spazzatura=false;
							break;
						}
					}
					if (spazzatura)
					{
						string senzaestensione=myleft(filename,filename.length()-7);
						string estensione=prendiestensione(senzaestensione);
						if ((estensione.length()>0) && (estensione.length()<=4))
						{
							string filetobepurged=percorso+filename;
							myprintf("rm ");
							myprintf("\"");
							printUTF8(filetobepurged.c_str());
							myprintf("\"");
							myprintf("\n");
							tobeerased++;
							if (flagkill)
							{
								myprintf("Deleting...\n");
								if (delete_file(filetobepurged.c_str()))
										erased++;
							}
						}
					}
				}
		}
	}
	if (flagkill)
	{
		myprintf("Erased  %08d / %08d\n",erased,tobeerased);
		if (tobeerased==erased)
			return 0;
		else
			return 1;
	}	
	if (tobeerased>0)
		return 0;
	else
		return 2;
}
bool isfilesequal(string i_source,string i_destination,bool i_flagfast=false)
{
	if (i_source=="")
		return false;
	if (i_destination=="")
		return false;
	if ((isdirectory(i_source)) && (isdirectory(i_destination)))
		return true;
	if (!((   (!isdirectory(i_source)) && (!isdirectory(i_destination)) )))
		return false;
	if (!fileexists(i_source))
		return false;
	if (!fileexists(i_destination))
		return false;
	FILE* source_file = freadopen(i_source.c_str());
	if (source_file==NULL) 
	{
		int err=1;
		myprintf("\n27547 ERR <%s> kind %d\n",i_source.c_str(),err); 
		return false;
	}
	fseeko(source_file, 0, SEEK_END);
	int64_t sorgente_dimensione=ftello(source_file);
	fseeko(source_file, 0, SEEK_SET);
	FILE* destination_file = freadopen(i_destination.c_str());
	if (destination_file==NULL) 
	{
		int err=1;
		myprintf("\n27555 ERR <%s> kind %d\n",i_destination.c_str(),err); 
		fclose(source_file);
		return false;
	}
	fseeko(destination_file, 0, SEEK_END);
	int64_t destinazione_dimensione=ftello(destination_file);
	fseeko(destination_file, 0, SEEK_SET);
	if (i_flagfast)
	{
		if (sorgente_dimensione<destinazione_dimensione)
		{
			if (flagdebug)
					myprintf("32805: sorgente < destinazione\n");
			fclose(source_file);
			fclose(destination_file);
			return false;
		}
	}
	else
	{
		if (sorgente_dimensione!=destinazione_dimensione)
		{
			fclose(source_file);
			fclose(destination_file);
			return false;
		}
	}
	size_t const blockSize 			= 65536;
	unsigned char buffersource		[blockSize];
	unsigned char bufferdestination	[blockSize];
	size_t readsource;
	size_t readdestination;
	if ((uint64_t)sorgente_dimensione<blockSize*4)
		i_flagfast=false;
	if (i_flagfast)
	{
			if (flagdebug)
				myprintf("Do a fast check!\n");
			readsource 		= 	fread(buffersource, 		1, blockSize, source_file);
			readdestination	=	fread(bufferdestination, 	1, blockSize, destination_file);
			if (readsource!=readdestination)
			{
				if (flagdebug)
					myprintf("32823: head read source != read dest %s %s\n",migliaia(readsource),migliaia2(readdestination));
				fclose(source_file);
				fclose(destination_file);
				return false;
			}
			if (memcmp(buffersource, bufferdestination, readsource))
			{
				if (flagdebug)
					myprintf("32831: head failed mem compare\n");
				fclose(source_file);
				fclose(destination_file);
				return false;
			}
			fseeko(source_file, 		blockSize/2, SEEK_SET);
			fseeko(destination_file, 	blockSize/2, SEEK_SET);
			readsource 		= 	fread(buffersource, 		1, blockSize, source_file);
			readdestination	=	fread(bufferdestination, 	1, blockSize, destination_file);
			if (readsource!=readdestination)
			{
				if (flagdebug)
					myprintf("32844: body read source != read dest %s %s\n",migliaia(readsource),migliaia2(readdestination));
				fclose(source_file);
				fclose(destination_file);
				return false;
			}
			if (memcmp(buffersource, bufferdestination, readsource))
			{
				if (flagdebug)
					myprintf("32851: body failed mem compare\n");
				fclose(source_file);
				fclose(destination_file);
				return false;
			}
			fseeko(source_file, 		destinazione_dimensione-blockSize, SEEK_SET);
			fseeko(destination_file, 	destinazione_dimensione-blockSize, SEEK_SET);
			readsource 		= 	fread(buffersource, 		1, blockSize, source_file);
			readdestination	=	fread(bufferdestination, 	1, blockSize, destination_file);
			if (readsource!=readdestination)
			{
				if (flagdebug)
					myprintf("32867: tail read source != read dest %s %s\n",migliaia(readsource),migliaia2(readdestination));
				fclose(source_file);
				fclose(destination_file);
				return false;
			}
			if (memcmp(buffersource, bufferdestination, readsource))
			{
				if (flagdebug)
					myprintf("32874: tail failed mem compare\n");
				fclose(source_file);
				fclose(destination_file);
				return false;
			}
	}
	else
	{
		while ((readsource = fread(buffersource, 1, blockSize, source_file)) > 0) 
		{
			readdestination=fread(bufferdestination, 1, blockSize, destination_file);
			if (readsource!=readdestination)
			{
				fclose(source_file);
				fclose(destination_file);
				return false;
			}
			if (memcmp(buffersource, bufferdestination, readsource))
			{
				fclose(source_file);
				fclose(destination_file);
				return false;
			}
		}
	}
	fclose(source_file);
	fclose(destination_file);
	if (flagdebug)
			if (i_flagfast)
					myprintf("32929: fast files ==\n");
	return true;
}
int Jidac::mycopy()
{
	myprintf("Your friendly neighborhood cp/copy ");
	if (flagverify)
		myprintf(" without a trusting attitude (-verify) ");
	if (flagparanoid)
		myprintf(" no overwrite (-paranoid) ");
	myprintf("\n");
	if (files.size()==0)
	{
		myprintf("33433: No source files\n");
		return 2;
	}
	if (tofiles.size()!=1)
	{
		myprintf("33438: exactly one -to required\n");
		return 2;
	}
	string	todirectory=tofiles[0];
	if (!isdirectory(todirectory))
			todirectory+='/';
	if (!flagforce)
		if (!saggiascrivibilitacartella(todirectory))
		{
			myprintf("33493: sorry -to directory seems not writeable. Use -force to bypass\n");
			return 2;
		}
	vector<string> 	sourcelist;
	vector<int64_t> sourcesize;
	int64_t			totalsourcesize=0;
	for (unsigned int i=0;i<files.size();i++)
	{
		scandir(false,edt,files[i].c_str(),false);
		for (DTMap::iterator p=edt.begin(); p!=edt.end(); ++p) 
		{
			if (!isdirectory(p->first))
			{
				sourcelist.push_back(p->first);
				sourcesize.push_back(p->second.size);
				totalsourcesize+=p->second.size;
			}
		}
	}
	if (sourcelist.size()==0)
	{
		myprintf("33461: cannot build source file list\n");
		return 2;
	}
	int64_t spaziolibero=0;
	spaziolibero=getfreespace(todirectory);
	if (spaziolibero<totalsourcesize)
	{
		myprintf("\n");
		printbar('*');
		myprintf("WARNING FREE SPACE %s NEEDED %s\n",migliaia(spaziolibero),migliaia2(totalsourcesize));
		printbar('*');
		if (!flagspace)
		{
			myprintf("34794: quit because not enough space; -space to bypass\n");
			return 2;
		}
	}
	myprintf("         Space needed             Space free\n");
	bool		allok=true;
	int64_t		totalwritten=0;
	int			fileswritten=0;
	for (unsigned int i=0;i<sourcelist.size();i++)
	{
		string 	filesource	=sourcelist[i];
		int64_t	filesize	=sourcesize[i];
		spaziolibero=getfreespace(todirectory);
		myprintf("%21s  %21s  %s\n",migliaia(filesize),migliaia2(spaziolibero),filesource.c_str());
		string risultato;
		risultato=filecopy(
		false, 
		flagappend, 
		filesource,todirectory,
		flagverify, 
		true,  
		!flagparanoid); 
		if (risultato=="")
		{
			myprintf("ERROR: %s\n",risultato.c_str());
			allok=false;
		}
		else
		{
			totalwritten+=prendidimensionefile(risultato.c_str());
			fileswritten++;
		}
	}
	myprintf("---------------------\n");
	myprintf("%21s   bytes written\n",migliaia(totalwritten));
	myprintf("%21s   bytes expected\n",migliaia(totalsourcesize));
	myprintf("%21s   files OK\n",migliaia(fileswritten));
	myprintf("%21s   files expected\n",migliaia(sourcelist.size()));
	if (totalwritten!=totalsourcesize)
	{
		myprintf("33497: Written %s != expected %s\n",migliaia(totalwritten),migliaia2(totalsourcesize));
		allok=false;
	}
	if (allok)
		return 0;
	else	
		return	2;
}
int64_t internal_getramdisksize()
{
	if (flagdebug)
		myprintf("Hello FreeBSD\n");
	int pagesize	=0;
	int inactive	=0;
	int free		=0;
	size_t size 	= sizeof free;
	sysctlbyname("vm.stats.vm.v_free_count", &free, &size, NULL, 0);
	sysctlbyname("vm.stats.vm.v_inactive_count", &inactive, &size, NULL, 0);
	size = sizeof pagesize;
	sysctlbyname("vm.stats.vm.v_page_size", &pagesize, &size, NULL, 0);
	return (free+inactive)*pagesize;
}
int64_t getramdisksize()
{
	return internal_getramdisksize(); 
}
int contabit(unsigned int u)
{
	unsigned int uCount;
	uCount=u-((u >> 1) & 033333333333)-((u >> 2) & 011111111111);
	return ((uCount + (uCount >> 3)) & 030707070707) % 63;
}
int bittino(int i)
{
	i=~i;
	return contabit((i&(-i))-1);
}
string windows_get_free_letter()
{
	return "";
}
int Jidac::benchmark()
{
	int64_t myram=getramdisksize();
	myprintf("RAM seems %s\n",migliaia(myram));
	vector<string> 	array_cpu;
	vector<float> 	array_single;
	vector<float> 	array_multi;
	array_cpu	.push_back("Atom N2800      (phy)  4");
	array_multi	.push_back(113);
	array_single.push_back(407);
	array_cpu	.push_back("Xeon E3 1245 V2 (vir)  4");
	array_multi	.push_back(819);
	array_single.push_back(2415);
	array_cpu	.push_back("i5-6200U        (phy)  2");
	array_multi	.push_back(352);
	array_single.push_back(1903);
	array_cpu	.push_back("Xeon E5 2620 V4 (phy)  8");
	array_multi	.push_back(1520);
	array_single.push_back(1848);
	array_cpu	.push_back("Xeon E5 2630 V4 (phy) 10");
	array_multi	.push_back(1596);
	array_single.push_back(1552);
	array_cpu	.push_back("Xeon D-1541     (vir)  8");
	array_multi	.push_back(1619);
	array_single.push_back(2031);
	array_cpu	.push_back("i5-3570         (phy)  4");
	array_multi	.push_back(852);
	array_single.push_back(2956);
	array_cpu	.push_back("i7-4790K        (phy)  4");
	array_multi	.push_back(1700);
	array_single.push_back(3265);
	array_cpu	.push_back("i7-8700K        (phy)  6");
	array_multi	.push_back(1836);
	array_single.push_back(3358);
	array_cpu	.push_back("i9-10900        (phy) 10");
	array_multi	.push_back(3049);
	array_single.push_back(3705);
	array_cpu	.push_back("AMD-5950X       (phy) 16");
	array_multi	.push_back(5843);
	array_single.push_back(4798);
	int			chunksize=100000;
	int			timelimit=5;
	if (all)
		timelimit=20;
	if (menoenne>0)
	{
		if (menoenne<1000)
			timelimit=menoenne;
		else
		{
			myprintf("Time limit (-n    -limit) must be <1000\n");
			return 1;
		}
	}
	if (minsize>0)
	{
		if (minsize<=2000000000)
			chunksize=minsize/4;
		else
		{
			myprintf("Chunk (-minsize) must be <= 2000000000 (2 billion)\n");
			return 1;
		}
	}
	uint32_t *buffer32bit = (uint32_t*)malloc(chunksize*sizeof(uint32_t));
	if (buffer32bit==0)
	{
		myprintf("21202: GURU cannot alloc the buffer32bit\n");
		return 1;
	}
	vector<string> thehashes;
	string hashes="";
	if (!ischecksum())
		hashes="XXHASH64;XXH3;SHA-1;SHA-256;BLAKE3;CRC-32;CRC-32C;WYHASH;WHIRLPOOL;MD5;SHA-3;NILSIMSA";
	else
	{
		if (flagxxhash64)
			hashes+="XXHASH64;";
		if (flagxxh3)
			hashes+="XXH3;";
		if (flagsha1)
			hashes+="SHA-1;";
		if (flagsha256)
			hashes+="SHA-256;";
		if (flagblake3)
			hashes+="BLAKE3;";
		if (flagcrc32)
			hashes+="CRC-32;";
		if (flagcrc32c)
			hashes+="CRC-32C;";
		if (flagwyhash)
			hashes+="WYHASH;";
		if (flagwhirlpool)
			hashes+="WHIRLPOOL;";
		if (flagmd5)
			hashes+="MD5;";
		if (flagnilsimsa)
			hashes+="NILSIMSA;";
		if (flagsha3)
			hashes+="SHA-3;";
	}
	explode(hashes,';',thehashes);
	if (thehashes.size()==0)
	{
		myprintf("27144: strange hash selection\n");
		free(buffer32bit);
		return 1;
	}
	if (all)
		if ((thehashes.size()!=1) && (thehashes.size()!=12))
		{
			myprintf("When benchmarking with -all (multithread), ONE algo or nothing (all)\n");
			free(buffer32bit);
			return 1;
		}
	vector<s_benchmark> 			vettorerisultati;     
	vector<tparametribenchmark> 	vettoreparametribenchmark; 
	myprintf("Benchmarks: ");
	for (unsigned int i=0;i<thehashes.size();i++)
		myprintf("%s ",thehashes[i].c_str());
	myprintf("\n");
	myprintf("Time limit %10d s  (-n X)\n",timelimit);
	myprintf("Chunks of  %12s  (-minsize Y)\n",tohuman(chunksize*4));
	myprintf("\n");
	double			franzomips=0;
	if (all)
	{
		int mythreads=howmanythreads;
		tparametribenchmark	myblock;
		for (int i=0;i<mythreads;i++)
		{
			myblock.tnumber=i;
			myblock.chunksize=chunksize;
			myblock.buffer32bit=buffer32bit;
			myblock.timelimit=timelimit;
			if (thehashes.size()==12)
				myblock.runningalgo="SHA-3";
			else
				myblock.runningalgo=thehashes[0];
			vettoreparametribenchmark.push_back(myblock);
		}	
		int rc;
		pthread_t* threads = new pthread_t[mythreads];
		pthread_attr_t attr;
		void *status;
		pthread_attr_init(&attr);
		pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_JOINABLE);
		if (!flagsilent)
		{
			setupConsole();
			printf("\033[2J"); 
			restoreConsole();
		}
		for(int i = 0; i < mythreads; i++ ) 
		{	
			rc 	= pthread_create(&threads[i], &attr, benchmark_thread, (void*)&vettoreparametribenchmark[i]);
			if (rc) 
			{
				myprintf("Error creating thread\n");
				exit(-1);
			}
		}
		pthread_attr_destroy(&attr);
		for(int i = 0; i <mythreads; i++ ) 
		{
			rc = pthread_join(threads[i], &status);
			if (rc) 
			{
				error("Unable to join\n");
				exit(-1);
			}
		}
		if (!flagsilent)
		{
			setupConsole();
			printf("\033[2J"); 
			printf("\033[%d;0H",(int)1);
			restoreConsole();
		}
		string 			risultato;
		s_benchmark		block;
		double total_speed=0;
		for (int i=0;i<mythreads;i++)
		{
			total_speed+=vettoreparametribenchmark[i].speed;
			franzomips+=vettoreparametribenchmark[i].speed;
		}
		myprintf("Total speed %s /s\n",tohuman((uint64_t)total_speed));
		if (thehashes.size()==12)
		{
			franzomips/=1000000;
			for (unsigned int i=0;i<array_cpu.size();i++)
				array_multi[i]=franzomips/array_multi[i]*100.0;
		}
		delete [] threads;
	}
	else
	{
		string 			risultato;
		double			speed;
		s_benchmark		block;
		for (unsigned int i=0;i<thehashes.size();i++)
		{
			risultato=do_benchmark(-1,timelimit,thehashes[i],chunksize,buffer32bit,speed);
			block.algoritmo=thehashes[i];
			block.speed=speed;
			block.risultati=risultato;
			vettorerisultati.push_back(block);
			if (thehashes[i]!="BLAKE3") 
				franzomips+=speed;
		}
		if (thehashes.size()==12)
		{
			franzomips/=thehashes.size()-1;
			franzomips/=1000000;
			for (unsigned int i=0;i<array_cpu.size();i++)
				array_single[i]=franzomips/array_single[i]*100.0;
		}
		std::sort(vettorerisultati.begin(), vettorerisultati.end(), compare_s_benchmark);
		myprintf("\nResults:\n\n");
		for (unsigned int i=0;i<vettorerisultati.size();i++)
			myprintf("%s\n",vettorerisultati[i].risultati.c_str());
	}
	free(buffer32bit);
	if (thehashes.size()==12)
	{			
		if (all)
			myprintf("\nfranzomips multi thread index %s ",migliaia((uint64_t)(franzomips*7.0)));
		else
			myprintf("\nfranzomips single thread index %s ",migliaia((uint64_t)franzomips));
		myprintf("(quick CPU check, raw %s)\n",migliaia((uint64_t)franzomips));
		for (unsigned int i=0;i<array_cpu.size();i++)
			if (all)
				myprintf("%s %10.2f %%\n",array_cpu[i].c_str(),array_multi[i]);
			else
				myprintf("%s %10.2f %%\n",array_cpu[i].c_str(),array_single[i]);			
	}
	return 0;
}
int Jidac::summa() 
{
#ifdef ESX
	return 0;
#else
	if (!flagpakka)
	{
		myprintf("Getting %s",mygetalgo().c_str());
		if (flagmm)
			myprintf(" WITH MEMORY MAPPED FILES ");
		if (!flagforcezfs)
			myprintf(" ignoring .zfs and :$DATA\n");
	}
	if (flagkill)
		if (flagforce)
			if (!getcaptcha("iamsure","Delete files without confirmation"))
				return 1;
	int quantifiles					=0;
	int64_t total_size				=0;  
	unsigned int duplicated_files	=0;
	uint64_t duplicated_size		=0;
	uint64_t scannedsize			=0;
	vector<string> myfiles;
	flagskipzfs					=true;  
	int64_t startscan=mtime();
	g_bytescanned=0;
	g_filescanned=0;
	g_dimensione=0;
	g_worked=0;
	vector<string> mydirs;
	if (flagchecksum)
	{
		myprintf("Getting cumulative 1-level SHA256\n");
		if (files.size()!=1)
		{
			myprintf("Error: with -checksum exactly one directory can be searched\n");
			return 1;
		}
		uint64_t startscan=0;			
		scandir(false,edt,files[0].c_str(),false);
		for (DTMap::iterator p=edt.begin(); p!=edt.end(); ++p) 
			if (p->first != files[0])
			{
			if (isdirectory(p->first))
				mydirs.push_back(p->first);
			else
				myfiles.push_back(p->first);
			}
		uint64_t scantime=mtime()-startscan;
		if (myfiles.size()+mydirs.size()==0)
		{
			myprintf("Nothing to do\n");
			return 0;
		}
		libzpaq::SHA256 sha256;
		libzpaq::SHA256 globalesha256;
		std::vector<std::pair<string, string>> vec;
		uint64_t hashtime=0;
		uint64_t printtime=0;
		uint64_t total_size=0;
		for (unsigned int i=0;i<mydirs.size();i++)
		{
			if (!flagnoeta)
				myprintf("Scanning %s\r",mydirs[i].c_str());
			edt.clear();
			startscan=mtime();
			scandir(true,edt,mydirs[i].c_str(),true);
			scantime+=mtime()-startscan;
			vec.clear();
			for (DTMap::iterator p=edt.begin(); p!=edt.end(); ++p) 
				if (!isdirectory(p->first))
				{
					startscan=mtime();
					uint32_t dummycrc;
					vec.push_back(make_pair("dummy",hash_calc_file(flag2algo(),p->first.c_str(),false,dummycrc,-1,-1,g_dimensione)));
					total_size+=p->second.size;
					hashtime+=mtime()-startscan;
				}
			std::sort(vec.begin(), vec.end(),sortbyval);
			for (unsigned int j=0;j<vec.size();j++)
				for (const char* p=vec[j].second.c_str(); *p; ++p) 
				{
					sha256.put(*p);
					globalesha256.put(*p);
				}
			scantime=mtime();
			char sha256result[32];
			memcpy(sha256result, sha256.result(), 32);
			myprintf("MAGIC_%s: ",mygetalgo().c_str());
			for (int j=0; j <= 31; j++)
				myprintf("%02X", (unsigned char)sha256result[j]);
			myprintf(" ");
			string directorypurgata=mydirs[i];
			myreplace(directorypurgata,files[0],"");
			printUTF8(directorypurgata.c_str());
			myprintf("\n");
			printtime+=mtime()-scantime;
		}
		vec.clear();
		startscan=mtime();
		uint32_t dummycrc;
		for (unsigned int i=0;i<myfiles.size();i++)
			vec.push_back(make_pair("dummy",hash_calc_file(flag2algo(),myfiles[i].c_str(),false,dummycrc,-1,-1,g_dimensione)));
		hashtime+=mtime()-startscan;
		std::sort(vec.begin(), vec.end(),sortbyval);
		for (unsigned int j=0;j<vec.size();j++)
			for (const char* p=vec[j].second.c_str(); *p; ++p) 
					globalesha256.put(*p);
		scantime=mtime();
		char sha256result[32];
		memcpy(sha256result, globalesha256.result(), 32);
		myprintf("\nGLOBAL_MAGIC_%s: ",mygetalgo().c_str());
		for (int j=0; j <= 31; j++)
			myprintf("%02X:", (unsigned char)sha256result[j]);
		myprintf("\n");
		printtime+=mtime()-scantime;
		if (!flagnoeta)
			{
				myprintf("Algo %s\n",mygetalgo().c_str());
				myprintf("Scanning filesystem time  %f s\n",scantime/1000.0);
				myprintf("Data transfer+CPU   time  %f s\n",hashtime/1000.0);
				myprintf("Data output         time  %f s\n",printtime/1000.0);
				myprintf("Total size  %19s (%10s)\n",migliaia(total_size),tohuman(total_size));
				int64_t myspeed=(int64_t)(total_size*1000.0/(hashtime));
				myprintf("Worked on %s bytes avg speed (hashtime) %s B/s\n",migliaia(total_size),migliaia2(myspeed));
			}
		return 0;
	}
	for (unsigned i=0; i<files.size(); ++i)
		scandir(true,edt,files[i].c_str());
	if (flagverify)
	{
		myprintf("\n*** Searching for duplicates with %s minsize %s ***\n",mygetalgo().c_str(),migliaia(minsize));
		std::vector<std::pair<uint64_t,string>> filestobepurged;
		for (DTMap::iterator p=edt.begin(); p!=edt.end(); ++p) 
			if (p->second.date && p->first!="" && (!isdirectory(p->first)) && (!isads(p->first)) ) 
			{
				if (minsize>0)
				{
					if ((uint64_t)p->second.size>minsize)
					{
						filestobepurged.push_back(make_pair(p->second.size,p->first));
						scannedsize+=p->second.size;
					}
				}
				else
				{
					filestobepurged.push_back(make_pair(p->second.size,p->first));
					scannedsize+=p->second.size;
				}
			}
		std::sort(filestobepurged.begin(), filestobepurged.end(),sortbysize);
		myfiles.clear();
		unsigned int i=0;
		while (i<filestobepurged.size())
		{
			int j=i;
			if (filestobepurged[j].first==filestobepurged[j+1].first)
			{
				myfiles.push_back(filestobepurged[j].second);
				total_size+=filestobepurged[j].first;
				quantifiles++;
			}
			while (filestobepurged[j].first==filestobepurged[j+1].first)
			{
				myfiles.push_back(filestobepurged[j+1].second);
				total_size+=filestobepurged[j+1].first;
				quantifiles++;
				j++;
			}
			j++;
			i=j;
		}
	}
	else
	{
		for (DTMap::iterator p=edt.begin(); p!=edt.end(); ++p) 
			if (p->second.date && p->first!="" && (!isdirectory(p->first)) && (!isads(p->first)) ) 
			{
				if (minsize>0)
				{
					if ((uint64_t)p->second.size>minsize)
					{
						myfiles.push_back(p->first);
						total_size+=p->second.size;
						quantifiles++;
					}
				}
				else
				{
					myfiles.push_back(p->first);
					total_size+=p->second.size;
					quantifiles++;
				}
			}
		scannedsize=total_size;
	}	
	if (myfiles.size()==0)
	{
		myprintf("Nothing to do\n");
		return 0;
	}
	vector<string> myhash;
	vector<tparametrihash> 	vettoreparametrihash;
	int mythreads=howmanythreads;
	if (!flagssd)
		mythreads=1;
	tparametrihash 	myblock;
	for (int i=0;i<mythreads;i++)
	{
		myblock.tnumber=(i%mythreads);
		myblock.inizio=mtime();
		myblock.dimensione=total_size;
		myblock.timestart=0;
		myblock.timeend=0;
		vettoreparametrihash.push_back(myblock);
	}
	printbar(' ');
	int64_t inizio		=mtime();
	double scantime=(inizio-startscan)/1000.0;
	if (!flagnoeta)
	myprintf("Found (%s) => %s bytes (%s) / %s files in %f\n",tohuman2(scannedsize),migliaia(total_size),tohuman(total_size),migliaia2(quantifiles),scantime);
	for (unsigned int i=0;i<myfiles.size();i++)
	{
		vettoreparametrihash[i%mythreads].filestobehashed.push_back(myfiles[i]);
		vettoreparametrihash[i%mythreads].algo.				push_back(mygetalgo().c_str());
	}
	int totfile=0;
	for (int i=0;i<mythreads;i++)
	{
		if (flagdebug)
			myprintf("Thread [%02d] files %s\n",i,migliaia(vettoreparametrihash[i].filestobehashed.size()));
		totfile+=+vettoreparametrihash[i].filestobehashed.size();
	}
	if (flagverbose)
	myprintf("Total files %s -> in threads %s\n",migliaia(myfiles.size()),migliaia2(totfile));
	int rc;
	pthread_t* threads = new pthread_t[mythreads];
	pthread_attr_t attr;
	void *status;
	pthread_attr_init(&attr);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_JOINABLE);
	if (!flagnoeta)
		myprintf("\nCreating %d hashing thread(s) with %s\n",mythreads,mygetalgo().c_str());
	uint64_t iniziohash=mtime();
	for(int i = 0; i < mythreads; i++ ) 
	{
		vettoreparametrihash[i].timestart=mtime();
		rc = pthread_create(&threads[i], &attr, scansionahash, (void*)&vettoreparametrihash[i]);
		if (rc) 
		{
			myprintf("Error creating thread\n");
			exit(-1);
		}
	}
	pthread_attr_destroy(&attr);
	for(int i = 0; i <mythreads; i++ ) 
	{
		rc = pthread_join(threads[i], &status);
		if (rc) 
		{
			error("Unable to join\n");
			exit(-1);
		}
	}
	uint64_t hashtime=mtime()-iniziohash+1;
	vector<std::pair<string, string>> vec;
	for(int i = 0; i <mythreads; i++ )
		for (unsigned int j=0;j<vettoreparametrihash[i].filestobehashed.size();j++)
			vec.push_back(make_pair(vettoreparametrihash[i].filestobehashed[j],vettoreparametrihash[i].o_hashcalculated[j]));
	if ((!flagnosort) || (flagverify))
	std::sort(vec.begin(), vec.end(),sortbyval);
	libzpaq::SHA256 sha256;
	int64_t startprint=mtime();
	uint64_t testedbytes=0;
	int64_t deletedfiles=0;
	int64_t deletedsize=0;
	vector<string> sortato;
	int	errori=0;
	for (unsigned int i=0;i<vec.size();i++)
	{
		string filename=vec[i].first;
		DTMap::iterator p=edt.find(filename);
		if (p != edt.end())
			testedbytes+=p->second.size;
		for (const char* p=vec[i].second.c_str(); *p; ++p) 
			sha256.put(*p);
		if (searchfrom!="")
			if (replaceto!="")
				replace(filename,searchfrom,replaceto);	
		if (flagkill)
		{
			if (i>0)
				if (vec[i-1].second==vec[i].second)
				{
					if (summary<0)
					{
						myprintf("=== \"");
						if (g_output_handle!=0)
							fprintf(g_output_handle,"    \"");
						printUTF8(filename.c_str());
						myprintf("\"\n");
					}
					duplicated_files++;
					if (p != edt.end())
						duplicated_size+=p->second.size;
					if (flagforce)
						if (delete_file(filename.c_str()))
						{
							deletedfiles++;
							if (p != edt.end())
								deletedsize+=p->second.size;
						}
				}
		}
		else
		{
			if (summary<0)
			{
				myprintf("%s: %s ",mygetalgo().c_str(),vec[i].second.c_str());
				if (p != edt.end())
				{
					myprintf("[%19s] ",migliaia(p->second.size));
				}
			}
			if (!flagnosort)
			{			
				if (i==0)
				{	
					if (summary<0)
						myprintf("    ");
				}	
				else
				{
					if (vec[i-1].second==vec[i].second)
					{
						if (summary<0)
						{
							myprintf("=== ");
							if (g_output_handle!=0)
								fprintf(g_output_handle,"    ");
						}
						duplicated_files++;
						if (p != edt.end())
							duplicated_size+=p->second.size;
					}
					else
					{
						if (summary<0)
							myprintf("    ");
					}
				}
			}
			if (summary<0)
			{
				printUTF8(filename.c_str());
				myprintf("\n");
			}
			if ((p->second.size)>0)
			{
				if (vec[i].second==emptyalgo(mygetalgo().c_str()))
				{
					myprintf("\n\n");
					myprintf("32609: **** GURU ERROR non zero-length file get empty hash!\n");
					myprintf("32609: **** A non-empty file have the same hash of empty one!\n");
					myprintf("\n\n");
					errori=2;
				}
			}
		}
	}
	int64_t printtime=mtime()-startprint;
	if (summary>0)
	{
		myprintf("Scanning filesystem time  %15.3f s\n",scantime);
		myprintf("Data transfer+CPU   time  %15.3f s\n",hashtime/1000.0);
		myprintf("Data output         time  %15.3f s\n",printtime/1000.0);
		myprintf("Total size                %19s (%10s)\n",migliaia(scannedsize),tohuman(scannedsize));
		myprintf("Tested size               %19s (%10s)\n",migliaia(testedbytes),tohuman(testedbytes));
		if (!flagnosort)
		{
		myprintf("Duplicated size           %19s (%10s)\n",migliaia(duplicated_size),tohuman(duplicated_size));
		myprintf("Duplicated files          %19s\n",migliaia(duplicated_files));
		}
		int64_t myspeed=(int64_t)(testedbytes*1000.0/(hashtime));
		myprintf("Worked on %s bytes avg speed (hashtime) %s B/s\n",migliaia(total_size),migliaia2(myspeed));
		char sha256result[32];
		memcpy(sha256result, sha256.result(), 32);
		myprintf("GLOBAL SHA256: ");
		for (int j=0; j <= 31; j++)
			myprintf("%02X", (unsigned char)sha256result[j]);
		myprintf("\n");
	}
	if (flagkill)
		if (flagforce)
			if (deletedfiles)
				myprintf("Duplicated deleted files %s for %s bytes\n",migliaia2(deletedfiles),migliaia(deletedsize));
	delete [] threads;
	return errori;
#endif
}
void my_handler(int s)
{
	if (s==2)
	{	
		if (!flagsilent)
		{
			setupConsole();
			printf("\033[?25h");
			fflush(stdout);
			restoreConsole();
		}
	}
	exit(1); 
}
int main(int argc, const char** argv) 
	{
	g_start=mtime();  		
	signal (SIGINT,my_handler); 
	struct hash_check dummycheck;
	dummycheck.algotype=ALGO_SHA1;
	g_mychecks.insert(std::pair<string, hash_check>("SHA-1",dummycheck));
	dummycheck.algotype=ALGO_SHA256;
	g_mychecks.insert(std::pair<string, hash_check>("SHA-256",dummycheck));
	dummycheck.algotype=ALGO_XXHASH64;
	g_mychecks.insert(std::pair<string, hash_check>("XXHASH64",dummycheck));
	dummycheck.algotype=ALGO_XXH3;
	g_mychecks.insert(std::pair<string, hash_check>("XXH3",dummycheck));
	dummycheck.algotype=ALGO_BLAKE3;
	g_mychecks.insert(std::pair<string, hash_check>("BLAKE3",dummycheck));
	dummycheck.algotype=ALGO_SHA3;
	g_mychecks.insert(std::pair<string, hash_check>("SHA-3",dummycheck));
	dummycheck.algotype=ALGO_MD5;
	g_mychecks.insert(std::pair<string, hash_check>("MD5",dummycheck));
	dummycheck.algotype=ALGO_NILSIMSA;
	g_mychecks.insert(std::pair<string, hash_check>("NILSIMSA",dummycheck));
	int errorcode=0;
	try 
	{
		Jidac jidac;
		errorcode=jidac.doCommand(argc, argv);
	}
	catch (std::exception& e) 
	{
		fflush(stdout);
		myprintf( "23013: zpaqfranz error: %s\n", e.what());
		errorcode=2;
	}
	fflush(stdout);
	if (g_fwritten!=g_fexpected)
	{
		myprintf("\n");
		printbar('*');
		myprintf("Something STRANGE happened. Archive seems corrupt. Media full?\n");
		myprintf("WRITTEN BYTES  %19s\n",migliaia(g_fwritten));
		myprintf("EXPECTED       %19s\n",migliaia(g_fexpected));
		printbar('*');
		errorcode=2;
	  }
#ifndef ESX	  
	if (command=='q')
	myprintf( "\n%1.3f seconds (%s)  on VSS operation\n", (mtime()-g_start)/1000.0,timetohuman((mtime()-g_start)/1000.0).c_str());
	else
	myprintf( "\n%1.3f seconds (%s)  %s\n", (mtime()-g_start)/1000.0,timetohuman((mtime()-g_start)/1000.0).c_str(),
      errorcode>1 ? "(with errors)" :
      errorcode>0 ? "(with warnings)" : "(all OK)");
#endif
	if (g_255)
		myprintf( "\nSeems %08d errors by path/filename too long (>255)\n", g_255);
	if (errorcode==2)
	{
		if (flagdebug)
				myprintf("33026: call xcommand on errorcode==2\n");
		xcommand(g_exec_error,g_exec_text);
	}
	else
	if (errorcode==1)
	{
		if (flagdebug)
			myprintf("33033: call xcommand on errorcode==1\n");
		xcommand(g_exec_warn,g_exec_text);
	}
	else
	{
		if (flagdebug)
			myprintf("33040: call xcommand with a different errorcode (not 1, not 2) %d\n",errorcode);
		if (g_archive!="")
		{
			g_exec_text=g_archive;
			if (flagdebug)
				myprintf("33047: g_archive not null, setting g_exec_text to %s\n",g_exec_text.c_str());
		}
		if (g_exec_ok!="")
			xcommand(g_exec_ok,g_exec_text);
	}	
	if (g_output_handle!=0)
		fclose(g_output_handle);
	return errorcode;
}
int Jidac::utf() 
{
#ifdef ESX
	myprintf("GURU: sorry: ESXi does not like this things\n");
	seppuku();
#else
	vector<string> sourcefile;     
	g_bytescanned=0;
	g_filescanned=0;
	g_worked=0;
	edt.clear();
	for (unsigned i=0; i<files.size(); ++i)
		scandir(true,edt,files[i].c_str());
	for (DTMap::iterator p=edt.begin(); p!=edt.end(); ++p) 
		if (!isdirectory(p->first))
			sourcefile.push_back(p->first);
	vector<string> strange;     
	myprintf("\nCheck directories %s\n",migliaia(sourcefile.size()));
	for (int unsigned i=0;i<sourcefile.size();i++)
	{
		string filename=extractfilepath(sourcefile[i]);
		string ansifilename=utf8toansi(filename);
		string ragione="";
		if (filename!=ansifilename)
			ragione+="CHAR |";
		if (dirlength>0)
			if (filename.length()>dirlength)
				ragione+="LEN "+myto_string(dirlength)+"-|";
		if (ragione!="")
			strange.push_back(padleft(ragione,15)+filename);
	}
	sort( strange.begin(), strange.end() );
	strange.erase( unique( strange.begin(), strange.end() ), strange.end() );
	if (!flagutf)
		for (int unsigned i=0;i<strange.size();i++)
		{
			myprintf("DIR:%08lu <<",(long unsigned int)strange[i].length());
			printUTF8(strange[i].c_str());
			myprintf(">>\n");
		}
	myprintf("DIR:Total %s\n",migliaia(strange.size()));
	strange.clear();
	myprintf("\nCheck files %s\n",migliaia(sourcefile.size()));
	for (unsigned int i=0;i<sourcefile.size();i++)
	{
		string filename=extractfilename(sourcefile[i]);
		string ansifilename=utf8toansi(filename);
		string ragione="";
		if (filename!=ansifilename)
			ragione+="CHAR |";
		if (filelength>0)
			if (filename.length()>filelength)
				ragione+="LEN "+myto_string(filelength)+"-|";
		if (ragione!="")
			strange.push_back(padleft(ragione,15)+filename);
	}
	sort( strange.begin(), strange.end() );
	strange.erase( unique( strange.begin(), strange.end() ), strange.end() );
	if (!flagutf)
		for (unsigned int i=0;i<strange.size();i++)
		{
			myprintf("FILE:%08ld <<",(long int)strange[i].length());
			printUTF8(strange[i].c_str());
			myprintf(">>\n");
		}
	myprintf("FILE:Total %s\n",migliaia(strange.size()));
	if (!flagutf)
		return 0;
	myprintf("******* RENAME STRANGE FILES\n");
	printsanitizeflags();
	if (!flagkill)
	myprintf("******* -kill not present => this is a dry run\n");
	int rinominati=0;
	int nonrinominati=0;
	int kollision=0;
	MAPPAFILEHASH mappacollisioni;
	MAPPASTRINGASTRINGA mappatofrom;
	for (unsigned int i=0;i<sourcefile.size();i++)
	{
		if (isdirectory(sourcefile[i]))
		{
			myprintf("This is strange, dir skipped %s\n",sourcefile[i].c_str());
		}
		else
		{
		string newname=sanitizzanomefile(sourcefile[i],filelength,kollision,mappacollisioni);
		if ((newname!=sourcefile[i]))
		{
			if (flagdebug)
			{
				myprintf("25733: pre       <<%s>>\n",sourcefile[i].c_str());
				myprintf("25734: Inserisco <<%s>>\n\n\n",newname.c_str());
			}
			mappatofrom.insert(std::pair<string, string>(newname, "DUMMY"));
			string sfrom=sourcefile[i];
			string sto=newname; 
			if (flagverbose)
			{
				myprintf("FROM: ");
				printUTF8(sfrom.c_str());
				myprintf("\nTO:   %s\n\n",sto.c_str());
			}
			if (flagkill)
			{
				if (::rename(sfrom.c_str(), sto.c_str()) != 0)
				{
					nonrinominati++;
					myprintf("ERROR NIX renaming\n");
					myprintf("from <<%s>>\n",sfrom.c_str());
					myprintf("to   <<%s>>\n",sto.c_str());
					if (flagverbose)
						for (unsigned int j=0;j<sfrom.length();j++)
							myprintf("%03d %03d %c\n",j,sto[j],sto[j]);
				}
				else
					rinominati++;		
			}
			else
				nonrinominati++;
		}
		}
	}
	myprintf("\n");
	myprintf("Candidates  %08d\n",rinominati+nonrinominati);
	if (flagkill)
	{
		myprintf("Renamed     %08d\n",rinominati);
		myprintf("Failed      %08d\n",nonrinominati);
	}
	else
		myprintf("*** dry run\n");
	if (nonrinominati>0)
		return 2;
	else
		return 0;
#endif	
}
int unz(const char * archive,const char * key)
{
	if (!archive)
		return 0;
	uint64_t until=0;
	bool index=false;
	myprintf("PARANOID TEST: working on %s\n",archive);
	std::map<uint32_t, unsigned> bsize;  
	std::map<std::string, unzDT> unzdt;   
	std::vector<std::string> frag;  
	std::string last_filename;      
	uint64_t ramsize=0;
	uint64_t csize=0;                    
	bool streaming=false, journaling=false;  
	int64_t inizio=mtime();
	uint64_t lavorati=0;
	unzInputFile in;  
	in.open(archive, key);
	int64_t total_size=in.getfilesize();
	unzDecompresser d;
	d.setInput(&in);
	bool done=false;  
	bool firstSegment=true;
	while (!done && d.findBlock()) 
  {
	unzBuf filename(65535);
    while (!done && d.findFilename(&filename)) 
	{
		unzBuf comment(65535);
		d.readComment(&comment);
		unzverify_utf8(filename.s.c_str());
		uint64_t jsize=0;  
		if (comment.s.size()>=4 && comment.s.substr(comment.s.size()-4)=="jDC\x01") 
		{
			unsigned i;
			for (i=0; i<comment.s.size()-5 && isdigit(comment.s[i]); ++i) 
			{
				jsize=jsize*10+comment.s[i]-'0';
				if (jsize>>32) unzerror("size in comment > 4294967295");
			}
			if (i<1) 
				unzerror("missing size in comment");
			if (streaming) 
				unzerror("journaling block after streaming block");
			journaling=true;
		}
		else 
		{
			if (journaling) 
			unzerror("streaming block after journaling block");
			if (index) 
				unzerror("streaming block in index");
			streaming=true;
		}
		uint64_t date=0, id=0;  
		char type=0;  
		if (journaling)  
		{
			if (filename.s.size()!=28) 
				unzerror("filename size not 28");
			if (filename.s.substr(0, 3)!="jDC") 
				unzerror("filename not jDC");
			type=filename.s[17];
			if (!strchr("cdhi", type)) 
				unzerror("type not c,d,h,i");
			if (filename.s<=last_filename) 
			unzerror("filenames out of order");
			last_filename=filename.s;
			for (int i=3; i<17; ++i) 
			{
				if (!isdigit(filename.s[i])) 
					unzerror("non-digit in date");
				date=date*10+filename.s[i]-'0';
			}
			verify_date(date);
			for (int i=18; i<28; ++i) 
			{
				if (!isdigit(filename.s[i])) 
					unzerror("non-digit in fragment ID");
				id=id*10+filename.s[i]-'0';
			}
			if (id<1 || id>4294967295llu) 
				unzerror("fragment ID out of range");
		}
		if (streaming && (firstSegment || filename.s!="")) 
		{
			std::string fn=filename.s;
		}
		firstSegment=false;
		fflush(stdout);
		unzBuf seg(jsize);
		if (journaling) 
			d.setOutput(&seg);
		unzSHA1 sha1;
		d.setSHA1(&sha1);
		d.decompress();
		if (journaling && seg.s.size()!=jsize) 
			unzerror("incomplete output");
		char checksum[21];
		d.readSegmentEnd(checksum);
		if (checksum[0]==1) 
		{
			if (memcmp(checksum+1, sha1.result(), 20)) 
				unzerror("unzSHA1 mismatch");
		}
		else 
		if (checksum[0]==0) 
			myprintf("not checked");
		else unzerror("invalid checksum type");
		filename.s="";
		if (csize && strchr("chi", type)) 
		{
			if (csize!=offset) 
			{
				myprintf("Z2:    csize=%1.0f, offset=%1.0f\n",double(csize), double(offset));		
				unzerror("csize does not point here");
			}
			csize=0;
		}
		const size_t len=seg.s.size();
		if (type=='c') 
		{
			if (len<8) 
				unzerror("c block too small");
			csize=unzget8(seg.s.data());
			lavorati+=csize;
			if (flagnoeta==false)
			{
				print_datetime();
				myprintf("%20s (%15s)\n", migliaia(lavorati),migliaia(csize));
			}
			if (csize>>63) 
			{
				myprintf("Incomplete transaction at end of archive (OK)\n");
				done=true;
			}
			else 
			if (index && csize!=0) 
				unzerror("nonzero csize in index");
			if (until && date>until) 
			{
				myprintf("Rollback: %1.0f is after %1.0f\n",double(date), double(until));
			done=true;
			}
			csize+=in.tell()+1;
		}
		if (type=='d') 
		{
			if (index) 
				unzerror("d block in index");
			bsize[id]=in.tell()+1-offset;  
			if (len<8) 
				unzerror("d block too small");
			const char* end=seg.s.data()+len;  
			uint32_t fid=unzget4(end-8);  
			const uint32_t n=unzget4(end-4);    
			if (fid==0) 
			fid=id;
			if (fid!=id) 
				unzerror("missing ID");
			if (n>(len-8)/4) 
				unzerror("frag list too big");
			uint64_t sum=0;  
			for (unsigned i=0; i<n; ++i) 
				sum+=unzget4(end-12-4*i);
			if (sum+n*4+8!=len) 
				unzerror("bad frag size list");
			const char* data=seg.s.data();  
			const char* flist=data+sum;  
			assert(flist+n*4+8==end);
			for (uint32_t i=0; i<n; ++i) 
			{
				while (frag.size()<=id+i) 
					frag.push_back("");
				if (frag[id+i]!="") 
					unzerror("duplicate frag ID");
				uint32_t f=unzget4(flist);  
				unzSHA1 sha1;
				for (uint32_t j=0; j<f; ++j) 
					sha1.put(data[j]);
				const char* h=sha1.result();  
				frag[id+i]=std::string(h, h+20)+std::string(flist, flist+4);
				frag[id+i]+=std::string(data, data+f);
				data+=f;
				flist+=4;
				ramsize+=frag[id+i].size();
			}
			assert(data+n*4+8==end);
			assert(flist+8==end);
		}
		if (type=='h') 
		{
			if (len%24!=4) 
			unzerror("bad h block size");
			uint32_t b=unzget4(seg.s.data());
			b++;
			const char* p=seg.s.data()+4;  
			uint32_t sum=0;  
			for (uint32_t i=0; i<len/24; ++i) 
			{
				if (index) 
				{
					while (frag.size()<=id+i) frag.push_back("");
					if (frag[id+i]!="") unzerror("data in index");
						frag[id+i]=std::string(p, p+24);
				}
				else 
				if (id+i>=frag.size() || frag[id+i].size()<24)
					unzerror("no matching d block");
				else 
				if (frag[id+i].substr(0, 24)!=std::string(p, p+24))
					unzerror("frag size or hash mismatch");
				sum+=unzget4(p+20);
				p+=24;
			}
		}
		if (type=='i') 
		{
			const char* p=seg.s.data();
			const char* end=p+seg.s.size();
			while (p<end) 
			{
				if (end-p<8) 
				unzerror("missing date");
				unzDT f;
				f.date=unzget8(p), p+=8;
				if (f.date!=0) 
					verify_date(f.date);
				std::string fn;
				while (p<end && *p) 
				{
					fn+=*p++;
				}
				if (p==end) 
					unzerror("missing NUL in filename");
				++p;
				if (fn.size()>65535) 
				unzerror("filename size > 65535");
				unzverify_utf8(fn.c_str());
				if (f.date>0) 
				{
					if (end-p<4) 
						unzerror("missing attr size");
					uint32_t na=unzget4(p);
					p+=4;
					if (na>65535) 
					unzerror("attr size > 65535");
					if (na>FRANZOFFSET) 
					{
						assert((na-8)<FRANZOFFSETSHA256); 
						for (unsigned int i=0;i<(na-8);i++)
							f.sha1hex[i]=*(p+(na-(na-8))+i);
						f.sha1hex[(na-8)]=0x0;
					}
					else
					{
						f.sha1hex[0]=0x0;
					}
					for (unsigned i=0; i<na; ++i) 
					{
						if (end-p<1) 
							unzerror("missing attr");
						uint64_t a=*p++&255;
						if (i<8) 
							f.attr|=a<<(i*8);
					}
					if (end-p<4) 
						unzerror("missing frag ptr size");
					uint32_t ni=unzget4(p);
					p+=4;
					for (uint32_t i=0; i<ni; ++i) 
					{
						if (end-p<4) 
							unzerror("missing frag ID");
						uint32_t a=unzget4(p);
						p+=4;
						f.ptr.push_back(a);
						if (!index) 
						{
							if (a<1 || a>=frag.size()) 
								unzerror("frag ID out of range");
							if (frag[a]=="") 
								unzerror("missing frag data");
						}
					}
				}
			unzdt[fn]=f;
			}
		}
		myprintf("\r");
		print_datetime();
		myprintf("Remaining %3s %% frags %12s (RAM used ~ %15s)\r",migliaia2(100-(offset*100/(total_size+1))),migliaia(frag.size()),migliaia2(ramsize));
    }  
    offset=in.tell();
  }  
	myprintf("\n%s bytes of %s tested\n", migliaia(in.tell()), archive);
	printbar('-');
	myprintf("Second stage: rebuilding hashes\n");
	std::vector<unzDTMap::iterator> mappadt;
	std::vector<unzDTMap::iterator> vf;
	std::map<std::string, unzDT>::iterator p;
	int64_t iniziocalcolo=mtime();
	for (p=unzdt.begin(); p!=unzdt.end(); ++p)
		mappadt.push_back(p);
	std::sort(mappadt.begin(), mappadt.end(),unzcompareprimo);
	for (unsigned int i=0; i<mappadt.size(); ++i) 
	{
		unzDTMap::iterator p=mappadt[i];
		unzDT f=p->second;
		if (f.date) 
		{
			uint64_t size=0;
			for (uint32_t i=0; i<f.ptr.size(); ++i)
				if (f.ptr[i]>0 && f.ptr[i]<frag.size() && frag[f.ptr[i]].size()>=24)
					size+=unzget4(frag[f.ptr[i]].data()+20);
			if (!index) 
			{
				std::string fn=p->first;
				if ((!isads(fn)) && (!iszfs(fn)) && (!isdirectory(fn)))
				{
					int64_t startrecalc=mtime();
					string hashstoredinzpaq="";
					string myhashtype="";
					string mycrc32="";
					int unzfranzotype=decode_franz_block(isdirectory(p->first),p->second.sha1hex,
					myhashtype,
					hashstoredinzpaq,
					mycrc32);
					if (unzfranzotype==FRANZO_XXHASH64)
					{
						uint64_t myseed = 0;
						XXHash64 myhash(myseed);
						for (uint32_t i=0; i<f.ptr.size(); ++i) 
							if (f.ptr[i]<frag.size())
								for (uint32_t j=24; j<frag[f.ptr[i]].size(); ++j)
									myhash.add(&frag[f.ptr[i]][j],1);
						sprintf(p->second.sha1decompressedhex,"%016llX",(unsigned long long)myhash.hash());
					}
					else
					if (unzfranzotype==FRANZO_SHA_1)
					{
						unzSHA1 mysha1;
						for (uint32_t i=0; i<f.ptr.size(); ++i) 
							if (f.ptr[i]<frag.size())
								for (uint32_t j=24; j<frag[f.ptr[i]].size(); ++j)
									mysha1.put(frag[f.ptr[i]][j]);
						char sha1result[20];
						memcpy(sha1result, mysha1.result(), 20);
						for (int j=0; j <= 19; j++)
							sprintf(p->second.sha1decompressedhex+j*2,"%02X", (unsigned char)sha1result[j]);
						p->second.sha1decompressedhex[40]=0x0;
					}
					else
					if (unzfranzotype==FRANZO_SHA_256)
					{
						unzSHA256 mysha256;
						for (uint32_t i=0; i<f.ptr.size(); ++i) 
							if (f.ptr[i]<frag.size())
								for (uint32_t j=24; j<frag[f.ptr[i]].size(); ++j)
									mysha256.put(frag[f.ptr[i]][j]);
						char sha256result[32];
						memcpy(sha256result, mysha256.result(), 32);
						for (int j=0; j <= 31; j++)
							sprintf(p->second.sha1decompressedhex+j*2,"%02X", (unsigned char)sha256result[j]);
						p->second.sha1decompressedhex[64]=0x0;
					}
					else
					if (unzfranzotype==FRANZO_BLAKE3)
					{
						blake3_hasher hasher;
						blake3_hasher_init(&hasher);
						for (uint32_t i=0; i<f.ptr.size(); ++i) 
							if (f.ptr[i]<frag.size())
								for (uint32_t j=24; j<frag[f.ptr[i]].size(); ++j)
									blake3_hasher_update(&hasher, &frag[f.ptr[i]][j],1);
						uint8_t output[BLAKE3_OUT_LEN];
						blake3_hasher_finalize(&hasher, output, BLAKE3_OUT_LEN);
						for (int j=0; j < BLAKE3_OUT_LEN; j++)
							sprintf(p->second.sha1decompressedhex+j*2,"%02X", (unsigned char)output[j]);
						p->second.sha1decompressedhex[64]=0x0;
					}
					else
					if (unzfranzotype==FRANZO_SHA3)
					{
						SHA3 hasher;
						for (uint32_t i=0; i<f.ptr.size(); ++i) 
							if (f.ptr[i]<frag.size())
								for (uint32_t j=24; j<frag[f.ptr[i]].size(); ++j)
									hasher.add(&frag[f.ptr[i]][j],1);
						sprintf(p->second.sha1decompressedhex,"%s",hasher.getHash().c_str());
						p->second.sha1decompressedhex[64]=0x0;
					}
					else
					if (unzfranzotype==FRANZO_MD5)
					{
						MD5 hasher;
						for (uint32_t i=0; i<f.ptr.size(); ++i) 
							if (f.ptr[i]<frag.size())
								for (uint32_t j=24; j<frag[f.ptr[i]].size(); ++j)
									hasher.add(&frag[f.ptr[i]][j],1);
						memset(p->second.sha1decompressedhex,0,64);
						sprintf(p->second.sha1decompressedhex,"%s",hasher.getHash().c_str());
					}
					else
					if (unzfranzotype==FRANZO_XXH3)
					{
						XXH3_state_t state128;
						(void)XXH3_128bits_reset(&state128);
						for (uint32_t i=0; i<f.ptr.size(); ++i) 
							if (f.ptr[i]<frag.size())
								for (uint32_t j=24; j<frag[f.ptr[i]].size(); ++j)
									(void)XXH3_128bits_update(&state128, &frag[f.ptr[i]][j],1);
						XXH128_hash_t myhash=XXH3_128bits_digest(&state128);
						sprintf(p->second.sha1decompressedhex,"%016llX%016llX",(unsigned long long)myhash.high64,(unsigned long long)myhash.low64);
					}
					else
						error("25904: unknown unzfranzotype");
					vf.push_back(p);
					if (flagverbose)
						myprintf("File <<%-20s>> %08u of %08lld (%20s) %1.3f %s\n",myhashtype.c_str(),i+1,(long long)mappadt.size(),migliaia(size),(mtime()-startrecalc)/1000.0,fn.c_str());
				}
			}
		}
	}
	std::sort(vf.begin(), vf.end(), unzcomparesha1hex);
	int64_t finecalcolo=mtime();
	myprintf("Calc time (hash rebuild from fragments) %f\n",(finecalcolo-iniziocalcolo)/1000.0);
	printbar('-');
	myprintf("Third stage");
	if (flagverify || flagparanoid)
		myprintf(": with check against filesystem");
	myprintf("\n");
		unsigned int status_e=0;
		unsigned int status_nohash=0;
		unsigned int status_filenotfound=0;
		unsigned int status_1=0;
		unsigned int status_2=0;
		std::string hashfromfile;
		for (unsigned i=0; i<vf.size(); ++i) 
		{
			unzDTMap::iterator p=vf[i];
			string finalfile=p->first;
			if (finalfile!="VFILE-l-filelist.txt")
			{
			string hashstoredinzpaq	="";
			string myhashtype		="";
			string mycrc32			="";
			int myfranzo=decode_franz_block(isdirectory(p->first),p->second.sha1hex,
					myhashtype,
					hashstoredinzpaq,
					mycrc32);
			if (myfranzo==-1)
				error("33351: archive use an unknown hasher!");
			string unzfranzostring="";
			if (flagverify || flagparanoid)
			{
				MAPPACHECK::iterator a=g_mychecks.find(myhashtype);
				if (a!=g_mychecks.end())
				{
					unzfranzostring=decodefranzoffset(a->second.algotype);
					myreplace(unzfranzostring,"+CRC-32","");				
					if (!fileexists(p->first.c_str()))
					{
							if (flagdebug)
								myprintf("25919: FILE NOT FOUND on %s: FILE %s\n",myhashtype.c_str(),p->first.c_str());
							status_filenotfound++;
					}
					else
					{
						uint32_t dummycrc;
						int64_t dummy;
						hashfromfile=hash_calc_file(
						a->second.algotype,
						p->first.c_str(),
						true,	
						dummycrc,
						-1,-1,dummy);
					}
				}
			}
			std::string hashdecompresso=p->second.sha1decompressedhex;
			if (flagverify || flagparanoid)
				if (hashfromfile=="")
					status_nohash++;
			bool localok=true;
			if (!hashstoredinzpaq.empty())
			{
				if (hashstoredinzpaq==hashdecompresso)
					status_1++;
				else
					localok=false;
			}			
			if (!hashfromfile.empty())
			{
				if (hashfromfile==hashdecompresso)
					status_2++;
				else
					localok=false;
			}
			if ((!localok) || (flagverbose))
				if (unzfranzostring!="")
				{
					myprintf("%14s: %s\n",myhashtype.c_str(),p->first.c_str());
					myprintf("DECOMPRESSED  : %s\n",hashdecompresso.c_str());
					if (!hashstoredinzpaq.empty())
					myprintf("STORED IN ZPAQ: %s\n",hashstoredinzpaq.c_str());
					if (!hashfromfile.empty())
					myprintf("FROM FILE     : %s\n",hashfromfile.c_str());
					myprintf("\n");
					if (!localok)
						status_e++;
				}
			}
		}
	int64_t fine=mtime();
	unsigned int total_files=vf.size();
	myprintf("SUMMARY  %1.3f s\n",(fine-inizio)/1000.0);
	myprintf("Total   : %08d\n",total_files);
	if (status_e>0)
	myprintf("ERRORS  : %08d (ERROR:  something WRONG)\n",status_e);
	if (status_nohash>0)
	myprintf("WARNING : %08d (UNKNOWN:cannot verify nohash)\n",status_nohash);
	if (status_filenotfound>0)
	myprintf("WARNING : %08d (UNKNOWN:file not found)\n",status_filenotfound);
	if (status_1>0)
	myprintf("GOOD    : %08d of %08d (stored=decompressed)\n",status_1,total_files);
	if (status_2>0)
	myprintf("SURE    : %08d of %08d (stored=decompressed=file on disk)\n",status_2,total_files);
	if (status_e==0)
	{
		if (status_nohash+status_filenotfound)
			myprintf("Unknown (cannot verify)\n");
		else
		{
			if (flagverify || flagparanoid)
			myprintf("All OK (paranoid test with check against filesystem)\n");
			else
			myprintf("All OK (paranoid test)\n");
		}
	}
	else
	{
		myprintf("WITH ERRORS\n");
		return 2;
	}
	return 0;
}
const uint32_t zero_block_crc32[54] =
{
0xD202EF8D,0x41D912FF,0x2144DF1C,0x6522DF69,0xECBB4B55,0x190A55AD,0x758D6336,0xC2A8FA9D,
0x0D968558,0xB2AA7578,0xEFB5AF2E,0xF1E8BA9E,0xC71C0011,0xD8F49994,0xAB54D286,0x011FFCA6,
0xD7978EEB,0x7EE8CDCD,0xE20EEA22,0x75660AAC,0xA738EA1C,0x8D89877E,0x1147406A,0x1AD2BC45,
0xA47CA14A,0x59450445,0xB2EB30ED,0x80654151,0x2A0E7DBB,0x6DB88320,0x5B64C2B0,0x4DBDF21C,
0xD202EF8D,0x41D912FF,0x2144DF1C,0x6522DF69,0xECBB4B55,0x190A55AD,0x758D6336,0xC2A8FA9D,
0x0D968558,0xB2AA7578,0xEFB5AF2E,0xF1E8BA9E,0xC71C0011,0xD8F49994,0xAB54D286,0x011FFCA6,
0xD7978EEB,0x7EE8CDCD,0xE20EEA22,0x75660AAC,0xA738EA1C,0x8D89877E
};
uint32_t crc32ofzeroblock(uint64_t i_size) 
{
	assert(i_size<9.007.199.254.740.992); 
	if (i_size==0)
		return 0;
	uint32_t mycrc=0;
	unsigned int i=0;
	while (i_size > 0)
	{
		if ((i_size%2)==1)
			mycrc=crc32_combine(mycrc,zero_block_crc32[i],1<<i);
		i_size=i_size/2;
		i++;
	}
   	return mycrc;
}
uint32_t crc32zeros(int64_t i_size)
{
	uint64_t inizio=mtime();
	uint32_t crc=crc32ofzeroblock(i_size);
	g_zerotime+=mtime()-inizio;
	return crc;
}
int Jidac::consolidate(string i_archive)
{
	assert(i_archive);
	myprintf("*** Merge (consolidate) ***\n");
	vector<string>	chunk_name;
	vector<int64_t>	chunk_size;
	const string part0=subpart(i_archive, 0);
	for (unsigned i=1; ;i++) 
	{
		const string parti=subpart(i_archive, i);
		if (i>1 && parti==part0) 
			break;
		if (!fileexists(parti))
			break;
		int64_t dimensione=prendidimensionefile(parti.c_str());
		if (dimensione<0)
			break;
		chunk_size.push_back(dimensione);
		chunk_name.push_back(parti);
	}
	if (chunk_name.size()==0)
	{
		myprintf("29515: Something strange: cannot find archive chunks\n");
		return 2;
	}
	int64_t total_size=0;
	for (int unsigned i=0;i<chunk_name.size();i++)
	{
		myprintf("Chunk %08d %20s <<%s>>\n",i,migliaia(chunk_size[i]),chunk_name[i].c_str());
		total_size+=chunk_size[i];
	}
	printbar('-');
	myprintf("Total %s %20s (%s)\n",migliaia2(chunk_name.size()),migliaia(total_size),tohuman(total_size));
	if (files.size()!=1)
	{
		myprintf("29545: exactly one file as output for consolidate\n");
		return 1;
	}
	string outfile=files[0];
	if (fileexists(outfile))
		if (!flagforce)
		{
			myprintf("29553: outfile exists, and no -force. Quit %s\n",outfile.c_str());
			return 1;
		}
	int64_t spazio=getfreespace(outfile);
	myprintf("Outfile    <<%s>>\n",outfile.c_str());
	myprintf("Free space %20s\n",migliaia(spazio));
	myprintf("Needed     %20s\n",migliaia(total_size));
	if (spazio<total_size)
		if (!flagspace)
		{
			myprintf("29564: Free space seems < needed, and no -space. Quit\n");
			return 1;
		}
	FILE* outFile=fopen(outfile.c_str(), "wb");
	if (outFile==NULL)
	{
		myprintf("29579 :CANNOT OPEN outfile %s\n",outfile.c_str());
		return 2;
	}
	size_t const blockSize = 65536;
	unsigned char buffer[blockSize];
	int64_t donesize=0;
	int64_t startcopy=mtime();
	XXH3_state_t state128;
    (void)XXH3_128bits_reset(&state128);
	if (flagverify)
		myprintf("-verify: trust, but check...\n");
	for (int unsigned i=0;i<chunk_name.size();i++)
	{
		string	sorgente_nome=chunk_name[i];
		FILE* inFile = freadopen(sorgente_nome.c_str());
		if (inFile==NULL) 
		{
		int err=1;
		myprintf("\n29585: ERR <%s> kind %d\n",sorgente_nome.c_str(),err); 
		return 2;
		}
		size_t readSize;
		int64_t	chunk_readed=0;
		int64_t	chunk_written=0;
		while ((readSize = fread(buffer, 1, blockSize, inFile)) > 0) 
		{
			int64_t written=fwrite(buffer,1,readSize,outFile);
			chunk_written+=written;
			chunk_readed+=readSize;
			donesize+=written;
			if (flagverify)
				(void)XXH3_128bits_update(&state128, buffer, readSize);
			avanzamento(donesize,total_size,startcopy);
		}
		fclose(inFile);
		if (flagverbose)
			myprintf("Chunk %08d R %20s W %20s E %20s\n",i,migliaia(chunk_readed),migliaia2(chunk_written),migliaia3(chunk_size[i]));
		if ((chunk_readed!=chunk_written) || (chunk_readed!=chunk_size[i]))
		{
			myprintf("29632: GURU on chunk %d Read, Write, Expec not equal!\n",i);
			return 1;
		}
	}
	fclose(outFile);
	myprintf("Done\n");
	myprintf("Written  %20s\n",migliaia(donesize));
	myprintf("Expected %20s\n\n",migliaia(total_size));
	if (donesize!=total_size)
	{
		myprintf("29645: GURU bytes written does not match expected\n");
		return 1;
	}
	if (flagverify)
	{
		myprintf("-flagverify: double check...\n");
		XXH128_hash_t myhash=XXH3_128bits_digest(&state128);
		char risultato[33];
		sprintf(risultato,"%016llX%016llX",(unsigned long long)myhash.high64,(unsigned long long)myhash.low64);
		uint32_t dummycrc32;
		int64_t startverify=mtime();
		int64_t io_lavorati=0;
		string hashreloaded=xxhash_calc_file(outfile.c_str(),false,dummycrc32,startverify,total_size,io_lavorati);
		myprintf("Expected   XXH3 hash of the output file %s\n",risultato);
		myprintf("Calculated XXH3 hash of the output file %s\n",hashreloaded.c_str());
		if (hashreloaded!=risultato)
		{
			myprintf("29658: GURU hash of output file does not match!\n");
			return 1;
		}
	}
	return 0;
}
int Jidac::test() 
{
	getpasswordifempty();
	if ((files.size()>0) && (!flagparanoid))
	{
		if (flagchecksum)
		myprintf("SHA-1-chunked verify+HASH checksum\n");
		else
		myprintf("SHA-1-chunked verify\n");
		return list();
	}
	if (flagparanoid)
	{
		if (tofiles.size()!=1)
		{
			myprintf("-paranoid needs a -to\n");
			return 2;
		}
		uint64_t tofoldersize=0;
		uint32_t tofoldernumber=0;
		uint32_t tofolderfolder=0;
		uint32_t tofolderlongfiles=0;
		if (getfoldersize(tofiles[0],tofoldersize,tofoldernumber,tofolderfolder,tofolderlongfiles))
			if (tofoldersize>0)
			{
				myprintf("37333: WARNING the folder <<");
				printUTF8(tofiles[0].c_str());
				myprintf(">> contain %s bytes\n\n\n",migliaia(files_size[0]));		
				if (!getcaptcha("withoutmercy","Extract-check-delete without confirmation"))
					return 1;
			}
		return extract();
	}
	int64_t starttest=mtime();
	flagtest=true;
	summary=1;
	const int64_t sz=read_archive(archive.c_str());
	if (sz<1) error("archive not found");
	for (unsigned i=0; i<block.size(); ++i) 
	{
		if (block[i].bsize<0) error("negative block size");
		if (block[i].start<1) error("block starts at fragment 0");
		if (block[i].start>=ht.size()) error("block start too high");
		if (i>0 && block[i].start<block[i-1].start) error("unordered frags");
		if (i>0 && block[i].start==block[i-1].start) error("empty block");
		if (i>0 && block[i].offset<block[i-1].offset+block[i-1].bsize)
			error("unordered blocks");
		if (i>0 && block[i-1].offset+block[i-1].bsize>block[i].offset)
			error("overlapping blocks");
	}
  ExtractJob job(*this);
  int total_files=0;
  for (DTMap::iterator p=dt.begin(); p!=dt.end(); ++p) 
  {
		p->second.data=-1;  
		if (p->second.date && p->first!="") 
		{
			const string fn=rename(p->first);
			const bool isdir=p->first[p->first.size()-1]=='/';
			if (isdir)  
				p->second.data=0;
			else 
				if (block.size()>0) 
			{  
				p->second.data=0;
				unsigned lo=0, hi=block.size()-1;  
				for (unsigned i=0; p->second.data>=0 && i<p->second.ptr.size(); ++i) 
				{
					unsigned j=p->second.ptr[i];  
					if (j==0 || j>=ht.size() || ht[j].usize<-1) 
					{
						fflush(stdout);
						printUTF8(p->first.c_str());
						myprintf( ": bad frag IDs, skipping...\n");
						p->second.data=-1;  
						continue;
					}
					assert(j>0 && j<ht.size());
					if (lo!=hi || lo>=block.size() || j<block[lo].start
						|| (lo+1<block.size() && j>=block[lo+1].start)) 
						{
							lo=0;  
							hi=block.size()-1;
							while (lo<hi) 
							{
								unsigned mid=(lo+hi+1)/2;
								assert(mid>lo);
								assert(mid<=hi);
								if (j<block[mid].start) 
									hi=mid-1;
								else 
									(lo=mid);
							}
						}
						assert(lo==hi);
						assert(lo>=0 && lo<block.size());
						assert(j>=block[lo].start);
						assert(lo+1==block.size() || j<block[lo+1].start);
						unsigned c=j-block[lo].start+1;
						if (block[lo].size<c) 
							block[lo].size=c;
						if (block[lo].files.size()==0 || block[lo].files.back()!=p)
						{
							block[lo].files.push_back(p);
						}
				}
				++total_files;
				job.total_size+=p->second.size;
			}
		}  
  }  
	myprintf("To be checked %s in %s files (%d threads)\n",migliaia(job.total_size), migliaia2(total_files), howmanythreads);
	vector<ThreadID> tid(howmanythreads);
	for (unsigned i=0; i<tid.size(); ++i) 
		run(tid[i], decompressThread, &job);
	for (unsigned i=0; i<tid.size(); ++i) 
		join(tid[i]);
  unsigned extracted=0, errors=0;
  for (DTMap::iterator p=dt.begin(); p!=dt.end(); ++p) 
  {
    string fn=rename(p->first);
    if (p->second.data>=0 && p->second.date
        && fn!="" && fn[fn.size()-1]!='/') {
      ++extracted;
      if (p->second.ptr.size()!=unsigned(p->second.data)) {
        fflush(stdout);
        if (++errors==1)
          myprintf(
          "\nFailed (extracted/total fragments, file):\n");
        myprintf( "UJO %u/%u ",
                int(p->second.data), int(p->second.ptr.size()));
        printUTF8(fn.c_str());
        myprintf( "\n");
      }
    }
  }
	if (errors>0) 
	{
		fflush(stdout);
		myprintf(
			"\nChecked %u of %u files OK (%u errors)"
			" using %1.3f MB x %d threads\n",
			extracted-errors, extracted, errors, job.maxMemory/1000000,
			int(tid.size()));
	}
	else
		myprintf("7.15 stage time %10.2f no error detected (RAM ~%s), try CRC-32 (if any)\n",
	(mtime()-starttest)/1000.0,tohuman((uint64_t)(tid.size()*job.maxMemory)));
	uint64_t startverify=mtime();
	sort(g_crc32.begin(),g_crc32.end(),comparecrc32block);
	unsigned int 	status_e		=0; 
	unsigned int 	status_e_hash	=0; 
	unsigned int 	status_e_crc	=0;	
	unsigned int 	status_e_blocks	=0;	
	unsigned int 	status_0		=0;
	unsigned int 	status_1		=0;
	uint32_t 		checkedfiles	=0;
	uint32_t 		uncheckedfiles	=0;
	unsigned int 	parti			=1;
	int64_t 		lavorati		=0;
	uint64_t 		dalavorare		=0;
	uint32_t 		currentcrc32	=0;
	uint32_t 		crc32stored		=0;
	for (unsigned int i=0;i<g_crc32.size();i++)
		dalavorare+=g_crc32[i].crc32size;
	myprintf("Checking %17s blocks with CRC-32 (%s not-0 bytes)\n",migliaia(g_crc32.size()),migliaia2(dalavorare));
	uint32_t 	parts=0;
	uint64_t	zeroedblocks=0;
	uint32_t	howmanyzero=0;
	g_zerotime=0;
	unsigned int i=0;
	while (i<g_crc32.size())
	{
		if ( ++parts % 1000 ==0)
			if (!flagnoeta)
				myprintf("Block %05uK %16s\r",i/1000,tohuman(lavorati));
		s_crc32block it=g_crc32[i];
		DTMap::iterator p=dt.find(it.filename);
		crc32stored=0;
		string myhashtype="";
		string myhash="";
		string mycrc32="";
		if (p != dt.end())
		{
			decode_franz_block(isdirectory(it.filename),p->second.franz_block,
			myhashtype,
			myhash,
			mycrc32);
			crc32stored=crchex2int(mycrc32.c_str());
		}
		if (flagdebug)
		{
			myprintf("MYhashtype   %s\n",myhashtype.c_str());
			myprintf("Myhash       %s\n",myhash.c_str());
			myprintf("Mycrc32      %s\n",mycrc32.c_str());
			myprintf("\n");
		}
		if (it.crc32start>0)
		{
			uint64_t holesize=it.crc32start;
			uint32_t zerocrc	=crc32zeros(holesize);
			currentcrc32		=crc32_combine(currentcrc32, zerocrc,holesize);
			lavorati			+=holesize;	
			zeroedblocks		+=holesize;
			howmanyzero++;
		}
		currentcrc32=crc32_combine(currentcrc32, it.crc32,it.crc32size);
		lavorati+=it.crc32size;
		while (g_crc32[i].filename==g_crc32[i+1].filename)
		{
			if ((g_crc32[i].crc32start+g_crc32[i].crc32size) != (g_crc32[i+1].crc32start))
			{
				uint64_t holesize=g_crc32[i+1].crc32start-(g_crc32[i].crc32start+g_crc32[i].crc32size);
				uint32_t zerocrc=crc32zeros(holesize);
				currentcrc32=crc32_combine(currentcrc32, zerocrc,holesize);
				lavorati+=holesize;
				zeroedblocks+=holesize;
				howmanyzero++;
			}
			i++;
			s_crc32block myit=g_crc32[i];
			currentcrc32=crc32_combine (currentcrc32, myit.crc32,myit.crc32size);
			lavorati+=myit.crc32size;
			parti++;
		}
		string filedefinitivo=g_crc32[i].filename;
		if ((searchfrom!="") && (replaceto!=""))
				replace(filedefinitivo,searchfrom,replaceto);
		if (flagdebug)
			myprintf("Stored %08X calculated %08X %s\n",crc32stored,currentcrc32,filedefinitivo.c_str());
		if (mycrc32!="")
		{
			if (currentcrc32==crc32stored)
			{
				if (flagdebug)
					myprintf("GOOD: STORED %08X = DECOMPRESSED %s\n",crc32stored,filedefinitivo.c_str());
				status_1++;
			}
			else
			{
				myprintf("ERROR:  STORED CRC-32 %08X != DECOMPRESSED %08X (ck %08d) %s\n",crc32stored,currentcrc32,parti,filedefinitivo.c_str());
				status_e_blocks++;
			}
		}
		else
		{	
			uncheckedfiles++;
		}
		parti=1;
		currentcrc32=0;
		i++;
	}
	myprintf("\nCRC-32 time %14.2fs\n",(mtime()-startverify)/1000.0);
	myprintf("Blocks %19s (%12s)\n",migliaia(dalavorare),migliaia2(g_crc32.size()));
	myprintf("Zeros  %19s (%12s) %f s\n",migliaia(zeroedblocks),migliaia2(howmanyzero),(g_zerotime/1000.0));
	myprintf("Total  %19s speed %s/sec (%s/s)\n",migliaia(dalavorare+zeroedblocks),migliaia2((uint64_t)((dalavorare+zeroedblocks)/((mtime()-startverify+1)/1000.0))),tohuman((uint64_t)((dalavorare+zeroedblocks)/((mtime()-startverify+1)/1000.0))));
	if (checkedfiles>0)
		myprintf("Checked         : %08d of %08d (zpaqfranz)\n",checkedfiles,total_files);
	if (uncheckedfiles>0)
	{
		myprintf("UNcheck         : %08d of %08d (zpaq 7.15?)\n",uncheckedfiles,total_files);
			status_0=uncheckedfiles;
	}
	if (status_e_hash)
	myprintf("ERRORS HASH   : %08d (ERROR verifyng hash from disk)\n",status_e_hash);
	if (status_e_crc)
	myprintf("ERRORS CRC FI : %08d (ERROR verifyng CRC-32 from disk)\n",status_e_crc);
	if (status_e_blocks)
	myprintf("ERRORS        : %08d (ERROR in rebuilded CRC-32, SHA-1 collisions?)\n",status_e_blocks);
	status_e = status_e_hash+status_e_crc+status_e_blocks;
	if (status_e)
	printbar('-');
	if (status_0)
	myprintf("WARNING         : %08d (Cannot say anything)\n",status_0);
	if (status_1)
	myprintf("GOOD            : %08d of %08d (stored=decompressed)\n",status_1,total_files);
	if (status_e==0)
	{
		if (status_0)
			myprintf("VERDICT         : UNKNOWN  (Cannot say anything)\n");
		else
			myprintf("VERDICT         : OK                   (CRC-32 stored vs decompressed)\n");
	}
	else
	{
		myprintf("WITH ERRORS\n");
		errors=2;
	}
	if (flagverify)
	{
		printbar('+');
		myprintf("Re-testing (hashing) from filesystem (-verify) if possible\n");
		errors+=verify(false);
	}
  return (errors+status_e)>0;
}
void myaddfile(uint32_t i_tnumber,DTMap& i_edt,string i_filename, int64_t i_date,int64_t i_size, bool i_flagcalchash) 
{
	if (!flag715)
		if (isads(i_filename))
			return;
	if (!flagforcezfs)
		if (iszfs(i_filename))
			return;
	if (minsize>0)
		if ((uint64_t)i_size<minsize)
		{
			if (flagdebug)
				myprintf("27072: (-minsize) too small %19s %s\n",migliaia(i_size),i_filename.c_str());
			return;
		}
	if (maxsize>0)
		if ((uint64_t)i_size>maxsize)
		{
			if (flagdebug)
				myprintf("27080: (-maxsize) too large %19s %s\n",migliaia(i_size),i_filename.c_str());
			return;
		}
	int64_t dummy;
	DT& d=i_edt[i_filename];
	d.date=i_date;
	d.size=i_size;
	d.attr=0;
	d.data=0;
	d.hexhash="";
	if (i_flagcalchash)
		if (!isdirectory(i_filename))
		{
			int64_t starthash=mtime();
			uint32_t dummycrc;
			d.hexhash=hash_calc_file(flag2algo(),i_filename.c_str(),false,dummycrc,mtime(),prendidimensionefile(i_filename.c_str()),dummy);
			if (flagverbose)
			{
				myprintf("%s: |%s| [%d] %6.3f ",mygetalgo().c_str(),d.hexhash.c_str(),i_tnumber,(mtime()-starthash)/1000.0);
				printUTF8(i_filename.c_str());
				myprintf("\n");
			}
		}
	pthread_mutex_lock(&g_mylock);
	g_arraybytescanned[i_tnumber]+=i_size;
	g_arrayfilescanned[i_tnumber]++;
	if (!flagnoeta)
	{
		if (i_flagcalchash)
		{
			if (!(g_arrayfilescanned[i_tnumber] % 100))
			{
				for (unsigned int i=0; i<g_arraybytescanned.size();i++)
					myprintf("Checksumming |%02d|%10s %12s\n",i,tohuman(g_arraybytescanned[i]),migliaia(g_arrayfilescanned[i]));
				if (!flagsilent)
				{
					setupConsole();
					printf("\033[%dA",(int)g_arraybytescanned.size());
					restoreConsole();
				}
			}
		}
		else
		{
			if (!(g_arrayfilescanned[i_tnumber] % 1000))
			{
				for (unsigned int i=0; i<g_arraybytescanned.size();i++)
					myprintf("|%02d|%10s %12s\n",i,tohuman(g_arraybytescanned[i]),migliaia(g_arrayfilescanned[i]));
				if (!flagsilent)
				{
					setupConsole();
					printf("\033[%dA",(int)g_arraybytescanned.size());
					restoreConsole();
				}
			}
		}
		fflush(stdout);
	}
	pthread_mutex_unlock(&g_mylock);
}
void myscandir(uint32_t i_tnumber,DTMap& i_edt,string filename, bool i_recursive,bool i_flagcalchash)
{
	if (isads(filename))
	{
		if (flagverbose)
			myprintf("Skip :$DATA ----> %s\n",filename.c_str());
		return;
	}
	if (!flagforcezfs)
		if (iszfs(filename))
		{
			if (flagverbose)
				myprintf("Skip .zfs ----> %s\n",filename.c_str());
			return;
		}
  while (filename.size()>1 && filename[filename.size()-1]=='/')
    filename=filename.substr(0, filename.size()-1);  
	struct stat sb;
	if (!lstat(filename.c_str(), &sb)) 
	{
		if (S_ISREG(sb.st_mode))
		myaddfile(i_tnumber,i_edt,filename, decimal_time(sb.st_mtime), sb.st_size,i_flagcalchash);
		if (S_ISDIR(sb.st_mode)) 
		{
			myaddfile(i_tnumber,i_edt,filename=="/" ? "/" : filename+"/", decimal_time(sb.st_mtime),0, i_flagcalchash);
			DIR* dirp=opendir(filename.c_str());
			if (dirp) 
			{
				for (dirent* dp=readdir(dirp); dp; dp=readdir(dirp)) 
				{
					if (strcmp(".", dp->d_name) && strcmp("..", dp->d_name)) 
					{
						string s=filename;
						if (s!="/") s+="/";
						s+=dp->d_name;
						if (i_recursive)        
							myscandir(i_tnumber,i_edt,s,true,i_flagcalchash);
						else
						{
							if (!lstat(s.c_str(), &sb)) 
							{
								if (S_ISREG(sb.st_mode))
									myaddfile(i_tnumber,i_edt,s, decimal_time(sb.st_mtime), sb.st_size,i_flagcalchash);
								if (S_ISDIR(sb.st_mode)) 
									myaddfile(i_tnumber,i_edt,s=="/" ? "/" :s+"/", decimal_time(sb.st_mtime),0, i_flagcalchash);
							}
						}          			
					}
				}
				closedir(dirp);
			}
			else
				perror(filename.c_str());
		}
	}
	else
		perror(filename.c_str());
}
struct tparametri
{
	bool		recursive;
	string 		directorytobescanned;
	DTMap		theDT;
	bool		flagcalchash;
	uint64_t	timestart;
	uint64_t	timeend;
	int	tnumber;
};
void * scansiona(void *t) 
{
	assert(t);
	tparametri* par= ((struct tparametri*)(t));
	DTMap& tempDTMap = par->theDT;
	myscandir(par->tnumber,tempDTMap,par->directorytobescanned,par->recursive,par->flagcalchash);
	par->timeend=mtime();
	pthread_exit(NULL);
	return 0;
}
string secure_copy_file(
const string i_filename,const string i_outfilename,int64_t i_startcopy,int64_t i_totalsize,int64_t i_totalcount,int64_t& o_writtensize,int64_t& o_donesize,int64_t& o_donecount,
int64_t i_sorgente_size,
int64_t i_sorgente_date,
int64_t i_sorgente_attr,
int64_t i_destinazione_size,
int64_t i_destinazione_date,
int64_t i_destinazione_attr
)
{
	static int ultimapercentuale=0;
	if (flagdebug)
	{
		myprintf("\n");
		myprintf("From:   %s\n",i_filename.c_str());
		myprintf("To:     %s\n",i_outfilename.c_str());
	}
	if (i_filename=="")
		return "30833:SOURCE-EMPTY";
	if (i_outfilename=="")
		return "30836:DEST-EMPTY";
	if (isdirectory(i_filename))
	{
		makepath(i_outfilename);
		return "OK";
	}
	int64_t sorgente_dimensione=0;
	int64_t sorgente_data=0;
	int64_t sorgente_attr=0;
	int64_t destinazione_dimensione=0;
	int64_t destinazione_data=0;
	int64_t destinazione_attr=0;
	bool	sorgente_esiste=false;
	bool	destinazione_esiste=false;
	sorgente_esiste=true;		
	sorgente_dimensione=i_sorgente_size;
	sorgente_data=i_sorgente_date;
	sorgente_attr=i_sorgente_attr;
	if (i_destinazione_size>=0)
	{
		destinazione_esiste=true;
		destinazione_dimensione=i_destinazione_size;
		destinazione_data=i_destinazione_date;
		destinazione_attr=i_destinazione_attr;
	}
	else
	{
		int64_t start_destinazione_esiste=mtime();
		destinazione_esiste	=getfileinfo(i_outfilename,destinazione_dimensione,destinazione_data,destinazione_attr);
		g_robocopy_check_destinazione+=mtime()-start_destinazione_esiste;
	}
	if (flagdebug)
	{
		myprintf("Sorgente     esiste  %d\n",(int)sorgente_esiste);
		myprintf("Sorgente     size    %s\n",migliaia(sorgente_dimensione));
		myprintf("Sorgente     data    %s\n",migliaia(sorgente_data));
		myprintf("Destinazione esiste  %d\n",(int)destinazione_esiste);
		myprintf("Destinazione size    %s\n",migliaia(destinazione_dimensione));
		myprintf("Destinazione data    %s\n",migliaia(destinazione_data));
		myprintf("\n");
	}
	if (!flagdonotforcexls)
		if (isxls(i_filename))
		{
			if (flagdebug)
				myprintf("27584: enforcing xls/ppt test %s\n",i_filename.c_str());
			destinazione_esiste=isfilesequal(i_filename,i_outfilename,flagzero);
			if (destinazione_esiste)
			{
				if (flagdebug)
					myprintf("Equal XLS: skip %s\n",i_outfilename.c_str());
				close(i_outfilename.c_str(),sorgente_data,sorgente_attr);
				return "=";
			}
			else
			{
				if (flagdebug)
					myprintf("Different XLSs!\n");
			}
		}
	if (destinazione_esiste)
	{
		if (flagdebug)
			myprintf("Esiste1\n");
		if (sorgente_esiste)
		{
			if (flagdebug)
			{
				myprintf("Esiste2\n");
			}
				if (destinazione_dimensione==sorgente_dimensione)
				{
					if (flagdebug)
						myprintf("Stessa dimensione\n");
					if (flagdebug)
					{
						myprintf("39590: PPP %s\n",migliaia(myabs(destinazione_data,sorgente_data)));
					}
					if (myabs(destinazione_data,sorgente_data)<=2)
					{
						if (flagdebug)
							myprintf("Stessa data\n");
						if (flagkill)
							if (sorgente_attr!=destinazione_attr)
								close(i_outfilename.c_str(),sorgente_data,sorgente_attr);
						o_donesize+=sorgente_dimensione;
						o_donecount++;
						if (!flagnoeta)
						{
							int percentuale=100*o_donecount/(i_totalcount+1);
							if (percentuale%10==0)
								if (percentuale!=ultimapercentuale)
								{
									myprintf("Done %02d %% %12s /%12s (%11s /%11s)\n",percentuale,migliaia(o_donecount),migliaia2(i_totalcount),tohuman(o_donesize),tohuman2(i_totalsize));
									ultimapercentuale=percentuale;
								}
						}
						return "=";
					}
				}
		}
		if (flagkill)
			if ((!flagappend) && (!iszpaq(i_outfilename)))
			{
				delete_file(i_outfilename.c_str());
			if (flagdebug)
				myprintf("Cancellato %s\n",i_outfilename.c_str());
			}
	}
	if (!flagkill)
		return "OK";
	size_t const blockSize = 65536;
	unsigned char buffer[blockSize];
	FILE* inFile = freadopen(i_filename.c_str());
	if (inFile==NULL) 
	{
		int err=1;
		myprintf("\nERR <%s> kind %d\n",i_filename.c_str(),err); 
		return "KAPUTT";
	}
	if (flagappend)
	{
		if (destinazione_dimensione>=sorgente_dimensione)
			flagappend=false;	
		if (!iszpaq(i_filename))
		{
			if (flagdebug)
				myprintf("35672: not a ZPAQ / not flagappend!\n");
			flagappend=false;
		}
		else
		{
			if (flagdebug)
				myprintf("35677: we have a ZPAQ and a --append!\n");
		}
	}
	makepath(i_outfilename);
	FILE* outFile=NULL;
	if (flagdebug)
	{
		if (fileexists(i_outfilename))
			myprintf("ESISTE file %s\n",i_outfilename.c_str());
		else
			myprintf("NON ESISTE APPEND %s\n",i_outfilename.c_str());
	}
	if (flagappend)
		if (!isfilesequal(i_filename,i_outfilename,true))
		{
			if (flagdebug)
					myprintf("35768: fast check failed, turn back to full copy %s %s\n",i_filename.c_str(),i_outfilename.c_str());
			flagappend=false;
		}
	if (flagappend)
		outFile=fopen(i_outfilename.c_str(), "ab");
	else
		outFile=fopen(i_outfilename.c_str(), "wb");
	if (outFile==NULL) 
		return "30847:CANNOT OPEN outfile "+i_outfilename;
	size_t readSize;
#define LARGEFILE 100000000
	int larghezzaconsole=terminalwidth();
	if (larghezzaconsole>=50)
		larghezzaconsole=50;
	else
		larghezzaconsole=0;
	if (flagnoeta)
		larghezzaconsole=0;
	int64_t scrittitotali=0;
	int64_t dascrivere=sorgente_dimensione;
	int lastbarra=0;
	if ((sorgente_dimensione>LARGEFILE) && (larghezzaconsole>0))
		myprintf("%s",tohuman(sorgente_dimensione));
	if (flagappend)
	{
		if (destinazione_dimensione<sorgente_dimensione)
		{
			if (flagdebug)
			{
				myprintf("\nFaccio APPEND\n");
				myprintf("Sorgente dimensione     %19s\n",migliaia(sorgente_dimensione));
				myprintf("Destinazione dimensione %19s\n",migliaia(destinazione_dimensione));
			}
			fseeko(inFile	,destinazione_dimensione, SEEK_SET);
			if (flagdebug)
				myprintf("Seekato a %s\n",migliaia(destinazione_dimensione));
			dascrivere=sorgente_dimensione-destinazione_dimensione;
			if (flagdebug)
				myprintf("Da scrivere             %19s\n",migliaia(dascrivere));
		}
	}
	while ((readSize = fread(buffer, 1, blockSize, inFile)) > 0) 
	{
		if (flagzero)
			memset(buffer,0,sizeof(buffer));
		int scritti=fwrite(buffer,1,readSize,outFile);
		scrittitotali+=scritti;
		o_donesize+=scritti;
		o_writtensize+=scritti;
		if ((sorgente_dimensione>LARGEFILE) && (larghezzaconsole>0))
		{
			int barra=larghezzaconsole*scrittitotali/(sorgente_dimensione+1);
			if (barra>lastbarra)
			{
				myprintf(".");
				lastbarra=barra;
			}
		}
		else
			myavanzamento(o_donesize,i_totalsize,i_startcopy);
	}
	if (flagappend)
		if (flagdebug)
		{
			myprintf("\nScritti %s\n",migliaia(scrittitotali));
		}	
	if ((sorgente_dimensione>LARGEFILE) && (larghezzaconsole>0))
		myprintf("\r                                                            \r");
	myavanzamento(o_donesize,i_totalsize,i_startcopy);
	fclose(inFile);
	fclose(outFile);
	close(i_outfilename.c_str(),sorgente_data,sorgente_attr);
	o_donecount++;
	if (scrittitotali!=dascrivere)
	{
		myprintf("\n");
		myprintf("35107: HOUSTON something seems wrong: expected %s, done %s\n",migliaia(dascrivere),migliaia2(scrittitotali));
		myprintf("35107: Corrupted source files? Lost connection? Cannot access? Media full?\n");
		return "35109: COPY CORRUPTED";
	}
	return "OK";
}
std::string exec(const char* cmd) 
{
	std::array<char, 128> buffer;
    std::string result;
    std::unique_ptr<FILE, decltype(&pclose)> pipe(popen(cmd, "r"), pclose);
    while (fgets(buffer.data(), buffer.size(), pipe.get()) != nullptr) 
        result += buffer.data();
    return result;
}
int pos(const std::string &i_stringa,const std::string& i_cerca)
{
    return (i_stringa.find(i_cerca));
}
string Jidac::zfs_get_snaplist(string i_header,string i_footer,vector<string>& o_array_primachiocciola,vector<string>& o_array_dopochiocciola)
{
	string filebatch="/tmp/exec_zfs.sh";
	filebatch=nomefileseesistegia(filebatch);
	if (flagdebug)
		myprintf("36337 script EXECUTING %s\n",filebatch.c_str());
	FILE* batch=fopen(filebatch.c_str(), "wb");
	fprintf(batch,"zfs list -t snapshot\n");
	fclose(batch);
	if (chmod(filebatch.c_str(),0700)!=0)
		return "30515: error on chmod";
	string snapshotlist=exec(filebatch.c_str());
	if (snapshotlist=="")
		return "30490: snapshot list empty";
	string temp;
	int 			posizioneused	=-1;
	unsigned int 	i				=0;
	while (i<snapshotlist.length())
	{
		if (snapshotlist[i]!=10)
			temp+=snapshotlist[i];
		else
		{
			if (pos(temp,"NAME")==0)
				posizioneused=pos(temp,"USED");
			if (stristr(temp.c_str(),i_header.c_str()))
			{
				if (posizioneused>=0)
				{
					temp=temp.substr(0,posizioneused);
					int posizionechiocciola=pos(temp,"@");
					if (posizionechiocciola>0)
					{
						string primachiocciola=temp.substr(0,posizionechiocciola);
						string nomesnap=temp.substr(posizionechiocciola+1,temp.length());
						string trimmato="";
						for (unsigned int i=0;i<nomesnap.length();i++)
							if (nomesnap[i]!=' ')
								trimmato+=nomesnap[i];
							else
								break;
						nomesnap=trimmato;
						int posizionefooter=pos(nomesnap,i_footer);
						if ((i_footer=="") || (posizionefooter>=0))
						{
							nomesnap=mytrim2(nomesnap);
							o_array_dopochiocciola.push_back(nomesnap);
							primachiocciola=mytrim2(primachiocciola);
							o_array_primachiocciola.push_back(primachiocciola);	
						}
					}
				}
			}
			temp="";
		}
		i++;
	}
	delete_file(filebatch.c_str());
	return snapshotlist;
}
string	heuristic_output_search(vector<string>& i_array)
{
	for (unsigned int i=0;i<i_array.size();i++)
	{
		if ((i_array[i]=="-output") || (i_array[i]=="-out"))
			if (i+1<i_array.size())
				if (i_array[i+1]!="")
					return i_array[i+1];
	}
	return "";
}
int Jidac::zfs(string command)
{
	if (flagdebug)
	{
		myprintf("*** ZFS support functions ***\n");
		myprintf("With command %s\n",command.c_str());
	}
	if (command=="zfsadd")
		if (files.size()<3)
			{
				myprintf("For zfsadd you need at least 3 parameters\n\n");
				myprintf("*** DO NOT FORGET THE DOUBLEQUOTE ***\n\n");
				help_zfs(true,true);
				return 1;
			}
	if ((command=="zfspurge") || (command=="zfslist"))
		if (files.size()<1) 
		{
			myprintf("For zfspurge/zfslist you need at least 1 parameter\n\n");
			myprintf("*** DO NOT FORGET THE DOUBLEQUOTE ***\n\n");
			help_zfs(true,true);
			return 1;
		}
	if ((command=="zfspurge") || (command=="zfslist") || (command=="zfsadd"))
	{
		string 	header		=files[0];
		string 	footer		="";
		string	exepath		=zpaqfranzexename;
		string  zpaqfile	=""; 
		string 	onlysubdir	=""; 
		if (files.size()>1)
			footer=files[1];
		if (header=="*")
			header="";
		if (footer=="*")
			footer="";
		vector<string> array_primachiocciola;
		vector<string> array_dopochiocciola;
		string risul=zfs_get_snaplist(header,footer,array_primachiocciola,array_dopochiocciola);
		vector<string> thefile;
		explode(risul,'\n',thefile);
		if (array_primachiocciola.size()==0)
		{
			myprintf("32030: nothing to do. Do you use the doublequote?\n");
			return 1;
		}
		string	myoutput=heuristic_output_search(files);
		if (myoutput!="")
			open_output(myoutput);
		if (command=="zfsadd")
		{
			if (flagdebug)
				for (unsigned int i=0;i<files.size();i++)
					myprintf("Files  %d %s\n",i,files[i].c_str());
			zpaqfile	=files[2];
			if (files.size()>3)
			{
				if ((files[3]!="-output") && (files[3]!="-out"))
				{
					onlysubdir=files[3];
					if (onlysubdir[0]=='/') 
						onlysubdir.erase(0,1);
					if (onlysubdir!="")
						if (!isdirectory(onlysubdir))
						onlysubdir+="/";
				}
			}
			{
				myprintf("Exepath  : %s\n",exepath.c_str());
				myprintf("Zpaqfile : %s\n",zpaqfile.c_str());
				myprintf("Header   : %s\n",header.c_str());
				myprintf("Footer   : %s\n",footer.c_str());
				if (onlysubdir!="")
					myprintf("Subdir   : %s\n",onlysubdir.c_str());
				if (myoutput!="")
					myprintf("Output on: %s\n",myoutput.c_str());
			}
		}
		vector<string> 	snapshot_folder;
		vector<int64_t>	snapshot_date;
		vector<string>  snapshot_to;
		for (unsigned int i=0;i<array_primachiocciola.size();i++)
		{
			string prima_chiocciola	=array_primachiocciola	[i];
			string dopo_chiocciola	=array_dopochiocciola	[i];
			string tutto=prima_chiocciola+"@"+dopo_chiocciola;
			string doublecheck=tutto+" "; 
			bool flagtrovato=false;
			for (unsigned int j=0;j<thefile.size();j++)
				if (pos(thefile[j],doublecheck)>=0)
				{
					flagtrovato=true;
					break;
				}
			if (flagtrovato)
			{
				if (command=="zfsadd")
				{
					if (prima_chiocciola[0]!='/') 
						prima_chiocciola="/"+prima_chiocciola;
					string percorso=prima_chiocciola+"/.zfs/snapshot/"+dopo_chiocciola+"/";
					string timestamp=dopo_chiocciola;
					myreplace(timestamp,footer,"");
					int64_t testdate=encodestringdate(timestamp);
					if (testdate==-1)
					{
						myprintf("30640: timestamp is strange %s\n",timestamp.c_str());
						return 2;
					}
					else
					{
						snapshot_date.push_back(testdate);
						snapshot_folder.push_back(percorso+onlysubdir);
						snapshot_to.push_back(prima_chiocciola+"/"+onlysubdir);
					}
					tutto=exepath+" a "+zpaqfile+" "+percorso+onlysubdir+" -to "+prima_chiocciola+"/"+onlysubdir+" -timestamp "+timestamp;
				}
				else
				if (command=="zfspurge")
					myprintf("zfs destroy ");
				if (!flagforce)
				myprintf("%s\n",tutto.c_str());
			}
			else
			{
				myprintf("30816: guru evalutating <<%s>>\n",doublecheck.c_str());
				return 2;
			}
		}
		if (g_output_handle)
		{
			fclose(g_output_handle);
		chmod(g_output.c_str(),0700);
		}
		if ((command=="zfsadd") && (flagforce)) 
			if (snapshot_date.size()>0)
			{
				archive=zpaqfile;
				bool allok=true;
				for (unsigned int i=0;i<snapshot_date.size();i++)
				{
					printbar('-');
					myprintf("Freezing %8s of %8s snapshots\n",migliaia(i+1),migliaia2(snapshot_date.size()));
					reset();
					myprintf("Folder %s\n",snapshot_folder[i].c_str());
					myprintf("To     %s\n",snapshot_to[i].c_str());
					files.push_back(snapshot_folder[i]);
					date=snapshot_date[i];
					tofiles.push_back(snapshot_to[i]);
					command='a'; 
					if (add()!=0)
						allok=false;
				}
				if (!allok)
					return 2;
			}
	}
	return 0;
}
int Jidac::zero()
{
	myprintf("*** Delete empty folders (zero length) *** ");
	if (!flagforcezfs)
		myprintf("* ignoring .zfs and :$DATA ");
	myprintf("\n");
	if (files.size()==0)
	{
		myprintf("40127: no folder selected\n");
		return 1;
	}
	flagverbose=true;
	int risultato=0;
	for (unsigned i=0; i<files.size(); ++i)
		risultato+=removeemptydirs(files[i],flagkill);
	return risultato;
}	
int Jidac::robocopy()
{
	int risultato=0;
	myprintf("*** ROBOCOPY MODE *** ");
	if (!flagkill)
		myprintf("*** -kill missing: dry run *** ");
	if (!flagforcezfs)
		myprintf("*** ignoring .zfs and :$DATA ***");
	myprintf("\n");
	if (files.size()<2)
	{
		myprintf("40188: at least two folders needed\n");
		return 1;
	}
	if (!direxists(files[0]))
	{
		myprintf("27420: Master dir does not exists\n");
		return 1;
	}
	vector<string> checkdupe;
	for (unsigned int i=0;i<files.size();i++)
	{
		if (!isdirectory(files[i]))
				files[i]=files[i]+'/';
		string	outputfolder=files[i];
		checkdupe.push_back(outputfolder);
	}
	if (flagdebug)
	{
		myprintf("Size checkdup %s\n",migliaia(checkdupe.size()));
		for (unsigned int i=0;i<files.size();i++)
			myprintf("40228: %03d files[i] %s  checkdupe [i] |%s|\n",i,files[i].c_str(),checkdupe[i].c_str());
	}
	for (unsigned int i=1;i<files.size();i++)
		if (checkdupe[0]==checkdupe[i])
		{
			myprintf("40222: a slave dir is == to the master, quit\n");
			return 1;
		}
	franzparallelscandir(false,true,true);
	if (!flagspace)
		if (files_size[0]>0)
		{
			bool	spazioinsufficiente=false;
			for (unsigned int i=1;i<files.size();i++)
			{
				int64_t spaziolibero=getfreespace(files[i]);
				if (spaziolibero>=0)
				{
					if (files_size[0]>spaziolibero)
					{
						myprintf("27437: space needed %s but only %s reported free on <<%s>>\n",tohuman(files_size[0]),tohuman2(spaziolibero),files[i].c_str());
						spazioinsufficiente=true;
					}
				}
			}
			if (spazioinsufficiente)
			{
				myprintf("27441: exit, not enough space; use -space if you want\n");
				return 1;
			}
		}
	int64_t 	startscan=mtime();
	uint64_t 	strangethings;
	myprintf("\nMaster  %s (%s files %s) <<%s>>\n",migliaia(files_size[0]),tohuman(files_size[0]),migliaia2(files_count[0]),files[0].c_str());
	printbar('-');
	int64_t total_size				=files_size[0];
	int64_t total_count				=files_count[0];
	int64_t done_size				=0;
	int64_t done_count				=0;
	int64_t written_size			=0;
	int robocopied					=0;
	uint64_t robocopiedsize			=0;
	int robodeleted					=0;
	uint64_t robodeletedsize		=0;
	int roboequal					=0;
	uint64_t roboequalsize			=0;
	int64_t timecopy				=0;
	int64_t timedelete				=0;
	int xlscopied					=0;
	uint64_t xlscopiedsize			=0;
	g_robocopy_check_sorgente		=0;
	g_robocopy_check_destinazione	=0;
	for (unsigned i=1; i<files.size(); ++i)
	{
		strangethings=0;
		if (flagkill)
			if (!exists(files[i]))
				makepath(files[i]);
		if (!exists(files[i]))
		{
			if (!flagkill)
			{
				myprintf("Dir %d (slavez) DOES NOT EXISTS %s\n",i,files[i].c_str());
				risultato=1;
			}
		}
		else
		{
			int64_t startdelete=mtime();
			for (DTMap::iterator p=files_edt[i].begin(); p!=files_edt[i].end(); ++p) 
			{
				string filenamei=p->first;
				string filename0=filenamei;
				myreplace(filename0,files[i],files[0]);
				DTMap::iterator cerca=files_edt[0].find(filename0);
				if  (cerca==files_edt[0].end())
				{
					if (flagdebug)
						myprintf("Delete %s\n",p->first.c_str());
					if (!flagkill)
					{
						robodeleted++;
						robodeletedsize+=p->second.size;
					}
					else
					{
						string temp=p->first;
						bool riuscito=true;
						if (isdirectory(temp))
						{
							stermina(temp); 
							riuscito=delete_dir(temp.c_str())==0;
						}
						else
						{ 
							delete_file(temp.c_str());
						}
						if (!riuscito)
							myprintf("31293: ERROR DELETING  <%s>\n",p->first.c_str());
						else
						{
							robodeleted++;
							robodeletedsize+=p->second.size;
						}
					}
				}
				if (menoenne>0)
					if (strangethings>menoenne)
					{
						myprintf("30146: **** TOO MANY STRANGE THINGS (-n %d)  %s\n",menoenne,migliaia(strangethings));
						break;
					}
			}	
			timedelete=mtime()-startdelete;
			int64_t globalstartcopy=mtime();
			for (DTMap::iterator p=files_edt[0].begin(); p!=files_edt[0].end(); ++p) 
			{
				string filename0=p->first;
				string filenamei=filename0;
				myreplace(filenamei,files[0],files[i]);
				DTMap::iterator cerca=files_edt[i].find(filenamei);
				int64_t dest_size=-1;
				int64_t dest_date=-1;
				int64_t dest_attr=-1;
				if  (cerca==files_edt[i].end())
				{
				}
				else
				{
					dest_size=cerca->second.size;
					dest_date=cerca->second.date;
					dest_attr=cerca->second.attr;
				}
					int64_t startcopy=mtime();
					string copyfileresult=secure_copy_file(
					filename0,filenamei,globalstartcopy,total_size*(files.size()-1),total_count*(files.size()-1),written_size,done_size,done_count,
					p->second.size,
					p->second.date,
					p->second.attr,
					dest_size,
					dest_date,
					dest_attr);
					if ((copyfileresult!="OK") && (copyfileresult!="="))
					{
						myprintf("31170: error robocoping data  <%s> to %s\n",copyfileresult.c_str(),filenamei.c_str());
						risultato=2;
					}
					else
					{
						if (!isdirectory(filename0))
						{
							if (copyfileresult=="OK")
							{
								robocopiedsize+=p->second.size;
								robocopied++;
								if (!flagdonotforcexls)
									if (isxls(filename0))
									{
										xlscopiedsize+=p->second.size;
										xlscopied++;
									}
								timecopy+=mtime()-startcopy;
							}
							else
							{
								roboequalsize+=p->second.size;
								roboequal++;
							}
						}
					}
				if (menoenne>0)
					if (strangethings>menoenne)
					{
						myprintf("30125: **** TOO MANY STRANGE THINGS (-n %d)  %s\n",menoenne,migliaia(strangethings));
						break;
					}
			}
		}
	}	
	timecopy++; 
	timedelete++;
	myprintf("\n");
	if (!flagkill)
		myprintf("FAKE: dry run!\n");
	myprintf("=   %12s %20s B\n",migliaia(roboequal),migliaia2(roboequalsize));
	myprintf("+   %12s %20s B in %9.2fs %15s/sec\n",migliaia(robocopied),migliaia2(robocopiedsize),(timecopy/1000.0),migliaia3((uint64_t)(robocopiedsize/(timecopy/1000.0))));
	if (xlscopied>0)
	myprintf("xls %12s %20s B\n",migliaia(xlscopied),migliaia2(xlscopiedsize));
	myprintf("-   %12s %20s B in %9.2fs %15s/sec\n",migliaia(robodeleted),migliaia2(robodeletedsize),(timedelete/1000.0),migliaia3((uint64_t)(robodeletedsize/(timedelete/1000.0))));
	myprintf("\nRobocopy time  %9.2f s\n",((mtime()-startscan)/1000.0));
	myprintf("Slaves getinfo %9.2f s\n",g_robocopy_check_destinazione/1000.0);
	myprintf("Written bytes %s (%s)\n",migliaia(written_size),tohuman(written_size));
	if (not flagverify)
		return risultato;
	myprintf("*** ROBOCOPY: do a (-verify) ");
	if (!flagforcezfs)
		myprintf(" ignoring .zfs and :$DATA");
	myprintf("\n");
	return dircompare(false,true);
}
int Jidac::dircompare(bool i_flagonlysize,bool i_flagrobocopy)
{
	bool hashscelto=ischecksum();
	if (flagchecksum)
		if (!hashscelto)
			flagxxh3=true;
	int risultato=0;
	if (i_flagonlysize)
		myprintf("Get directory size ");
	else
	{
		if (!i_flagrobocopy)
			myprintf("Dir compare (%s dirs to be checked) ",migliaia(files.size()));
		if (files.size()<2)
			error("28212: At least two directories required\n");
	}
	if (!flagforcezfs)
			myprintf(" ignoring .zfs and :$DATA\n");
	franzparallelscandir(flagchecksum,true,true);
	printbar('=');
	for (unsigned i=0; i<files.size(); ++i)
	{
		int64_t spazio=getfreespace(files[i]);
		if (spazio<0)
			spazio=0;
		myprintf("Free %d %21s (%12s)  <<%s>>\n",i,migliaia(spazio),tohuman(spazio),files[i].c_str());
		if (minsize)
			if (minsize>(uint64_t)spazio)
			{
				myprintf("***************************************\n");
				myprintf("|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|\n");
				myprintf("WARN: free space < of minsize   %19s  %19s\n",migliaia(spazio),migliaia2(minsize));
				myprintf("|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|=|\n");
				myprintf("***************************************\n");
			}
	}
	uint64_t total_size	=0;
	int64_t delta_size	=0;
	int64_t delta_files	=0;
	printbar('=');
	for (unsigned int i=0;i<files_size.size();i++)
	{
		if (i==0)
			myprintf("Dir  %d %21s |%12s| |%12s| %9.2f <<%s>>\n",i,migliaia(files_size[i]),"Delta bytes",									 migliaia3(files_count[i]),files_time[i]/1000.0,files[i].c_str());
		else
		{
			myprintf("Dir  %d %21s |%12s| |%12s| %9.2f <<%s>>\n",i,migliaia(files_size[i]),tohuman(myabs(files_size[0],files_size[i])),migliaia3(files_count[i]),files_time[i]/1000.0,files[i].c_str());
			delta_size	+= myabs(files_size[0],files_size[i]);
			delta_files	+= myabs(files_count[0],files_count[i]);
		}
		total_size	+=files_size[i];
	}
	printbar('=');
	myprintf("Total  |%21s| (%s)\n",migliaia(total_size),tohuman(total_size));
	myprintf("Delta  |%21s| %21s|files\n",migliaia(delta_size),migliaia2(delta_files));
	if (i_flagonlysize)
		return 0;
	uint64_t strangethings;
	myprintf("\nDir 0 (master) %s (files %s) <<%s>>\n",migliaia(files_size[0]),migliaia2(files_count[0]),files[0].c_str());
	printbar('-');
	bool flagerror=false;
	for (unsigned i=1; i<files.size(); ++i)
	{
		strangethings=0;
		if (!exists(files[i]))
		{
			myprintf("[%03d] ERROR DOES NOT EXISTS <<",i);
			printUTF8(files[i].c_str());
			myprintf(">>\n");
			flagerror=true;
			risultato=1;
		}
		else
		{
			if ((files_size[i]!=files_size[0]) || (files_count[i]!=files_count[0]))
			{
				myprintf("Dir %d (slave) IS DIFFERENT time %6g <<%s>>\n",i,files_time[i]/1000.0,files[i].c_str());
				myprintf("size  %24s (files %s)\n",migliaia(files_size[i]),migliaia2(files_count[i]));
			}
			for (DTMap::iterator p=files_edt[0].begin(); p!=files_edt[0].end(); ++p) 
			{
				string filename0=p->first;
				string filenamei=filename0;
				myreplace(filenamei,files[0],files[i]);
				DTMap::iterator cerca=files_edt[i].find(filenamei);
				if  (cerca==files_edt[i].end())
				{
					myprintf("missing (not in %d) ",i);
					printUTF8(filename0.c_str());
					myprintf("\n");
					flagerror=true;
					strangethings++;
				}
				if (menoenne>0)
					if (strangethings>menoenne)
					{
						myprintf("30125: **** TOO MANY STRANGE THINGS (-n %d)  %s\n",menoenne,migliaia(strangethings));
						break;
					}
			}
			for (DTMap::iterator p=files_edt[i].begin(); p!=files_edt[i].end(); ++p) 
			{
				string filenamei=p->first;
				string filename0=filenamei;
				myreplace(filename0,files[i],files[0]);
				DTMap::iterator cerca=files_edt[0].find(filename0);
				if  (cerca==files_edt[0].end())
				{
					myprintf("excess  (not in 0) ");
					printUTF8(filename0.c_str());
					myprintf("\n");
					flagerror=true;
					strangethings++;
				}
				if (menoenne>0)
					if (strangethings>menoenne)
					{
						myprintf("30146: **** TOO MANY STRANGE THINGS (-n %d)  %s\n",menoenne,migliaia(strangethings));
						break;
					}
			}	
			for (DTMap::iterator p=files_edt[0].begin(); p!=files_edt[0].end(); ++p) 
			{
				string filename0=p->first;
				string filenamei=filename0;
				myreplace(filenamei,files[0],files[i]);
				DTMap::iterator cerca=files_edt[i].find(filenamei);
				if  (cerca!=files_edt[i].end())
				{
					if (p->second.size!=cerca->second.size)
					{
						myprintf("diff size  %18s (0) %18s (%d) %s\n",migliaia(p->second.size),migliaia2(cerca->second.size),i,filename0.c_str());
						flagerror=true;
						strangethings++;
					}
					else
					if (flagchecksum)
					{
						if (p->second.hexhash!=cerca->second.hexhash)
						{
							myprintf("%s different %s (0) vs %s (%d) ",mygetalgo().c_str(),p->second.hexhash.c_str(),cerca->second.hexhash.c_str(),i);
							printUTF8(filename0.c_str());
							myprintf("\n");
							flagerror=true;
							strangethings++;
						}
					}
				}
				if (menoenne>0)
					if (strangethings>menoenne)
					{
						myprintf("30146: **** TOO MANY STRANGE THINGS (-n %d)  %s\n",menoenne,migliaia(strangethings));
						break;
					}
			}
			if (!flagerror)
				if ((files_size[i]==files_size[0]) && (files_count[i]==files_count[0]))
				{
					myprintf("[%03d] == <<",i);
					printUTF8(files[i].c_str());	
					myprintf(">>\n");
				}
			printbar('-');
		}
	}	
	if (!flagerror)
	{
		if (flagchecksum)
			myprintf("NO diff FOR SURE in slave dirs (checksum check %s)\n",mygetalgo().c_str());
		else
			myprintf("NO diff in slave dirs (fast check, only size)\n");
	}
	else
	{
		myprintf("DIFFERENT SLAVE DIRS!!\n");
		risultato=2;
	}
	return risultato;
}
int64_t Jidac::franzparallelscandir(bool i_flaghash,bool i_recursive,bool i_forcedir)
{
	if (flagverbose)
		flagnoeta=true;
	files_edt.clear();
	files_size.clear();
	files_count.clear();
	files_time.clear();
	g_arraybytescanned.clear();
	g_arrayfilescanned.clear();
	if (files.size()==0)
	{
		if (flagdebug)
			myprintf("28403: files.size zero\n");
		return 0;
	}
	if (i_forcedir)
		for (unsigned i=0; i<files.size(); ++i)
			if (!isdirectory(files[i]))
				files[i]+='/';
	int64_t startscan=mtime();
	int quantifiles			=0;
	g_bytescanned			=0;
	g_worked				=0;
	if (flagssd)	
	{
		vector<tparametri> 	vettoreparametri;
		vector<DTMap>		vettoreDT;
		tparametri 	myblock;
		DTMap		mydtmap;
		for (unsigned int i=0;i<files.size();i++)
		{
			vettoreDT.push_back(mydtmap);
			myblock.tnumber=i;
			myblock.directorytobescanned=files[i];
			myblock.recursive=i_recursive;
			myblock.theDT=vettoreDT[i];
			myblock.flagcalchash=i_flaghash;
			myblock.timestart=mtime();
			myblock.timeend=myblock.timestart;
			vettoreparametri.push_back(myblock);
		}
		int rc;
		pthread_t* threads = new pthread_t[files.size()];
		pthread_attr_t attr;
		void *status;
		pthread_attr_init(&attr);
		pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_JOINABLE);
		myprintf("Creating %s scan threads\n",migliaia(files.size()));
		if (!flagsilent)
			if (!flagnoeta)
		{
			setupConsole();
			printf("\033[?25l");	
			fflush(stdout);
			restoreConsole();
		}
		for(unsigned int i = 0; i < files.size(); i++ ) 
		{
			print_datetime();
			myprintf("Scan dir |%02d| <<%s>>\n",i,files[i].c_str());
		}
		for(unsigned int i = 0; i < files.size(); i++ ) 
		{
			g_arraybytescanned.push_back(0);
			g_arrayfilescanned.push_back(0);
			rc = pthread_create(&threads[i], &attr, scansiona, (void*)&vettoreparametri[i]);
			if (rc) 
			{
				myprintf("Error creating thread\n");
				exit(-1);
			}
		}
		myprintf("\n");
		pthread_attr_destroy(&attr);
		for(unsigned int i = 0; i < files.size(); i++ ) 
		{
			rc = pthread_join(threads[i], &status);
			if (rc) 
			{
				error("Unable to join\n");
				exit(-1);
			}
		}
		if (!flagsilent)
			if (!flagnoeta)
		{
			setupConsole();
			printf("\033[%dB",(int)g_arraybytescanned.size());
			printf("\033[?25h");
			fflush(stdout);
			restoreConsole();
		}
		myprintf("\nParallel scan ended in %f s\n",(mtime()-startscan)/1000.0);
		for (unsigned i=0; i<files.size(); ++i)
		{
			uint64_t sizeofdir=0;
			uint64_t dircount=0;
			for (DTMap::iterator p=vettoreparametri[i].theDT.begin(); p!=vettoreparametri[i].theDT.end(); ++p) 
			{
				string filename=rename(p->first);
				if (p->second.date && p->first!="" && (!isdirectory(p->first)) && (!isads(filename))) 
				{
					sizeofdir+=p->second.size;
					dircount++;
					quantifiles++;
				}
				if (flagdebug)
				{
					printUTF8(filename.c_str());
					myprintf("\n");
				}
			}
			files_edt.push_back(vettoreparametri[i].theDT);
			files_size.push_back(sizeofdir);
			files_count.push_back(dircount);
			files_time.push_back(vettoreparametri[i].timeend-vettoreparametri[i].timestart+1);
		}
		delete[] threads;
	}
	else
	{	
		g_arraybytescanned.push_back(0);
		g_arrayfilescanned.push_back(0);
		for (unsigned i=0; i<files.size(); ++i)
		{
			DTMap myblock;
			print_datetime();
			myprintf("Scan dir <<%s>>\n",files[i].c_str());
			uint64_t blockstart=mtime();
			myscandir(0,myblock,files[i].c_str(),i_recursive,i_flaghash);
			uint64_t sizeofdir=0;
			uint64_t dircount=0;
			for (DTMap::iterator p=myblock.begin(); p!=myblock.end(); ++p) 
			{
				string filename=rename(p->first);
				if (p->second.date && p->first!="" && (!isdirectory(p->first)) && (!isads(filename))) 
				{
					sizeofdir+=p->second.size;
					dircount++;
					quantifiles++;
				}
				if (flagdebug)
				{
					printUTF8(filename.c_str());
					myprintf("\n");
				}
			}
			files_edt.push_back(myblock);
			files_size.push_back(sizeofdir);
			files_count.push_back(dircount);
			files_time.push_back(mtime()-blockstart);
		}
	}
	return mtime()-startscan;
}	
int Jidac::fillami() 
{
#ifdef ESX
	myprintf("GURU: sorry: ESXi does not like this things\n");
	seppuku();
#endif
	if (files.size()!=1)
	{
		myprintf("FILL: exactly one directory\n");
		return 2;
	}
	if (!isdirectory(files[0]))
	{
		myprintf("FILL: you need to specify a directory, not a file (last bar)\n");
		return 2;
	}
	moreprint("");
	if (flagzero)
	moreprint("Almost all free space will be filled by zeroed 512MB files.");
	else
	moreprint("Almost all free space will be filled by pseudorandom 512MB files,");
	if (!flagzero)
	moreprint("then checked from the ztempdir-created folder (2GB+ needed).");
	moreprint("");
	moreprint("These activities can reduce the media life,");
	moreprint("especially for solid state drives (SSDs) and if repeated several times.");
	moreprint("");
	if (flagforce)
	{
		moreprint("*** Temporary files are NOT deleted (no -force, to enforce zfs's scrub) ***");
		moreprint("");
	}
	if (!getcaptcha("ok","Fill (wipe) free space"))
				return 1;
	string outputdir=files[0]+"ztempdir/";
	makepath(outputdir);
	if (!direxists(outputdir))
	{
		myprintf("\n28599: impossible to makepath %s\n",outputdir.c_str());
		return 2;
	}
	unsigned int percent=99;
	int64_t spazio=getfreespace(outputdir);
	myprintf("Free space %12s (%s) <<%s>>\n",migliaia(spazio),tohuman(spazio),outputdir.c_str());
	if (!flagzero)
		if (spazio<600000000)
		{
			myprintf("28607: less than 600.000.000 bytes free on %s\n",outputdir.c_str());
			return 2;
		}
	uint64_t spacetowrite=spazio*percent/100;
	myprintf("To write   %12s (%s) %d percent\n",migliaia(spacetowrite),tohuman(spacetowrite),percent);
	uint32_t chunksize=(2<<28)/sizeof(uint32_t); 
	int chunks=spacetowrite/(chunksize*sizeof(uint32_t));
	chunks--; 
	if (chunks<=0)
	{
		if (flagzero)
			chunks=1;
		else
		{
			myprintf("Abort: there is something strange on free space (2GB+)\n");
			return 1;
		}
	}
	myprintf("%d chunks of (%s) will be written\n",chunks,tohuman(chunksize*sizeof(uint32_t)));
	uint32_t *buffer32bit = (uint32_t*)malloc(chunksize*sizeof(uint32_t));
	if (buffer32bit==0)
	{
		myprintf("28628: GURU cannot alloc the buffer\n");
		return 2;
	}
	uint64_t starttutto=mtime();	
	uint64_t hashtime=0;
	uint64_t totaliotime=0;
	uint64_t totalhashtime=0;
	uint64_t totalrandtime=0;
	vector<string> chunkfilename;     
	vector<string> chunkhash;     
	assert(outputdir.size()<200);
	char mynomefile[200+100];
	memset(buffer32bit,0,chunksize*4);
	for (int i=0;i<chunks;i++)
	{
		uint64_t startrandom=mtime();
		if (!flagzero)
			populateRandom_xorshift128plus(buffer32bit, chunksize,324+i,4444+i);
		uint64_t randtime=mtime()-startrandom;
		uint64_t starthash=mtime();
		XXH3_state_t state128;
		(void)XXH3_128bits_reset(&state128);
		(void)XXH3_128bits_update(&state128, buffer32bit, chunksize*4);
		XXH128_hash_t myhash=XXH3_128bits_digest(&state128);
		char risultato[33];
		sprintf(risultato,"%016llX%016llX",(unsigned long long)myhash.high64,(unsigned long long)myhash.low64);
		chunkhash.push_back(risultato);
		hashtime=mtime()-starthash;
		sprintf(mynomefile,"%szchunk_%05d_$%s",outputdir.c_str(),i,risultato);
		chunkfilename.push_back(mynomefile);
		double percentuale=(double)i/(double)chunks*100.0;
		if (i==0)
			percentuale=0;
		myprintf("%03d%% ",(int)percentuale);
		uint64_t startio=mtime();
		FILE* myfile=fopen(mynomefile, "wb");
		fwrite(buffer32bit, sizeof(uint32_t), chunksize, myfile);
		fclose(myfile);			
		uint64_t iotime=mtime()-startio;
		uint64_t randspeed=(uint64_t)	(chunksize*sizeof(uint32_t)/((randtime+1)/1000.0));
		uint64_t hashspeed=(uint64_t)	(chunksize*sizeof(uint32_t)/((hashtime+1)/1000.0));
		uint64_t iospeed=(uint64_t)	(chunksize*sizeof(uint32_t)/((iotime+1)/1000.0));
		double trascorso=(mtime()-starttutto+1)/1000.0;
		double eta=((double)trascorso*(double)chunks/(double)i)-trascorso;
		if (i==0)
			eta=0;
		if (eta<356000)
		{
			myprintf("ETA %0d:%02d:%02d",int(eta/3600), int(eta/60)%60, int(eta)%60);
			myprintf(" todo (%10s) rnd (%10s/s) hash (%10s/s) W (%10s/s)",
			tohuman(sizeof(uint32_t)*uint64_t(chunksize)*(uint64_t)(chunks-i)),
			tohuman2(randspeed),
			tohuman3(hashspeed),
			tohuman4(iospeed));
			if (flagverbose)
				myprintf("\n");
			else
				myprintf("\r");
		}
		totaliotime		+=iotime;
		totalrandtime	+=randtime;
		totalhashtime	+=hashtime;
	}
	uint64_t timetutto=mtime()-starttutto;
	myprintf("Total time %f  rnd %f  hash %f  write %f\n",timetutto/1000.0,totalrandtime/1000.0,totalhashtime/1000.0,totaliotime/1000.0);
	free(buffer32bit);
	if (chunkfilename.size()!=chunkhash.size())
	{
		myprintf("Guru 23925: filename size != hash size\n");
		return 2;
	}
	if (chunkfilename.size()!=(unsigned int)chunks)
	{
		myprintf("Abort: expecting %d chunks but %d founded\n",chunks,(unsigned int)chunkfilename.size());
		return 2;
	}
	bool flagallok=true;
	bool doverify=true;
	if (flagzero)
		if (!flagverify)
			doverify=false;
	if (doverify)
	{
		myprintf("******* VERIFY\n");
		g_bytescanned=0;
		g_filescanned=0;
		g_worked=0;
		edt.clear();
		int64_t lavorati=0;
		uint64_t startverify=mtime();
		for (int unsigned i=0;i<chunkfilename.size();i++)
		{
			string filename=chunkfilename[i];
			myprintf("Reading chunk %05d ",i);
			uint32_t dummycrc32;
			string filehash=xxhash_calc_file(filename.c_str(),false,dummycrc32,-1,-1,lavorati);
			uint64_t hashspeed=(uint64_t)(lavorati/((mtime()-startverify+1)/1000.0));
			myprintf(" (%12s/s) ",tohuman(hashspeed));
			bool flagerrore=(filehash!=chunkhash[i]);
			if (flagerrore)
			{
				myprintf("ERROR\n");
				flagallok=false;
			}
			else
			{
				myprintf("OK %s",chunkhash[i].c_str());
				if (flagverbose)
					myprintf("\n");
				else
					myprintf("\r");
			}
		}
		myprintf("\n");
		uint64_t verifytime=mtime()-startverify;
		myprintf("Verify time %f (%10s) speed (%10s/s)\n",verifytime/1000.0,tohuman(lavorati),tohuman2((uint64_t)(lavorati/(verifytime/1000.0))));
	}
	if (flagallok)
	{
		myprintf("+OK all OK\n");
		if (!flagforce)
		{
			for (int unsigned i=0;i<chunkfilename.size();i++)
			{
				delete_file(chunkfilename[i].c_str());
				myprintf("Deleting tempfile %05d / %05d\r",i,(unsigned int)chunkfilename.size()-1);
			}
			delete_dir(outputdir.c_str());
			myprintf("\n");
		}
		else
		{
			myprintf("REMEMBER: temp file in %s\n",outputdir.c_str());
		}
	}	
	else
		myprintf("ERROR: SOMETHING WRONG\n");
	return 0;
}
string my_realpath(std::string const& i_path) 
{
	char buf[33000]; 
    char *res=realpath(i_path.c_str(),buf);
    if (res) 
	{ 
		return buf;
    } 
	else 
	{
		if (flagdebug)
			myprintf("38761: error on realpath of %s\n",i_path.c_str());
		return i_path;
    }
}
int  Jidac::dir() 
{
	bool barras	=false;
	bool barraos=false;
	bool barraod=false;
	bool barraa	=false;
#ifndef ESX
	if (files.size()==0)
	{
		if (flagdebug)
			myprintf("38759: push .\n");
		files.push_back(".");
	}
#endif
	string cartella=files[0];
	if ((cartella=="/s") || (cartella=="/os") || (cartella=="/od") || (cartella=="/a"))
	{
		files.push_back(cartella);
		files[0]="./";
		cartella=files[0];
	}
	if (cartella==".")
			cartella+='/';
	if (flagdebug)
		myprintf("38802: folder before %s\n",cartella.c_str());
	string nuovacartella=my_realpath(cartella);
	if (flagdebug)
		myprintf("38805: folder after %s\n",nuovacartella.c_str());
	if	(!isdirectory(nuovacartella))
		nuovacartella+='/';
	if (cartella!=nuovacartella)
	{
		myprintf("38798: WARNING path : <<");
		printUTF8(cartella.c_str());
		myprintf(">>\nresolved to         : <<");
		printUTF8(nuovacartella.c_str());
		myprintf(">>\n");
	}
	cartella=nuovacartella;
	files[0]=cartella;
	if (!isdirectory(cartella))
		if (!realfileexists(cartella))
			if (direxists(cartella))
				cartella+='/';
	if (files.size()>1)
		for (unsigned i=0; i<files.size(); i++) 
		{
				barras	|=(stringcomparei(files[i],"/s"));
				barraos	|=(stringcomparei(files[i],"/os"));
				barraod	|=(stringcomparei(files[i],"/od"));
				barraa	|=(stringcomparei(files[i],"/a"));
		}
	myprintf("==== Scanning dir <<");
	printUTF8(cartella.c_str());
	myprintf(">> ");
	if (barras)
		myprintf(" /s");
	if (barraos)
		myprintf(" /os");
	if (barraod)
		myprintf(" /od");
	if (barraa)
		myprintf(" /a");
	myprintf("\n");
	bool		flagduplicati	=false;
	int64_t 	total_size		=0;
	int 		quantifiles		=0;
	int 		quantedirectory	=0;
	int64_t		dummylavorati	=0;
	int			quantihash		=0;
	int64_t		hash_calcolati	=0;
	uint64_t	iniziohash		=0;
	uint64_t	finehash			=0;
	flagduplicati=ischecksum(); 
	if (flagchecksum)
			flagduplicati=false;
	g_bytescanned=0;
	g_filescanned=0;
	g_worked=0;
	scandir(true,edt,cartella,barras);
	printbar(' ',false);
	myprintf("\r");
	vector <s_fileandsize> fileandsize;
	for (DTMap::iterator p=edt.begin(); p!=edt.end(); ++p) 
	{
		bool flagaggiungi=true;
		if (searchfrom!="")
			flagaggiungi &= (stristr(p->first.c_str(),searchfrom.c_str())!=0);
		if (flagaggiungi)
		{
			s_fileandsize myblock;
			myblock.filename=p->first;
			myblock.size=p->second.size;
			myblock.attr=p->second.attr;
			myblock.date=p->second.date;
			myblock.isdir=isdirectory(p->first);
			myblock.flaghashstored=false;
			if (flagduplicati)
			{
				if (!myblock.isdir)
				{
					if (minsize)
					{
						if (myblock.size>minsize)
							fileandsize.push_back(myblock);
					}
					else
					if (maxsize)
					{
						if (myblock.size<minsize)
							fileandsize.push_back(myblock);
					}
					else
						fileandsize.push_back(myblock);
				}
			}
			else
				fileandsize.push_back(myblock);
		}
	}
	if (flagduplicati)
	{
		if (flagdebug)
		{
			myprintf("Pre-sort\n");
			for (unsigned int i=0;i<fileandsize.size();i++)
				myprintf("PRE %08d  %s %s\n",i,migliaia(fileandsize[i].size),fileandsize[i].filename.c_str());
		}
		sort(fileandsize.begin(),fileandsize.end(),comparefilenamesize);
		if (flagdebug)
		{
			myprintf("Post-sort\n");
			for (unsigned int i=0;i<fileandsize.size();i++)
				myprintf("POST %08d  %s %s\n",i,migliaia(fileandsize[i].size),fileandsize[i].filename.c_str());
		}
		iniziohash=mtime();
		int64_t dalavorare=0;
		for (unsigned int i=0;i<fileandsize.size();i++)
			if (i<fileandsize.size()-1)
			{
				bool entrato=false;
				while (fileandsize[i].size==fileandsize[i+1].size)
				{
					if (!entrato)
					{
						dalavorare+=fileandsize[i].size;
						entrato=true;
					}
					dalavorare+=fileandsize[i+1].size;
					i++;
					if (i==fileandsize.size())
						break;
				}
			}
		myprintf("\nStart checksumming %s / %s bytes ...\n",migliaia(fileandsize.size()),migliaia2(dalavorare));
		int larghezzaconsole=terminalwidth()-2;
		if (larghezzaconsole<10)
			larghezzaconsole=80;
		int64_t ultimapercentuale=0;
		int64_t rapporto;
		int64_t percentuale;
		for (unsigned int i=0;i<fileandsize.size();i++)
		{
			if (i<fileandsize.size()-1)
			{
				bool entrato=false;
				while (fileandsize[i].size==fileandsize[i+1].size)
				{
					if (!entrato)
					{
						bool saveeta=flagnoeta;
						flagnoeta=true;
						uint32_t dummycrc;
						string temp=hash_calc_file(flag2algo(),fileandsize[i].filename.c_str(),false,dummycrc,0,0,dummylavorati);
						flagnoeta=saveeta;
						fileandsize[i].hashhex=temp;
						fileandsize[i].flaghashstored=true;
						quantihash++;
						hash_calcolati+=fileandsize[i].size;
						entrato=true;
						if (flagdebug)
							myprintf("%08d HASH %s %s %19s %s\n",i,fileandsize[i].hashhex.c_str(),dateToString(fileandsize[i].date).c_str(),migliaia(fileandsize[i].size),fileandsize[i].filename.c_str());
						else
						{
							rapporto=larghezzaconsole*hash_calcolati/(dalavorare+1);
							percentuale=100*hash_calcolati/(dalavorare+1);
							if (!flagnoeta)
							{
								myprintf("Done %03d ",(unsigned int)percentuale);
								if (percentuale>ultimapercentuale)
								{
									if (rapporto>10)
									{
										for (unsigned j=0;j<rapporto-10;j++)
											myprintf(".");
										ultimapercentuale=percentuale;
									}
								}
								myprintf("\r");
							}
						}
					}
					bool saveeta=flagnoeta;
					flagnoeta=true;
					uint32_t dummycrc;
					string temp=hash_calc_file(flag2algo(),fileandsize[i+1].filename.c_str(),false,dummycrc,0,0,dummylavorati);
					flagnoeta=saveeta;
					fileandsize[i+1].hashhex=temp;
					fileandsize[i+1].flaghashstored=true;
					quantihash++;
					hash_calcolati+=fileandsize[i+1].size;
					if (flagdebug)
						myprintf("%08d HASH-2 %s %s %19s %s\n",i+1,fileandsize[i+1].hashhex.c_str(),dateToString(fileandsize[i+1].date).c_str(),migliaia(fileandsize[i+1].size),fileandsize[i+1].filename.c_str());
					else
					{
						rapporto=larghezzaconsole*hash_calcolati/(dalavorare+1);
						percentuale=100*hash_calcolati/(dalavorare+1);
						if (!flagnoeta)
						{
							myprintf("Done %03d ",(unsigned int)percentuale);
							if (percentuale>ultimapercentuale)
								{
									if (rapporto>10)
									{
										for (unsigned j=0;j<rapporto-10;j++)
											myprintf(".");
										ultimapercentuale=percentuale;
									}
								}
							myprintf("\r");
						}
					}
					i++;
					if (i==fileandsize.size())
						break;
				}
			}
		}
		finehash=mtime();
		myprintf("\n");
		sort(fileandsize.begin(),fileandsize.end(),comparecrc32);
		if (flagdebug)
		{
			myprintf("Hash taken %08d %s\n",quantihash,migliaia(hash_calcolati));
			myprintf("Before shrink %s\n",migliaia(fileandsize.size()));
			myprintf("Time %f\n",(finehash-iniziohash)/1000.0);
			for (unsigned int i=0;i<fileandsize.size();i++)
				myprintf("before shrink %08d  %s %s\n",i,fileandsize[i].hashhex.c_str(),fileandsize[i].filename.c_str());
		}
		int limite=-1;
		for (unsigned int i=0;i<fileandsize.size(); i++)
		{
			if (flagdebug)
				myprintf("%d size %s <<%s>>\n",i,migliaia(fileandsize.size()),fileandsize[i].hashhex.c_str());
			if (!fileandsize[i].flaghashstored)
			{
				limite=i;
				break;
			}	
		}
		if (flagverbose)
		myprintf("Limit founded %d\n",limite);
		if (limite>-1)
			for (int i=fileandsize.size()-1;i>=limite;i--)
				fileandsize.pop_back();
		if (flagdebug)
		{
			myprintf("After shrink %s\n",migliaia(fileandsize.size()));
			for (unsigned int i=0;i<fileandsize.size();i++)
				myprintf("After shrinking %08d  %s %s\n",i,fileandsize[i].hashhex.c_str(),fileandsize[i].filename.c_str());
		}
		sort(fileandsize.begin(),fileandsize.end(),comparesizehash);
		if (flagdebug)
		{
			myprintf("After re-sort %s\n",migliaia(fileandsize.size()));
			for (unsigned int i=0;i<fileandsize.size();i++)
				myprintf("After re-sort %08d  %s %s\n",i,fileandsize[i].hashhex.c_str(),fileandsize[i].filename.c_str());
		}
	}
	else
	{
		if (barraod)
			sort(fileandsize.begin(),fileandsize.end(),comparefilenamedate);
		if (barraos)
			sort(fileandsize.begin(),fileandsize.end(),comparefilenamesize);
	}
	unsigned int inizio=0;
	if (menoenne)
		if (menoenne<fileandsize.size())
			inizio=fileandsize.size()-menoenne;
	int64_t tot_duplicati=0;
	for (unsigned int i=inizio;i<fileandsize.size();i++)
		if (fileandsize[i].isdir)
		{
			if (fileandsize[i].filename[0]=='.')
				if (fileandsize[i].filename[1]=='/')
					 fileandsize[i].filename=fileandsize[i].filename.substr(2,fileandsize[i].filename.size()-3);
		}
		else
		{
			if (fileandsize[i].filename[0]=='.')
				if (fileandsize[i].filename[1]=='/')
					fileandsize[i].filename=fileandsize[i].filename.substr(2,string::npos);
		}
	for (unsigned int i=inizio;i<fileandsize.size();i++)
		if (fileandsize[i].isdir)
		{
			myprintf("%s    <DIR>               ",dateToString(fileandsize[i].date,!flagutc).c_str());
			printUTF8(fileandsize[i].filename.c_str());
			myprintf("\n");
			quantedirectory++;
		}
		else
		{
			total_size+=fileandsize[i].size;
			quantifiles++;
			if (flagduplicati)
			{
				if (i<fileandsize.size()-1)
				{
					bool entrato=false;
					if (fileandsize[i].hashhex==fileandsize[i+1].hashhex)
					{
						if (flagverbose)
							myprintf("%s ",fileandsize[i].hashhex.c_str());
						myprintf("%s %19s ",dateToString(fileandsize[i].date,!flagutc).c_str(),migliaia(fileandsize[i].size));
						printUTF8(fileandsize[i].filename.c_str());
						myprintf("\n");
						while (fileandsize[i].hashhex==fileandsize[i+1].hashhex)
						{
							if (flagverbose)
							myprintf("%s ",fileandsize[i].hashhex.c_str());
							myprintf("================= %19s ",migliaia(fileandsize[i+1].size));
							printUTF8(fileandsize[i+1].filename.c_str());
							myprintf("\n");
							tot_duplicati+=fileandsize[i].size;
							entrato=true;
							i++;
							if (i==fileandsize.size())
								break;
						}
					}
					if (entrato)
						myprintf("\n");
				}
			}
			else
			{
				myprintf("%s %22s ",dateToString(fileandsize[i].date,!flagutc).c_str(),migliaia(fileandsize[i].size));
				if (flagchecksum)
				{
					uint32_t dummycrc;
					string temp=hash_calc_file(flag2algo(),fileandsize[i].filename.c_str(),false,dummycrc,0,0,dummylavorati);
					myprintf("|| %s:%s ",mygetalgo().c_str(),temp.c_str());
				}
				printUTF8(fileandsize[i].filename.c_str());
				myprintf("\n");
			}
		}
	myprintf("    %10s File %20s byte\n",migliaia(quantifiles),migliaia2(total_size));
	if (!flagduplicati)
	myprintf("    %10s dir ",migliaia(quantedirectory));
	else
	myprintf("                   ");
	if (!isdirectory(cartella))
	{
		string percorso=extractfilepath(cartella);
		if (percorso=="")
			cartella="./";
		else
			cartella=percorso;
	}
	int64_t spazio=getfreespace(cartella);
	myprintf(" %20s bytes (%s) free",migliaia(spazio),tohuman(spazio));
	myprintf("\n");
	if (flagduplicati)
	{
		myprintf("\n          Duplicated %19s byte\n",migliaia(tot_duplicati));
		myprintf("Hashed %8s files %18s bytes in %f s %s /s\n",migliaia(quantihash),migliaia2(hash_calcolati),(finehash-iniziohash)/1000.0,migliaia2((uint64_t)(hash_calcolati/((finehash-iniziohash+1)/1000.0))));
	}
	return 0;
}
int Jidac::decimation()
{
	bool flagthelastone=false;
	if (g_exec!="")
		flagthelastone=true;
	if (flagthelastone)
		myprintf("*** Run the last ones *** ");
	else
		myprintf("*** Decimation *** ");
	myprintf("*** -kill missing: dry run *** ");
	if (!flagforcezfs)
		myprintf("*** ignoring .zfs and :$DATA ***");
	myprintf("\n\n");
	if (g_exec!="")
		if (!fileexists(g_exec))
		{
			myprintf("29066: -g_exec does not exists\n");
			return 2;
		}
	if (flagthelastone)
		if (menoenne<=0)
			menoenne=1;
	if (menoenne<=0)
	{
		myprintf("28960: -n or -limit not set\n");
		return 1;
	}
	flagbarraod=true; 
	if (flagbarraon)
		flagbarraod=false; 
	if (files.size()>1)
	{
		myprintf("28966: only one dir can be elaborated\n");
		return 1;
	}
	if (mypos("*",files[0])==-1)
	{
		myprintf("29053: * pattern requested (ex. /tmp/dump_*.sql)\n");
		return 1;
	}
	franzparallelscandir(false,false,false);
	myprintf("\n");
	if (files_edt[0].size()==0)
	{
		myprintf("29048: empty result, nothing to do\n");
		return 0;
	}
	if (!flagthelastone)
		if (!flagforce)
			if (files_edt[0].size()>50)
			{
				myprintf("29024: founded lots of files (%s), no -force => quit (security measure)\n",migliaia(files_edt[0].size()));
				return 1;
			}
	vector<string> 		scannedfiles;
	if (flagbarraod)
	{
		myprintf("Order by DATE (/od or default)\n");
		vector<DTMap::iterator> filelist;
		for (DTMap::iterator a=files_edt[0].begin(); a!=files_edt[0].end(); ++a) 
			filelist.push_back(a);
		sort(filelist.begin(), filelist.end(), comparedatethenfilename);
		for (unsigned int i=0; i<filelist.size();i++)
			scannedfiles.push_back(filelist[i]->first);
	}
	else
	{
		myprintf("Order by NAME (/on)\n");
		for (DTMap::iterator p=files_edt[0].begin(); p!=files_edt[0].end(); ++p) 
			scannedfiles.push_back(p->first);
	}
	if (scannedfiles.size()<=menoenne)
	{
		if (flagthelastone)
			menoenne=scannedfiles.size();
		else
		{
			myprintf("28977: candidate %s less or equal to limit %s => do nothing\n",migliaia(menoenne),migliaia2(scannedfiles.size()));
			return 0;
		}
	}
	vector<string> tobedeleted;
	if (flagthelastone)
	{
		for (unsigned int i=1;i<=menoenne;i++)
			tobedeleted.push_back(scannedfiles[scannedfiles.size()-i]);
	}
	else
	{
		for (unsigned int i=0;i<scannedfiles.size()-menoenne;i++)
			tobedeleted.push_back(scannedfiles[i]);
		if (flagverbose)
			for (unsigned int i=scannedfiles.size()-menoenne;i<scannedfiles.size();i++)
				myprintf("KEEP   %s\n",scannedfiles[i].c_str());
	}
	myprintf("\n");
	myprintf("Candidate (to be elaborated) %12s\n",migliaia(tobedeleted.size()));
	if (tobedeleted.size()==0)
	{
		myprintf("28985: Nothing to do\n");
		return 0;
	}
	if (!flagkill)
		myprintf("28990: dry run (no -kill)\n");
	if (flagthelastone)
	{
		myprintf("Executing  %s times <<%s>>\n",migliaia(tobedeleted.size()),g_exec.c_str());
		for (unsigned int i=0;i<tobedeleted.size();i++)
		{
			myprintf("%08d with param <<%s>>\n",i+1,tobedeleted[i].c_str());
			if (flagkill)
				xcommand(g_exec,tobedeleted[i]);
		}
		return 0;
	}
	int deleted=0;
	int highlander=0;
	for (unsigned int i=0;i<tobedeleted.size();i++)
	{
		if (flagverbose)
		{
			myprintf("DELETE <<");
			printUTF8(tobedeleted[i].c_str());
			myprintf(">>\n");
		}
		if (flagkill)
		{
			if (delete_file(tobedeleted[i].c_str()))
				deleted++;
			else
				highlander++;
		}
	}
	if (deleted>0)
	myprintf("Deleted                      %12s\n",migliaia(deleted));
	if (highlander>0)
	myprintf("Highlander                   %12s\n",migliaia(highlander));
	if (highlander>0)
		return 2;
	return 0;
}	
int Jidac::add() 
{
	if (flagparanoid && flagforce)
	{
		myprintf("42681: -paranoid and -force, disabling -paranoid and keeping -force\n");
		flagparanoid=false;
	}
	getpasswordifempty();
	if (g_freeze!="")
	{
		if (maxsize>0)
		{
			if (fileexists(archive))
			{
				int64_t dimensionefile=prendidimensionefile(archive.c_str());
				if (dimensionefile>(int64_t)maxsize)
				{
					myprintf("Freezing archive size %s vs maxsize %s\n",migliaia(dimensionefile),migliaia2(maxsize));
					string filescritto=filecopy(false,false,archive,g_freeze,true,false,false);
					if (filescritto!="")
					{
						myprintf("Moved <<%s>> to <<%s>>\n",archive.c_str(),filescritto.c_str());
						myprintf("Deleting (by -freeze) <<%s>>\n",archive.c_str());
						delete_file(archive.c_str());
					}
					else
						myprintf("34971: ERROR doing -freeze from %s to %s\n",archive.c_str(),filescritto.c_str());
				}
			}
		}
		else
			error("-freeze without -maxsize");
	}
	if (flagvss)
	{
		if (flagtest)
			error("incompatible -vss and -test");
		if (flagnopath)
			error("incompatible -vss and -nopath");
	}
	g_scritti=0;
	string primalettera="";
	string cartellalocale="";
	if (flagvss)
	{
		myprintf("Volume Shadow Copies runs only on Windows\n");
	}
	string ffranzotype=decodefranzoffset(g_franzotype);
	if (flagverify)
		ffranzotype+=" + CRC-32 by fragments";
	if (flagverbose)
	myprintf("Integrity check type: %s\n",ffranzotype.c_str());
  int errors=0;
  const bool archive_exists=exists(subpart(archive, 1).c_str());
  string arcname=archive;  
  if (index) arcname=index;
  int64_t header_pos=0;
  if (exists(subpart(arcname, 1).c_str()))
    header_pos=read_archive(arcname.c_str(), &errors);
  arcname=archive;  
  int64_t offset=0;  
  char salt[32]={0};  
  if (password) libzpaq::random(salt, 32);
  if (index) {
    if (dcsize>0) error("index is a regular archive");
    if (version!=DEFAULT_VERSION) error("cannot truncate with an index");
    offset=header_pos+dhsize;
    header_pos=32*(password && offset==0);
    arcname=subpart(archive, ver.size());
    if (exists(arcname)) {
      printUTF8(arcname.c_str());
      myprintf( ": archive exists\n");
	  g_exec_text=arcname;
	  g_exec_text+=" archive exists";
      error("archive exists");
    }
    if (password) {  
      FP fp=fopen(index, RB);
      if (fp!=FPNULL) {
        if (fread(salt, 1, 32, fp)!=32) error("cannot read salt from index");
        salt[0]^='7'^'z';
        fclose(fp);
      }
    }
  }
  else {
    int parts=0;  
    string part0=subpart(archive, 0);
    if (part0!=archive) {  
      for (int i=1;; ++i) {
        string partname=subpart(archive, i);
        if (partname==part0) error("too many archive parts");
        FP fp=fopen(partname.c_str(), RB);
        if (fp==FPNULL) break;
        ++parts;
        fseeko(fp, 0, SEEK_END);
        offset+=ftello(fp);
        fclose(fp);
      }
      header_pos=32*(password && parts==0);
      arcname=subpart(archive, parts+1);
      if (exists(arcname)) error("part exists");
    }
    if (password) {
      FP fp=fopen(subpart(archive, 1).c_str(), RB);
      if (fp==FPNULL) {
        if (header_pos>32) error("archive first part not found");
        header_pos=32;
      }
      else {
        if (fread(salt, 1, 32, fp)!=32) error("cannot read salt");
        fclose(fp);
      }
    }
  }
	g_archive=arcname; 
  if (method=="") method="1";
  if (method.size()==1) {  
    if (method[0]>='2' && method[0]<='9') method+="6";
    else method+="4";
  }
  if (strchr("0123456789xs", method[0])==0)
    error("-method must begin with 0..5, x, s");
  assert(method.size()>=2);
  if (method[0]=='s' && index) error("cannot index in streaming mode");
  if (fragment<0) fragment=0;
  const int log_blocksize=20+atoi(method.c_str()+1);
  if (log_blocksize<20 || log_blocksize>31) error("blocksize must be 0..11");
  const unsigned blocksize=(1u<<log_blocksize)-4096;
  const unsigned MAX_FRAGMENT=fragment>19 || (8128u<<fragment)>blocksize-12
      ? blocksize-12 : 8128u<<fragment;
  const unsigned MIN_FRAGMENT=fragment>25 || (64u<<fragment)>MAX_FRAGMENT
      ? MAX_FRAGMENT : 64u<<fragment;
  for (unsigned i=0; i<block.size(); ++i) {
    if (method[0]=='s') {
      if (block[i].usize>=0)
        error("cannot update journaling archive in streaming format");
    }
    else if (block[i].usize<0)
      error("cannot update streaming archive in journaling format");
  }
	g_bytescanned=0;
	g_filescanned=0;
	g_worked=0;
	for (unsigned i=0; i<files.size(); ++i)
		scandir(true,edt,files[i].c_str(),!flagnorecursion);
	printbar(' ',false);
	myprintf("\r");
	unsigned int	maxfilelength=0;
  vector<DTMap::iterator> vf;
  int64_t total_size=0;  
  int64_t total_done=0;  
  int64_t total_xls=0;
  int64_t file_xls=0;
	int toolongfilenames=0;
	int adsfilenames=0;
	int utf8names=0;
	int casecollision=0;
	int	folders=0;
	FILE* myoutfile=NULL;
	string tempfile="";
	if (flagfilelist)
	{
		tempfile=g_gettempdirectory()+"VFILE-l-filelist.txt";
		myreplaceall(tempfile,"\\","/");
		myprintf("\nTemp dir <<%s>>\n",tempfile.c_str());
		myoutfile=fopen(tempfile.c_str(), "wb");
		if (myoutfile)
		{
			fprintf(myoutfile,"This is filelist for version %s\n",migliaia(ver.size()));
			for (DTMap::iterator p=edt.begin(); p!=edt.end(); ++p) 
			{
				string filename=rename(p->first);
				if (searchfrom!="")
					if (replaceto!="")
						replace(filename,searchfrom,replaceto);
				fprintf(myoutfile,"%s %19s ", dateToString(p->second.date).c_str(), migliaia(p->second.size));
				printUTF8(filename.c_str(),myoutfile);
				fprintf(myoutfile,"\n");
			}
			fclose(myoutfile);
			int64_t dimensionelista=0;
			int64_t dimensionedata=0;
			int64_t dimensioneattr=0;
			if (getfileinfo(tempfile,dimensionelista,dimensionedata,dimensioneattr))
			{
				myprintf("Uncompressed filelist size %s\n",migliaia(dimensionelista));
				addfile(false,edt,tempfile,dimensionedata,dimensionelista,dimensioneattr);
			}
		}
	} 
	if (flagparanoid)
	{
		hashselect();
		if (flagdebug)
		{
			myprintf("----files forced\n");
			for (DTMap::iterator p=edt.begin(); p!=edt.end(); ++p) 
			{
				if (p->second.forceadd)
				{
					string filename=rename(p->first);
					myprintf("43180: forceadd %s\n",filename.c_str());
				}
			}
			myprintf("----end files forced\n");
		}
	}
	for (DTMap::iterator p=edt.begin(); p!=edt.end(); ++p) 
	{
			string filename=rename(p->first);
			DTMap::iterator a=dt.find(filename);
			if (isdirectory(filename))
				folders++;
			if (strstr(filename.c_str(), ":$DATA"))
				adsfilenames++;
			if (filename.length()>255)
				toolongfilenames++;
			if (flagverbose)
				if (filename!=utf8toansi(filename))
					utf8names++;
			if (!flagdonotforcexls) 
				if (isxls(filename))
				{
					if (flagdebug)
						myprintf("\nENFORCING XLS/PPT %s\n",filename.c_str());
					total_xls+=p->second.size;
					file_xls++;
				}
			if (flagtouch)
				p->second.date+=1;  
			if (a!=dt.end()) 
				a->second.data=1;  
			if ((p->second.forceadd) || (
					(p->second.date) && (p->first!="") && (p->first[p->first.size()-1]!='/') && 
					(
						flagforce || 
						a==dt.end() || 
						( (!(isads(filename))) && (!flagdonotforcexls) && (isxls(filename))) || 
						p->second.date!=a->second.date || 
						p->second.size!=a->second.size
					)
				)) 
			{
				total_size+=p->second.size;
				int sp=0;  
				for (string::const_iterator q=p->first.begin(); q!=p->first.end(); ++q)
				{
					uint64_t c=*q&255;
					if (c>='A' && c<='Z') c+='a'-'A';
					if (c=='/') sp=0, p->second.data=0;
					else if (c=='.') sp=8, p->second.data=0;
					else if (sp>3) p->second.data+=c<<(--sp*8);
				}
				int64_t s=p->second.size>>14;
				if (s>=(1<<24)) s=(1<<24)-1;
				p->second.data+=(1<<24)-s-1;
				vf.push_back(p);
			}
	}  
	if (menoenne>0) 
	{
		int	dastampare=vf.size();
		if (menoenne<(unsigned int)dastampare)
				dastampare=menoenne;
		for (int i=0;i<dastampare; i++) 
			myprintf("PRE  %08d sort %19s |%s| |%s|\n",i,migliaia(vf[i]->second.size),vf[i]->second.hexhash.c_str(),vf[i]->first.c_str());
	}
	if (orderby.size()>0)
	{
		g_theorderby.clear();
		if (orderby[orderby.size()-1]!=';')
			orderby+=';';
		explode(orderby,';',g_theorderby);
		if (g_theorderby.size()>0)
		{
			for (unsigned int i=0;i<g_theorderby.size();i++)
			{
				if (
					(g_theorderby[i]!="ext") &&
					(g_theorderby[i]!="nilsimsa") &&
					(g_theorderby[i]!="size") &&
					(g_theorderby[i]!="name") &&
					(g_theorderby[i]!="hash") &&
					(g_theorderby[i]!="date") &&
					(g_theorderby[i]!="data") 
					)
				myprintf("\n38022: WARNING: discarded orderby |%s|\n",g_theorderby[i].c_str());
			}
			myprintf("\nMaking the orderby\n");
			MAPPAFILEHASH mappacollisioni;
			int64_t starthashsort=mtime();
			int64_t	hashed=0;
			if ( std::find(g_theorderby.begin(), g_theorderby.end(), "hash") != g_theorderby.end() )
			for (unsigned i=0; i<vf.size(); i++) 
			{
				DTMap::iterator p=vf[i];
				string	filename=p->first;
				uint32_t dummycrc=0;
				string thehash=hash_calc_file(ALGO_XXHASH64,filename.c_str(),false,dummycrc,starthashsort,total_size,hashed);
				if (thehash!="")
					p->second.hexhash=thehash;
				else
					myprintf("38082: error taking hash %s\n",filename.c_str());
			}
			if ( std::find(g_theorderby.begin(), g_theorderby.end(), "nilsimsa") != g_theorderby.end() )
			{
				myprintf("Getting nilsimsa digest\n");
				for (unsigned i=0; i<vf.size(); i++) 
				{
					DTMap::iterator p=vf[i];
					string	filename=p->first;
					uint32_t dummycrc=0;
					string thehash=mm_hash_calc_file(ALGO_NILSIMSA,filename.c_str(),false,dummycrc,starthashsort,total_size,hashed);
					if (thehash!="")
						p->second.hexhash=thehash;
					else
						myprintf("38402: error taking hash %s\n",filename.c_str());
				}
			}
			std::sort(vf.begin(), vf.end(), compareorderby);
		}
	}
	else
	{
		if (!flagnosort)
		{
			if (flagdebug)
				myprintf("Default sort\n");
			std::sort(vf.begin(), vf.end(), compareFilename);
		}
	}
	if (menoenne>0)
	{
		int	dastampare=vf.size();
		if (menoenne<(unsigned int)dastampare)
				dastampare=menoenne;
		printbar('-');
		for (int i=0;i<dastampare; i++) 
			myprintf("POST %08d sort %19s |%s| |%s|\n",i,migliaia(vf[i]->second.size),vf[i]->second.hexhash.c_str(),vf[i]->first.c_str());
	}
	if ((total_size==0) && (vf.size()==0))
	{
		myprintf("\nTotal size and file count == zero, quit. Already archived/wrong/inaccessible source ?\n");
		return 1;	
	}
  if (archive_exists!=exists(subpart(archive, 1).c_str()))
    error("archive access is intermittent");
  if (exists(arcname)) myprintf("Updating ");
  else myprintf("Creating ");
  printUTF8(arcname.c_str());
  myprintf(" at offset %s + %s\n", migliaia(header_pos), migliaia2(offset));
  OutputArchive out(arcname.c_str(), password, salt, offset);
  out.seek(header_pos, SEEK_SET);
  vector<ThreadID> tid(howmanythreads*2-1);
  ThreadID wid;
  CompressJob job(howmanythreads, tid.size(), &out);
	myprintf("Adding %s (%s) in %s files (%s dirs), %d threads ",migliaia(total_size), tohuman(total_size),migliaia2(int(vf.size())),migliaia3(folders),howmanythreads);
	if (flagverbose)
		myprintf("-method %s ",method.c_str());
	myprintf("@ %s ",dateToString(date).c_str());
	if (flagcomment)
		if (versioncomment.length()>0)
			myprintf("<<%s>>",versioncomment.c_str());
	myprintf("\n");
	if (casecollision>0)
		myprintf("Case collisions       %9s (-fix255)\n",migliaia(casecollision));
	if (toolongfilenames)
	{
	myprintf("Long filenames (>255) %9s\n",migliaia(toolongfilenames));
	}
	if (utf8names)
		myprintf("Non-latin (UTF-8)     %9s\n",migliaia(utf8names));
	if (adsfilenames)
		myprintf("ADS ($:DATA)          %9s\n",migliaia(adsfilenames));
	for (unsigned i=0; i<tid.size(); ++i) 
		run(tid[i], compressThread, &job);
	run(wid, writeThread, &job);
  int64_t dedupesize=0;  
  if (method[0]=='s') {
    StringBuffer sb(blocksize+4096-128);
    for (unsigned fi=0; fi<vf.size(); ++fi) {
      DTMap::iterator p=vf[fi];
      print_progress(total_size, total_done,g_scritti,-1);
      FP in=fopen(p->first.c_str(), RB);
      if (in==FPNULL) {
        printerr("16570",p->first.c_str(),0);
        total_size-=p->second.size;
        ++errors;
        continue;
      }
      uint64_t i=0;
      const int BUFSIZE=4096;
      char buf[BUFSIZE];
      while (true) {
        int r=fread(buf, 1, BUFSIZE, in);
        sb.write(buf, r);
        i+=r;
        if (r==0 || sb.size()+BUFSIZE>blocksize) {
          string filename="";
          string comment="";
          if (i==sb.size()) {  
            filename=rename(p->first);
            comment=itos(p->second.date);
            if ((p->second.attr&255)>0) {
              comment+=" ";
              comment+=char(p->second.attr&255);
              comment+=itos(p->second.attr>>8);
            }
          }
          total_done+=sb.size();
          job.write(sb, filename.c_str(), method, comment.c_str());
          assert(sb.size()==0);
        }
        if (r==0) break;
      }
      fclose(in);
    }
    job.write(sb, 0, "");  
    for (unsigned i=0; i<tid.size(); ++i) join(tid[i]);
    join(wid);
    const int64_t outsize=out.tell();
    myprintf("%1.0f + (%1.0f -> %1.0f) = %s\n",
        double(header_pos),
        double(total_size),
        double(outsize-header_pos),
        migliaia(outsize));
    out.close();
    return errors>0;
  }  
  if (ver.size() && ver.back().lastdate>=date) {
    const int64_t newdate=decimal_time(unix_time(ver.back().lastdate)+1);
    fflush(stdout);
    myprintf( "Warning: adjusting date from %s to %s\n",
      dateToString(date).c_str(), dateToString(newdate).c_str());
    assert(newdate>date);
    date=newdate;
  }
  HTIndex htinv(ht, ht.size()+(total_size>>(10+fragment))+vf.size());
  const unsigned htsize=ht.size();  
  writeJidacHeader(&out, date, -1, htsize);
  const int64_t header_end=out.tell();
  assert(method!="");
  StringBuffer sb(blocksize+4096-128);  
  unsigned frags=0;    
  unsigned redundancy=0;  
  unsigned text=0;     
  unsigned exe=0;      
  const int ON=4;      
  unsigned char o1prev[ON*256]={0};  
  libzpaq::Array<char> fragbuf(MAX_FRAGMENT);
  vector<unsigned> blocklist;  
  for (unsigned fi=0; fi<=vf.size(); ++fi) 
  {
	string workingfile="";
	FP in=FPNULL;
    const int BUFSIZE=4096;  
    char buf[BUFSIZE];
    int bufptr=0, buflen=0;  
	DTMap::iterator p;
    if (fi<vf.size()) 
	{
      assert(vf[fi]->second.ptr.size()==0);
      p=vf[fi];
		workingfile=p->first;
      bufptr=buflen=0;
      in=fopen(p->first.c_str(), RB);
      if (in==FPNULL) 
	  {  
			p->second.date=0;
			total_size-=p->second.size;
			int64_t attrib=0;
			printerr("16672",p->first.c_str(),attrib);
			++errors;
			continue;
      }
		{
			fseeko(in, 0, SEEK_END);
			p->second.expectedsize=ftello(in);
			fseeko(in, 0, SEEK_SET);
		}
		p->second.data=1;  
    }
	int		ultimapercentuale=0;
    int64_t fsize=0;  
    for (unsigned fj=0; true; ++fj) {
      int64_t sz=0;  
      unsigned hits=0;  
      int c=EOF;  
      unsigned htptr=0;  
      char sha1result[20]={0};  
      unsigned char o1[256]={0};  
      if (fi<vf.size()) {
        int c1=0;  
        unsigned h=0;  
        libzpaq::SHA1 sha1;
        assert(in!=FPNULL);
        while (true) {
			if (bufptr>=buflen) bufptr=0, buflen=fread(buf, 1, BUFSIZE, in);
			if (flagdebug)
				if (flagzero)
				{
					if (flagkill)
						bufptr=buflen;
					else
						memset(buf,0,buflen);
				}
			if (g_franzotype>0)
				if (bufptr==0)
					if (buflen>0) 
					{
						p->second.hashedsize+=buflen;
						if (p->second.expectedsize>100000000)
						{
							int percentuale=(int)(100.0*p->second.hashedsize/p->second.expectedsize)+1;
							int modulo=10;
							if (p->second.expectedsize>1000000000)
								modulo=1;
							if (percentuale!=ultimapercentuale)
							if (percentuale%modulo==0)
							{
								print_progress(total_size, total_done,g_scritti,ultimapercentuale);
								ultimapercentuale=percentuale;
							}
						}
						p->second.file_crc32=crc32_16bytes(buf,buflen,p->second.file_crc32);
						if (g_franzotype==FRANZO_XXHASH64)
							if (p->second.pfile_xxhash64)
								(*p->second.pfile_xxhash64).add(buf,buflen);
						if (g_franzotype==FRANZO_SHA_1)
							if (p->second.pfile_sha1)
								(*p->second.pfile_sha1).write(buf,buflen);
						if (g_franzotype==FRANZO_SHA_256)
							if (p->second.pfile_sha256)
								for (int i=0;i<buflen;i++)
									(*p->second.pfile_sha256).put(*(buf+i));
						if (g_franzotype==FRANZO_XXH3)
							if (p->second.pfile_xxh3)
								(void)XXH3_128bits_update(p->second.pfile_xxh3, buf,buflen);
						if (g_franzotype==FRANZO_BLAKE3)
							if (p->second.pfile_blake3)
								blake3_hasher_update(p->second.pfile_blake3, buf,buflen);
						if (g_franzotype==FRANZO_SHA3)
							if (p->second.pfile_sha3)
								(*p->second.pfile_sha3).add(buf,buflen);
						if (g_franzotype==FRANZO_MD5)
							if (p->second.pfile_md5)
							(*p->second.pfile_md5).add(buf,buflen);
					}
          if (bufptr>=buflen) c=EOF;
          else c=(unsigned char)buf[bufptr++];
          if (c!=EOF) {
            if (c==o1[c1]) h=(h+c+1)*314159265u, ++hits;
            else h=(h+c+1)*271828182u;
            o1[c1]=c;
            c1=c;
            sha1.put(c);
            fragbuf[sz++]=c;
          }
          if (c==EOF
              || sz>=MAX_FRAGMENT
              || (fragment<=22 && h<(1u<<(22-fragment)) && sz>=MIN_FRAGMENT))
            break;
        }
        assert(sz<=MAX_FRAGMENT);
        total_done+=sz;
        assert(uint64_t(sz)==sha1.usize());
		memcpy(sha1result, sha1.result(), 20);
		if (flagnodedup)
			htptr=0;
		else
			htptr=htinv.find(sha1result);
		}  
		uint32_t crc;
		if (flagverify)
			if (g_franzotype>0)
			{
				crc=crc32_16bytes(&fragbuf[0],(uint32_t) sz);
				if (htptr)
				{
					ht[htptr].crc32=crc;
					ht[htptr].crc32size=sz;
				}
			}
      if (htptr==0) {  
        int text1=0, exe1=0;
        int64_t h1=sz;
        unsigned char o1ct[256]={0};  
        static const unsigned char dt[256]={  
          160,80,53,40,32,26,22,20,17,16,14,13,12,11,10,10,
            9, 8, 8, 8, 7, 7, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5,
            4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 3, 3, 3,
            3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
            2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
            1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
            1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
            1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
            1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
            1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1};
        for (int i=0; i<256; ++i) {
          if (o1ct[o1[i]]<255) h1-=(sz*dt[o1ct[o1[i]]++])>>15;
          if (o1[i]==' ' && (isalnum(i) || i=='.' || i==',')) ++text1;
          if (o1[i] && (i<9 || i==11 || i==12 || (i>=14 && i<=31) || i>=240))
            --text1;
          if (i>=192 && i<240 && o1[i] && (o1[i]<128 || o1[i]>=192))
            --text1;
          if (o1[i]==139) ++exe1;
        }
        text1=(text1>=3);
        exe1=(exe1>=5);
        if (sz>0) h1=h1*h1/sz; 
        unsigned h2=h1;
        if (h2>hits) hits=h2;
        h2=o1ct[0]*sz/256;  
        if (h2>hits) hits=h2;
        h2=0;
        for (int i=0; i<256*ON; ++i)  
          h2+=o1prev[i]==o1[i&255];
        h2=h2*sz/(256*ON);
        if (h2>hits) hits=h2;
        if (hits>sz) hits=sz;
        bool newblock=false;
        if (frags>0 && fj==0 && fi<vf.size()) {
          const int64_t esize=vf[fi]->second.size;
          const int64_t newsize=sb.size()+esize+(esize>>14)+4096+frags*4;
          if (newsize>blocksize/4 && redundancy<sb.size()/128) newblock=true;
          if (newblock) {  
            unsigned ct=0;
            for (unsigned i=0; i<256*ON; ++i)
              if (o1prev[i] && o1prev[i]==o1[i&255]) ++ct;
            if (ct>ON*2) newblock=false;
          }
          if (newsize>=blocksize) newblock=true;  
        }
        if (sb.size()+sz+80+frags*4>=blocksize) newblock=true; 
        if (fi==vf.size()) newblock=true;  
        if (frags<1) newblock=false;  
        if (newblock) {
          assert(frags>0);
          assert(frags<ht.size());
          for (unsigned i=ht.size()-frags; i<ht.size(); ++i)
            puti(sb, ht[i].usize, 4);  
          puti(sb, 0, 4); 
          puti(sb, frags, 4);  
          string m=method;
          if (isdigit(method[0]))
            m+=","+itos(redundancy/(sb.size()/256+1))
                 +","+itos((exe>frags)*2+(text>frags));
          string fn="jDC"+itos(date, 14)+"d"+itos(ht.size()-frags, 10);
          print_progress(total_size, total_done,g_scritti,ultimapercentuale);
  if (method[0]!='i')
		  {
			job.write(sb, fn.c_str(), m.c_str());
		  }
          else {  
            job.csize.push_back(sb.size());
            sb.resize(0);
          }
          assert(sb.size()==0);
          blocklist.push_back(ht.size()-frags);  
		  frags=redundancy=text=exe=0;
          memset(o1prev, 0, sizeof(o1prev));
        }
        assert(sz==0 || fi<vf.size());
        sb.write(&fragbuf[0], sz);
        ++frags;
        redundancy+=hits;
        exe+=exe1*4;
        text+=text1*2;
        if (sz>=MIN_FRAGMENT) {
          memmove(o1prev, o1prev+256, 256*(ON-1));
          memcpy(o1prev+256*(ON-1), o1, 256);
        }
      }  
      if (fi<vf.size()) 
	  {
        if (htptr==0) {
          htptr=ht.size();
          ht.push_back(HT(sha1result, sz));
          htinv.update();
          fsize+=sz;
        }
        vf[fi]->second.ptr.push_back(htptr);
		if (flagverify)
			if (g_franzotype>0)
			{
				ht[htptr].crc32=crc;
				ht[htptr].crc32size=sz;
			}
	}
      if (c==EOF) break;
    }  
    if (fi<vf.size()) {
      dedupesize+=fsize;
      print_progress(total_size, total_done,g_scritti,ultimapercentuale);
      assert(in!=FPNULL);
      fclose(in);
      in=FPNULL;
    }
  }  
  assert(sb.size()==0);
  job.write(sb, 0, "");  
  for (unsigned i=0; i<tid.size(); ++i) join(tid[i]);
  join(wid);
  salt[0]^='7'^'z';
  OutputArchive outi(index ? index : "", password, salt, 0);
  WriterPair wp;
  wp.a=&out;
  if (index) wp.b=&outi;
  writeJidacHeader(&outi, date, 0, htsize);
  int64_t cdatasize=out.tell()-header_end;
  StringBuffer is;
  assert(blocklist.size()==job.csize.size());
  blocklist.push_back(ht.size());
  for (unsigned i=0; i<job.csize.size(); ++i) {
    if (blocklist[i]<blocklist[i+1]) {
      puti(is, job.csize[i], 4);  
      for (unsigned j=blocklist[i]; j<blocklist[i+1]; ++j) {
        is.write((const char*)ht[j].sha1, 20);
        puti(is, ht[j].usize, 4);
      }
      libzpaq::compressBlock(&is, &wp, "0",
          ("jDC"+itos(date, 14)+"h"+itos(blocklist[i], 10)).c_str(),
          "jDC\x01");
      is.resize(0);
    }
  }
  int dtcount=0;  
  int removed=0;  
  for (DTMap::iterator p=dt.begin(); p!=dt.end(); ++p) {
    if (p->second.date && !p->second.data) {
      puti(is, 0, 8);
      is.write(p->first.c_str(), strlen(p->first.c_str()));
      is.put(0);
      ++removed;
      if (is.size()>16000) {
        libzpaq::compressBlock(&is, &wp, "1",
            ("jDC"+itos(date)+"i"+itos(++dtcount, 10)).c_str(), "jDC\x01");
        is.resize(0);
      }
    }
  }
	int added=0;  
	for (DTMap::iterator p=edt.begin();; ++p) 
	{
		if (p!=edt.end()) 
		{
			string filename=rename(p->first);
			if (command=='q')
			{
				myreplace(filename,g_vss_shadow,g_franzsnap);
			}
			if (searchfrom!="")
				if (replaceto!="")
					replace(filename,searchfrom,replaceto);
			DTMap::iterator a=dt.find(filename);
			if (p->second.date && (a==dt.end() 
			|| a->second.date!=p->second.date  
			|| ((int32_t)a->second.attr && (int32_t)a->second.attr!=(int32_t)p->second.attr)  
			|| a->second.size!=p->second.size  
			|| (p->second.data && a->second.ptr!=p->second.ptr))) 
			{ 
				if (mypos("VFILE-",filename)>-1)
				{
					myprintf("\nWe get a VFILE\n");
					filename=extractfilename(filename);
				}
				uint32_t currentcrc32=0;
				if (flagverify)
				{
					for (unsigned i=0; i<p->second.ptr.size(); ++i)
						currentcrc32=crc32_combine(currentcrc32, ht[p->second.ptr[i]].crc32,ht[p->second.ptr[i]].crc32size);
					if (currentcrc32!=p->second.file_crc32)
						myprintf("29604 SOMETHING WRONG ON %s\n",p->first.c_str());
				}		
				++added;
				puti(is, p->second.date, 8);
				is.write(filename.c_str(), strlen(filename.c_str()));
				is.put(0);
				string 	hashtobewritten="";
				string	hasherror="";
				if (!(flagdebug && flagzero && flagkill))
				{
					if (g_franzotype==FRANZO_CRC_32) 
					{
						hashtobewritten="";
						if (flagdebug)
							myprintf("Mode1: CRC32 by frag <<%08X>> for %s\n",currentcrc32,p->first.c_str());
					}
					else
					if (g_franzotype==FRANZO_XXHASH64)
					{
						char temp[17]={0};
						sprintf(temp,"%016llX",(unsigned long long)(*p->second.pfile_xxhash64).hash());
						hashtobewritten=temp;
						if (flagdebug)
							myprintf("Model2: XXHASH64 %s %s\n",hashtobewritten.c_str(),p->first.c_str());				
						p->second.hashtype="XXHASH64";
						p->second.hexhash=hashtobewritten;
						hasherror="!ERROR!         ";
					}
					else
					if (g_franzotype==FRANZO_SHA_1)
					{
						char sha1result[21]={0};
						memcpy(sha1result, (*p->second.pfile_sha1).result(), 20);
						hashtobewritten=binarytohex((const unsigned char*)sha1result,20);
						if (flagdebug)
							myprintf("Mode3: SHA1 %s %s\n",hashtobewritten.c_str(),p->first.c_str());
						p->second.hashtype="SHA-1";
						p->second.hexhash=hashtobewritten;
						hasherror="!ERROR!                                 ";
					}
					else
					if (g_franzotype==FRANZO_SHA_256)
					{
						char sha256result[33]={0};
						memcpy(sha256result, (*p->second.pfile_sha256).result(), 32);
						hashtobewritten=binarytohex((const unsigned char*)sha256result,32);
						if (flagdebug)
							myprintf("Mode4: SHA256 %s %s\n",hashtobewritten.c_str(),p->first.c_str());
						p->second.hashtype="SHA-256";
						p->second.hexhash=hashtobewritten;	
						hasherror="!ERROR!                                                         ";
					}
					else
					if (g_franzotype==FRANZO_BLAKE3)
					{
						uint8_t output[BLAKE3_OUT_LEN];
						blake3_hasher_finalize(p->second.pfile_blake3, output, BLAKE3_OUT_LEN);
						hashtobewritten=binarytohex((const unsigned char*)output,BLAKE3_OUT_LEN);
						if (flagdebug)
							myprintf("Mode6: BLAKE3 %s %s\n",hashtobewritten.c_str(),p->first.c_str());
						p->second.hashtype="BLAKE3";
						p->second.hexhash=hashtobewritten;
						hasherror="!ERROR!                                                         ";
					}
					else
					if (g_franzotype==FRANZO_SHA3)
					{
						hashtobewritten=(*p->second.pfile_sha3).getHash();
						if (flagdebug)
							myprintf("Mode7: SHA3 %s %s\n",hashtobewritten.c_str(),p->first.c_str());
						p->second.hashtype="SHA-3";
						p->second.hexhash=hashtobewritten;
						hasherror="!ERROR!                                                         ";
					}
					else
					if (g_franzotype==FRANZO_MD5)
					{
						hashtobewritten=(*p->second.pfile_md5).getHash();
						if (flagdebug)
							myprintf("Mode8: MD5 %s %s\n",hashtobewritten.c_str(),p->first.c_str());
						p->second.hashtype="MD5";
						p->second.hexhash=hashtobewritten;
						hasherror="!ERROR!                         ";
					}
					else
					if (g_franzotype==FRANZO_XXH3)
					{
						char xxh3result[33]={0};
						XXH128_hash_t myhash=XXH3_128bits_digest(p->second.pfile_xxh3);
						sprintf(xxh3result,"%016llX%016llX",(unsigned long long)myhash.high64,(unsigned long long)myhash.low64);
						hashtobewritten=xxh3result;
						if (flagdebug)
							myprintf("Model5: XXH3 %s %s\n",hashtobewritten.c_str(),p->first.c_str());
						p->second.hashtype="XXH3";
						p->second.hexhash=hashtobewritten;
						hasherror="!ERROR!                         ";
					}
					if (hashtobewritten!="")
					{
						if ((p->second.size!=p->second.hashedsize) && (p->second.hashedsize==0))
						{
							if (!flagvss)
							{
								myprintf("38383: ERROR expected %19s getted 0 bytes  ",migliaia(p->second.size));
								printUTF8(filename.c_str());
								myprintf("\n");
							}
							hashtobewritten=hasherror;
						}
						else
						if (p->second.size!=p->second.hashedsize)
						{
							if (!flagvss)
							{
								myprintf("38385: WARN expected %19s getted %19s for ",migliaia(p->second.size),migliaia2(p->second.hashedsize));
								printUTF8(filename.c_str());
								myprintf("\n");
							}
						}
					}
				}
				if ((p->second.attr&255)=='u')
						writefranzattr(is,p->second.attr,3,filename,currentcrc32,p->second.file_crc32,hashtobewritten);
				else 
				if ((p->second.attr&255)=='w')
						writefranzattr(is,p->second.attr,5,filename,currentcrc32,p->second.file_crc32,hashtobewritten);
				else 
					puti(is, 0, 4);  
				if (a==dt.end() || p->second.data) 
					a=p;  
				puti(is, a->second.ptr.size(), 4);  
				for (unsigned i=0; i<a->second.ptr.size(); ++i)
					puti(is, a->second.ptr[i], 4);
			}
		}
		else
		{
			if (versioncomment.length()>0)
			{
				char versioni8[32];
				sprintf(versioni8,"%08lld",(long long)ver.size());
				versioni8[8]=0x0;
				string fakefile="VCOMMENT "+string(versioni8)+" "+versioncomment+":$DATA"; 
				puti(is, 0, 8); 
				is.write(fakefile.c_str(), strlen(fakefile.c_str()));
				is.put(0);
			}
		}
		if (is.size()>16000 || (is.size()>0 && p==edt.end())) 
		{
			libzpaq::compressBlock(&is, &wp, "1",
				("jDC"+itos(date)+"i"+itos(++dtcount, 10)).c_str(), "jDC\x01");
			is.resize(0);
		}
		if (p==edt.end()) 
			break;
	}	
	printbar(' ',false);
	myprintf("\r%s +added, %s -removed.\n", migliaia(added), migliaia2(removed));
	assert(is.size()==0);
  outi.close();
  int64_t archive_end=out.tell();
  out.seek(header_pos, SEEK_SET);
  writeJidacHeader(&out, date, cdatasize, htsize);
  out.seek(0, SEEK_END);
  int64_t archive_size=out.tell();
  out.close();
  if (!index) 
  {
		if (added+removed==0 && archive_end-header_pos==104) 
			archive_end=header_pos;
		if (archive_end<archive_size) 
		{
			if (archive_end>0) 
			{
				if (flagverbose)
				myprintf("truncating archive from %s to %s\n",migliaia(archive_size), migliaia2(archive_end));
				if (truncate(arcname.c_str(), archive_end)) 
					printerr("17092",archive.c_str(),0);
			}
			else 
			if (archive_end==0) 
			{
				if (delete_file(arcname.c_str()))
					if (flagverbose)
					{
						myprintf("deleted ");
						printUTF8(arcname.c_str());
						myprintf(" : no data to be archived\n");
					}
			}
		}
  }
  fflush(stdout);
	if (archive_end) 
	{
		if (flagverbose)
			if (total_xls)
					myprintf("Forced XLS/PPT has included %s bytes in %s files\n",migliaia(total_xls),migliaia2(file_xls));
		int64_t speed=0;
		int64_t ticks=mtime()-g_start;
		if (ticks>0) 	
			speed=total_size/(ticks/1000.0);
		  if (flagverbose)
			myprintf("\n %21s starting size\n %21s data to be added\n %21s after deduplication\n+%21s after compression\n %21s total size\nTotal speed %s/s\n",
			  migliaia(header_pos), migliaia2(total_size), migliaia3(dedupesize),
			  migliaia4(archive_end-header_pos), migliaia5(archive_end),tohuman(speed));
			else
		  myprintf( "\n%s + (%s -> %s -> %s) = %s @ %s/s\n",
			  migliaia(header_pos), migliaia2(total_size), migliaia3(dedupesize),
			  migliaia4(archive_end-header_pos), migliaia5(archive_end),tohuman(speed));
	}
	if (flagfilelist)
		if (fileexists(tempfile))
		{
			if (flagdebug)
				myprintf("42972: deleting tempfile %s\n",tempfile.c_str());
			delete_file(tempfile.c_str());
		}
	if (errors==0)
		if (g_copy!="")
		{
			string filescritto=filecopy(false,false,g_archive,g_copy,true,false,false);
			if (filescritto!="")
				myprintf("Copied <<%s>> to <<%s>>\n",g_archive.c_str(),filescritto.c_str());
			else
				myprintf("34971: ERROR doing -copy from %s to %s\n",g_archive.c_str(),filescritto.c_str());
		}
	if (flagtest)
	{
		printbar('=');
		if (flagverbose)
			myprintf("43054: Do a testverify()\n");
		all=false;
		ver.clear();
		block.clear();
		dt.clear();
		ht.clear();
		edt.clear();
		ht.resize(1);  
		ver.resize(1); 
		dhsize=dcsize=0;
		errors=testverify();
	}	
	if (flagverify)
	{
		printbar('=');
		if (flagverbose)
			myprintf("43070: Do a verify()\n");
		all=false;
		ver.clear();
		block.clear();
		dt.clear();
		ht.clear();
		edt.clear();
		ht.resize(1);  
		ver.resize(1); 
		dhsize=dcsize=0;
		errors=verify(true); 
	}	
	if (g_sfx!="")
		errors+=writesfxmodule(g_sfx);
	if (!(flagdebug && flagzero && flagkill))
		if (total_size!=(total_done))
		{
			myprintf("\n");
			myprintf("38271: HOUSTON expected %s, done %s, diff %s\n",migliaia(total_size),migliaia2(total_done),migliaia3(myabs(total_size,total_done)));
			if (flagvss)
			{
				myprintf("38271: This could be 'normal' for a VSS operation\n");
			}
			else
			{
				myprintf("38271: Corrupted source files? Lost connection? Cannot access? Media full?\n");
				myprintf("38271: =>The updated .zpaq archive is almost certainly incompleted\n");
			}
			g_exec_text="38271: HOUSTON something seems wrong expected vs done";
			errors=2;
		}
	return errors;
}
char zsfx_mime64[]=
{"RVJST1I="};
int b64invs[] = { 62, -1, -1, -1, 63, 52, 53, 54, 55, 56, 57, 58,
	59, 60, 61, -1, -1, -1, -1, -1, -1, -1, 0, 1, 2, 3, 4, 5,
	6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20,
	21, 22, 23, 24, 25, -1, -1, -1, -1, -1, -1, 26, 27, 28,
	29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42,
	43, 44, 45, 46, 47, 48, 49, 50, 51 };
int ismime(char i_c)
{
	if ((i_c>='0') && (i_c<='9'))
		return 1;
	if ((i_c >='A') && (i_c<='Z'))
		return 1;
	if ((i_c>='a') && (i_c <= 'z'))
		return 1;
	if ((i_c=='+') || (i_c=='/') || (i_c =='='))
		return 1;
	return 0;
}
size_t mimesize(const char *i_input)
{
	if (i_input==NULL)
		return 0;
	size_t len;
	size_t ret;
	size_t i;
	len=strlen(i_input); 
	ret=len/4*3;
	for (i=len; i-->0;) 
		if (i_input[i] == '=') 
			ret--;
		else 
			break;
	return ret;
}
int mime2binary(const char *i_in, unsigned char *o_out, size_t outlen)
{
	if (i_in==NULL)
		return 0;
	if (o_out==NULL)
		return 0;
	size_t lunghezza=strlen(i_in);
	if ((outlen<mimesize(i_in)) || (lunghezza % 4 != 0))
		return 0;
	for (unsigned int i=0; i<lunghezza; i++) 
		if (!ismime(i_in[i])) 
			return 0;
	size_t i;
	size_t j;
	int    temp;
	for (i=0,j=0;i<lunghezza;i+=4,j+=3) 
	{
		temp= b64invs[i_in[i]-43];
		temp= (temp << 6) | b64invs[i_in[i+1]-43];
		temp= i_in[i+2]=='=' ? temp << 6 : (temp << 6) | b64invs[i_in[i+2]-43];
		temp= i_in[i+3]=='=' ? temp << 6 : (temp << 6) | b64invs[i_in[i+3]-43];
		o_out[j] = (temp >> 16) & 0xFF;
		if (i_in[i+2] != '=')
			o_out[j+1] = (temp >> 8) & 0xFF;
		if (i_in[i+3] != '=')
			o_out[j+2] = temp & 0xFF;
	}
	return 1;
}
#ifndef FALSE
#define FALSE 0
#define TRUE  1
#endif
static void unlz4error(const char* msg)
{
  fputs("ERROR: ", stderr);
  fputs(msg,       stderr);
  fputc('\n',      stderr);
  exit(1);
}
typedef unsigned char (*GET_BYTE)  (void* userPtr);
typedef void          (*SEND_BYTES)(const unsigned char*, unsigned int, void* userPtr);
struct s_lz4parameter
{
	unsigned char*	source;		
	FILE* out;
	unsigned int  	pos;		
	unsigned int	size;
	unsigned int	extracted;	
	s_lz4parameter(): source(0), out(0), pos(0), size(0),extracted(0){};
}; 
static unsigned char getByteFromIn(void* userPtr) 
{
	struct s_lz4parameter* user = (struct s_lz4parameter*)userPtr;
	return user->source[user->pos++];
}
static void sendBytesToOut(const unsigned char* data, unsigned int numBytes, void* userPtr)
{
  struct s_lz4parameter* user = (struct s_lz4parameter*)userPtr;
  if (data != NULL && numBytes > 0)
	if (user->out != NULL)
	{
		size_t written=fwrite(data, 1, numBytes, user->out);
		user->extracted+=written;
	}
}
void unlz4_userPtr(GET_BYTE getByte, SEND_BYTES sendBytes, void* userPtr)
{
  unsigned char signature1 = getByte(userPtr);
  unsigned char signature2 = getByte(userPtr);
  unsigned char signature3 = getByte(userPtr);
  unsigned char signature4 = getByte(userPtr);
  unsigned int  signature  = (signature4 << 24) | (signature3 << 16) | (signature2 << 8) | signature1;
  unsigned char isModern   = (signature == 0x184D2204);
  unsigned char isLegacy   = (signature == 0x184C2102);
  if (!isModern && !isLegacy)
    unlz4error("invalid signature");
  unsigned char hasBlockChecksum   = FALSE;
  unsigned char hasContentSize     = FALSE;
  unsigned char hasContentChecksum = FALSE;
  unsigned char hasDictionaryID    = FALSE;
  if (isModern)
  {
    unsigned char flags = getByte(userPtr);
    hasBlockChecksum   = flags & 16;
    hasContentSize     = flags &  8;
    hasContentChecksum = flags &  4;
    hasDictionaryID    = flags &  1;
    unsigned char version = flags >> 6;
    if (version != 1)
      unlz4error("only LZ4 file format version 1 supported");
    char numIgnore = 1;
    if (hasContentSize)
      numIgnore += 8;
    if (hasDictionaryID)
      numIgnore += 4;
    numIgnore++;
    while (numIgnore--)
      getByte(userPtr);
  }
#define HISTORY_SIZE 64*1024
  unsigned char history[HISTORY_SIZE];
  unsigned int  pos = 0;
  while (1)
  {
    unsigned int blockSize = getByte(userPtr);
    blockSize |= (unsigned int)getByte(userPtr) <<  8;
    blockSize |= (unsigned int)getByte(userPtr) << 16;
    blockSize |= (unsigned int)getByte(userPtr) << 24;
    unsigned char isCompressed = isLegacy || (blockSize & 0x80000000) == 0;
    if (isModern)
      blockSize &= 0x7FFFFFFF;
    if (blockSize == 0)
      break;
    if (isCompressed)
    {
      unsigned int blockOffset = 0;
      unsigned int numWritten  = 0;
      while (blockOffset < blockSize)
      {
        unsigned char token = getByte(userPtr);
        blockOffset++;
        unsigned int numLiterals = token >> 4;
        if (numLiterals == 15)
        {
          unsigned char current;
          do
          {
            current = getByte(userPtr);
            numLiterals += current;
            blockOffset++;
          } while (current == 255);
        }
        blockOffset += numLiterals;
        if (pos + numLiterals < HISTORY_SIZE)
        {
          while (numLiterals-- > 0)
            history[pos++] = getByte(userPtr);
        }
        else
        {
          while (numLiterals-- > 0)
          {
            history[pos++] = getByte(userPtr);
            if (pos == HISTORY_SIZE)
            {
              sendBytes(history, HISTORY_SIZE, userPtr);
              numWritten += HISTORY_SIZE;
              pos = 0;
            }
          }
        }
        if (blockOffset == blockSize)
          break;
        unsigned int delta = getByte(userPtr);
        delta |= (unsigned int)getByte(userPtr) << 8;
        if (delta == 0)
          unlz4error("invalid offset");
        blockOffset += 2;
        unsigned int matchLength = 4 + (token & 0x0F);
        if (matchLength == 4 + 0x0F)
        {
          unsigned char current;
          do 
          {
            current = getByte(userPtr);
            matchLength += current;
            blockOffset++;
          } while (current == 255);
        }
        unsigned int referencePos = (pos >= delta) ? (pos - delta) : (HISTORY_SIZE + pos - delta);
        if (pos + matchLength < HISTORY_SIZE && referencePos + matchLength < HISTORY_SIZE)
        {
          if (pos >= referencePos + matchLength || referencePos >= pos + matchLength)
          {
            memcpy(history + pos, history + referencePos, matchLength);
            pos += matchLength;
          }
          else
          {
            while (matchLength-- > 0)
              history[pos++] = history[referencePos++];
          }
        }
        else
        {
          while (matchLength-- > 0)
          {
            history[pos++] = history[referencePos++];
            if (pos == HISTORY_SIZE)
            {
              sendBytes(history, HISTORY_SIZE, userPtr);
              numWritten += HISTORY_SIZE;
              pos = 0;
            }
            referencePos %= HISTORY_SIZE;
          }
        }
      }
      if (isLegacy && numWritten + pos < 8*1024*1024)
        break;
    }
    else
    {
      while (blockSize-- > 0)
      {
        history[pos++] = getByte(userPtr);
        if (pos == HISTORY_SIZE)
        {
          sendBytes(history, HISTORY_SIZE, userPtr);
          pos = 0;
        }
      }
    }
    if (hasBlockChecksum)
    {
      getByte(userPtr); getByte(userPtr); getByte(userPtr); getByte(userPtr);
    }
  }
  if (hasContentChecksum)
  {
    getByte(userPtr); getByte(userPtr); getByte(userPtr); getByte(userPtr);
  }
  sendBytes(history, pos, userPtr);
}
void scambia(string& i_str)
{
    int n=i_str.length();
    for (int i=0;i<n/2;i++)
        std::swap(i_str[i],i_str[n-i-1]);
}
string ahahencrypt(string i_string)
{
	string risultato="";
	for (unsigned int i=0;i<i_string.size();i++)
        risultato+=i_string[i] ^33;
    return risultato;
}
int Jidac::decompress_sfx_to_file(FILE* i_outfile)
{
	if (i_outfile==NULL)
		return 0;
	size_t 	zsfx_exe_len=mimesize(zsfx_mime64);
	char*	zsfx_exe;
	zsfx_exe=(char*)malloc(zsfx_exe_len);
	if (zsfx_exe==NULL)
	{
		myprintf("87420: error in malloc zsfx\n");
		return 0;
	}
	if (!mime2binary(zsfx_mime64,(unsigned char *)zsfx_exe,zsfx_exe_len)) 
	{
		myprintf("87425: mime decoder kaputt!\n");
		return 0;
	}
	struct s_lz4parameter user;
	user.source		=(unsigned char*)zsfx_exe;
	user.size		=zsfx_exe_len;
	user.out		=i_outfile;
	user.pos		=0;
	user.extracted	=0;
	unlz4_userPtr(getByteFromIn,sendBytesToOut,&user);
	free(zsfx_exe);
	return user.extracted;
}
int Jidac::writesfxmodule(string i_filename)
{
	return 0;
}
int Jidac::sfx()
{
	return 0;
}
int Jidac::decompress_mime64_to_file(FILE* i_outfile,const char* i_mime64)
{
	if (i_outfile==NULL)
		return 0;
	if (i_mime64==NULL)
		return 0;
	size_t 	the_exe_len=mimesize(i_mime64);
	char*	the_exe;
	the_exe=(char*)malloc(the_exe_len);
	if (the_exe==NULL)
	{
		myprintf("45953: error in malloc\n");
		return 0;
	}
	if (!mime2binary(i_mime64,(unsigned char *)the_exe,the_exe_len)) 
	{
		myprintf("45960: mime decoder kaputt!\n");
		return 0;
	}
	struct s_lz4parameter user;
	user.source		=(unsigned char*)the_exe;
	user.size		=the_exe_len;
	user.out		=i_outfile;
	user.pos		=0;
	user.extracted	=0;
	unlz4_userPtr(getByteFromIn,sendBytesToOut,&user);
	free(the_exe);
	return user.extracted;
}
int Jidac::writeresource(string i_filename,bool i_force,const char* i_mime64)
{
	return 0;
}
int Jidac::verify(bool i_readfile) 
{
	getpasswordifempty();
	flagforce		=true;
	flagtest		=true;
	summary			=1;
	bool myflagall	=all;
	all=false;
	if (i_readfile)
	{
		const int64_t sz=read_archive(archive.c_str());
		if (sz<1) 
			error("archive not found");
	}
	all=myflagall;	
	if (flagssd)
	myprintf("\nVerify hashes of one version vs filesystem (multithreaded)\n");
		else
	myprintf("\nVerify hashes of one version vs filesystem (1 thread, -ssd for multithread)\n");
	int 		checkedbyhash=0;
	uint64_t 	hashtotali=0;
	int			tobechecked=0;
	int			nohashfound=0;
	vector<string> 	myfiles;
	vector<string> 	myfilesoriginal;		
	vector<string> 	myfilehash;
	vector<string> 	myalgo;
	for (DTMap::iterator p=dt.begin(); p!=dt.end(); ++p) 
		if (p->second.date && p->first!="") 
		{
			string finalfile=rename(p->first);
			if (!isdirectory(finalfile))
			if (p->second.size>0)
			if (finalfile!="VFILE-l-filelist.txt")
			{
				hashtotali+=p->second.size;
				tobechecked++;
				string myhashtype	="";
				string myhash		="";
				string mycrc32		="";
				decode_franz_block(false,p->second.franz_block,
					myhashtype,
					myhash,
					mycrc32);
				if (myhashtype!="")
				{
					MAPPACHECK::iterator a=g_mychecks.find(myhashtype);
					if (a!=g_mychecks.end())
					{
						if ((searchfrom!="") && (replaceto!=""))
							replace(finalfile,searchfrom,replaceto);
						myfiles.push_back(finalfile);
						myfilesoriginal.push_back(p->first);
						myfilehash.push_back(myhash);
						myalgo.push_back(myhashtype);
					}
					else
					{
						myprintf("39202: unknown algo |%s| for %s\n",myhashtype.c_str(),finalfile.c_str());
					}
				}
				else
					nohashfound++;
			}
		}
	unsigned int mythreads=howmanythreads;
	if (flagssd)
	{
		if (myfiles.size()<mythreads)
			mythreads=myfiles.size();
	}
	else
		mythreads=1;
	vector<tparametrihash> 	vettoreparametrihash;
	tparametrihash 	myblock;
	for (unsigned int i=0;i<mythreads;i++)
	{
		myblock.tnumber		=(i%mythreads);
		myblock.inizio		=mtime();
		myblock.dimensione	=hashtotali;
		myblock.timestart	=0;
		myblock.timeend		=0;
		vettoreparametrihash.push_back(myblock);
	}
	for (unsigned int i=0;i<myfiles.size();i++)
	{
		vettoreparametrihash[i%mythreads].filestobehashed.	push_back(myfiles[i]);
		vettoreparametrihash[i%mythreads].algo.				push_back(myalgo[i]);
		vettoreparametrihash[i%mythreads].filehash.			push_back(myfilehash[i]);
		vettoreparametrihash[i%mythreads].originalfilenames.push_back(myfilesoriginal[i]);
	}
	int totfile=0;
	for (unsigned int i=0;i<mythreads;i++)
	{
		if (flagdebug)
			myprintf("Thread [%02d] files %s\n",i,migliaia(vettoreparametrihash[i].filestobehashed.size()));
		totfile+=+vettoreparametrihash[i].filestobehashed.size();
	}
	int rc;
	pthread_t* threads = new pthread_t[mythreads];
	pthread_attr_t attr;
	void *status;
	pthread_attr_init(&attr);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_JOINABLE);
	if (!flagnoeta)
		myprintf("Total files %s -> in %03d threads -> %s to be checked\n",migliaia(myfiles.size()),mythreads,migliaia2(totfile));
	int64_t	startrunning=mtime();
	for(unsigned int i=0; i<mythreads; i++ ) 
	{
		vettoreparametrihash[i].timestart=mtime();
		rc = pthread_create(&threads[i], &attr, scansionahash, (void*)&vettoreparametrihash[i]);
		if (rc) 
		{
			myprintf("39264: Error creating thread\n");
			exit(-1);
		}
	}
	pthread_attr_destroy(&attr);
	for(unsigned int i=0; i <mythreads; i++ ) 
	{
		rc = pthread_join(threads[i], &status);
		if (rc) 
		{
			error("39275: Unable to join\n");
			exit(-1);
		}
	}
	if (flagverbose)
		myprintf("Scan done, preparing report...\n");
	for(unsigned int i=0;i<mythreads;i++)
		for (unsigned int j=0;j<vettoreparametrihash[i].filestobehashed.size();j++)
		{
			string finalfile		=vettoreparametrihash[i].filestobehashed[j];
			string myhashtype		=vettoreparametrihash[i].algo[j];
			if (myhashtype=="")
			{
				nohashfound++;
				if (flagverbose)
					myprintf("44039: NO hashtype %s\n",finalfile.c_str());
			}
			else
			{
				MAPPACHECK::iterator a	=g_mychecks.find(myhashtype);
				if (a!=g_mychecks.end())
				{
					checkedbyhash++;
					if (vettoreparametrihash[i].o_hashcalculated[j]=="")
					{
						if (flagverbose || (g_output!=""))
							myprintf("FILE NOT FOUND on %s: FILE %s\n",myhashtype.c_str(),finalfile.c_str());
						a->second.checkednotfound++;
					}
					else
					{
						if (vettoreparametrihash[i].o_hashcalculated[j]==vettoreparametrihash[i].filehash[j])
						{
							if (flagdebug)
								myprintf("GOOD %s:  STORED == FROM FILE %s\n",myhashtype.c_str(),finalfile.c_str());
							a->second.checkedok++;
							DTMap::iterator p=dt.find(vettoreparametrihash[i].originalfilenames[j]);
							if (p!=dt.end())
								a->second.checksize+=p->second.size; 
							else
							{
								if (flagdebug)
									myprintf("38931: Cannot find originalfilename %s\n",vettoreparametrihash[i].originalfilenames[j].c_str());
							}
						}
						else
						{
							if (flagverbose || (g_output!=""))
							{
								myprintf("ERROR on %s: STORED HASH %s VS %s IN FILE ",myhashtype.c_str(),vettoreparametrihash[i].filehash[j].c_str(),vettoreparametrihash[i].o_hashcalculated[j].c_str());
								printUTF8(finalfile.c_str());
								myprintf("\n");
							}
							a->second.checkedfailed++;
						}
					}
				}
				else
				{
					nohashfound++;
					if (flagverbose)
						myprintf("26620: algo unknown (or no algo!) %s\n",finalfile.c_str());
				}
			}
		}
	int risultato=0;
	bool outsomething=(nohashfound>0);
	if (nohashfound>0)
		risultato=1;
	for (MAPPACHECK::iterator p=g_mychecks.begin(); p!=g_mychecks.end(); ++p) 
		outsomething |= (p->second.checkedok+p->second.checkedfailed+p->second.checkednotfound);
	if (outsomething)
	{
		printbar('-');
		int64_t	byteshashed=0;
		for (MAPPACHECK::iterator p=g_mychecks.begin(); p!=g_mychecks.end(); ++p) 
		{
			byteshashed+=p->second.checksize;
			if (p->second.checkedok)
				myprintf("OK   %8s : %08d of %08d (%12s hash check against file on disk)\n",p->first.c_str(),p->second.checkedok,tobechecked,tohuman(p->second.checksize));
			if (p->second.checkedfailed)
			{
				myprintf("FAIL %8s : %08d of %08d (   FAILED    hash check against file on disk)\n",p->first.c_str(),p->second.checkedfailed,tobechecked);
				risultato=2;
			}
			if (p->second.checkednotfound)
			{
				myprintf("WARN %8s : %08d of %08d (file not found, cannot check hash)\n",p->first.c_str(),p->second.checkednotfound,tobechecked);
				if (risultato!=2)
					risultato=1;
			}
		}
		if (nohashfound)
			myprintf("UNKNOWN/NOHASH: %08d of %08d (legacy 7.15 archive?)\n",nohashfound,tobechecked);
		printbar('-');
		if (flagverbose)
		myprintf("Total hashed bytes %s @ %s B/s\n",migliaia((uint64_t)byteshashed),migliaia2((uint64_t)(byteshashed/((mtime()-startrunning)/1000.0))));
	}
	delete [] threads;
	return risultato;
}
void Jidac::handleflaglongpath()
{ 
}	
int Jidac::extractw() 
{
	myprintf("**** CHUNKED EXTRACTION/TEST ****\n");
	if (flagverify && flagtest)
	{
		myprintf("44477: -verify and -test incompatible (-test does not write on disk)\n");
		myprintf("44477: maybe you mean -test -checksum ?\n");
		return 1;
	}
	if (!flagtest)
		if (tofiles.size()!=1)
		{
			myprintf("42845: you need exactly one -to\n");
			return 2;
		}
	if (flagparanoid && !flagverify)
	{
		myprintf("44059: WARNING -paranoid without -verify: ignored\n");
		flagparanoid=false;
	}
	handleflaglongpath();
	string outputdirectory="";
	if (flagtest)
		tofiles.push_back("K:/dummy/");
	else
	{
		if (!isdirectory(tofiles[0]))
			tofiles[0]+='/';
		outputdirectory=tofiles[0];
		uint64_t tofoldersize=0;
		uint32_t tofoldernumber=0;
		uint32_t tofolderfolder=0;
		uint32_t tofolderlongfiles=0;
		if (getfoldersize(tofiles[0],tofoldersize,tofoldernumber,tofolderfolder,tofolderlongfiles))
			if (tofoldersize>0)
			{
				myprintf("42854: WARNING the folder <<");
				printUTF8(tofiles[0].c_str());
				myprintf(">> already contain %s bytes\n\n\n",migliaia(tofoldersize));		
				if (!getcaptcha("deleteall","Data can be overwritten, use EMPTY folder!"))
					return 1;
			}
	}
	if (flagverify && flagparanoid)
		tofiles[0]+="zfranz/";
	getpasswordifempty();
	g_scritti		=0;
	int	errors		=0;
	int64_t sz=read_archive(archive.c_str(),&errors);
	if (sz<1) 
		error("44504: archive not found");
	for (unsigned i=0; i<block.size(); ++i) 
	{
		if (block[i].bsize<0) 
			error("negative block size");
		if (block[i].start<1) 
			error("block starts at fragment 0");
		if (block[i].start>=ht.size()) 
			error("block start too high");
		if (i>0 && block[i].start<block[i-1].start) 
			error("unordered frags");
		if (i>0 && block[i].start==block[i-1].start) 
			error("empty block");
		if (i>0 && block[i].offset<block[i-1].offset+block[i-1].bsize)
		  error("unordered blocks");
		if (i>0 && block[i-1].offset+block[i-1].bsize>block[i].offset)
		  error("overlapping blocks");
	}
	int64_t	totalarchive=0;
	vector <s_fileandsize> fileandsize;
	vector <s_fileandsize> chunkfile;
	for (DTMap::iterator p=dt.begin(); p!=dt.end(); ++p) 
		if (!isdirectory(p->first))
				if (p->second.size>0)
				{
					totalarchive+=p->second.size;
					string myhashtype	="";
					string myhash		="";
					string mycrc32		="";
					decode_franz_block(false,p->second.franz_block,
					myhashtype,
					myhash,
					mycrc32);
					MAPPACHECK::iterator a=g_mychecks.find(myhashtype);
					s_fileandsize myblock;
					myblock.filename	=p->first;
					myblock.size		=p->second.size;
					myblock.attr		=p->second.attr;
					myblock.date		=p->second.date;
					myblock.data		=p->second.data;
					myblock.isdir		=isdirectory(p->first);
					if (a!=g_mychecks.end())
					{
						myblock.hashtype=myhashtype;
						myblock.hashhex=myhash;
						myblock.flaghashstored=true;
					}
					else
						myblock.flaghashstored=false;
					fileandsize.push_back(myblock);
				}
	sort(fileandsize.begin(),fileandsize.end(),comparefilenamesize);
	int64_t biggestfile=fileandsize[fileandsize.size()-1].size*1.1;
	if (flagverbose)
		myprintf("Minimum needed  (+10%%) %21s %s\n",migliaia(biggestfile),fileandsize[fileandsize.size()-1].filename.c_str());
	int64_t freediskspace=0;
	int64_t	freeramdisk=0;
	if (flagramdisk)
	{
		freeramdisk=getramdisksize()*75/100;
		if (flagverbose)
			myprintf("Free RAM (-25%%)        %21s (as reported by OS)\n",migliaia(freeramdisk));
	}
	if (flagtest)
		freediskspace=totalarchive;
	else
	{
		if (tofiles.size()>0) 
		{
			freediskspace=getfreespace(outputdirectory)*90/100;
			if (!flagspace)
			{
				if (flagverbose)
					myprintf("Free work space (-10%%) %21s on <<-to %s>>\n",migliaia(freediskspace),outputdirectory.c_str());
				if (! (flagverify && flagparanoid))
					if (freediskspace<totalarchive)
					{
						myprintf("41173: free space too small %s, at least %s (bypass with -space)\n",migliaia(freediskspace),migliaia2(totalarchive+1));
						return 1;
					}
			}
		}
	}
	int64_t spazio=0;
	if (flagramdisk)
		spazio=freeramdisk;
	else
		spazio=freediskspace;
	if (maxsize>0)
		spazio=maxsize;
	if (flagfrugal)
		spazio=biggestfile;
	unsigned		int	chunkscount	=0;
	int64_t			chunkcorrente	=0;
	unsigned int 	indice			=0;
	string	initialtofiles=tofiles[0];
	char	chunksbuffer[10];
	chunkfiles.clear();
	int	quantichunk=0;
	while (indice<fileandsize.size())
		if ((chunkcorrente+(int64_t)fileandsize[indice].size)>spazio)
		{
			chunkcorrente=0;
			quantichunk++;
		}
		else
		{
			chunkcorrente+=fileandsize[indice].size;
			indice++;
		}
	quantichunk++;
	if (spazio>totalarchive)
			spazio=totalarchive;
	myprintf("Chunks %04d x          %21s (total decompressed size %s)\n",quantichunk,migliaia(spazio),migliaia2(totalarchive));
	if (!flagspace)
		if (!flagtest)
		{
			if (spazio<biggestfile)
			{
				myprintf("41165: chunk size (-maxsize) too small %s, at least %s needed (bypass with -space)\n",migliaia(spazio),migliaia2(biggestfile+1));
				return 1;
			}
			if (tofiles.size()>0)
				if (freediskspace<spazio)
				{
					myprintf("41173: free disk space too small %s, at least %s (bypass with -space)\n",migliaia(freediskspace),migliaia2(spazio+1));
					return 1;
				}
		}
	if ((!flagtest) && (!(flagverify && flagparanoid)))
	{
		if (flagverbose)
		{
			print_datetime();
			myprintf("44567: creating folders tree and zero-bytes files\n");
		}
		for (DTMap::iterator p=dt.begin(); p!=dt.end(); ++p) 
		{
			string thefolder=rename(p->first);
			if (isdirectory(thefolder))
				makepath(thefolder,p->second.date,p->second.attr);
			else
			{
				if (p->second.size==0)
				{
					FILE* myfile=fopen(thefolder.c_str(), "wb");
					fclose(myfile);
					close(thefolder.c_str(),p->second.data,p->second.attr);
				}
			}
		}
		if (flagverbose)
		{
			print_datetime();
			myprintf("44574: end\n");
		}
	}	
	indice=0;
	chunkcorrente=0;
	int	chunkinlavorazione=1;
	while (indice<fileandsize.size())
		if ((chunkcorrente+(int64_t)fileandsize[indice].size)>spazio)
		{
			printbar('=');
			errors+=extractqueue2(chunkscount,quantichunk);
			if (flagverify)
				errors+=multiverify(chunkfile);
			if (errors==0)
			myprintf("Stage XTR %04d : errors  %d (0=good)\n",chunkinlavorazione,errors);
			else
			myprintf("Stage XTR %04d : errors  %d (0=good) *** NOT GOOD ***\n",chunkinlavorazione,errors);
			chunkcorrente=0;
			chunkscount++;
			chunkfile.clear();
			chunkfiles.clear();
			chunkinlavorazione++;
		}
		else
		{
			if (flagverify && flagparanoid)	
			{
				sprintf(chunksbuffer,"%08d",chunkscount);
				tofiles[0]=initialtofiles+chunksbuffer+"/";
			}
			else
				tofiles[0]=initialtofiles;
			chunkcorrente+=fileandsize[indice].size;
			string fn=fileandsize[indice].filename;
			if (!isdirectory(fn))
			{
				string writtenfilename=rename(fn);
				fileandsize[indice].writtenfilename=writtenfilename;
				chunkfile.push_back(fileandsize[indice]);
				chunkfiles.push_back(fn);
				indice++;
			}
		}
	printbar('=');
	errors+=extractqueue2(chunkscount,quantichunk);
	if (flagverify)
		errors+=multiverify(chunkfile);
	if (errors==0)
		myprintf("Stage VEF %04d : errors  %d (0=good)\n",chunkinlavorazione,errors);
	else
		myprintf("Stage VEF %04d : errors  %d (0=good) *** NOT GOOD ***\n",chunkinlavorazione,errors);
	printbar('=');
	if (flagverify && flagparanoid)
			if (!removetempdirifempty(outputdirectory,true))
				errors++;
	return errors>0;
}
bool Jidac::removetempdirifempty(string i_folder,bool i_deleteifsizezero=false)
{
	if (flagdebug)
		myprintf("\n44385 removetempdirifempty on %s\n",i_folder.c_str());
	if (i_folder=="")
		return false;
	if (isdirectory(i_folder))
		i_folder=i_folder.substr(0,i_folder.size()-1);
	if (flagdebug)
		myprintf("\n44394 ready on %s\n",i_folder.c_str());
	if (!direxists(i_folder))
	{
		myprintf("\nFolder does not exist? ");
		printUTF8(i_folder.c_str());
		myprintf("\n");
		return false;
	}
	if (flagdebug)
		myprintf("\n44406 removeemptydirs on %s\n",i_folder.c_str());
	removeemptydirs(i_folder,true);
	uint64_t 		totalsize=0;
	unsigned int 	totalfile=0;
	unsigned int 	totaldir=0;
	unsigned int	totallongfiles=0;
	bool 			somefile=false;
	if (flagdebug)
		myprintf("\n44417 getfoldersize on %s\n",i_folder.c_str());
	getfoldersize(i_folder,totalsize,totalfile,totaldir,totallongfiles);
	if (flagdebug)
	{
		myprintf("43308: files %s folders %s size %s ",migliaia(totalfile),migliaia2(totaldir),migliaia3(totalsize));
		if ((totalfile==0) && (totalsize==0))
			myprintf("THIS IS GOOD");
		else
			myprintf("*** SOMETHING HERE ***");
		myprintf("\n");
	}
	if (totalfile)			
		somefile=true;
	if (totalsize>0)		
		somefile=true;
	if (totalsize==0) 		
		if (i_deleteifsizezero)
			somefile=false;
	if (somefile)
	{
		myprintf("41279: some files founded in %s, do nothing\n",i_folder.c_str());
	}
	else
	{
		if (flagverbose)
		{
			myprintf("44445: No files found (this is good): deleting everything in <<");
			printUTF8(i_folder.c_str());
			myprintf(">>\n");
		}
		return stermina(i_folder,totalfile); 
	}
	return false;
}
int Jidac::multiverify(vector <s_fileandsize>& i_arrayfilename)
{
	myprintf("VERIFY (=re-read from filesystem) and compare hashes\n");
	g_dimensione=0;
	for (MAPPACHECK::iterator p=g_mychecks.begin(); p!=g_mychecks.end(); ++p) 
	{
		p->second.checkedok			=0;
		p->second.checkedfailed		=0;
		p->second.checkednotfound	=0;
	}
	int 		checkedbyhash	=0;
	uint64_t 	hashtotali		=0;
	int			nohashfound		=0;
	vector<string> 	myfiles;
	vector<string> 	myfilehash;
	vector<string> 	myfilesoriginal;		
	vector<string> 	myalgo;
	for (unsigned int i=0;i<i_arrayfilename.size();i++)
		if (i_arrayfilename[i].hashhex!="")
		{
			myfiles			.push_back(i_arrayfilename[i].writtenfilename);
			myfilesoriginal	.push_back(i_arrayfilename[i].filename);
			myfilehash		.push_back(i_arrayfilename[i].hashhex);
			myalgo			.push_back(i_arrayfilename[i].hashtype);
			hashtotali+=i_arrayfilename[i].size;
		}
	unsigned int mythreads=howmanythreads;
	if (flagssd)
	{
		if (myfiles.size()<mythreads)
			mythreads=myfiles.size();
	}
	else
		mythreads=1;
	vector<tparametrihash> 	vettoreparametrihash;
	tparametrihash 	myblock;
	for (unsigned int i=0;i<mythreads;i++)
	{
		myblock.tnumber		=(i%mythreads);
		myblock.inizio		=mtime();
		myblock.dimensione	=hashtotali;
		myblock.timestart	=0;
		myblock.timeend		=0;
		vettoreparametrihash.push_back(myblock);
	}
	for (unsigned int i=0;i<myfiles.size();i++)
	{
		vettoreparametrihash[i%mythreads].filestobehashed.	push_back(myfiles[i]);
		vettoreparametrihash[i%mythreads].algo.				push_back(myalgo[i]);
		vettoreparametrihash[i%mythreads].filehash.			push_back(myfilehash[i]);
		vettoreparametrihash[i%mythreads].originalfilenames.push_back(myfilesoriginal[i]);
	}
	int totfile=0;
	for (unsigned int i=0;i<mythreads;i++)
	{
		if (flagdebug)
			myprintf("Thread [%02d] files %s\n",i,migliaia(vettoreparametrihash[i].filestobehashed.size()));
		totfile+=+vettoreparametrihash[i].filestobehashed.size();
	}
	int rc;
	pthread_t* threads = new pthread_t[mythreads];
	pthread_attr_t attr;
	void *status;
	pthread_attr_init(&attr);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_JOINABLE);
	if (flagverbose)
		myprintf("Total files %s -> in %03d threads -> %s to be checked\n",migliaia(myfiles.size()),mythreads,migliaia2(totfile));
	int64_t	startrunning=mtime();
	for(unsigned int i=0; i<mythreads; i++ ) 
	{
		vettoreparametrihash[i].timestart=mtime();
		rc = pthread_create(&threads[i], &attr, scansionahash, (void*)&vettoreparametrihash[i]);
		if (rc) 
		{
			myprintf("39264: Error creating thread\n");
			exit(-1);
		}
	}
	pthread_attr_destroy(&attr);
	for(unsigned int i=0; i <mythreads; i++ ) 
	{
		rc = pthread_join(threads[i], &status);
		if (rc) 
		{
			error("39275: Unable to join\n");
			exit(-1);
		}
	}
	for(unsigned int i=0;i<mythreads;i++)
		for (unsigned int j=0;j<vettoreparametrihash[i].filestobehashed.size();j++)
		{
			string finalfile		=vettoreparametrihash[i].filestobehashed[j];
			string myhashtype		=vettoreparametrihash[i].algo[j];
			MAPPACHECK::iterator a	=g_mychecks.find(myhashtype);
			if (myhashtype=="")
			{
				nohashfound++;
				if (flagverbose)
					myprintf("44695: NO hashtype %s\n",finalfile.c_str());
			}
			else
			{
			if (a!=g_mychecks.end())
			{
				checkedbyhash++;
				if (vettoreparametrihash[i].o_hashcalculated[j]=="")
				{
					if (flagverbose || (g_output!=""))
					{
						myprintf("FILE NOT FOUND on %s: FILE ",myhashtype.c_str());
						printUTF8(finalfile.c_str());
						myprintf("\n");
					}
					a->second.checkednotfound++;
				}
				else
				{
					if (vettoreparametrihash[i].o_hashcalculated[j]==vettoreparametrihash[i].filehash[j])
						{
							if (flagdebug)
								myprintf("GOOD %s:  STORED == FROM FILE %s\n",myhashtype.c_str(),finalfile.c_str());
							a->second.checkedok++;
							DTMap::iterator p=dt.find(vettoreparametrihash[i].originalfilenames[j]);
							if (p!=dt.end())
								a->second.checksize+=p->second.size; 
							else
							{
								if (flagdebug)
									myprintf("38931: Cannot find originalfilename %s\n",vettoreparametrihash[i].originalfilenames[j].c_str());
							}
						}
						else
						{
							if (flagverbose || (g_output!=""))
							{
								myprintf("ERROR on %s: STORED HASH %s VS %s IN FILE ",myhashtype.c_str(),vettoreparametrihash[i].filehash[j].c_str(),vettoreparametrihash[i].o_hashcalculated[j].c_str());
								printUTF8(finalfile.c_str());
								myprintf("\n");
							}
							a->second.checkedfailed++;
						}
					}
				}
				else
				{
					nohashfound++;
					if (flagverbose)
						myprintf("44750: algo unknown (or no algo!) %s\n",finalfile.c_str());
				}
			}
		}
	int risultato=0;
	bool outsomething=(nohashfound>0);
	if (nohashfound>0)
		risultato=1;
	for (MAPPACHECK::iterator p=g_mychecks.begin(); p!=g_mychecks.end(); ++p) 
		outsomething |= (p->second.checkedfailed+p->second.checkednotfound);
	if (flagverbose)
		outsomething=true;
	if (outsomething)
	{
		if (!flagverbose)
			myprintf("\n");
		printbar('-');
		int64_t	byteshashed=0;
		for (MAPPACHECK::iterator p=g_mychecks.begin(); p!=g_mychecks.end(); ++p) 
		{
			byteshashed+=p->second.checksize;
			if (p->second.checkedok)
				if (flagverbose)
					myprintf("OK   %8s : %08d of %08d (%12s hash check against file on disk)\n",p->first.c_str(),p->second.checkedok,(int)myfiles.size(),tohuman(p->second.checksize));
			if (p->second.checkedfailed)
			{
				myprintf("FAIL %8s : %08d of %08d (   FAILED    hash check against file on disk) ***\n",p->first.c_str(),p->second.checkedfailed,myfiles.size());
				risultato=2;
			}
			if (p->second.checkednotfound)
			{
				myprintf("WARN %8s : %08d of %08d (file not found, cannot check hash)\n",p->first.c_str(),p->second.checkednotfound,myfiles.size());
				if (risultato!=2)
					risultato=1;
			}
		}
		if (nohashfound)
			myprintf("UNKNOWN/NOHASH: %08d of %08d (legacy 7.15 archive?)\n",nohashfound,myfiles.size());
		printbar('-');
		if (flagverbose)
			myprintf("Total hashed bytes %s @ %s B/s\n",migliaia((uint64_t)byteshashed),migliaia2((uint64_t)(byteshashed/((mtime()-startrunning)/1000.0))));
	}
	delete [] threads;
	if (flagverify)
		if (flagparanoid) 
		{
			if (flagdebug)
				myprintf("44950: -paranoid, deleting files with OK matches\n");
			bool	alldeleted=true;
			uint32_t	tobedeleted=0;
			for(unsigned int i=0;i<mythreads;i++)
				tobedeleted+=vettoreparametrihash[i].filestobehashed.size();
			uint32_t	testati=0;
			int			percentualestampata=0;
			myprintf("Purging ");
			for(unsigned int i=0;i<mythreads;i++)
				for (unsigned int j=0;j<vettoreparametrihash[i].filestobehashed.size();j++)
				{
					testati++;
					int percentuale=(int)(100.0*testati/tobedeleted);
					if ((percentuale %10 ==0))
					if (percentuale!=percentualestampata)
					{
						myprintf("%d ",percentuale);
					percentualestampata=percentuale;
					}
					if (vettoreparametrihash[i].o_hashcalculated[j]!="")
					{
						if (vettoreparametrihash[i].o_hashcalculated[j]==vettoreparametrihash[i].filehash[j])
						{	
							if (!delete_file(vettoreparametrihash[i].filestobehashed[j].c_str()))
							{
								if (flagverbose || (g_output!=""))
								{
									myprintf("45256: cannot delete ");
									printUTF8(vettoreparametrihash[i].filestobehashed[j].c_str());
									myprintf("\n");
								}
								alldeleted=false;
							}
						}
						else
						{
						alldeleted=false;
						if (flagverbose)
						{
							myprintf("44697: NON DELETED ");
							printUTF8(vettoreparametrihash[i].filestobehashed[j].c_str());
							myprintf("\n");
						}
						}
					}
					else
						alldeleted=false;
				}
			myprintf("\r");
			printbar(' ',false);
			myprintf("\r");
			if (flagverbose)
				if (!alldeleted)
				{
					myprintf("MMMMMMMMMMMMMMMMMMMMMMMMMMMMM\n");
					myprintf("MMMMMMMMMMMMMMMMMMMMMMMMMMMMM\n");
					myprintf("MMMMMMMMMMMMMMMMMMMMMMMMMMMMM\n");
					myprintf("MMMMMMMM  GURUUUU  MMMMMMMMMM\n");
					myprintf("MMMMMMMMMMMMMMMMMMMMMMMMMMMMM\n");
					myprintf("MMMMMMMMMMMMMMMMMMMMMMMMMMMMM\n");
					myprintf("MMMMMMMMMMMMMMMMMMMMMMMMMMMMM\n");
				}
			if (flagverbose)
				myprintf("44667: removing temp dir (if empty) %s\n",tofiles[0].c_str());
			if (!removetempdirifempty(tofiles[0],false))
			{
				if (flagverbose)
				{
					myprintf("44719: something left in ");
					printUTF8(tofiles[0].c_str());
					myprintf("\n");
				}
				risultato++;
			}
			else
			{
				if (flagdebug)
				{
					myprintf("44732: folder removed ");
					printUTF8(tofiles[0].c_str());
					myprintf("\n");
				}
			}
		}
	return risultato;
}
int Jidac::extractqueue2(int i_chunk,int i_chunksize)
{
	if (i_chunk<0)
	{
		myprintf("44664: chunk must be >=0\n");
		return 0;
	}
	if (chunkfiles.size()==0)
	{
		myprintf("44669: WARN: chunfiles.size == 0\n");
		return 0;
	}
	vector<Block> preblock=block;      			
	sort(chunkfiles.begin(),chunkfiles.end()); 
	int	errors		=0;
	int total_files	=0;
	int filesinchunk=0;
	ExtractJob job(*this);
	for (DTMap::iterator p=dt.begin(); p!=dt.end(); ++p) 
	{
		p->second.data=-1;  
		if (std::binary_search(chunkfiles.begin(), chunkfiles.end(), p->first)) 
		{
			string fn=rename(p->first);
			string dummy="";
			if (block.size()>0)  
			{  
				filesinchunk++;
				p->second.data=0;
				unsigned lo=0, hi=block.size()-1;  
				for (unsigned i=0; p->second.data>=0 && i<p->second.ptr.size(); ++i) 
				{
					unsigned j=p->second.ptr[i];  
					if (j==0 || j>=ht.size() || ht[j].usize<-1) 
					{
						fflush(stdout);
						printUTF8(p->first.c_str());
						myprintf( ": bad frag IDs, skipping...\n");
						p->second.data=-1;  
						continue;
					}
					assert(j>0 && j<ht.size());
					if (lo!=hi || lo>=block.size() || j<block[lo].start
						|| (lo+1<block.size() && j>=block[lo+1].start)) 
					{
						lo=0;  
						hi=block.size()-1;
						while (lo<hi) 
						{
							unsigned mid=(lo+hi+1)/2;
							assert(mid>lo);
							assert(mid<=hi);
							if (j<block[mid].start) 
								hi=mid-1;
							else 
							(lo=mid);
						}
					}
					assert(lo==hi);
					assert(lo>=0 && lo<block.size());
					assert(j>=block[lo].start);
					assert(lo+1==block.size() || j<block[lo+1].start);
					unsigned c=j-block[lo].start+1;
					if (block[lo].size<c) block[lo].size=c;
					if (block[lo].files.size()==0 || block[lo].files.back()!=p)
						block[lo].files.push_back(p);
				}
				++total_files;
				job.total_size+=p->second.size;
			}
			else
				myprintf("43406 BLOCK ZERO %s\n",fn.c_str());
		}  
	}  
	g_crc32.clear();
	if (flagverbose)
	myprintf("Chunk %03d/%03d %21s bytes (%s) in %s files by %d threads\n",i_chunk+1,i_chunksize,migliaia(job.total_size), tohuman(job.total_size),migliaia2(total_files),howmanythreads);
	int64_t startextract=mtime();
	vector<ThreadID> tid(howmanythreads);
	for (unsigned i=0; i<tid.size(); ++i)
		if (flagramdisk)
			run(tid[i], decompressthreadramdisk, &job);
		else
			run(tid[i], decompressThread, &job);
	for (unsigned i=0; i<tid.size(); ++i) 
		join(tid[i]);
	printbar(' ',false);
	myprintf("\r");	
	if (!flagramdisk)
	{
		unsigned extracted=0;
		for (DTMap::iterator p=dt.begin(); p!=dt.end(); ++p) 
		{
			string fn=rename(p->first);
			if (std::binary_search(chunkfiles.begin(), chunkfiles.end(), p->first)) 
			{
				++extracted;
				if (p->second.ptr.size()!=unsigned(p->second.data)) 
				{
					fflush(stdout);
					if (++errors==1)
						myprintf("\nFailed (extracted/total fragments, file):\n");
					myprintf( "SOK p->second.data %u / p->second.ptr.size() %u ",int(p->second.data), int(p->second.ptr.size()));
					printUTF8(fn.c_str());
					myprintf("\n");
				}
			}
		}
		if (errors>0) 
		{
			fflush(stdout);
			myprintf("\nExtracted %s files (%s errors) using %s bytes x %d threads\n",
			migliaia(extracted), migliaia3(errors), migliaia4(job.maxMemory),
			int(tid.size()));
		}
		block=preblock; 
		chunkfiles.clear();
		return errors>0;
	}
	int64_t endextract=mtime();
	double	time_extract=(endextract-startextract)*0.001+0.001;
	if (flagverbose)
	{
		myprintf("RAMDISK       %21s bytes (%s) ",migliaia(g_ramdisksize),tohuman(g_ramdisksize)); 
		myprintf("time %.2f s @ %s (%s/s)\n",time_extract,migliaia(job.total_size/time_extract),tohuman(job.total_size/time_extract));
	}
	int64_t 	startwrite=mtime();
	int64_t 	expected=0;
	uint32_t	file_expected=0;
	vector<string> 		myfiles;
	vector<int64_t> 	mydate;
	vector<int64_t> 	myattr;
	vector<string> 		myfilehash;
	vector<string> 		myalgo;
	vector<char*> 		mydata;
	vector<int64_t> 	myfilesize;
	vector<string> 		myfilecrc;
	for (DTMap::iterator p=dt.begin(); p!=dt.end(); ++p) 
		if (std::binary_search(chunkfiles.begin(), chunkfiles.end(), p->first)) 
		{
			string finalfile=rename(p->first);
			if ((searchfrom!="") && (replaceto!=""))
				replace(finalfile,searchfrom,replaceto);
			string myhashtype	="";
			string myhash		="";
			string mycrc32		="";
			if (!isdirectory(finalfile))
			{	
				decode_franz_block(false,p->second.franz_block,
					myhashtype,
					myhash,
					mycrc32);
				myfilesize.push_back((*p->second.pramfile).filesize);
				expected+=(*p->second.pramfile).filesize;
				mydata.push_back((*p->second.pramfile).data);
				file_expected++;
			}
			else
			{
				myfilesize.push_back(0);
				mydata.push_back(NULL);
			}
			myfiles.push_back(finalfile);
			myfilehash.push_back(myhash);
			myfilecrc.push_back(mycrc32);
			myalgo.push_back(myhashtype);
			mydate.push_back(p->second.date);
			myattr.push_back(p->second.attr);
		}
	unsigned int mythreads=howmanythreads;
	if (myfiles.size()<mythreads)
		mythreads=myfiles.size();
	if (flagssd)
	{
		if (myfiles.size()<mythreads)
			mythreads=myfiles.size();
	}
	else
		mythreads=1;
	vector<tparametriramtodisk> vettoreramtodisk;
	tparametriramtodisk 	myblock;
	for (unsigned int i=0;i<mythreads;i++)
	{
		myblock.tnumber		=(i%mythreads);
		myblock.timestart	=mtime();
		myblock.o_timeend	=0;
		myblock.flagtest	=flagtest;
		vettoreramtodisk.push_back(myblock);
	}
	if (flagdebug)
	{
		myprintf("33817: myfiles    %12s\n",migliaia(myfiles.size()));
		myprintf("33817: mydate     %12s\n",migliaia(mydate.size()));
		myprintf("33817: myattr     %12s\n",migliaia(myattr.size()));
		myprintf("33817: myalgo     %12s\n",migliaia(myalgo.size()));
		myprintf("33817: myfilehash %12s\n",migliaia(myfilehash.size()));
		myprintf("33817: mysize     %12s\n",migliaia(myfilesize.size()));
		myprintf("33817: mydata     %12s\n",migliaia(mydata.size()));
		myprintf("33817: mycrc32    %12s\n",migliaia(myfilecrc.size()));
	}
	for (unsigned int i=0;i<myfiles.size();i++)
	{
		vettoreramtodisk[i%mythreads].filenameondisk	.push_back(myfiles[i]);
		vettoreramtodisk[i%mythreads].filedate			.push_back(mydate[i]);
		vettoreramtodisk[i%mythreads].fileattr			.push_back(myattr[i]);
		vettoreramtodisk[i%mythreads].algo				.push_back(myalgo[i]);
		vettoreramtodisk[i%mythreads].filehash			.push_back(myfilehash[i]);
		vettoreramtodisk[i%mythreads].filesize			.push_back(myfilesize[i]);
		vettoreramtodisk[i%mythreads].data				.push_back(mydata[i]);
		vettoreramtodisk[i%mythreads].filecrc			.push_back(myfilecrc[i]);
	}
	int totfile=0;
	for (unsigned int i=0;i<mythreads;i++)
	{
		if (flagdebug)
			myprintf("Thread [%02d] files %s\n",i,migliaia(vettoreramtodisk[i].filenameondisk.size()));
		totfile+=+vettoreramtodisk[i].filenameondisk.size();
	}
	int rc;
	pthread_t* threads = new pthread_t[mythreads];
	pthread_attr_t attr;
	void *status;
	pthread_attr_init(&attr);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_JOINABLE);
	assert(myfiles.size()==totfile);
	printbar(' ',false);
	myprintf("\r");
	if (flagverbose)
		myprintf("Running %d threads on %s files\n",mythreads,migliaia(myfiles.size()));
	for(unsigned int i=0; i<mythreads; i++ ) 
	{
		vettoreramtodisk[i].timestart=mtime();
		rc = pthread_create(&threads[i], &attr, scriviramtodisk, (void*)&vettoreramtodisk[i]);
		if (rc)
		{
			myprintf("39264: Error creating thread\n");
			exit(-1);
		}
	}
	pthread_attr_destroy(&attr);
	for(unsigned int i=0; i <mythreads; i++ ) 
	{
		rc = pthread_join(threads[i], &status);
		if (rc) 
		{
			error("33821: Unable to join\n");
			exit(-1);
		}
	}
	int64_t			t_crcsize			=0;
	int64_t			t_hashedsize		=0;
	int64_t			t_writtenbythread	=0;
	int64_t			t_timecrc 			=1;
	int64_t			t_timehash			=1;
	int64_t			t_timefilesystem	=1;
	int64_t			t_timewrite			=1;
	uint32_t		t_writeerror		=0;
	uint32_t		t_fileok			=0;
	uint32_t		t_fileerror			=0;
	uint32_t		t_filesnotchecked	=0;
	uint32_t		t_filewithoutcrc	=0;
	uint32_t		t_filecrc			=0;
	uint32_t		t_filecrcok			=0;
	uint32_t		t_filecrcerror		=0;
	for(unsigned int i=0;i<mythreads;i++)
	{
		t_crcsize			+=vettoreramtodisk[i].o_crcsize;
		t_hashedsize		+=vettoreramtodisk[i].o_hashedsize;
		t_writtenbythread	+=vettoreramtodisk[i].o_writtenbythread;
		t_timecrc			+=vettoreramtodisk[i].o_timecrc;
		t_timehash			+=vettoreramtodisk[i].o_timehash;
		t_timefilesystem	+=vettoreramtodisk[i].o_timefilesystem;
		t_timewrite			+=vettoreramtodisk[i].o_timewrite;
		t_writeerror		+=vettoreramtodisk[i].o_writeerror;
		t_fileok			+=vettoreramtodisk[i].o_fileok;
		t_fileerror			+=vettoreramtodisk[i].o_fileerror;
		t_filesnotchecked	+=vettoreramtodisk[i].o_filesnotchecked;
		t_filewithoutcrc	+=vettoreramtodisk[i].o_filewithoutcrc;
		t_filecrc			+=vettoreramtodisk[i].o_filecrc;
		t_filecrcok			+=vettoreramtodisk[i].o_filecrcok;
		t_filecrcerror		+=vettoreramtodisk[i].o_filecrcerror;
	}
	double writetime=(1+mtime()-startwrite)*0.001;
	if (t_filecrcerror)
		errors++;
	if (t_fileerror)
		errors++;
	bool	issomething=(t_filecrcerror || t_fileerror || (t_crcsize!=expected) || t_filewithoutcrc || (t_hashedsize!=expected) || (t_filesnotchecked!=0) || (t_fileok!=file_expected));
	if (flagverbose)
	if (flagverify || flagchecksum)
	{	
		if (issomething)
			printbar('-');
		myprintf("CRC-32 %21s ",migliaia(t_crcsize));
		if (t_crcsize==expected)
			myprintf("[OK] ");
		else
			myprintf("[WARN] ");
		myprintf("(%8.2f s) @ %8s/s ",t_timecrc*0.001,tohuman(t_crcsize/(t_timecrc*0.001)));
		myprintf("UNKN %s ",migliaia(t_filewithoutcrc));
		if (t_filewithoutcrc==0)
			myprintf("[OK] ");
		else
			myprintf("[WARN] ");
		myprintf("GOOD %s ",migliaia(t_filecrcok));
		if (t_filecrcok==file_expected)
			myprintf("[OK] ");
		else
			myprintf("[WARN] ");
		myprintf("BAD %s ",migliaia(t_filecrcerror));
		if (t_filecrcerror==0)
			myprintf("[OK]");
		else
			myprintf("[FAULT: -verbose] ");
		myprintf("\n");
		myprintf("HASHes %21s ",migliaia(t_hashedsize));
		if (t_hashedsize==expected)
			myprintf("[OK] ");
		else
			myprintf("[WARN] ");
		myprintf("(%8.2f s) @ %8s/s ",t_timehash*0.001,tohuman(t_hashedsize/(t_timehash*0.001)));
		myprintf("UNKN %s ",migliaia(t_filesnotchecked));
		if (t_filesnotchecked==0)
			myprintf("[OK] ");
		else
			myprintf("[WARN] ");
		myprintf("GOOD %s ",migliaia(t_fileok));
		if (t_fileok==file_expected)
			myprintf("[OK] ");
		else
			myprintf("[WARN] ");
		myprintf("BAD %s ",migliaia(t_fileerror));
		if (t_fileerror==0)
			myprintf("[OK] ");
		else
			myprintf("[FAULT! -verbose] ");
		myprintf("\n");
		printbar('-');
	}
	if (!flagtest)
	{
		if (flagverbose)
		{
			myprintf("Time on FS (%6.2f s) writing data (%6.2f s) @ %s/s\n",t_timefilesystem*0.001,t_timewrite*0.001,tohuman(t_writtenbythread/(t_timewrite*0.001)));
			myprintf("Written by threads %21s / reported write errors %d ",migliaia(t_writtenbythread),t_writeerror);
			if (t_writeerror==0)
				myprintf("[OK] ");
			else
				myprintf("[FAULT!] ");
			myprintf("\n");
		}
	}
	if (flagverbose)
	{
		myprintf("Bytes expected     %21s (%6.2f s) @ %s B/s ",migliaia2(expected),writetime,migliaia3((t_writtenbythread/writetime)));
		if (!flagtest)
		{
			if (t_writtenbythread==expected)
				myprintf("[OK]");
			else
				myprintf("[FAULT!] ");
		}
		myprintf("\n");
		myprintf("RAMDISK releasing  %21s bytes ",migliaia(g_ramdisksize));
	}
	for (DTMap::iterator p=dt.begin(); p!=dt.end(); ++p) 
		if (std::binary_search(chunkfiles.begin(), chunkfiles.end(), p->first)) 
			if (p->second.pramfile!=NULL)
				(*p->second.pramfile).reset();
	if (flagverbose)
		myprintf("to %s (should be zero)\n",migliaia(g_ramdisksize));
	if (g_ramdisksize!=0)
		myprintf("\n\n45519: WARNING SOMETHING WRONG WITH RAM!\n");
	block=preblock; 
	chunkfiles.clear();
	return errors>0;
}
int Jidac::removeemptydirs(string i_folder,bool i_kill)
{
	if (i_folder=="")
		return 0;
	if (isdirectory(i_folder))
		i_folder=i_folder.substr(0,i_folder.size()-1);
	DTMap mydestinationdir;
	if (flagdebug)
	{
		myprintf("45124: Scanning dir <<");
		printUTF8(i_folder.c_str());
		myprintf(">>\n");
	}
	scandir(false,mydestinationdir,i_folder);
	printbar(' ',false);
	myprintf("\r");
	vector<string> scannedfiles;
	for (DTMap::iterator p=mydestinationdir.begin(); p!=mydestinationdir.end(); ++p) 
		scannedfiles.push_back(p->first);
	myprintf("Scanned files %s\n",migliaia(scannedfiles.size()));
	vector<string> tobedeleted;
	int candidati=0;
	for (unsigned int i=0;i<scannedfiles.size();i++)
		if (i<scannedfiles.size())
			if (isdirectory(scannedfiles[i]))
				{
					string corrente=scannedfiles[i];
					bool flagfigli=false;
					for (unsigned int j=i+1;j<scannedfiles.size();j++)
					{
						string prossima=extractfilepath(scannedfiles[j]);
						string nomefile=extractfilename(scannedfiles[j]);
						{
							if (mypos(corrente,prossima)!=0)
							{
								break;
							}
							else
							{
								if (!isdirectory(scannedfiles[j]))
								{
									flagfigli=true;
									break;
								}
							}
						}
					}
					if (flagfigli==0)
						tobedeleted.push_back(scannedfiles[i]);
				}
	candidati=tobedeleted.size();
	if (flagdebug)
	{
		printbar('-');
		for (unsigned int i=0;i<tobedeleted.size();i++)
		{
			myprintf("45264: TO BE DELETED <<");
			printUTF8(tobedeleted[i].c_str());
			myprintf(">>\n");
		}
		printbar('-');
	}
	if (candidati==0)
	{
		if (flagverbose)
		{
			myprintf("45291: zero candidates <<");
			printUTF8(i_folder.c_str());
			myprintf(">>\n");
		}
		return 0;
	}
	if (!i_kill)
	{
		myprintf("45344: Empty folders        %12s on <<",migliaia(candidati));
		printUTF8(i_folder.c_str());
		myprintf(">>\n");
		myprintf("45347: dry run, exiting (no -kill)\n");
		return 0;
	}	
	if (flagverbose)
		myprintf("45291: Empty folders %12s ",migliaia(candidati));
	int lastrun=tobedeleted.size();
	int newrun=0;
	int64_t startdelete=mtime();
	int runs=0;
	while (lastrun>newrun)
	{
		runs++;
		for (unsigned int i=0;i<tobedeleted.size();i++)
			if (delete_dir(tobedeleted[i].c_str()))
				tobedeleted.erase(tobedeleted.begin()+i);
		newrun=tobedeleted.size();
		if (flagdebug)
			myprintf("\nlastrun - newrun %d %d\n",lastrun,newrun);
		if (lastrun>newrun)
		{
			lastrun=newrun;
			newrun=0;
		}
	}
	if (flagverbose)
	{
		myprintf(" time %.2f sec, runs %04d, highlanders %s <<",(mtime()-startdelete)/1000.0,runs,migliaia(tobedeleted.size()));
		printUTF8(i_folder.c_str());
		myprintf(">>\n");
	}
	if (tobedeleted.size()>0)
		if (flagdebug)
			for (unsigned int i=0;i<tobedeleted.size();i++)
			{
				myprintf("Highlander <<");
				printUTF8(tobedeleted[i].c_str());
				myprintf(">>\n");
			}
	if (tobedeleted.size()==0)
		return 0;
	else
		return 1;
}
int Jidac::adminrun()
{
	return 0;
}
int Jidac::windowsc()
{
	return 0;
}
int Jidac::hashselect()
{
	if (dt.size()==0)
		return 0;
	int64_t		startrecalc=mtime();
	vector<string> myfiles;
	vector<string> myhashestype;
	vector<string> mydirs;
	int quantifiles					=0;
	int64_t total_size				=0;  
	for (DTMap::iterator p=edt.begin(); p!=edt.end(); ++p) 
		if (p->second.date) 
			if((p->first!="") && (!isdirectory(p->first)) && (!isads(p->first))) 
			{
				string filename=rename(p->first);
				DTMap::iterator a=dt.find(filename);
				string solonome=extractfilename(filename);
				string myhashtype	="";
				string myhash		="";
				string mycrc32		="";
				if (a!=dt.end())
				{
					decode_franz_block(isdirectory(filename),a->second.franz_block,
					myhashtype,
					myhash,
					mycrc32);
					if (myhashtype!="")
						if (myhash!="")
						{
							a->second.hexhash		=myhash;
							a->second.hashtype		=myhashtype;
							myfiles.push_back		(p->first);
							myhashestype.push_back	(myhashtype);
							total_size+=p->second.size;
							quantifiles++;
						}
				}
			}
	if (myfiles.size()==0)
	{
		return 0;
	}
	vector<string> 			myhash;
	vector<tparametrihash> 	vettoreparametrihash;
	unsigned int mythreads=howmanythreads;
	if (flagssd)
	{
		if (myfiles.size()<mythreads)
			mythreads=myfiles.size();
	}
	else
		mythreads=1;
	tparametrihash 	myblock;
	for (unsigned int i=0;i<mythreads;i++)
	{
		myblock.tnumber=(i%mythreads);
		myblock.inizio=mtime();
		myblock.dimensione=total_size;
		myblock.timestart=0;
		myblock.timeend=0;
		vettoreparametrihash.push_back(myblock);
	}
	for (unsigned int i=0;i<myfiles.size();i++)
	{
		vettoreparametrihash[i%mythreads].filestobehashed	.push_back(myfiles[i]);
		vettoreparametrihash[i%mythreads].algo				.push_back(myhashestype[i]);
	}
	int totfile=0;
	for (unsigned int i=0;i<mythreads;i++)
	{
		if (flagdebug)
			myprintf("Thread [%02d] files %s\n",i,migliaia(vettoreparametrihash[i].filestobehashed.size()));
		totfile+=+vettoreparametrihash[i].filestobehashed.size();
	}
	int rc;
	pthread_t* threads = new pthread_t[mythreads];
	pthread_attr_t attr;
	void *status;
	pthread_attr_init(&attr);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_JOINABLE);
	myprintf("Paranoid select: %8s files %21s (%s in %d threads)\n",migliaia(myfiles.size()),migliaia2(total_size),tohuman(total_size),mythreads);
	for(unsigned int i=0;i<mythreads;i++ ) 
	{
		vettoreparametrihash[i].timestart=mtime();
		rc = pthread_create(&threads[i], &attr, scansionahash, (void*)&vettoreparametrihash[i]);
		if (rc) 
		{
			myprintf("Error creating thread\n");
			exit(-1);
		}
	}
	pthread_attr_destroy(&attr);
	for(unsigned int i=0;i<mythreads;i++ ) 
	{
		rc = pthread_join(threads[i], &status);
		if (rc) 
		{
			error("Unable to join\n");
			exit(-1);
		}
	}
	unsigned int forzati=0;
	for(unsigned int i=0;i<mythreads;i++)
		for (unsigned int j=0;j<vettoreparametrihash[i].filestobehashed.size();j++)
		{
			string	hashfromfilesystem	=vettoreparametrihash[i].o_hashcalculated[j];
			if (hashfromfilesystem!="")
			{
				string 	filename		=rename(vettoreparametrihash[i].filestobehashed[j]);
				DTMap::iterator a		=dt.find(filename);
				if (a!=dt.end())
					if (hashfromfilesystem!=a->second.hexhash)
					{
						DTMap::iterator pedt=edt.find(filename);
						if (pedt!=edt.end())
						{
							pedt->second.forceadd=true;
							forzati++;
							if (flagverbose)
							{
								myprintf("DT hashtype |%s| hash |%s| filesystem |%s| ",a->second.hashtype.c_str(),a->second.hexhash.c_str(),hashfromfilesystem.c_str());
								printUTF8(filename.c_str());
								myprintf("\n");
							}
						}
					}
			}
		}
	delete [] threads;
	float tempo=(mtime()-startrecalc)/1000.0;
	printbar(' ',false);
	myprintf("\r");
	myprintf("Time for paranoid select : %.2fs (speed %s/s), forced files %s\n",tempo,tohuman((total_size/tempo)),migliaia(forzati));
	return 0;
}